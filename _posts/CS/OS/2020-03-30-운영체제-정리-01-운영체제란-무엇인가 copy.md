---
layout: post
title: "02: 운영체제의 역사"
category: "CS/OS"
comments: true
tags: [OS, "Booting"]
feature-img: "assets/img/1.jpg"
feature-title:
use_math: true
series: "운영체제 정리"
---

운영체제에 역사에 대해 알아본다.

# 1. 초기 컴퓨터
> 노가다, 사람 손도 많이가, 장치도 엄청커, 비싸기도 비싸


운영체제는 컴퓨터가 발전하면서 같이 발전하게 되었다. 초기 컴퓨터는 크게 3가지로 구성되었다. 카드 리더, 프로세서, 프린터이다. 카드 리더는 입력기이다. 입력은 종이에 입력할 코드에 맞는 구멍을 뚫어서 넣어주는 방식이었다. 프로세서는 현재와 비슷한 계산하는 역할이었고, 프린터는 입력에 대한 결과를 종이에 찍어서 보여주었다. 이 시기에는 운영체제도 존재하지 않았으므로, 오퍼레이터(operator)라는 컴퓨터를 사용하는 직업이 따로 있었고, 컴퓨터의 크기 또한 너무 커서 건물 전체를 사용해야할 정도였다.

# 2. Batch processing system(일괄 처리 시스템)
> 코드로 반복되는 거 좀 자동화 하자!

위에서 초기 컴퓨터의 상황을 살펴보았는데, 프로그램을 수행할 때마다 컴파일->링크->로딩 순서를 오퍼레이터가 직접 입력해주었다. 이러한 과정을 자동화한 것이 batch processing system 이다. 위 과정을 하나의 프로그램으로 작성하여 프로세서의 메모리안에 할당해주었는데, 이 프로그램을 resident monitor라고 불렀다.

resident는 "거주" 라는 의미로 이 프로그램이 항상 프로세서안에서 거주한다는 의미로 이러한 이름을 사용하였다. 그리고 이것이 **최초의 운영체제**로 알려져 있다.


# 3. Multiprogramming system(다중 프로그래밍)
> CPU가 노는 시간이 너무 많은데? 쉴 동안 다른일을 시켜버리자.

과거에는 컴퓨터가 매우 비싼 장비였다. 그리고 초창기 메모리의 상태는 resident monitor를 제외하고 **단 하나의 애플리케이션만을 할당하여 사용**하였다. 하지만 이는 매우 비효율적인 방법이었다.

프로그램을 수행하는 도중에는 계산을 하는 CPU 외에도 입출력을 담당하는 I/O장치가 수행한다. 즉, **CPU와 I/O장치가 교대로 동작**하는데 I/O장치가 수행하는 동안에는 **CPU가 아무것도 할 일이 없었다.** CPU가 아무일도 안하는 상태를 ***idle*** 상태라고 말한다. 그리고 I/O장치는 CPU에 비해 매우 느리기때문에 idle 상태의 비율이 너무 높았다. 이러한 비효율적인 수행을 해결하기 위해 multiprogramming system이 나왔다. ~~즉 CPU를 못놀게 하자~~

## 방법
Multiprogramming system은 메모리에 여러 애플리케이션(프로그램)을 올리는 시스템이다. 예를 들어 a, b 두 개의 애플리케이션이 있을 떄, 처음에는 a에서 CPU 수행을 하다가 I/O장치 수행으로 넘어간다. 이 순간 CPU는 idle 상태에 있지 않고 b가 있다는 것을 보고 b의 CPU 수행을 시작한다. 이렇게 **idle상태의 시간을 최대한 줄이고자 하였다.** 이런 동작을 가능하게 하려면 앞서 말했듯, 메모리에 여러 어플리케이션을 올린 상태여야만 한다.

## 한계 및 문제
하지만 메모리에 여러 프로그램을 올리면서 많은 문제점이 발생했다. 가장 큰 문제점은 CPU가 **어느 프로그램을 수행해야하는지 선택**하는 것이다. 이러한 작업을 ***CPU 스케줄링***이라고 하며, 이는 운영체제의 중요한 역할 중 하나이다. 그리고 여러 어플리케이션의 공간을 할당한다는 전제 조건 때문에, 새롭데 들어온 어플리케이션에 대해 **어느 메모리 공간에 할당**해야하는지도 큰 문제였다. 이러한 문제도 운영체제가 다뤄야 하는 중요한 과제로 남았다.

# 4. Time-sharing system(시분할 시스템)
> 하나 다 끝날 때까지 기다리지 말고 Interval을 주자!

시간이 지나 모니터와 키보드를 사용하면서 사용자와 컴퓨터 사이에 대화 형식이 가능해졌다. 하지만 여전히 컴퓨터 자체가 너무 비쌌기 때문에 아래와 같이 단말기(terminal) 형태로 사용하였다.

<img width="1026" alt="image" src="https://user-images.githubusercontent.com/37871541/77890996-43c24280-72ab-11ea-9987-b9384ebb4975.png">{: .center}

각 사용자(User)들은 모니터와 키보드만을 가지고, 실제 프로세서는 하나의 단말기에 존재하여 이를 공유하여 사용하였다. 멀티 프로그래밍에서는 이와 같은 단말기 형태에서 문제가 생긴다.

예를 들어, 단말기 메모리에 User1 프로그램, User2 프로그램, User3 프로그램이 할당되어 있고 User1이 먼저 CPU를 사용한다고 하자. **멀티프로그래밍에서는 User1이 CPU를 수행하고 있는 도중에는 다른 사용자는 CPU자체를 사용할 수 없다.** (CPU가 하나인 환경) 그러므로 다른 사용자들은 User1이 CPU수행을 모두 마칠 때까지(또는 I/O를 만날 때까지) 기다려야한다. 하지만 이는 매우 비효율적이다.

## 해결
이를 해결하기 위해 나온 것이 time-sharing system이다. 시분할 시스템은 CPU가 하나의 프로그램을 수행하는 **시간을 제한**하는 것이다. 예를 들어, User1 프로그램을 일정 시간 수행하면 반드시 다음 프로그램으로 넘어가서(스위칭, switching) 또 다시 일정 시간을 수행한다. 이렇게 일정 시간을 두어 프로그램들을 번갈아 수행하면서 모든 프로그램이 공평하게 수행이 되도록 한다. 그리고 이 일정 시간은 매우 짧은 시간(ms)이므로 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 가져온다. 가장 대표적인 시분할 시스템은 Unix가 있었다.

## 한계 및 문제
시분할 시스템을 사용하면서 여러 사용자(프로세스)간에 통신이 가능해졌다. 하지만 여기서도 여전히 멀티프로그래밍에서와 같은 스케줄링과 메모리 문제가 있었다. 이를 해결하기 위해 동기화 기술, 가상 메모리 등이 이후에 나왔다.

# 5. 고등 운영체제
## 5.1 다중 프로세서 시스템 (Multiprocessor system)
> CPU가 여러개

* 병렬 시스템 (parallel system)  
    + 여러개의 CPU가 동시에 처리할 수 있다.
* 강결합 시스템 (tightly-coupled system)  
    + 메모리에 여러 CPU가 연결되어 있다.
* 3가지 장점: performance, cost, reliability  
    + 여러 일꾼을 쓰니 빠르다.  
    + 싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.  
    + 하나가 망가져도 작동할 수 있다. 신뢰도가 높다.
* 다중 프로세서 운영체제 (Multiprocessor OS)  
    + CPU가 늘어났기 때문에, 다른 처리 방법이 필요하다.
## 5.2 분산 시스템 (Distributed system)]
> 컴퓨터가 여러대, 근데 묶여있다.
* 다중 컴퓨터 시스템 (multi-computer system)
    여러대의 컴퓨터로 만든 시스템이다.
* 소결합 시스템 (loosely-coupled system)
    + 메모리가 느슨하게 연결되어 있다.
* 3가지 장점: performance, cost, reliability  
    + 여러 일꾼을 쓰니 빠르다.  
    + 싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.  
    + 하나가 망가져도 작동할 수 있다. 신뢰도가 높다.
* 분산 운영체제 (Distributed OS)
    + 다른 컴퓨터들을 관리해야 하기 때문에 새로운 처리 방법이 필요하다.
## 5.3 실시간 시스템 (Real-time system)
* 시간 제약: Deadline
* 공장 자동화 (FA), 군사, 항공, 우주
* 실시간 운영체제 (Real-time OS = RTOS)

# 6. 인터럽트 기반 시스템(Interrupt based system)
현대 운영체제는 인터럽트 기반 시스템이다. 그렇다면 인터럽트는 무엇인가?
## 6.1 인터럽트



### Reference
[KOCW 양희재 교수님 - 운영체제](http://www.kocw.net/home/search/kemView.do?kemId=978503)  
[양희재 교수님 블로그(시험 기출 문제)](https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&categoryNo=13)  
[codemcd 님의 정리글](https://velog.io/@codemcd/)