---
layout: post
title: "03: 이중모드와 보호"
category: "CS/OS"
comments: true
tags: [OS, "Booting"]
feature-img: "assets/img/11.jpg"
feature-title:
use_math: true
series: "운영체제 정리"
---

운영체제의 사용자모드와 관리자모드, 하드웨어 보호 관해서 알아본다.

# 1. 이중 모드 (Dual mode)

현재 컴퓨터 환경은 여러 사람이 동시에 한 컴퓨터를 사용하는 경우가 많다.(서버 컴퓨터) 그리고 그 외에도 하나의 컴퓨터 내에서 여러 프로그램을 수행하는 것이 일반적이다. 이 때 특정 컴퓨터나 프로그램에서 잘못된 동작으로 인해 다른 컴퓨터(프로그램)가 영향을 받는다면 이는 매우 위험하다.

예를 들어, 어셈블리어에서 사용하는 명령어 중 `STOP`, `HALT`, `RESET`과 같은 명령어는 CPU의 동작과 관계된 명령어이다. 이런 명령어를
한 프로그램에서 고의 또는 실수로 입력하여 전체 컴퓨터의 동작이 멈추거나 꺼진다면 이 컴퓨터의 정상적인 동작을 위해서는 재부팅을 할 수 밖에 없다. 이러한 결함을 매우 치명적이다.

이런 문제점을 해결하기 위해 일반 사용자가 위와 같은 명령어들을 요청하는 것을 막을 필요가 생겼다. 여기서 **이중 모드** 라는 것이 나왔다.

## 설명

이중 모드는 말 그대로 모드를 아래와 같이 둘로 나누는 것이다.

- 사용자(User) 모드
- 관리자(Supervisor) 모드
  - = 시스템(system) 모드
  - = 모니터(monitor) 모드
  - = 특권(privileged) 모드

특권 모드에서만 내릴 수 있는 명령을 **특권 명령(privileged instruction)** 이라고 하며, `STOP`, `HALT`, `RESET`, `SET_TIMER` 등이 있다. 만약 사용자 모드에서 특권 명령을 사용하려고 하면 CPU에서 내부 인터럽트를 발생시켜 해당 명령어를 요청한 프로그램을 강제로 종료시킨다.

이중 모드는 CPU 내부의 레지스터(register)의 비트(bit)를 활용하여 **플래그(flag)**로 나타낸다. 예를 들어 특권 모드일 때는 **비트 값이 0** 이고, 사용자 모드일 때는 **비트 값을 1** 로 설정하여 구분한다.

### 상태 레지스터 (플레그 레지스터)

CPU에서 다양한 산술 연산의 결과의 상태를 알려주는 플래그 비트들이 모인 레지스터이다. flag라는 이름의 어원은 경주할 때, 시작, 정지와 같은 상태를 깃발의 색, 들어올림과 같은 것으로 알렸기 때문이다. CPU에서는 연산을 수행하는데, 제약사항을 갖고 (자리수의 제한 같은) 수행하기 때문에 이를 나타낼 다양한 코드가 필요하다. 이 상태는 비트를 통해 정의되어 있으며 다양한 플래그가 존재한다.  
[상태 레지스터의 종류](https://ko.wikipedia.org/wiki/상태_레지스터)

## Mode의 변경 과정

컴퓨터가 켜진 뒤에 한 사용자 애플리케이션을 실행시키는 동안 모드가 어떻게 변하는지 살펴보자.

1. 컴퓨터 부팅 과정 - 관리자 모드
2. 애플리케이션 실행 과정 - 관리자 모드
3. 애플리케이션 실행중 - 사용자 모드
4. 인터럽트 발생 후 처리 과정 - 관리자 모드
5. 인터럽트 처리 후 - 사용자 모드

사용자가 하드웨어의 자원에 접근하는 것은 매우 위험한 동작이다. 그러므로 이러한 경우에는 모두 **관리자 모드로 운영체제에서 처리하도록 한다.** (프로그램에서 소프트웨어 인터럽트를 발생시켜 운영체제에 위임한다.)

위의 4번 과정을 하드웨어 인터럽트로 가정하고 자세히 살펴보면 아래와 같다.

1. 하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)
2. CPU에서 모드 플래그를 관리자 모드값으로 설정
3. 해당 하드웨어 인터럽트 서비스 루틴(ISR)으로 이동 (관리자 모드)
4. 인터럽트 처리 (관리자 모드)
5. 인터럽트 처리 완료 후 CPU의 모드 플래그를 다시 6. 사용자 모드값으로 설정
6. 원래의 애플리케이션 위치로 복귀 (사용자 모드)

![Mode bit 변경](https://miro.medium.com/max/1400/1*J3LbfnG88ysmltH48VhU6w.png){: .center}

만약 사용자 모드인 상태에서 치명적인 명령어를 사용자 프로그램이 Call했을 경우에 CPU는 모드 비트를 확인하고 관리자 모드가 아닐 경우, **내부 인터럽트**를 발생시킨다. (잘못된 명령을 내렸을 때 발생하는 인터럽트) 그 결과, 메모리에 올라와있는 사용자 프로그램을 종료시켜버린다.

애플리케이션이 실행하는 동안에는 위와 같은 모드 변경이 반복적으로 일어나는 것을 볼 수 있다. 대부분의 CPU는 이중 모드를 지원한다.

# 2. 하드웨어 보호

이중 모드는 사용자의 접근을 제한하여 치명적인 문제가 발생하지 않도록 방지하는 보호 기능에 해당한다. 이러한 보호 기능에 대해 추가적으로 알아본다.

## 2.1 입출력 장치 보호

여러 정보들은 입출력 장치를 통해 컴퓨터로 입력되고, 외부 장치로 출력이 된다. 여기서 크게 두 가지의 문제점이 발생한다.

- 여러 입출력 장치의 사용으로 인한 혼선
- 사용자가 자신의 데이터가 아닌 다른 사용자의 데이터에 입출력을 하는 일
  - 위와 같이 입출력 장치에 여러 사용자의 데이터가 뒤엉켜서 들어오거나 다른 사용자의 데이터에 접근하려는 경우를 막아야 한다.
    이를 해결하기 위해 `in`, `out` 과 같은 입출력 명령을 **특권 명령**으로 설정하는 것이다. 즉, 사용자 애플리케이션에서 입출력을 사용하려면 운영체제를 통해서 수행해야한다.(소프트웨어 인터럽트) 여러 프로그램이 동시에 입출력을 사용하려고 하면 운영체제 내부에서 순서를 정하여 혼선을 막아줄 수 있다.
    **즉, 컴퓨터의 하드웨어를 사용하는 과정에서는 모두 운영체제를 거치도록 한다!** 라는 대원칙이 사실 숨어있다.

만약 A, B 사용자가 있는 상황에서 A가 B의 데이터를 읽기 위해 운영체제에게 소프트웨어 인터럽트를 발생하였다고 하자. 이 때, A의 데이터와 B의 데이터는 각각 A, B만이 읽기가 가능하다고 가정하자. 그러면 인터럽트가 발생하고, CPU는 RAM에 있는 운영체제 내부의 해당 ISR로 이동하게 된다. ISR은 현재 사용자 A가 해당 데이터 B에 접근할 수 없으므로 해당 요청을 거부한다.

<img width="947" alt="image" src="https://user-images.githubusercontent.com/37871541/77887354-63ef0300-72a5-11ea-9231-1c571b962db6.png">{: .center}
~~다시보는 이 그림..~~{: .center-text}

## 2.2 메모리 보호

메모리에는 운영체제뿐만 아니라 여러 개의 사용자 애플리케이션이 존재한다. 한 애플리케이션이 자신의 메모리 영역이 아닌 운영체제나 다른 애플리케이션의 메모리 영역에 침범하려하면 매우 위험하다.

<img width="1252" alt="image" src="https://user-images.githubusercontent.com/37871541/77922369-e8f50f00-72db-11ea-8a4c-0c8bb7a09c3d.png">{:.center}

메모리는 일반적으로 위와 같이 구성되어 있을 것이다. 여기서 user1이 OS나 user2, user3에 접근하는 것을 막아야 한다. CPU는 address bus를 통해 메모리 주소에 접근하게 되는데, user1 프로그램이 실행되는 동안에는 user1이 할당되어 있는 메모리 주소 범위 안인 경우에만 접근하면 될 것이다. 이를 **address bus에서 검사**하는 것이 가장 효율적일 것이다.

<img width="970" alt="image" src="https://user-images.githubusercontent.com/37871541/77922593-35d8e580-72dc-11ea-80dd-d2ca33d48f9f.png">{:.center}

위의 생각으로 나온 것이 **MMU(Memory Management Unit)** 이다. MMU는 위의 그림처럼 address bus 중간에 설치된 하드웨어 칩으로서 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다.

예를 들어, User1의 시작 주소는 1024, 끝 주소는 4048이라고 하자. User1이 수행되는 동안 운영체제는 해당 프로그램의 주소 범위를 MMU에 설정(특권 명령)하는데, base는 1024, limit는 4048이 될 것이다. 결과적으로 user1이 수행되는 동안에는 이 범위 안의 주소값인 경우에만 address bus를 통과시킨다.

만약 해당 프로그램의 주소 범위 밖의 주소값이 MMU에 들어온다면, MMU에서 내부 인터럽트 를 발생시켜 CPU에 신호를 준다. 그러면 CPU는 그에 맞는 ISR로 이동하여 해당 프로그램을 강제로 종료시킨다. 이과 같은 잘못된 메모리 접근을 Segment violation 이라 한다.

## 2.3 CPU 보호

CPU 보호는 사용자의 실수 또는 고의로 인한 CPU 독점을 방지해야 한다. 하나의 프로그램이 CPU를 독점하게 되면 다른 프로그램은 수행되지 못한다.

```c++
while(true){

}
```

CPU를 독점하는 가장 대표적인 예는 **무한 반복**이다. 위의 코드를 보면 while문의 조건문이 잘못된 것을 볼 수 있다. 비교 연산자가 아닌 대입 연산자를 사용하여 n값이 1이 되므로 while문의 조건은 TRUE가 된다. 이는 n값이 변하지 않는 이상 무한으로 반복된다.

이를 해결하는 방법은 Timer를 두어 일정 시간이 지나면 **타이머 인터럽트**를 발생시킨다. 인터럽트가 발생하면 반드시 운영체제 내의 ISR로 이동하므로, 해당 ISR에서 각 프로그램의 CPU 점유 시간을 측정하여 적절히 분배되도록 조정한다.

예를 들어, 한 프로그램의 CPU 점유 시간이 비정상적으로 오래 걸리는 경우, 강제로 다른 프로그램으로 CPU를 전환시켜 줄 수 있다.

### Reference

[KOCW 양희재 교수님 - 운영체제](http://www.kocw.net/home/search/kemView.do?kemId=978503)  
[양희재 교수님 블로그(시험 기출 문제)](https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&categoryNo=13)  
[codemcd 님의 정리글](https://velog.io/@codemcd/)  
Operating System Concepts, 9th Edition - Abraham Silberschatz
