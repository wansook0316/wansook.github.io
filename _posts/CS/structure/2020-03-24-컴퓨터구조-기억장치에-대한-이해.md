---
layout: post
title: "04: 기억장치에 대한 이해"
category: "CS/Structure"
comments: true
tags: [컴퓨터 구조, 기억장치]
feature-img: "assets/img/30.jpg"
feature-title:
use_math: true
series: "가볍게 이해하는 컴퓨터"
---

기억 장치의 동작방법에 대해 이해해보자.

최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.

# Memory Device

## 계층 구조

![기억장치의 계층 구조](https://t1.daumcdn.net/cfile/tistory/992DB8435AEF240E25){: .center-text}
[출처 : https://programmer-student.tistory.com](https://programmer-student.tistory.com/8){: .center-text}

### 쉬운 이해를 위한 도표

| 기억장치 |  분류  |
| :------: | :----: |
|   캐시   |  책상  |
|   RAM    | 책꽂이 |
|   HDD    | 도서관 |

## 컴퓨터가 관리하는 방법 - 관리 체계

> 컴퓨터는 모든 것이 **숫자**이다.

그래서 기억 공간도 번호를 붙여 관리한다. 이와 같은 관리 체계는 아파트 단지를 동, 호로 관리하는 것과 비슷하다.

1. RAM에 있는 n번 번호에 있는 정보를 가져와
2. 그 정보를 CPU에서 사용할 연산 저장 공간에 저장해
3. 연산을 수행해
4. RAM의 m번 공간에 저장해

여기서 CPU에서 저장하는 공간의 명칭이 register이다.

### 레지스터

> 개별 기억 공간마다 **_고유 이름_**을 붙인다.

기본적으로 레지스터는 많은 저장 공간을 갖고 있지 않다. 그래서 이 각각에 이름을 붙여 관리한다.

### 주기억장치(RAM)

> 일련 번호를 붙인다.

위에서 언급했던 번호에 해당하는 것이 보통 RAM에 대한 설명이다.

<img width="763" alt="image" src="https://user-images.githubusercontent.com/37871541/77840905-287e0700-71c7-11ea-8293-6a7e9082c6f1.png">{: .center}

> 신발장 번호 : 주소  
> 신발 : 정보

이 신발장을 컴퓨터는 약 43억 개 갖고 있는데, 이 숫자는 $2^32$ 가지에 해당하는 숫자이다. 저 숫자를 표시하기 위해서 32비트가 필요하다.

### 보조 기억장치(HDD, SDD)

> 트랙 번호와 섹터 번호를 붙여 관리한다.

<img width="1177" alt="image" src="https://user-images.githubusercontent.com/37871541/77840491-17cb9200-71c3-11ea-995f-e12caab4c6ff.png">{: .center}

#### Track

중심부로 부터 밖으로 나가는 원들 중 하나를 말한다.

#### Sector

원을 균등하게 부채꼴 모양으로 나눈 것들중 하나를 섹터라 말한다.

#### Format 이란?

하드디스크의 섹터와 트랙을 구성하는 작업을 말한다. Format을 하면 데이터가 다 날아가는 이유는, 하드디스크에 정보를 저장하는 체계인 트랙과 섹터를 **재구성**하기 때문이다.

#### 파일 시스템

하드 디스크에 내가 가진 파일의 위치를 Track, Sector로 나타낸 표

| 파일이름 | Track | Sector |
| :------: | :---: | :----: |
|  a.mp3   |   1   |   1    |

이런 파일 시스템은 File Allocation Table (FAT), NTFS.. 등등 엄청 많다. 내가 파일을 삭제하면, 이 파일 시스템의 Delete Field에 True로 체크가 되고, 이 공간은 운영체제에서 쓰기 가능한 공간으로 바뀐다. 그래서 디스크 복구같은 것이 가능한 것.

#### 디스크 조각 모음

하드디스크는 기본적으로 원의 형태를 띈 모양으로 구성되어 있고, 이것을 Arm을 사용해 읽는다. 그래서 갖는 특징이 있는데, 같은 track에 내가 사용하는 데이터가 모여있는 경우 입출력 속도가 빠르다. 하지만 만약에 데이터가 다른 트랙, 다른 섹터에 분산되어 있다면 이 파일을 읽기 위해서 Arm이 여러번 움직어야 한다. 관성 때문에 Arm의 속도가 느려지고 결과적으로 입출력 속도의 감소가 이루어진다.

이렇게 흩어져 있는 파일을 같은 track이나 그 근처로 모으는 작업을 디스크 조각 모음이라 한다.

## 전체 흐름

1. HDD에 몇번 트랙, 몇번 섹터에서 정보를 읽어와
2. 그걸 RAM의 몇번 주소에 저장해라
3. 그리고 그걸 다시가져와서 CPU에 EAX라는 이름을 가진 레지스터에 저장해라

# 컴퓨터가 연산하는 과정

이제 메모리가 어떻게 구성되어 있는 지를 대충 알았다면, 실제 연산과정을 들여다 보자.

> 캐시 메모리는 CPU 그 자체다.  
> RAM은 CPU의 연산을 돕기위한 **연습장**이다.

<img width="1218" alt="image" src="https://user-images.githubusercontent.com/37871541/77840990-151f6b80-71c8-11ea-8414-bcbb03c2a359.png">
{: .center}

맨 위에서 보았듯이 메모리가 정보를 불러오는 데에는 속도가 존재한다. 전체적인 과정은 HDD, RAM, Resister 순으로 입출력이 일어나는데, 이 때 속도차이가 나므로 CPU가 빠르게 연산을 처리하는데 문제가 생긴다.

그래서 이 병목구조를 탈피하기 위해서 CPU, RAM 등에 캐시 메모리를 두어 이 부분을 해소한다. 캐시 메모리는 CPU가 연산을 수행하는 동안 다음에 필요한 정보를 RAM에서 미리 가져와 저장하는 역을 한다. 그 결과 CPU는 RAM에서 정보를 가져올 때 걸리는 시간을 캐시에서 가져오므로써 시간적 이득을 가질 수 있다.

## CPU ALU

ALU는 가산기를 뜻한다. CPU에 대해서 배울 때, 이는 연산 처리 장치이고 모든 연산은 가산기 하나로 가능하다고 배웠다. 결과적으로 Core 하나에는 ALU하나가 들어있다고 생각하면 된다. 쿼드코어 컴퓨터는 가산기가 4개 존재한다.

## 64bit 컴퓨터

CPU가 연산을 처리할 때 발생하는 input, output의 단위가 64bit 만큼의 정보를 단위로 연산을 수행한다는 의미이다.

## 전체 과정

1. RAM에서 정보를 가져온다
2. 캐시 메모리에서 정보를 읽는다.
3. 레지스터로 해당 값을 옮긴다.
4. ALU에서 연산을 수행한다.
5. 결과를 레지스터로 복사한다.
6. 그 값을 RAM으로 옮긴다.

이런 작업을 **_코드_**라 한다. 그런데 CPU(기계)에게 명령하는 코드이므로 **기계어 코드**라 한다.
