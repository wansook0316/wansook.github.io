---
layout: post
title: "13: HTTP"
category: "DV/Concept"
comments: true
tags: [Concept, "추후 재분류"]
feature-img: "assets/img/82.jpg"
feature-title: ""
use_math: true
series: "Boost"
summary: "HTTP에 대해 궁금했던 것을 모두 저장하는 공간"
---

* 통신 프로토콜은 <mark style='background-color: #fff5b1'> Header </mark>를 보면 알 수 있다.

# HTTP 개요

* HTML 문서와 같은 리소스를 가져올 수 있도록 해주는 프로토콜

![image](https://user-images.githubusercontent.com/37871541/129831502-62c1656c-ee40-4fac-8212-a1b5fa290c81.png){: .center}
![image](https://user-images.githubusercontent.com/37871541/129856192-e023ecf3-68a6-4138-b66d-38db3bc81989.png){: .center-small}_Web의 구성_


* 클라이언트와 서버들은 개별적인 메시지 교환에 의해 통신
* 요청과 응답
* 애플리케이션 계층의 프로토콜
* 신뢰 가능한 전송 프로토콜이라면 무엇이든 사용할 수 있으나 TCP, 또는 암호화된 TCP 연결인 TLS를 통해 전송
  * HTTP3는 UDP도 사용
* 이전에는 하이퍼 텍스트 문서만 보냈으나, HTTP가 확장되면서, 이미지, 비디오와 같은 내용을 서버로 POST도 할 수 있다.
* 또는 필요할 때마다 웹 페이지를 갱신하기 위해 문서의 일부를 가져오는데 활용될 수도 있다.

## 구성 요소

* 사용자 에이전트가 요청을 수행함
  * 여기서 사용자는 특정 객체라고 생각할 수 있음
  * 실제 사용자(사람이 사용하는 브라우저)일 수도 있고, 다른 서버(프록시)일 수도 있고, 로봇(검색 엔진)일수도 있다.
* 클라이언트가 요청을 하게되면, 서버로 보내지고 응답을 제공한다.
* 그 사이에는 여러 개체를 통해 접근할 수 있는데, 게이트웨이, 프록시(캐시 역할 또는 보안 목적을 수행)가 그 예이다.
* 사실 그 사이에는 OSI 7 Layer를 거치면서, 라우터, 모뎀등을 거치게 된다. 일단 제쳐두자.
* 여기서는 일단 사용자 에이전트를 브라우저라 생각해보자.

### 클라이언트

* 사용자 에이전트 : 브라우저
* 요청을 보내는 객체
* 페이지의 HTML 문서를 가져오기 위한 요청 전송
* 파일을 구문 분석하여 추가적인 요청을 보낸다. (이게 미션에서 수행해본 내용)
* 그리고 이 리소스를 혼합한다. (DOM, CSDOM)


### 웹 서버

* 클라이언트의 요청에 대한 문서를 제공하는 서버가 있다.
* 논리적으로 단일 기계
  * 물리적으로는 여러대를 모아두고 처리할 수 있다는 뜻
  * 로드 밸런싱, 혹은 받은 요청에 대해 다른 서버에서 요청을 받아 돌려주는 복잡한 구조를 가진 서버들의 집합일 수도 있기 때문

### 프록시

* 웹 브라우저와 서버 사이에는 수많은 컴퓨터와 머신이 HTTP 메시지를 이어 받고 전달함
* 상당수가 원래는 네트워크, 물리 계층에서 동작하고 있지만 HTTP에서는 이를 알 수 없다.
* 이러한 중간 계층 머신 중에서도 어플리케이션 레벨에서 동작하는 것들을 **프록시** 라고 부른다.
* 역할
  * 캐싱
  * 필터링 (바이러스 등)
  * 로드 밸런싱 (여러 서버들이 서로 다른 요청을 처리하도록 허용)
  * 인증 (다양한 리소스에 대한 접근 제어)
  * 로깅 (이력 정보를 저장)


## HTTP의 특징

* 간단하다.
  * 사람이 읽고 이해가 가능하다.
* 확장 가능
  * HTTP 헤더가 확장가능하다.
  * 추가적인 헤더에 대해 합의만 한다면 새로운 기능 추가가 가능
* 상태가 없다.
  * 동일한 연결 상에서 연속하여 전달된 두개의 요청 사이에 연결성이 없다.
  * 만약 쇼핑몰을 만들었는데, 장바구니에 있는 내용이 페이지와 상호작용하길 바란다면 문제가 된다.
    * 서버에서는 클라이언트의 상태를 모르기 때문
  * HTTP 쿠키를 통해 상태가 있는 세션을 만들 수 있도록 한다.
* HTTP와 연결
  * 신뢰성 통신을 위해 TCP 표준에 의존한다.
  * 그래서 이 네트워크 계층에서 THS를 수행하여 연결을 설정하게 된다.
  * 그렇기 때문에 속도가 느려 효율적이지 못하다.
  * HTTP/1.1에서는 파이프라이닝 개념과 지속적인 연결의 개념을 도입
    * 기본적 TCP 연결은 Connection 헤더를 사용하여 부분적으로 제어가 가능
      * HTTP/2.0에서는 금지되었다고 한다..
  * HTTP/2는 연결을 좀더 지속되고 효율적으로 유지할 수 있도록 단일 연결 상에서 메시지를 다중 전송(multiflex)할 수 있다.
  * HTTP3를 구글이 만들었고, UDP 기반의 QUIC을 진행하는 중이다.


## HTTP로 제어할 수 있는 것

* 캐시
  * 서버는 캐시 대상과 기간을 프록시와 클라이언트에 지시할 수 있다.
  * 클라이언트는 저장된 문서를 무시하고 새걸 받아오라고 중간 캐시 프록시에게 지시할 수 있다.
* 인증
  * HTTP 쿠키를 사용해 특정 세션을 설정할 수 있다.
* 세션
  * 쿠키를 사용함으로서 HTTP가 상태없는 프로토콜임에도 세션을 만들 수 있다.




# HTTP1, 2, 3의 차이 정리

* 추후 진행.. 내용이 방대하다.





# 추가 공부

* HyperText Transfer Protocol
* www 상에서 서버와 클라이언트간 상호 통신을 위한 응용계층 프로토콜
* 요청과 응답 방식으로 동작
* 비연결성 프로토콜
  * 한번 연결을 맺은 후, 요청에 대해 응답을 끝내면 연결을 끊어버림
  * 왜? 
    * HTTP는 불특정 다수의 통신 환경을 기반으로 설계됨
    * 연결을 계속 유지한다면 많은 리소스가 발생
  * 단점
    * 동일한 클라이언트의 모든 요청에 대해 매번 새로운 연결을 시도, 해제함
    * 즉, 연결과 해제에 대한 오버해드가 발생한다.
  * 해결책
    * keepAlive
    * HTTP 헤더에 추가가 가능함
    * 지정된 시간 동안 서버와 클라이언트 사이에서 패킷 교환이 없을 경우, 패킷을 주기적으로 보내는 것을 말함
    * 패킷 반응이 없을 경우 접속을 끊는다.
    * 서버가 바쁠 경우, 프로세스 수가 기하급수적으로 늘어나기 때문에, 해당 상태를 유지하기 위한 메모리를 사용하게 되므로 주의가 필요
* 상태를 유지하지 않는 프로토콜
  * 비연결적인 특징으로 인해, 서버는 클라이언트를 식별할 수가 없다.
  * 예시
    * 쇼핑몰 접속 -> 로그인 -> 상품 클릭 -> 로그인 -> 주문 -> 로그인
  * 즉, 요청이 들어왔을 때, 해당 클라이언트가 로그인이 되었는지에 대한 정보가 없기 때문에, 이에 대한 정보를 다시 전해주고를 반복해야 하는 것
  * 쿠키
    * 여기서 쿠키의 개념이 들어오게 되는데, 클라이언트를 식별할 수 있는 값이다.
    * 브라우저 단에서 쿠키를 저장하여 서버가 클라이언트를 식별할 수 있게 한다.
    * 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각
    * 브라우저가 이를 저장해두었다가 동일한 서버에 재요청할 때, 이 저장된 데이터를 함게 전송
    * 세션관리(로그인, 장바구니, 게임 스코어등의 정보 관리)
    * 개인화( 사용자 선호 테마 등의 세팅)
    * 트래킹(사용자 행동 기록 분석)
    * 헤더 : `set-cookie`
    * 단점
      * 모든 요청마다 쿠키가 함게 전송됨
      * 성능이 떨어진다.
      * 요즘은 클라이언트쪽에 데이터를 저장하기 위해서는 웹 스토리지 API(`localStorage`, `sessionStorage`), `IndexedDB`를 사용
  * 세션
    * 쿠키는 사용자의 정보가 브라우저에 저장되기 때문에 위변조 가능성이 높아 보안에 취약하다.
    * 세션은 브라우저가 아닌 서버단에서 사용자 정보를 저장한다.
    * 쿠키보다는 안전한 편
    * 단점
      * 여전히 중간에 탈취가 가능하다.

# References

* [🙈[HTTP] HTTP 특성(비연결성, 무상태)과 구성요소 그리고 Restful API🐵](https://victorydntmd.tistory.com/286)
* [HTTP 쿠키](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)
* [MDN HTTP](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP)
* [Connection Header](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Connection)