<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>완숙의 에그머니🍳</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>개발, 데이터, 통계, 수학를 좋아하는 반항아의 블로그</description>
    <pubDate>Wed, 01 Apr 2020 23:11:32 +0900</pubDate>
    
      <item>
        <title>09: 프로세스 동기화 &lt;2. &gt;</title>
        <link>/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-09-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-2.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-09-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-2.html</guid>
        <description>&lt;p&gt;프로세스 동기화 도구에 대해 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;1-semaphore세마포&quot;&gt;1. Semaphore(세마포)&lt;/h1&gt;

&lt;p&gt;&lt;img width=&quot;801&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78143768-a95c2d80-7469-11ea-81b6-5ff62292d1f0.png&quot; class=&quot;center&quot; /&gt;
Semaphoresms 깃발이라는 네덜란드 단어이다. 옛날에는 기찻길에서 공유하는 길이 있을 때, 깃발 표식으로 오고감의 신호를 주고 받았다. 이러한 맥락에서, Critical section을 사용하는 쓰레드에 사용하는 방법의 이름으로 붙게 되었다.&lt;/p&gt;

&lt;p&gt;위의 그림을 보면 공유하는 기찻길이 하나이다. 이 경우 공유 자원이 1이라 볼 수 있다. 하나의 기차가 지나갈 때 1을 감소시키고, 다 지나간 뒤에 1을 증가시키는 일을 반복한다. 그리고 다른 기차가 지나가려고 할 때, Semaphore가 0인 경우에는 정지하고 1인 경우에 순차적으로 지나가게 하면 해결된다. 이렇게 Semaphore가 0, 1인 경우를 Binary Semaphore라 한다.&lt;/p&gt;

&lt;p&gt;공유 자원이 꼭 1개일 필요는 없다. 여러개의 자원인 상황도 존재한다. 가령 위의 기차 그림에서 통과해서 갈 수 있는 공유 기찻길이 5개라면, 공유자원은 5이다. 이런 경우를 counting semaphore라 한다.&lt;/p&gt;

&lt;h2 id=&quot;11-구현&quot;&gt;1.1 구현&lt;/h2&gt;

&lt;p&gt;위의 예시에서 보듯, 깃발은 총 두가지가 필요하다. 지나가는 경우에는 감소, 지나간 뒤에는 증가이다. 초기에는 P, V로 불렸다.(네덜란드에서 만들어져 네덜란드어의 약자이다.) 현재에는 P는 test를 의미하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire()&lt;/code&gt; 로 사용하고, V는 increment를 의미하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release()&lt;/code&gt; 로 사용한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire()&lt;/code&gt;는 자원이 사용가능한지 확인하고, 사용가능하다면 사용하고 그렇지 않다면 대기한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release()&lt;/code&gt;는 자원을 내놓고, 다음 자원을 실행시킨다.&lt;/p&gt;

&lt;p&gt;자바를 통해 세마포 구조를 간단히 살펴보면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// number of permits&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// add this process/thread to list&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// block&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// remove a process P from list&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// wakeup P&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://mblogthumb-phinf.pstatic.net/20140527_265/wndrlf2003_1401125270012DhChu_PNG/1.png?type=w2&quot; class=&quot;center-text&quot;&gt;세마포 간단한 그림&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 코드에서 acquire() 는 value값을 감소시키고 만약 &lt;strong&gt;value값이 0보다 작으면(가용자원을 모두 사용함) 이미 해당 임계구역에 어느 프로세스가 존재&lt;/strong&gt;한다는 의미이므로 현재 프로세스는 접근하지 못하도록 막아야한다. 이를 list라는 기다리는 줄에 추가한 뒤 block을 걸어준다.(list는 일반적으로 큐로 되어있다.)&lt;/p&gt;

&lt;p&gt;release() 는 value값을 증가시키고, 만약 &lt;strong&gt;value값이 0보다 같거나 작으면 임계구역에 진입하려고 대기하는 프로세스가 list에 남아있다는 의미&lt;/strong&gt;이므로 그 중에서 하나를 꺼내어 임계구역을 수행할 수 있도록 해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78147073-f8a45d00-746d-11ea-923c-9767bbb82cb5.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세마포를 그림으로 나타내면 위와 같다. list는 실제로 큐로 볼 수 있다. acquire()에 의해 block되는 프로세스는 세마포 내부에 있는 큐에 삽입된 후, 다른 프로세스가 임계구역을 나오면서 release()를 호출하여 &lt;strong&gt;세마포 큐에 있는 프로세스를 깨워야 한다.&lt;/strong&gt;(다시 ready queue로 보낸다.)&lt;/p&gt;

&lt;p&gt;위에서 살펴본 것처럼 세마포는 일반적으로 &lt;strong&gt;Mutual exclusion&lt;/strong&gt;을 위해 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>08: 프로세스 동기화 &lt;1. 발생 이유와 목적&gt;</title>
        <link>/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-08-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-08-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1.html</guid>
        <description>&lt;p&gt;프로세스 동기화가 발생하는 예시와 목적, 그리고 그것을 해결하기 위한 원칙에 대해 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;1-프로세스-동기화란&quot;&gt;1. 프로세스 동기화란?&lt;/h1&gt;

&lt;h2 id=&quot;11-배경&quot;&gt;1.1 배경&lt;/h2&gt;

&lt;p&gt;현대 컴퓨터의 메모리에는 여러 프로세스가 존재하는데, 이러한 프로세스들이 하나의 공유 메모리나 또 다른 프로세스에 접근할 때는 매우 신중해야 한다. 이처럼 한 프로세스가 다른 프로세스에게 영향을 받거나 주는 프로세스를 &lt;strong&gt;Cooperating process&lt;/strong&gt;라고 한다. 반대로 아무런 영향을 미치지 않는 독립적인 프로세스는 &lt;strong&gt;Independent process&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;현대 컴퓨터 환경에는 cooperating process가 훨씬 많이 존재하고, 이들은 서로 영향을 미치기 때문에 데이터나 흐름에 대한 &lt;strong&gt;동기화&lt;/strong&gt;가 매우 중요하다. 프로세스 사이에 동기화를 하는 것을 &lt;strong&gt;프로세스 동기화(Process Synchronization)&lt;/strong&gt; 라고 한다.(현재에는 대부분 쓰레드 기준으로 스위칭을 하므로, &lt;strong&gt;Thread synchronization&lt;/strong&gt;으로 많이 불린다.)&lt;/p&gt;

&lt;h2 id=&quot;12-필요성&quot;&gt;1.2 필요성&lt;/h2&gt;

&lt;p&gt;대표적인 예로 기차표 예매가 있다. 어느 시간에 한 좌석의 기차표는 반드시 하나만 존재해야한다. 그런데 이를 예매하려는 사용자(프로세스)는 여러 명이다. 이 사용자들이 동시에 하나의 좌석 기차표를 구매하려고 하면 어떠한 일이 발생할까? 실제 환경에서는 당연하게도 동기화 문제를 해결한 시스템이므로 한 사람만이 기차표를 예매할 수 있을 것이다. 만약 동기화에 문제가 발생한다면 한 기차표를 여러 사람이 예매하는 불상사가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;13-목표&quot;&gt;1.3 목표&lt;/h2&gt;

&lt;p&gt;프로세스 동기화는 여러 프로세스가 공유하는 &lt;strong&gt;자원의 일관성을 유지&lt;/strong&gt;하는 것이다. 가령 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때 이 프로세스들의 순서를 정하여 데이터의 일관성을 유지시켜주어야 한다. 이 부분에 대한 자세한 목적은 아래의 예를 파악하며 문제를 인지한 후에 명확하게 재정의하겠다.&lt;/p&gt;

&lt;h1 id=&quot;2-bank-account-problem은행-계좌-문제&quot;&gt;2. Bank Account Problem(은행 계좌 문제)&lt;/h1&gt;

&lt;h2 id=&quot;21-문제-설명&quot;&gt;2.1 문제 설명&lt;/h2&gt;

&lt;p&gt;동기화 문제 중에서 대표적인 은행 계좌 문제를 살펴보자. 은행에는 하나의 계좌에 입금, 출금을 할 수 있다. 여기서 계좌는 &lt;strong&gt;공유하는 자원&lt;/strong&gt;이고, 입금과 출금은 각각 프로세스라고 볼 수 있다. 부모님이 자식에게 입금을 하고, 자식은 출금을 하는 상황을 자바로 구현한 코드는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 계좌&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBalance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;입금, 출금, 잔액조회 함수를 멤버함수로 갖는 클래스를 구현한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 입금 프로세스&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 생성자는 공유하는 계좌를 초기값으로 가진다.&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// run(): 쓰레드가 실제로 동작하는 부분(치환)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
		  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;멤버 변수로 계좌를 가지고, 이것을 생성할 때 인자로 받는 클래스이다. 해당 클래스에서 run()은 입금을 100번 수행한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 출금 프로세스&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 생성자는 공유하는 계좌를 초기값으로 가진다.&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
		  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;멤버 변수로 계좌를 가지고, 이것을 생성할 때 인자로 받는 클래스이다. 해당 클래스에서 run()은 출금을 100번 수행한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Test.java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// start(): 쓰레드를 실행하는 메서드&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// join(): 쓰레드가 끝나기를 기다리는 메서드&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;balance = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBalance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;main 함수에서는 위에서 만든 클래스들을 사용하여, 계좌를 공유하는 두 개의 쓰레드를 만든다. 그리고 부모, 자식 클래스에서 각각 입금과 출금을 100번씩 수행하고, 결과적으로 남은 잔액을 조회한다. 잔액은 &lt;strong&gt;0&lt;/strong&gt;이 나와야 할 것이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Result&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 결과는 정상적이다. 100번 1,000원을 입금하고, 100번 1,000원을 출금하면 잔액은 0원이 남는다. 위 코드는 2개의 쓰레드가 동작하고 있음에도 불구하고 동기화 문제가 발생할 확률은 매우 낮다. 반복이 100번 밖에 안 일어나는 매우 간단한 코드 이기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;22-동기화-문제-발생&quot;&gt;2.2 동기화 문제 발생&lt;/h2&gt;

&lt;p&gt;실제 상황에서는, 입금, 출금 명령을 내리고 이 명령이 전달되는데 까지 시간이 소요된다. 그런 상황을 만들기 위해 출금하는 과정에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;temp&lt;/code&gt;라는 필요없는 변수를 추가하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+,-&lt;/code&gt;를 출력하고, 반복 횟수를 1000번으로 늘렸다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 계좌&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBalance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Result&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++++++++++++++++++++++++++++++----------------------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;--------------------------------------------------------------------------++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+++----------------------------------------------+++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+----+++++++-+++++----+++-------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-+++++++-++++-+++++++++-------++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++---------------+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+-++++++++++++-------------------++++++++++++++++++++-++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++-+------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-+++++++++++-+++++++----------------------------------------+-------+-----------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-+------+-----------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-+------------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-+------------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-------------------+-------+----------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;------------------------------+-------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;------------------------------------------------------+-------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-+------------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-++---------------------------------------++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;+는 입금을 한 경우, -는 출금을 한 경우이고, 주목할 점은 balance값이 0이 아닌 1000000이라는 알 수 없는 값이 출력되었다. 또한 여러번 실행할 경우 100000이라는 값이 고정되어 출력되는 것도 아니다. &lt;strong&gt;결과가 불일치하며, 비일관적이다.&lt;/strong&gt; (비일관적인 이유는 운영체제에서 쓰레드를 스위칭하는 패턴이 매번 다르기 때문이다.)&lt;/p&gt;

&lt;p&gt;약간의 시간 지연을 준 것만으로도 여러 쓰레드가 하나의 공유 자원을 사용하는 프로그램은 망가지게 된다.&lt;/p&gt;

&lt;h2 id=&quot;23-왜-발생할까&quot;&gt;2.3 왜 발생할까?&lt;/h2&gt;

&lt;p&gt;이러한 문제가 발생하는 원인은 &lt;strong&gt;공통변수(common variable)에 대한 동시 업데이트(concurrent update)&lt;/strong&gt; 때문이다.&lt;/p&gt;

&lt;p&gt;위 예제에서 공통 변수는 계좌의 잔액이다. 이에 접근하는 프로세스의 코드를 보면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 입금&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 출금&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 자바 문법에서는 한 줄이라 문제가 없어 보이지만, 로우 레벨(어셈블리어)로 내려가면 &lt;strong&gt;여러 줄로 구현&lt;/strong&gt;된다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;balance&lt;/code&gt;를 업데이트 하는 하이 레벨 코드 1줄이 로우 레벨에서 3줄로 구현된다고 하자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;공유 변수인 현재 잔액을 복사한다.&lt;/li&gt;
  &lt;li&gt;현재 잔액에서 명령을 수행한다.&lt;/li&gt;
  &lt;li&gt;나온 결과를 가지고 잔액을 갱신한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그런데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt;가 수행하던 도중에 1000번을 다 수행하지 못한 상황에서 interrupt(이 경우에는 시간 지연을 걸었으므로 timer interrupt가 되겠다.)가 걸려 2번 라인에서 멈췄다고 생각해보자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt;가 1000원을 입금했지만, 업데이트가 되지 않아 여전히 현재 잔액은 0이다.&lt;/p&gt;

&lt;p&gt;이번에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child&lt;/code&gt;가 부모님이 용돈을 넣은 줄 알고 신나서 돈을 뽑는 상황을 생각해보자. 잔액을 확인했더니, 아직 0이다. 그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child&lt;/code&gt;는 마이너스 통장을 통해 돈은 인출하고 현재 잔액은 -1000이 된다.&lt;/p&gt;

&lt;p&gt;따라서 이 경우, 입금과 인출이라는 행위는 프로세스 입장에서 원자성을 갖는 행위이므로 동기화가 필수적이다. 기억이 안난다면 이 글을 보자.
&lt;a href=&quot;http://127.0.0.1:4000/cs/structure/2020/03/21/컴퓨터구조-용어정리.html&quot;&gt;가볍게 이해하는 컴퓨터 01: 용어 정리&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-임계구역critical-section-문제&quot;&gt;3. 임계구역(Critical section) 문제&lt;/h1&gt;

&lt;p&gt;위의 예에서 보았던 문제를 임계구역 문제라 한다. 임계구역은 여러 개의 쓰레드가 수행되는 시스템에서 각 쓰레드들이 &lt;strong&gt;공유하는 데이터(변수, 테이블, 파일 등)를 변경하는 코드 영역&lt;/strong&gt;을 말한다. 이는 동기화에서 중요한 문제 중 하나이다. 은행계좌 문제에서의 임계구역은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;31-해결-방법&quot;&gt;3.1 해결 방법&lt;/h2&gt;

&lt;p&gt;임계구역을 해결하기 위해서는 3가지 조건이 만족해야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mutual exclusion(상호배타)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;오직 한 쓰레드만이 진입 가능&lt;/strong&gt;하다. 한 쓰레드가 임계구역에서 수행 중인 상태에서는 다른 쓰레드는 절대 이 구역에 접근할 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Progress(진행)
    &lt;ul&gt;
      &lt;li&gt;한 임계구역에 접근하는 쓰레드를 결정하는 것은 유한 시간 이내에 이루어져야한다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;누가 먼저 들어갈 것인지 빠르게 결정&lt;/strong&gt;해라&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bounded waiting(유한대기)
    &lt;ul&gt;
      &lt;li&gt;임계구역으로 진입하기 위해 대기하는 모든 쓰레드는 유한 시간 이내에 해당 임계구역으로 진입할 수 있어야 한다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;기다리는 모든 쓰레드가 진입가능하도록 만들어라.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-프로세스쓰레드-동기화의-목적&quot;&gt;4. 프로세스/쓰레드 동기화의 목적&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;원하는 결과값을 도출하도록 임계구역 문제를 해결한다.&lt;/li&gt;
  &lt;li&gt;프로세스의 실행 순서를 원하는대로 제어한다.&lt;/li&gt;
  &lt;li&gt;Busy wait 등과 같은 비효율성을 제거한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>07: 쓰레드(Thread)</title>
        <link>/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-07-%EC%93%B0%EB%A0%88%EB%93%9C.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-07-%EC%93%B0%EB%A0%88%EB%93%9C.html</guid>
        <description>&lt;p&gt;Thread에 대해서 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;쓰레드thread&quot;&gt;쓰레드(Thread)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;쓰레드는 프로그램 &lt;strong&gt;내부의 흐름(맥)&lt;/strong&gt;이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;end&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 코드는 하나의 흐름을 가지고 있고 이것을 쓰레드라 부른다. 일반적으로 하나의 프로그램은 하나의 쓰레드를 갖는다.&lt;/p&gt;

&lt;h2 id=&quot;다중-쓰레드mulitithreads&quot;&gt;다중 쓰레드(Mulitithreads)&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78137531-73ff1200-7460-11ea-95ec-2f7db82f5c64.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하나의 프로그램에 쓰레드가 2개 이상 존재하는 것을 다중 쓰레드라고 한다. 이렇게 한 프로그램에 여러 개의 쓰레드 즉, 흐름이 있을 수 있는 이유는 쓰레드가 빠른 시간 간격으로 스위칭되기 때문이다. 이러한 동작으로 사용자는 여러 쓰레드가 동시에 실행되는 것처럼 보인다.&lt;/p&gt;

&lt;p&gt;이 때, 동시에 수행되는 것 처럼 보이는 것을 concurrent, 실제 동시에 수행되는 것을 simultaneous라고 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;concurrent
    &lt;ul&gt;
      &lt;li&gt;CPU가 하나인 환경에서 스위칭에 의해 동시에 수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;simultaneous
    &lt;ul&gt;
      &lt;li&gt;여러개의 CPU 환경에서 실제로 동시에 수행되는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;

&lt;p&gt;다중 쓰레드를 사용하는 대표적인 예는 Web browser 이다. 화면을 출력하는 쓰레드와 데이터를 읽어오는 쓰레드가 기본적으로 따로 수행하고 있다. 그 외에도 Word processor, Media player 등 현재 대부분의 프로그램은 다중 쓰레드로 동작한다.&lt;/p&gt;

&lt;h3 id=&quot;현대-운영체제의-switching-단위&quot;&gt;현대 운영체제의 Switching 단위&lt;/h3&gt;

&lt;p&gt;이전의 CPU 스케줄링에서 하나의 프로세스가 수행하다가 다른 프로세스로 넘어간다고 하였는데, 이는 예전의 방식이다. 현재 운영체제에서는 대부분 다중 쓰레드를 지원하기 때문에 하나의 프로세스 안에서 여러 쓰레드를 수행하다가 다른 프로세스로 넘어가서 그 프로세스의 쓰레드를 수행한다. 그러므로 현대 운영체제의 &lt;strong&gt;context switching 단위는 프로세스가 아닌 쓰레드 단위&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h2 id=&quot;thread-vs-precess&quot;&gt;Thread VS Precess&lt;/h2&gt;

&lt;p&gt;이 부분을 제대로 이해하기 위해 process를 보고오자.&lt;br /&gt;
&lt;a href=&quot;http://127.0.0.1:4000/cs/structure/2020/03/27/컴퓨터구조-운영-체제가-하는-일.html&quot;&gt;가볍게 이해하는 컴퓨터 07: 운영 체제가 하는 일&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://127.0.0.1:4000/cs/os/2020/04/01/운영체제-정리-05-운영체제-프로세스-관리.html&quot;&gt;운영체제 정리 05: 프로세스 관리&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;프로세스는 다른 프로세스와 완전히 독립적이다. 해당 프로세스가 가지는 구조로는 Code, Data, Heap, Stack이 있다. 이 때 쓰레드는 자기가 속한 프로세스의 일부 메모리를 공유한다. 집이라면 각 개인 구성원이 거실을 공유하는 셈이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;공유&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;독립&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Code&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Stack&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Data&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PC(program counter)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Heap&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SP(stack pointer)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Registers&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;thread가-독립적-요소를-가져야-하는-이유&quot;&gt;Thread가 독립적 요소를 가져야 하는 이유&lt;/h3&gt;

&lt;p&gt;현대 운영체제는 결국 Context Switching의 최소단위를 thread로 잡고 있기 때문이다. 결국 CPU가 처리하는 것은 thread이고, 그렇기 때문에 현재 실행 흐름을 독립적으로 기록할 필요가 있다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>06: CPU 스케쥴링</title>
        <link>/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-06-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-06-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81.html</guid>
        <description>&lt;p&gt;CPU 스케쥴링에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다. 이때 다음 프로세스가 어느 프로세스인지를 선택하는 알고리즘을 CPU Scheduling 알고리즘이라고 한다. 간단히 생각해보면 먼저 온 프로세스가 먼저 실행되는 것이 가장 좋을 것이라 생각할 수 있다. 하지만 여러 상황에서 사용되는 컴퓨터 환경에서 꼭 이러한 방법이 좋다고 할 수 없다. (단순한 환경에서도 이 방법이 반드시 빠른 것도 아니다.) 그러므로 CPU 스케줄링에는 여러가지 방법이 존재한다.&lt;/p&gt;

&lt;h1 id=&quot;1-스케쥴링의-유형&quot;&gt;1. 스케쥴링의 유형&lt;/h1&gt;

&lt;p&gt;유형으로는 Preemptive 와 Non-preemptive가 있다.&lt;/p&gt;

&lt;h2 id=&quot;11-preemptive&quot;&gt;1.1 Preemptive&lt;/h2&gt;

&lt;p&gt;Preemptive(선점)은 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생한 것도 아니고 모든 작업을 끝내지도 않았는데, 다른 프로세스가 해당 CPU를 강제로 점유 할 수 있다. 즉, 프로세스가 정상적으로 수행중인 가운데 다른 프로세스가 CPU를 강제로 점유하여 실행할 수 있는 것이다. &lt;del&gt;급똥 우선순위&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-non-preemptive&quot;&gt;1.2 Non-preemptive&lt;/h2&gt;

&lt;p&gt;Non-preemptive(비선점)은 말 그대로 preemptive와 반대이다. 한 프로세스가 한 번 CPU를 점유했다면, I/O나 인터럽트 발생 또는 프로세스 종료가 될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다. &lt;del&gt;순서대로 들어가자&lt;/del&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-scheduling-criteria&quot;&gt;2. Scheduling criteria&lt;/h1&gt;

&lt;p&gt;Scheduling criteria(척도)는 스케줄링의 효율을 분석하는 기준들이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU Utilization(이용률, %)
    &lt;ul&gt;
      &lt;li&gt;CPU가 수행되는 비율&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Throughput(처리율, jobs/sec)
    &lt;ul&gt;
      &lt;li&gt;단위시간당 처리하는 작업의 수(처리량)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Turnaround time(반환시간)
    &lt;ul&gt;
      &lt;li&gt;프로세스의 처음 시작 시간부터 모든 작업을 끝내고 종료하는데 걸린 시간이다.(CPU, waiting, I/O 등 모든 시간을 포함한다.) 반환시간은 짧을 수록 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Waiting time(대기시간)
    &lt;ul&gt;
      &lt;li&gt;CPU를 점유하기 위해서 ready queue에서 기다린 시간을 말한다.(다른 큐에서 대기한 시간은 제외한다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Response time(응답시간)
    &lt;ul&gt;
      &lt;li&gt;일반적으로 대화형 시스템에서 입력에 대한 반응 시간을 말한다. 사용자와의 상호작용을 중요로 하는 프로세스의 경우이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-cpu-scheduling-algorithms&quot;&gt;3. CPU Scheduling Algorithms&lt;/h1&gt;

&lt;p&gt;CPU에서 프로세스의 순서를 처리하는 알고리즘에 대해 알아본다.&lt;/p&gt;

&lt;h2 id=&quot;31-first-come-first-servedfcfs&quot;&gt;3.1 First-Come, First-Served(FCFS)&lt;/h2&gt;

&lt;p&gt;FCFS는 먼저 온 프로세스가 먼저 CPU를 점유하는 방식이다. 이는 매우 단순하고 많이 사용하는 방법이지만, 모든 부분에서 효율적인 것은 아니다.&lt;/p&gt;

&lt;h3 id=&quot;gantt-chart&quot;&gt;Gantt Chart&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Burst Time(msec)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78102085-61ff7e00-7424-11ea-8df9-eafb8dfce216.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 표를 아래의 그림으로 나타낸 것을 Gantt Chart라 한다. P1, P2, P3 순으로 메모리에 도착했다고 가정했을 때, P1, P2, P3의 총 대기시간의 평균을 구해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Average Waiting Time = ${0+24+27\over 3} = 17msec$ 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런데 만약 P3, P2, P1 순으로 들어왔다고 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78102317-041f6600-7425-11ea-9ccd-094082d6b0d1.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Average Waiting Time = ${6+3+0\over 3} = 3msec$ 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 예제에서 모든 프로세스가 끝난 시간은 30msec로 같지만, 평균 대기시간으로 봤을 때는 위의 예제는 17msec이고 아래는 3msec로 차이가 난다. 즉, 들어온 순서로 수행한다고 해도 반드시 효율적인 것은 아닌 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;이것은 공중화장실을 기다리는 &lt;del&gt;맨날 더럽냐&lt;/del&gt; 3명의 사람으로 치환해서 생각할 수 있다. 빠른 맺고 끊음이 가능한 선수가 먼저 입장하는 것이 공공의 이익을 최대화 할 수 있다. &lt;del&gt;응?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;위 예제처럼 P1, P2, P3 순서로 들어와 시간이 오래 걸리는 현상을 Convoy Effect 라고 한다. 이는 CPU 시간을 오래 사용하는 프로세스가 먼저 수행하는 동안 나머지 프로세스들은 그 만큼 오래 기다리는 것을 말한다.&lt;/p&gt;

&lt;h3 id=&quot;fcfs의-특징-정리&quot;&gt;FCFS의 특징 정리&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Convoy Effect가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;Non-preemptive 방식이다. 하나의 프로세스가 끝나기 전에 다른 프로세스가 끼어들 수 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;32-shortest-job-firstsjf&quot;&gt;3.2 Shortest-Job-First(SJF)&lt;/h2&gt;

&lt;p&gt;SJF는 이름에서도 나타나듯이 가장 짧게 수행되는 프로세스가 가장 먼저 수행되는 것을 말한다. FCFS에서 보았듯이 수행 시간이 짧은 프로세스가 먼저 오는 것이 평균 대기시간이 짧은 것을 알 수 있었다. 이를 이용한 것이 SJF이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Burst Time(msec)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78102712-ee5e7080-7425-11ea-93f8-4948627e05fa.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Average Waiting Time(AWT) = ${3+16+9+0\over 4} = 7msec$ 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 예를 FCFS로 나타냈을 때 평균 대기시간을 계산해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Average Waiting Time(AWT) = ${0+6+14+21\over 4} = 10.25msec$ 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SJF와 FCFS의 평균 대기시간을 살펴보면 당연히 SJF가 더 짧은 것을 볼 수 있다. SJF가 평균 대기시간 기준으로 어떠한 방법보다 짧은 것은 이미 수학적으로 증명되어 있다. 그러므로 어떠한 예제를 보더라도 &lt;strong&gt;SJF가 AWT는 가장 짧다&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;한계&quot;&gt;한계&lt;/h3&gt;

&lt;p&gt;이를 보면 SJF가 가장 효율적인 CPU 스케줄링 방법으로 이를 쓰면 될 것 같지만, 사실은 이 스케줄링 방법은 매우 &lt;strong&gt;비현실적&lt;/strong&gt;이다. 왜냐하면 현실적인 컴퓨터 환경에서는 &lt;strong&gt;프로세스의 CPU 점유 시간(burst time)을 알 수 없다.&lt;/strong&gt; 왜냐하면 한 프로세스가 실행 중에는 많은 변수가 존재하기 때문에 CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수 밖에 없다. 실제 측정한 시간으로 예측해서 SJF를 사용할 수도 있지만, 이는 오버헤드가 매우 큰 작업으로 잘 사용되지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;preemptive--non-preemptive-방식&quot;&gt;Preemptive &amp;amp; non-preemptive 방식&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Arrival Time&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Burst Time(msec)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78103548-2ff01b00-7428-11ea-9a65-aad9caada41f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;non-preemptive&quot;&gt;non-preemptive&lt;/h4&gt;

&lt;p&gt;가장 먼저 도착한 P1이 수행되는 동안 P2, P3, P4 모두 도착하지만, non-preemptive이므로 이미 수행중인 프로세스가 끝날 때까지 기다려야 한다. &lt;strong&gt;일단 시작한 놈은 그대로 하고&lt;/strong&gt; 남은 놈들에 대해서 대기시간이 짧은 것에 우선순위를 주자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Average Waiting Time(AWT) = ${0+7+15+9\over 4} = 7.75msec$ 이다.
​&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;preemptive&quot;&gt;Preemptive&lt;/h4&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78103852-e18f4c00-7428-11ea-94fb-648871a903d6.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 p]Preemptive이므로 &lt;strong&gt;프로세스가 도착할 때마다&lt;/strong&gt;, 어느 프로세스가 가장 짧은 것인지 선택해야 한다. 주목할 점은 P2 프로세스가 도착했을 때, 현재 남은 burst time 중 가장 짧은 프로세스가 P2이므로 P1을 수행하던 것을 멈추고 P2가 수행을 시작한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Average Waiting Time(AWT) = ${9+0+15+2\over 4} = 6.5msec$ 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Preemptive SJF는 예제에서 살펴보았듯이 현재 남아있는 시간 중 가장 짧은 프로세스를 선택하므로 Shortest-Remaining-Time-First(최소잔여시간 우선) 이라 불리기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;sjf의-특징-정리&quot;&gt;SJF의 특징 정리&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;AWT가 가장 짧다.&lt;/li&gt;
  &lt;li&gt;프로세스의 실행 시간을 알 수 없기 때문에 비현실적이다. 이를 가능케 하기 쉬해서는 예측이 필요하다.&lt;/li&gt;
  &lt;li&gt;Preemptive &amp;amp; non-preemptive 둘다 가능하다.
    &lt;ul&gt;
      &lt;li&gt;이 중 Preemptive SJF는 Shortest-Remaining-Time-First(최소잔여시간 우선)이라 불린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;33-priority&quot;&gt;3.3 Priority&lt;/h2&gt;

&lt;p&gt;Priority 스케줄링은 말그대로 &lt;strong&gt;우선순위가 높은 프로세스가 먼저 선택&lt;/strong&gt;되는 스케줄링 알고리즘이다. 운영체제에서 일반적으로 우선순위는 정수값으로 나타내며, 작은 값이 우선순위가 높다.(Unix/Linux 기준)&lt;del&gt;돈 주며 화장실 앞 줄을 사는 행위&lt;/del&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Burst Time(msec)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Priority&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78104260-d8eb4580-7429-11ea-88f0-10e0b3bfd245.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;표에서 우선순위 값이 가장 낮은 순서대로 수행한 모습을 간트 차트로 나타내었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Average Waiting Time(AWT) = ${6+0+16+18+1\over 5} = 8.2msec$ 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;우선-순위를-정하는-방법&quot;&gt;우선 순위를 정하는 방법&lt;/h3&gt;

&lt;p&gt;우선순위를 정하는 방법은 크게 내부적인 요소와 외부적인 요소 두 가지로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Internal
    &lt;ul&gt;
      &lt;li&gt;time limit, memory requirement, I/O to CPU burst(I/O작업은 길고, CPU 작업은 짧은 프로세스 우선) 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;External
    &lt;ul&gt;
      &lt;li&gt;amount of funds being paid, political factors 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Priority 스케줄링 역시 preemprive 와 non-preemptive 두 방식 모두 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;한계-1&quot;&gt;한계&lt;/h3&gt;

&lt;p&gt;Priority 스케줄링의 문제점은 &lt;strong&gt;Starvation(기아)&lt;/strong&gt;이 있다. &lt;del&gt;못 싸는 놈은 평생 못싸 ㅠㅠ&lt;/del&gt; Starvation은 말 그대로 CPU의 점유를 오랫동안 하지 못하는 현상을 말한다. Priority 스케줄링 방식에서 우선순위가 매우 낮은 프로세스가 ready queue에서 대기하고 있다고 가정해보자. 이 프로세스는 아무리 오래 기다려도 CPU를 점유하지 못할 가능성이 매우 크다. 실제 컴퓨터 환경에서는 새로운 프로세스가 자주 ready queue에 들어온다. 이러한 프로세스가 모두 우선순위가 높은 상태라면 이미 기다리고 있던 우선순위가 낮은 프로세스는 하염없이 기다리고만 있는 상태로 남아있을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h3&gt;

&lt;p&gt;이를 해결하는 방법 중 하나는 &lt;strong&gt;aging&lt;/strong&gt;이 있다. 이 방식은 ready queue에서 기다리는 동안 일정 시간이 지나면 우선순위를 일정량 높여주는 것이다. &lt;del&gt;복지&lt;/del&gt; 그러면 우선순위가 매우 낮은 프로세스라 하더라도, 기다리는 시간이 길어질수록 우선순위도 계속 높아지므로 수행될 가능성이 커진다.&lt;/p&gt;

&lt;h3 id=&quot;priority의-특징-정리&quot;&gt;Priority의 특징 정리&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;우선 순위가 높은 녀석 부터 처리&lt;/li&gt;
  &lt;li&gt;그렇기 때문에 평생 처리 못받는 녀석이 생긴다. (Starvation)&lt;/li&gt;
  &lt;li&gt;이를 방지 하기 위해 Ready 상태에서 일정시간이 지나면 우선 순위를 높여준다. (aging)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;34-round-robinrr&quot;&gt;3.4 Round-Robin(RR)&lt;/h2&gt;

&lt;p&gt;Round-Robin은 원 모양으로 모든 프로세스가 돌아가며 스케줄링하는 것을 말한다. 이는 &lt;strong&gt;시분할 시스템에서 주로 사용&lt;/strong&gt;하는 방식이다. 일정 시간을 정하여 하나의 프로세스가 이 시간동안 수행하고 다시 대기 상태로 돌아간다. 그리고 다음 프로세스가 역시 같은 시간동안 수행한 후 대기한다. 이러한 작업을 모든 프로세스가 돌아가면서 하며, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아와서 반복한다.&lt;/p&gt;

&lt;p&gt;위에서 말한 일정 시간을 Time Quantum(Time Slice)이라 부른다. Time Quantum은 일반적으로 10 ~ 100msec 사이의 범위를 갖는다. Round-Robin은 기본적으로 &lt;strong&gt;preemptive&lt;/strong&gt; 이다. 한 프로세스가 종료되기 전에 time quantum이 끝나면 다른 프로세스로 CPU를 넘겨주기 때문이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Burst Time(msec)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78105020-29af6e00-742b-11ea-8342-501d0e471ae9.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong class=&quot;center-text&quot;&gt;time Quantum = 4msec&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Round-Robin 방식에서는 time quantum이 끝나면 CPU는 현재 프로세스를 대기상태로 보내고 다음 프로세스를 수행한다. 예제에서 P1이 0msec에 수행을 시작하여 종료되기 전에 time quantum 시간이 끝나여 P2가 수행되는 모습을 볼 수 있다. 그리고 P2, P3는 time quantum이 끝나기전에 수행이 끝났고, 마지막 남은 P1은 다른 프로세스가 없으므로 time quantum이 끝나더라도 종료될 때까지 계속해서 수행하는 모습이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Average Waiting Time(AWT) = ${6+4+7\over 3} = 5.66msec$ 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;한계-2&quot;&gt;한계&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;1000&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78105871-2321f600-742d-11ea-9f30-9dc151db36ff.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RR방식은 time quantum 크기에 따라 AWT와 같은 스케줄링 척도가 바뀐다. 그러므로 RR 방식은 &lt;strong&gt;time quantum에 매우 의존적&lt;/strong&gt;인 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;만약 time quantum 크기가 &lt;strong&gt;무한&lt;/strong&gt;에 가깝게 설정한다면 &lt;strong&gt;FCFS&lt;/strong&gt;와 동일하게 동작한다. 반대로 time quantum 크기를 &lt;strong&gt;0&lt;/strong&gt;에 가깝게 설정하면 &lt;strong&gt;switching overhead가 매우 증가&lt;/strong&gt;하여 비효율적이다. 결과적으로 time quantum 은 적당한 크기로 설정해주어야 하는데, 일반적으로 위에서 말했듯이 10 ~ 100msec 으로 정한다.&lt;/p&gt;

&lt;h3 id=&quot;rr의-특징-정리&quot;&gt;RR의 특징 정리&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;모든 프로세스에 일정한 시간(time quantum)을 주어서 관리한다.&lt;/li&gt;
  &lt;li&gt;따라서 time quantum에 매우 의존적이다. 적당한 값(10 ~ 100msec)이 중요하다.
    &lt;ul&gt;
      &lt;li&gt;$\infty$ ~ FCFS&lt;/li&gt;
      &lt;li&gt;$0$ ~ switching overhead가 매우 증가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;35-multilevel-queue&quot;&gt;3.5 Multilevel Queue&lt;/h3&gt;

&lt;p&gt;Multilevel Queue를 살펴보기 전에 프로세스 그룹에 대해 살펴보자. 프로세스는 기준에 따라 여러 그룹으로 나눌 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;System processes
    &lt;ul&gt;
      &lt;li&gt;운영체제 커널 수준의 프로세스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Interactive processes
    &lt;ul&gt;
      &lt;li&gt;유저 수준의 대화형 프로세스 (게임)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Interactive editing processes
    &lt;ul&gt;
      &lt;li&gt;Word Processor&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Batch processes
    &lt;ul&gt;
      &lt;li&gt;대화형 프로세스의 반대인 것으로 일정량을 한 번에 처리하는 프로세스(Ex, 컴파일러)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Student processes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같이 여러 성격에 따라 프로세스 그룹을 나눌 수 있는데 이를 하나의 큐에 사용하는 것은 비효율적이라고 판단하였다. 그래서 각 그룹에 따라 큐를 두어 여러 개의 큐를 사용하는 것이 Muitilevel Queue 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78106173-d12da000-742d-11ea-82d9-f3010a2a1d7f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 각 그룹에 따라 큐를 나눈 것이다. 그리고 각 큐마다 다른 규칙을 지정할 수도 있다.&lt;/p&gt;

&lt;p&gt;먼저, &lt;strong&gt;큐마다 우선순위를 지정&lt;/strong&gt;해줄 수 있다. 프로세스 그룹을 보면 System process는 커널 수준에서 중요한 작업이므로 우선순위가 높은 그룹이라 볼 수 있다. 위 그림에서 System process, Interactive process, Batch process 순으로 우선순위가 높은 순서이다. Batch 프로세스는 운영체제의 개입이 매우 적으므로 우선순위가 가장 낮다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;위의 방식 이외에도 &lt;strong&gt;큐에 따라 여러 기준&lt;/strong&gt;을 둘 수 있다. 큐마다 CPU 시간을 다르게 줄 수도 있고, 큐마다 다른 스케줄링 방식을 사용할 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;multilevel-queue의-특징&quot;&gt;Multilevel Queue의 특징&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스를 그룹으로 나눈다.&lt;/li&gt;
  &lt;li&gt;각각의 Queue에 절대적 우선 순위가 존재한다.&lt;/li&gt;
  &lt;li&gt;CPU time을 Queue에 차등 배분한다.&lt;/li&gt;
  &lt;li&gt;각 Queue는 독립된 scheduling 정책을 갖는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;36-multilevel-feedback-queue&quot;&gt;3.6 Multilevel Feedback Queue&lt;/h2&gt;

&lt;p&gt;Multilevel Feedback Queue도 Multilevel Queue와 같이 여러 개의 큐를 사용한다는 점에서 유사하다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78106392-45684380-742e-11ea-9576-e1a34b4f661f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림을 보면 먼저 모든 프로세스는 가장 위의 큐에서 CPU의 점유를 대기한다. 이 상태로 진행하다가 이 큐에서 기다리는 시간이 너무 오래 걸린다면 아래의 큐로 프로세스를 옮긴다. 이와 같은 방식으로 대기 시간을 조정할 수 있다. 그리고 Multilevel Feedback Queue에서도 각 큐마다 다른 스케줄링, 다른 우선순위 등을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 우선순위순으로 큐를 사용하는 상황에서 우선순위가 낮은 아래의 큐에 있는 프로세스에서 starvation 상태가 발생하면 이를 우선순위가 높은 위의 큐로 옮길 수도 있다.&lt;/p&gt;

&lt;p&gt;대부분의 상용 운영체제는 여러 개의 큐를 사용하고 각 큐마다 다른 스케줄링 방식을 사용한다. 프로세스의 성격에 맞는 스케줄링 방식을 사용하여 최대한 효율을 높일 수 있는 방법을 선택한다.&lt;/p&gt;

&lt;h3 id=&quot;multilevel-feedback-queue의-특징&quot;&gt;Multilevel Feedback Queue의 특징&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;여러개의 Queue를 가진다.&lt;/li&gt;
  &lt;li&gt;다른 Queue로 점진적 이동한다.
    &lt;ul&gt;
      &lt;li&gt;모든 프로세스는 각자의 하나의 Queue로 진입한다.&lt;/li&gt;
      &lt;li&gt;너무 많은 CPU time 사용시 다른 Queue로 이동한다.&lt;/li&gt;
      &lt;li&gt;기아 상태 우려시 우선 순위 높은 Queue로 이동한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>05: 프로세스 관리</title>
        <link>/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-05-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-05-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC.html</guid>
        <description>&lt;p&gt;프로세스의 정의, CPU 스케쥴러, 멀티 프로그래밍에 대해 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;1-프로세스process&quot;&gt;1. 프로세스(Process)&lt;/h1&gt;

&lt;p&gt;프로세스는 메인 메모리에 할당되어 실행중인 상태인 프로그램을 말한다. 프로그램은 일반적으로 하드디스크(보조기억장치)에 저장되어 아무 일도 하지 않는 상태이다. 프로세스는 실행하면서 stack pointer, data, text, register 등이 끊임없이 변한다. 프로세스는 job, task 등으로 불리기도 한다.&lt;/p&gt;

&lt;h2 id=&quot;11-프로세스의-생성과-종료&quot;&gt;1.1 프로세스의 생성과 종료&lt;/h2&gt;

&lt;p&gt;프로세스는 프로세스에 의해 만들어진다. 컴퓨터가 부팅이 되면 운영체제가 메모리에 올라오는데 &lt;strong&gt;운영체제가 처음으로 수행하는 일 중에 하나는 최초의 프로세스를 생성하는 것&lt;/strong&gt;이다. 이렇게 처음 만들어진 프로세스가 다른 프로세스를 만들고 그 프로세스가 또 다른 프로세스를 만드는 과정을 반복한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1000&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78107398-57e37c80-7430-11ea-821d-38e28c8f0b6a.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 최초의 프로세스는 &lt;strong&gt;Init&lt;/strong&gt;이다. 이 이름은 운영체제마다 다르고, init은 UNIX 운영체제 기준 이름이다. 여기서 여러 다른 프로세스들이 생성되면 위와 같은 그림처럼 트리 모양으로 나타낼 수 있다.여기서 프로세스를 생성한 쪽을 부모 프로세스, 만들어진 프로세스를 자식 프로세스라고 한다. 같은 부모를 갖는 자식 프로세스 끼리는 서로 Sibling(형제) 프로세스라고 한다.&lt;/p&gt;

&lt;p&gt;프로세스는 각각 고유의 번호를 갖는데 이를 &lt;strong&gt;PID(Process Identifirer)&lt;/strong&gt;라고 한다. PID는 일반적으로 정수형(integer)으로 표현한다. PPID는 부모의 PID를 말한다.&lt;/p&gt;

&lt;h3 id=&quot;111-프로세스-생성&quot;&gt;1.1.1 프로세스 생성&lt;/h3&gt;

&lt;p&gt;새로운 프로세스를 만드는 시스템 콜이 존재하는데, 이는 fork() 라 한다. 만들어진 프로세스에서 어떠한 파일을 실행하려면 exec() 시스템 콜을 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;112-프로세스-종료&quot;&gt;1.1.2 프로세스 종료&lt;/h3&gt;

&lt;p&gt;프로세스를 종료하는 시스템 콜은 exit() 이다. 한 프로세스가 종료되면 해당 프로세스가 사용한 모든 자원(메모리, 파일, I/O 등)을 회수해야한다. 이러한 회수된 자원과 권한은 모두 운영체제로 되돌아가야한다.&lt;/p&gt;

&lt;h2 id=&quot;12-프로세스의-구조&quot;&gt;1.2 프로세스의 구조&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;1690&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78095078-0a0b4c00-7411-11ea-9716-9dc0f2c2a88a.png&quot; class=&quot;center&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://mintnlatte.tistory.com/396&quot; class=&quot;center-text&quot;&gt;출처 : https://mintnlatte.tistory.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rookieboxsite.files.wordpress.com/2017/10/c_memmap_exam_vs.png?w=540&amp;amp;zoom=2&quot; alt=&quot;&quot; class=&quot;center&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://rookieboxsite.wordpress.com/2017/10/20/프로세스-메모리-구조/&quot; class=&quot;center-text&quot;&gt;출처 : https://rookieboxsite.wordpress.com&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;121-stack&quot;&gt;1.2.1 Stack&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램의 지역 변수, 함수, return 주소를 포함한다.&lt;/li&gt;
  &lt;li&gt;함수 호출을 하면 해당 주소가 스택영역에 저장되어 있다가 return하면 pop된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;122-heap&quot;&gt;1.2.2 Heap&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;힙 영역에는 프로그램이 실행되는 동안 동적으로 사용할 데이터들이 저장된다.&lt;/li&gt;
  &lt;li&gt;c언어의 malloc을 이용해서 메모리를 동적할당하면 힙 영역에 저장된다.(free시키지 않으면 힙 영역에 계속 들어 있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;123-data&quot;&gt;1.2.3 Data&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 영역에는 전역 변수와 정적 지역 변수가 포함되어 있다.
데이터 영역은 &lt;strong&gt;BSS&lt;/strong&gt;, &lt;strong&gt;Data&lt;/strong&gt;로 나눠진다.&lt;/li&gt;
  &lt;li&gt;BSS는 초기화 되지 않은 변수들이 저장
초기화 된 변수들이 저장된 영역으로 0으로 자동 초기화해 준다.&lt;/li&gt;
  &lt;li&gt;Data는 초기값을 설정한 전역 변수와 정적 변수를 위한 영역이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bssdata로-구분하는-이유&quot;&gt;BSS,Data로 구분하는 이유?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;초기화 된 데이터는 초기값을 저장해야 함으로 Data영역에 저장되서 Rom에 저장된다. 하지만 초기화 되지 않은 데이터 까지 Rom에 저장되면 큰 size의 rom이 필요하므로 구분한다 ( 초기화 되지 않은 데이터는 ram에 저장하자)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;124-text&quot;&gt;1.2.4 Text&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;해당 코드가 저장되는 영역이다.&lt;/li&gt;
  &lt;li&gt;힙과 ,스택영역에서 오버플로우가 발생할 것을 대비해서 힙/스택의 아래부분에 위치한다.&lt;/li&gt;
  &lt;li&gt;실행 순서등이 저장되어 있다.&lt;/li&gt;
  &lt;li&gt;읽기 전용이다.&lt;/li&gt;
  &lt;li&gt;다른 프로세스에서 참조 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;125-정리&quot;&gt;1.2.5 정리&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;크기 변화&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;O&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;X&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Stack&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Text&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Heap&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Data&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Bss&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Text
    &lt;ul&gt;
      &lt;li&gt;Program Counter(다음번에 실행될 명령어의 주소를 저장하는 레지스터 : CPU에게 줄 예정)&lt;/li&gt;
      &lt;li&gt;프로그램 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data
    &lt;ul&gt;
      &lt;li&gt;전역 변수 저장&lt;/li&gt;
      &lt;li&gt;스태틱 변수 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Heap
    &lt;ul&gt;
      &lt;li&gt;메모리 관리&lt;/li&gt;
      &lt;li&gt;동적 메모리 할당 (system call로 관리)&lt;/li&gt;
      &lt;li&gt;메모리에 접근하기 때문에 주의해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stack
    &lt;ul&gt;
      &lt;li&gt;임시 데이터 저장&lt;/li&gt;
      &lt;li&gt;지역 변수&lt;/li&gt;
      &lt;li&gt;반환 주소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;13-프로세스-상태&quot;&gt;1.3 프로세스 상태&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;New: 프로그램이 메인 메모리에 할당된다.&lt;/li&gt;
  &lt;li&gt;Ready: 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친다.&lt;/li&gt;
  &lt;li&gt;Running: CPU가 해당 프로세스를 실행한다.&lt;/li&gt;
  &lt;li&gt;Waiting: 프로세스가 끝나지 않은 시점에서 I/O로 인해 CPU를 사용하지 않고 다른 작업을 한다. (해당 작업이 끝나면 다시 CPU에 의해 실행되기 위해 ready 상태로 돌아가야 한다.)&lt;/li&gt;
  &lt;li&gt;Terminated: 프로세스가 완전히 종료된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;1122&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78094481-9a489180-740f-11ea-93b9-ae4c3e5a78f2.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 &lt;strong&gt;프로세스 상태 전이도&lt;/strong&gt;의 모습이다. new에서부터 프로세스가 어떤 작업에 의해 상태가 변하는지 나타낸다. running에서 ready로 변할 때는 time sharing system에서 해당 프로세스가 CPU시간을 모두 소진하였을 때 인터럽트에 의해 강제로 ready상태로 변하고, CPU는 다른 프로세스를 실행시킨다.&lt;/p&gt;

&lt;h2 id=&quot;14-pcbprocess-control-block&quot;&gt;1.4 PCB(Process Control Block)&lt;/h2&gt;

&lt;p&gt;PCB는 &lt;strong&gt;프로세스에 대한 모든 정보가 모여있는 곳&lt;/strong&gt;으로, Task Control Block(TCB) 이라고도 한다. PCB안에는 프로세스의 상태, 프로세스 번호(PID), 해당 프로세스의 program counter(pc), register값, MMU(Memory Management Unit)정보, CPU점유 시간 등이 포함되어 있다. PCB는 &lt;strong&gt;운영체제 내부&lt;/strong&gt;의 프로세스를 관리하는 코드 부분에 저장되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1000&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78096444-86ebf500-7414-11ea-80e3-4f6f4be7403a.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU는 한 프로세스가 종료될 때까지 수행하는 것이 아니라 여러 프로세스를 중간 중간에 바꿔가면서 수행한다. 그러므로 CPU는 수행중인 프로세스를 나갈 때, 이 프로세스의 정보를 어딘가에 저장하고 있어야 다음에 이 프로세스를 수행할 때 이전에 수행한 그 다음부터 이어서 작업할 수 있다. 이러한 정보를 저장하는 곳이 PCB이다.&lt;/p&gt;

&lt;h2 id=&quot;15-프로세스-큐queue&quot;&gt;1.5 프로세스 큐(Queue)&lt;/h2&gt;

&lt;p&gt;프로세스의 생애 주기를 생각해보면, DISK, Memory, cpu등을 거치게 된다. 갈수록 좁아지는 공간과, 한정된 자원 때문에 &lt;strong&gt;병목현상&lt;/strong&gt;이 발생할 수 밖에 없다. 그렇기 때문에 우리는 먼저 실행된 프로세스와 같은 &lt;strong&gt;규칙에 따라 이 프로세스들을 줄세워 관리&lt;/strong&gt;해야 한다. 이러한 순서를 Queue로 관리한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1202&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78097269-d4696180-7416-11ea-919b-b6fb06952fb3.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Job Queue: 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐이다.&lt;/li&gt;
  &lt;li&gt;Ready Queue: CPU 점유 순서를 기다리는 큐이다.&lt;/li&gt;
  &lt;li&gt;Device Queue: I/O를 하기 위한 여러 장치가 있는데, 각 장치를 기다리는 큐가 각각 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;scheduling스케쥴링&quot;&gt;Scheduling(스케쥴링)&lt;/h3&gt;

&lt;p&gt;위와 같이 여러 큐가 존재하는데, 각 큐 내부에 저장된 실제 데이터는 각 프로세스의 &lt;strong&gt;PCB&lt;/strong&gt;가 저장되어 있다. 그리고 이러한 순서를 기다리는 공간이 있다면 이 순서를 정해주는 알고리즘이 있어야 한다. 이러한 알고리즘을 &lt;strong&gt;스케줄링(Scheduling)&lt;/strong&gt;이라 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Job Queue - Job Scheduler(Long-term scheduler)&lt;/li&gt;
  &lt;li&gt;Ready Queue - CPU Scheduler(Short-term scheduler)&lt;/li&gt;
  &lt;li&gt;Device Queue - Device Scheduler&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Job queue의 순서를 정해주는 job scheduler를 long-term scheduler라고도 하는데, 이는 이 스케줄링이 발생하는 시간이 비교적 오래걸리기 때문이다.(대략 초~분) 반면에 ready queue의 스케줄러를 short-term scheduler라고도 하는데, 이는 스케줄링이 발생하는 시간이 매우 짧기 때문이다. CPU scheduling은 말 그대로 프로세스가 CPU를 점유하는 순서를 정해주는데 이는 매우 빠른 시간안에 이루어져야한다. 현대 컴퓨터가 여러 프로그램을 동시에 사용하는 것과 같은 효과를 주는 이유가 이 스케줄링 속도가 매우 빠르게 이루어지기 때문이다.&lt;/p&gt;

&lt;h1 id=&quot;2-멀티-프로그래밍&quot;&gt;2. 멀티 프로그래밍&lt;/h1&gt;

&lt;p&gt;멀티프로그래밍은 단일 프로세서(CPU) 환경에서 메모리에 다수의 프로세서들을 올려둔 상태로, CPU가 쉬는 동안 다른 프로세서에게 CPU자원을 할당하여 동시에 실행하는 것처럼 보이게 하는 방법이다. 이에 관한 용어에 대해 정리해 보자.&lt;/p&gt;

&lt;h2 id=&quot;21-degree-of-multiprogramming&quot;&gt;2.1 Degree of multiprogramming&lt;/h2&gt;

&lt;p&gt;Degree of multiprogramming 는 현재 메모리에 할당되어 있는 프로세스 개수를 말한다.&lt;/p&gt;

&lt;h2 id=&quot;22-io-bound-process-vs-cpu-bound-process&quot;&gt;2.2. I/O bound process VS CPU bound process&lt;/h2&gt;

&lt;p&gt;프로세스는 I/O bound process 와 CPU bound process 로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I/O bound process: 해당 프로세스에서 I/O(입출력) 작업이 차지는 비중이 높은 프로세스를 말한다.
    &lt;ul&gt;
      &lt;li&gt;Word processor&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CPU bound process: 해당 프로세스에서 CPU 작업(계산)이 차지는 비중이 높은 프로세스를 말한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Super computer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;운영체제, 정확히 말하면 job scheduler 는 이러한 프로세서의 특징을 감안하여 I/O bound process와 CPU bound process를 적절히 분배해서 메모리에 할당해주어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;23-medium-term-scheduler&quot;&gt;2.3 Medium-term scheduler&lt;/h2&gt;

&lt;p&gt;Medium-term scheduler는 말그대로 short-term보다는 덜 발생하지만, long-term보다는 자주 발생하는 scheduler이다. 하는 일은 운영체제가 실행하는 동안 주기적으로 메인 메모리에 있는 전체 프로세스를 검사하여 직접적으로 CPU와 일을 하지 않는 프로세스를 찾아 보조기억장치로 옮기는 것이다. 옮기는 기준은 여러가지 있겠지만 대표적으로 장기간 사용하지 않는 프로세스가 있다.&lt;/p&gt;

&lt;h3 id=&quot;swapping&quot;&gt;Swapping&lt;/h3&gt;

&lt;p&gt;일하지 않는 프로세스를 쫒아내는 행위를 Swapping이라 부르는데, 이는 메인 메모리에서 장시간 사용하지 않는 프로세스를 하드디스크(Swap device = Backing store, 일반적으로 하드디스크는 File system + Backing store 로 구성되어 있다.)로 옮겨주고(Swap out ), 나중에 이 프로세스가 다시 사용되려고 하면 하드디스크에서 해당 프로세스를 다시 메인 메모리에 할당해준다.(Swap in)&lt;/p&gt;

&lt;p&gt;Swap out을 통해 메인 메모리의 공간이 생기므로 이를 더욱 효율적으로 사용할 수 있다. 만약 swap out된 프로세스가 다시 swap in으로 메인 메모리에 할당하려고 할 때 이전의 공간으로 할당되는 것을 보장하지는 않는다. 왜냐하면 위에 말했듯이 swap out으로 생긴 메모리 공간은 &lt;strong&gt;다른 프로세스가 사용할 수 있기 때문&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h2 id=&quot;24-context-switching문맥-전환&quot;&gt;2.4 Context Switching(문맥 전환)&lt;/h2&gt;

&lt;p&gt;Context switching은 CPU가 한 프로세스에서 다른 프로세스로 옮겨가는 것을 말한다. 즉, 한 프로세스가 실행중인 것을 멈추고 다른 프로세스가 실행되는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scheduler
    &lt;ul&gt;
      &lt;li&gt;여기서 스케줄러는 CPU Scheduler를 말하며, CPU가 어느 프로세스를 선택할지 정한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dispatcher
    &lt;ul&gt;
      &lt;li&gt;실제 context switching이 발생하면 CPU의 내부 데이터를 새로 시작되는 데이터로 바꿔준다. 이 과정에서 현재 실행하고 있는 프로세스의 PCB에 현재까지 작업과정으로 갱신하고, 새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원(Restore)하는 작업을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Context switching overhead&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Context switching이 발생할 때마다, dispatcher에서 수행하는 작업을 매번 수행해야하며 이 모든 것은 overhead(부담)이다. 그리고 문맥 전환은 매우 자주 발생하는 작업이므로 overhead를 줄이기 위해서는 dispatcher를 구현하는 코드에 대한 효율을 최대한 높여주어야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@pa324/운영체제-프로세스-메모리-구조-18k3jfidll&quot;&gt;프로세스의 구조&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>백준(1325번): 효율적인 해킹</title>
        <link>/cs/algorithm/2020/03/31/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%95%B4%ED%82%B9.html</link>
        <guid isPermaLink="true">/cs/algorithm/2020/03/31/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%95%B4%ED%82%B9.html</guid>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;실버2&lt;/em&gt;&lt;/strong&gt; : 그래프 문제이다.&lt;br /&gt;
&lt;a href=&quot;https://www.acmicpc.net/problem/1325&quot;&gt;백준(1325번) - 효율적인 해킹&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;생각&quot;&gt;생각&lt;/h1&gt;

&lt;p&gt;아.. 정말 쉽겠지 했는데, 되지도 않는 시간 복잡도 줄여보겠다고 확인 되지 않는 것 썼다가 하루 다 날린 문제이다. 문제는 상당히 간단하게 DFS로 풀 수 있다. 그런데, N이 10000개 이고 M이 100000이기에 이 것을 배열로 무식하게 만들 수는 없고 vector를 사용하여 데이터를 저장해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;input
5 4
3 1
3 2
4 3
5 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;컴퓨터&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;연결된&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;컴퓨터&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;4&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이런식으로 모양을 맞춘 뒤에, 1번에 들어가서 연결된 컴퓨터를 따라 DFS를 적용하면서 연결된 선을 하나씩 늘려주면 된다. 시간 복잡도는 $O(NM)$ 이다.&lt;/p&gt;

&lt;p&gt;나는 여기서 괜히 1번을 탐색할 때, 3번을 탐색하게 되므로, 3번의 탐색 결과를 배열에 저장해 둔 뒤, 2번 컴퓨터를 탐색할 때 이 정보를 가져다가 사용했다. 하지만 어떠한 반례가 존재했고 계속 틀렸다..(&lt;del&gt;하아&lt;/del&gt;)&lt;/p&gt;

&lt;p&gt;아마 루프가 생기는 시점에 숫자가 다르게 적힐 것 같다는 생각이 든다. 그래서 그냥 무식하게 하면 된다. &lt;del&gt;무식한게 최고다&lt;/del&gt; 루프가 생길 수 있기 때문에 컴퓨터 한대를 탐색할 때 왔던 경로인지 체크해주는 배열이 필요하다.&lt;/p&gt;

&lt;h1 id=&quot;code&quot;&gt;Code&lt;/h1&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;checkVisit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkVisit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nowNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checkVisit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nowNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nowNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ios_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync_with_stdio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checkVisit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checkVisit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maxNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 31 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>백준(10830번): 행렬 곱셈</title>
        <link>/cs/algorithm/2020/03/31/%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88.html</link>
        <guid isPermaLink="true">/cs/algorithm/2020/03/31/%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88.html</guid>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;실버1&lt;/em&gt;&lt;/strong&gt; : 분할 정복 문제이다.&lt;br /&gt;
&lt;a href=&quot;https://www.acmicpc.net/problem/10830&quot;&gt;백준(10830번) - 행렬 곱셈&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;



&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;




&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 31 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>백준(1149번): RGB 거리</title>
        <link>/cs/algorithm/2020/03/31/RGB%EA%B1%B0%EB%A6%AC.html</link>
        <guid isPermaLink="true">/cs/algorithm/2020/03/31/RGB%EA%B1%B0%EB%A6%AC.html</guid>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;실버1&lt;/em&gt;&lt;/strong&gt; : 동적계획법 문제이다.&lt;br /&gt;
&lt;a href=&quot;https://www.acmicpc.net/problem/1149&quot;&gt;백준(1149번) - 이친수&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;생각&quot;&gt;생각&lt;/h1&gt;
&lt;p&gt;동적 계획법하면 유명한 문제이다. 나는 동적 계획법을 풀 때 보통 두가지 방법을 많이 사용한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;상태에 대한 정의와 점화식을 직관으로 때린다. (&lt;del&gt;감..&lt;/del&gt;)&lt;/li&gt;
  &lt;li&gt;순차적으로 완전 탐색 방법으로 그려본다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;문제가 잘 안보이면 2번 방법을 선택하는데, 이 문제를 그려보면 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;~~R~~&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;G&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;R&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;R&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;~~G~~&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;G&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;R&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;G&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;~~B~~&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;1번 집에서 2번 집으로 넘어갈 때, 2번 집의 선택에 따라 1번집의 선택은 2번 집에서 선택한 색을 제외한 두가지 색으로 정해진다. 여기서 Dp의 정의 방법의 특징이 드러나는데, 사실 나는 처음 생각할 때, 1번이 선택을 하고, 2번이 어떻게 바뀌는 지를 생각했다. 하지만 그렇게 코드를 짤 경우 굉장히 귀찮고 어렵다는 것을 깨달았다. dp의 정의는 &lt;strong&gt;해당 위치까지&lt;/strong&gt;에 어떤 의미를 주는 것이 문제를 풀이할 때 훨씬 수월하다. 이것은 수열에서 일반항의 정의와 비슷하다.&lt;/p&gt;

&lt;h1 id=&quot;정의&quot;&gt;정의&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dp[N][color]&lt;/code&gt; = N번 집에 color를 칠했을 때 발생하는 최소 값&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;color 변수를 추가한 이유는, 해당 집에 어떤 색을 칠하냐에 따른 가격을 마지막에 최종적으로 비교해주기 위함이다.&lt;/p&gt;

&lt;h1 id=&quot;점화식&quot;&gt;점화식&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dp[N][color1] = min(dp[N-1][color2], dp[N-1][color3]) + cost[i][color1]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;color2, color3&lt;/code&gt;는 color1이외의 두 색을 의미한다.&lt;/p&gt;

&lt;h1 id=&quot;code&quot;&gt;Code&lt;/h1&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 초기값 세팅&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// dp&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 최종적인 최소값&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min_element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 31 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>margin 겹침 현상</title>
        <link>/dv/css/2020/03/30/margin-%EA%B2%B9%EC%B9%A8.html</link>
        <guid isPermaLink="true">/dv/css/2020/03/30/margin-%EA%B2%B9%EC%B9%A8.html</guid>
        <description>&lt;p&gt;css를 먹일 때 요소들이 붙어있는 경우 margin을 주었지만 먹히지 않을 때 해결방법을 알아본다.&lt;/p&gt;

&lt;p&gt;이 문제는 margin이 겹칠 경우 작은 값을 가지는 요소의 margin을 무시하는 것이다.&lt;/p&gt;

&lt;p&gt;요소에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display: inline-block;&lt;/code&gt;을 걸어주면 된다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;.class&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inline-block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 30 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>04: 운영체제 서비스</title>
        <link>/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-04-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%9C%EB%B9%84%EC%8A%A4.html</link>
        <guid isPermaLink="true">/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-04-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%9C%EB%B9%84%EC%8A%A4.html</guid>
        <description>&lt;p&gt;운영체제의 주요 서비스: 프로세스, 메모리, 파일관리, 시스템 호출에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;운영체제의 주요 서비스는 하드웨어 자원을 각 사용자 애플리케이션에 적절히 분배해주는 것이다. 하드웨어 자원은 CPU, 메인 메모리, 하드디스크, 키보드, 마우스, 프린터 등이 존재한다. 이러한 하드웨어 자원을 사용자 애플리케이션이 요구하거나 운영체제 내의 규칙에 의해 적절히 분배하여 컴퓨터의 성능을 최대한 효율적으로 사용해야 한다.&lt;/p&gt;

&lt;p&gt;이를 실현하기 위해 운영체제 내에서는 각 하드웨어를 관리하는 기능을 다음과 같이 나눈다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1135&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77925334-b5b47f00-72df-11ea-8677-5a8827511f84.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 관리&lt;/li&gt;
  &lt;li&gt;주기억장치 관리&lt;/li&gt;
  &lt;li&gt;파일 관리&lt;/li&gt;
  &lt;li&gt;보조기억장치 관리&lt;/li&gt;
  &lt;li&gt;입출력 장치 관리&lt;/li&gt;
  &lt;li&gt;네트워킹&lt;/li&gt;
  &lt;li&gt;보호&lt;/li&gt;
  &lt;li&gt;기타…&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1-프로세스-관리process-management&quot;&gt;1. 프로세스 관리(Process management)&lt;/h1&gt;

&lt;p&gt;프로세스 관리는 운영체제 기능 중 가장 중요한 기능 중 하나이다. 프로세스와 프로그램은 기본적으로 구분된다. &lt;strong&gt;프로세스&lt;/strong&gt;는 실제 메인 메모리에서 &lt;strong&gt;실행 중인 프로그램(program in execution)&lt;/strong&gt;을 말한다. &lt;strong&gt;프로그램&lt;/strong&gt;은 하드디스크와 같은 보조기억장치에서 &lt;strong&gt;아무런 동작을 하지 않는 상태&lt;/strong&gt;이다. 이를 어떠한 요청에 의해 메인 메모리에 할당하여 CPU를 사용하면서 실행하게 되는데 이를 프로세스라 부른다.&lt;/p&gt;

&lt;p&gt;프로세스 관리의 주요 기능은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스의 생성과 소멸(creation, deletion)&lt;/li&gt;
  &lt;li&gt;프로세스 활동 일시 중지, 활동 재게(suspend, resume)&lt;/li&gt;
  &lt;li&gt;프로세스간 통신(interprocess communication: IPC)&lt;/li&gt;
  &lt;li&gt;프로세스간 동기화(synchronization)&lt;/li&gt;
  &lt;li&gt;교착상태 처리(deadlock handling)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2-주기억장치-관리main-memory-management&quot;&gt;2. 주기억장치 관리(Main memory management)&lt;/h1&gt;

&lt;p&gt;주기억장치 즉, 메인 메모리는 프로그램이 실행되기 위한 공간이다. CPU는 오직 메인 메모리에 있는 프로그램(프로세스)하고만 소통할 수 있다. 주기억장치 관리에서는 메인 메모리를 효율적으로 사용하도록 관리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스에게 메모리 공간 할당(allocation)&lt;/li&gt;
  &lt;li&gt;메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시&lt;/li&gt;
  &lt;li&gt;프로세스 종료 시 메모리 회수(deallocation)&lt;/li&gt;
  &lt;li&gt;메모리의 효과적 사용&lt;/li&gt;
  &lt;li&gt;가상 메모리: 물리적 실제 메모리보다 큰 용량을 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-파일-관리file-management&quot;&gt;3. 파일 관리(File management)&lt;/h1&gt;

&lt;p&gt;디스크는 물리적으로 Track과 sector로 구성되어 있으며, 여기서 파일이라는 논리적 관점으로 데이터를 바라보고 관리하는 것이다.&lt;/p&gt;

&lt;p&gt;파일은 OS가 실행되는 컴퓨터에서 자주 볼 수 있는데, 이는 복잡한 과정으로 하드디스크에 저장되어 있는 것을 사용자가 편리하게 사용할 수 있도록 파일이라는 논리적 형태로 운영체제에서 관리하여 보여준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일의 생성과 삭제(file creation, deletion)&lt;/li&gt;
  &lt;li&gt;디렉토리(Directory)의 생성과 삭제&lt;/li&gt;
  &lt;li&gt;기본 동작 지원: open, close, read, write, create, delete&lt;/li&gt;
  &lt;li&gt;Track/sector - file 간의 매핑(mapping)&lt;/li&gt;
  &lt;li&gt;백업(Backup)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-보조기억장치-관리secondary-storage-management&quot;&gt;4. 보조기억장치 관리(Secondary storage management)&lt;/h1&gt;

&lt;p&gt;보조기억장치는 대표적으로 하드 디스크, 플래시 메모리(주로 스마트폰에 사용)가 있다. 하드 디스크를 예로 들면, 하드 디스크에서 아무 것도 저장되어 있지 않는 공간을 block이라 하는데, 보조기억장치 관리는 이를 관리하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빈 공간 관리(Free space management)&lt;/li&gt;
  &lt;li&gt;저장공간 할당(Storage allocation)&lt;/li&gt;
  &lt;li&gt;디스크 스케줄링(Disk scheduling)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-입출력-장치-관리io-device-management&quot;&gt;5. 입출력 장치 관리(I/O device management)&lt;/h1&gt;

&lt;p&gt;입출력 장치에는 키보드, 마우스, 프린터, 스피커, 마이크 등이 있다. 입출력 장치 관리는 이와 같은 여러 입출력 장치를 사용하기 위해 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장치 드라이브(Device drivers)&lt;/li&gt;
  &lt;li&gt;입출력 장치의 성능향상: buffering, caching, spooling&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-시스템-콜system-call&quot;&gt;6. 시스템 콜(System call)&lt;/h1&gt;

&lt;p&gt;시스템 콜은 유저 프로세스에서 운영체제 서비스를 필요로 할 때 이를 받기 위해 사용하는 호출이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1000&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77928781-cd8e0200-72e3-11ea-941a-143a9f60d88f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;61-주요-시스템-콜&quot;&gt;6.1 주요 시스템 콜&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Process&lt;/strong&gt;: end(정상 종료), abort(강제 종료), load, execute, create, terminate, get/set, attributes, wait event, signal event&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Memory&lt;/strong&gt;: allocate, free&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;File&lt;/strong&gt;: create, delete, open, close, read, write, get/set attributes&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Device&lt;/strong&gt;: request, release, read, write, get/set attributes, attach/detach devices&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Information&lt;/strong&gt;: get/set time, get/set system data&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Communication&lt;/strong&gt;: socket, send, receive&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>03: 이중모드와 보호</title>
        <link>/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-03-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8.html</link>
        <guid isPermaLink="true">/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-03-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8.html</guid>
        <description>&lt;p&gt;운영체제의 사용자모드와 관리자모드, 하드웨어 보호 관해서 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;1-이중-모드-dual-mode&quot;&gt;1. 이중 모드 (Dual mode)&lt;/h1&gt;

&lt;p&gt;현재 컴퓨터 환경은 여러 사람이 동시에 한 컴퓨터를 사용하는 경우가 많다.(서버 컴퓨터) 그리고 그 외에도 하나의 컴퓨터 내에서 여러 프로그램을 수행하는 것이 일반적이다. 이 때 특정 컴퓨터나 프로그램에서 잘못된 동작으로 인해 다른 컴퓨터(프로그램)가 영향을 받는다면 이는 매우 위험하다.&lt;/p&gt;

&lt;p&gt;예를 들어, 어셈블리어에서 사용하는 명령어 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STOP&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HALT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESET&lt;/code&gt;과 같은 명령어는 CPU의 동작과 관계된 명령어이다. 이런 명령어를
한 프로그램에서 고의 또는 실수로 입력하여 전체 컴퓨터의 동작이 멈추거나 꺼진다면 이 컴퓨터의 정상적인 동작을 위해서는 재부팅을 할 수 밖에 없다. 이러한 결함을 매우 치명적이다.&lt;/p&gt;

&lt;p&gt;이런 문제점을 해결하기 위해 일반 사용자가 위와 같은 명령어들을 요청하는 것을 막을 필요가 생겼다. 여기서 &lt;strong&gt;이중 모드&lt;/strong&gt; 라는 것이 나왔다.&lt;/p&gt;

&lt;h2 id=&quot;설명&quot;&gt;설명&lt;/h2&gt;

&lt;p&gt;이중 모드는 말 그대로 모드를 아래와 같이 둘로 나누는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자(User) 모드&lt;/li&gt;
  &lt;li&gt;관리자(Supervisor) 모드
    &lt;ul&gt;
      &lt;li&gt;= 시스템(system) 모드&lt;/li&gt;
      &lt;li&gt;= 모니터(monitor) 모드&lt;/li&gt;
      &lt;li&gt;= 특권(privileged) 모드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특권 모드에서만 내릴 수 있는 명령을 &lt;strong&gt;특권 명령(privileged instruction)&lt;/strong&gt; 이라고 하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STOP&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HALT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESET&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SET_TIMER&lt;/code&gt; 등이 있다. 만약 사용자 모드에서 특권 명령을 사용하려고 하면 CPU에서 내부 인터럽트를 발생시켜 해당 명령어를 요청한 프로그램을 강제로 종료시킨다.&lt;/p&gt;

&lt;p&gt;이중 모드는 CPU 내부의 레지스터(register)의 비트(bit)를 활용하여 &lt;strong&gt;플래그(flag)&lt;/strong&gt;로 나타낸다. 예를 들어 특권 모드일 때는 &lt;strong&gt;비트 값이 0&lt;/strong&gt; 이고, 사용자 모드일 때는 &lt;strong&gt;비트 값을 1&lt;/strong&gt; 로 설정하여 구분한다.&lt;/p&gt;

&lt;h3 id=&quot;상태-레지스터-플레그-레지스터&quot;&gt;상태 레지스터 (플레그 레지스터)&lt;/h3&gt;

&lt;p&gt;CPU에서 다양한 산술 연산의 결과의 상태를 알려주는 플래그 비트들이 모인 레지스터이다. flag라는 이름의 어원은 경주할 때, 시작, 정지와 같은 상태를 깃발의 색, 들어올림과 같은 것으로 알렸기 때문이다. CPU에서는 연산을 수행하는데, 제약사항을 갖고 (자리수의 제한 같은) 수행하기 때문에 이를 나타낼 다양한 코드가 필요하다. 이 상태는 비트를 통해 정의되어 있으며 다양한 플래그가 존재한다.&lt;br /&gt;
&lt;a href=&quot;https://ko.wikipedia.org/wiki/상태_레지스터&quot;&gt;상태 레지스터의 종류&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;mode의-변경-과정&quot;&gt;Mode의 변경 과정&lt;/h2&gt;

&lt;p&gt;컴퓨터가 켜진 뒤에 한 사용자 애플리케이션을 실행시키는 동안 모드가 어떻게 변하는지 살펴보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;컴퓨터 부팅 과정 - 관리자 모드&lt;/li&gt;
  &lt;li&gt;애플리케이션 실행 과정 - 관리자 모드&lt;/li&gt;
  &lt;li&gt;애플리케이션 실행중 - 사용자 모드&lt;/li&gt;
  &lt;li&gt;인터럽트 발생 후 처리 과정 - 관리자 모드&lt;/li&gt;
  &lt;li&gt;인터럽트 처리 후 - 사용자 모드&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;사용자가 하드웨어의 자원에 접근하는 것은 매우 위험한 동작이다. 그러므로 이러한 경우에는 모두 &lt;strong&gt;관리자 모드로 운영체제에서 처리하도록 한다.&lt;/strong&gt; (프로그램에서 소프트웨어 인터럽트를 발생시켜 운영체제에 위임한다.)&lt;/p&gt;

&lt;p&gt;위의 4번 과정을 하드웨어 인터럽트로 가정하고 자세히 살펴보면 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)&lt;/li&gt;
  &lt;li&gt;CPU에서 모드 플래그를 관리자 모드값으로 설정&lt;/li&gt;
  &lt;li&gt;해당 하드웨어 인터럽트 서비스 루틴(ISR)으로 이동 (관리자 모드)&lt;/li&gt;
  &lt;li&gt;인터럽트 처리 (관리자 모드)&lt;/li&gt;
  &lt;li&gt;인터럽트 처리 완료 후 CPU의 모드 플래그를 다시 6. 사용자 모드값으로 설정&lt;/li&gt;
  &lt;li&gt;원래의 애플리케이션 위치로 복귀 (사용자 모드)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/1*J3LbfnG88ysmltH48VhU6w.png&quot; alt=&quot;Mode bit 변경&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 사용자 모드인 상태에서 치명적인 명령어를 사용자 프로그램이 Call했을 경우에 CPU는 모드 비트를 확인하고 관리자 모드가 아닐 경우, &lt;strong&gt;내부 인터럽트&lt;/strong&gt;를 발생시킨다. (잘못된 명령을 내렸을 때 발생하는 인터럽트) 그 결과, 메모리에 올라와있는 사용자 프로그램을 종료시켜버린다.&lt;/p&gt;

&lt;p&gt;애플리케이션이 실행하는 동안에는 위와 같은 모드 변경이 반복적으로 일어나는 것을 볼 수 있다. 대부분의 CPU는 이중 모드를 지원한다.&lt;/p&gt;

&lt;h1 id=&quot;2-하드웨어-보호&quot;&gt;2. 하드웨어 보호&lt;/h1&gt;

&lt;p&gt;이중 모드는 사용자의 접근을 제한하여 치명적인 문제가 발생하지 않도록 방지하는 보호 기능에 해당한다. 이러한 보호 기능에 대해 추가적으로 알아본다.&lt;/p&gt;

&lt;h2 id=&quot;21-입출력-장치-보호&quot;&gt;2.1 입출력 장치 보호&lt;/h2&gt;

&lt;p&gt;여러 정보들은 입출력 장치를 통해 컴퓨터로 입력되고, 외부 장치로 출력이 된다. 여기서 크게 두 가지의 문제점이 발생한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 입출력 장치의 사용으로 인한 혼선&lt;/li&gt;
  &lt;li&gt;사용자가 자신의 데이터가 아닌 다른 사용자의 데이터에 입출력을 하는 일
    &lt;ul&gt;
      &lt;li&gt;위와 같이 입출력 장치에 여러 사용자의 데이터가 뒤엉켜서 들어오거나 다른 사용자의 데이터에 접근하려는 경우를 막아야 한다.
이를 해결하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 과 같은 입출력 명령을 &lt;strong&gt;특권 명령&lt;/strong&gt;으로 설정하는 것이다. 즉, 사용자 애플리케이션에서 입출력을 사용하려면 운영체제를 통해서 수행해야한다.(소프트웨어 인터럽트) 여러 프로그램이 동시에 입출력을 사용하려고 하면 운영체제 내부에서 순서를 정하여 혼선을 막아줄 수 있다.
&lt;strong&gt;즉, 컴퓨터의 하드웨어를 사용하는 과정에서는 모두 운영체제를 거치도록 한다!&lt;/strong&gt; 라는 대원칙이 사실 숨어있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 A, B 사용자가 있는 상황에서 A가 B의 데이터를 읽기 위해 운영체제에게 소프트웨어 인터럽트를 발생하였다고 하자. 이 때, A의 데이터와 B의 데이터는 각각 A, B만이 읽기가 가능하다고 가정하자. 그러면 인터럽트가 발생하고, CPU는 RAM에 있는 운영체제 내부의 해당 ISR로 이동하게 된다. ISR은 현재 사용자 A가 해당 데이터 B에 접근할 수 없으므로 해당 요청을 거부한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;947&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77887354-63ef0300-72a5-11ea-9231-1c571b962db6.png&quot; class=&quot;center&quot; /&gt;
&lt;del class=&quot;center-text&quot;&gt;다시보는 이 그림..&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-메모리-보호&quot;&gt;2.2 메모리 보호&lt;/h2&gt;

&lt;p&gt;메모리에는 운영체제뿐만 아니라 여러 개의 사용자 애플리케이션이 존재한다. 한 애플리케이션이 자신의 메모리 영역이 아닌 운영체제나 다른 애플리케이션의 메모리 영역에 침범하려하면 매우 위험하다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1252&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77922369-e8f50f00-72db-11ea-8a4c-0c8bb7a09c3d.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메모리는 일반적으로 위와 같이 구성되어 있을 것이다. 여기서 user1이 OS나 user2, user3에 접근하는 것을 막아야 한다. CPU는 address bus를 통해 메모리 주소에 접근하게 되는데, user1 프로그램이 실행되는 동안에는 user1이 할당되어 있는 메모리 주소 범위 안인 경우에만 접근하면 될 것이다. 이를 &lt;strong&gt;address bus에서 검사&lt;/strong&gt;하는 것이 가장 효율적일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;970&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77922593-35d8e580-72dc-11ea-80dd-d2ca33d48f9f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 생각으로 나온 것이 &lt;strong&gt;MMU(Memory Management Unit)&lt;/strong&gt; 이다. MMU는 위의 그림처럼 address bus 중간에 설치된 하드웨어 칩으로서 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다.&lt;/p&gt;

&lt;p&gt;예를 들어, User1의 시작 주소는 1024, 끝 주소는 4048이라고 하자. User1이 수행되는 동안 운영체제는 해당 프로그램의 주소 범위를 MMU에 설정(특권 명령)하는데, base는 1024, limit는 4048이 될 것이다. 결과적으로 user1이 수행되는 동안에는 이 범위 안의 주소값인 경우에만 address bus를 통과시킨다.&lt;/p&gt;

&lt;p&gt;만약 해당 프로그램의 주소 범위 밖의 주소값이 MMU에 들어온다면, MMU에서 내부 인터럽트 를 발생시켜 CPU에 신호를 준다. 그러면 CPU는 그에 맞는 ISR로 이동하여 해당 프로그램을 강제로 종료시킨다. 이과 같은 잘못된 메모리 접근을 Segment violation 이라 한다.&lt;/p&gt;

&lt;h2 id=&quot;23-cpu-보호&quot;&gt;2.3 CPU 보호&lt;/h2&gt;

&lt;p&gt;CPU 보호는 사용자의 실수 또는 고의로 인한 CPU 독점을 방지해야 한다. 하나의 프로그램이 CPU를 독점하게 되면 다른 프로그램은 수행되지 못한다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CPU를 독점하는 가장 대표적인 예는 &lt;strong&gt;무한 반복&lt;/strong&gt;이다. 위의 코드를 보면 while문의 조건문이 잘못된 것을 볼 수 있다. 비교 연산자가 아닌 대입 연산자를 사용하여 n값이 1이 되므로 while문의 조건은 TRUE가 된다. 이는 n값이 변하지 않는 이상 무한으로 반복된다.&lt;/p&gt;

&lt;p&gt;이를 해결하는 방법은 Timer를 두어 일정 시간이 지나면 &lt;strong&gt;타이머 인터럽트&lt;/strong&gt;를 발생시킨다. 인터럽트가 발생하면 반드시 운영체제 내의 ISR로 이동하므로, 해당 ISR에서 각 프로그램의 CPU 점유 시간을 측정하여 적절히 분배되도록 조정한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 한 프로그램의 CPU 점유 시간이 비정상적으로 오래 걸리는 경우, 강제로 다른 프로그램으로 CPU를 전환시켜 줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>02: 운영체제의 역사</title>
        <link>/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-02-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%EC%82%AC.html</link>
        <guid isPermaLink="true">/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-02-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%EC%82%AC.html</guid>
        <description>&lt;p&gt;일괄처리부터 시분할시스템, 최근의 고급운영체제, 인터럽트에 기반한 현대 운영체제까지 변천 역사를 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;1-초기-컴퓨터&quot;&gt;1. 초기 컴퓨터&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;노가다, 사람 손도 많이가, 장치도 엄청커, 비싸기도 비싸&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;운영체제는 컴퓨터가 발전하면서 같이 발전하게 되었다. 초기 컴퓨터는 크게 3가지로 구성되었다. 카드 리더, 프로세서, 프린터이다. 카드 리더는 입력기이다. 입력은 종이에 입력할 코드에 맞는 구멍을 뚫어서 넣어주는 방식이었다. 프로세서는 현재와 비슷한 계산하는 역할이었고, 프린터는 입력에 대한 결과를 종이에 찍어서 보여주었다. 이 시기에는 운영체제도 존재하지 않았으므로, 오퍼레이터(operator)라는 컴퓨터를 사용하는 직업이 따로 있었고, 컴퓨터의 크기 또한 너무 커서 건물 전체를 사용해야할 정도였다.&lt;/p&gt;

&lt;h1 id=&quot;2-batch-processing-system일괄-처리-시스템&quot;&gt;2. Batch processing system(일괄 처리 시스템)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;코드로 반복되는 거 좀 자동화 하자!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img width=&quot;634&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77924633-ddefae00-72de-11ea-8d68-976a20051552.png&quot; class=&quot;center&quot; /&gt;
위에서 초기 컴퓨터의 상황을 살펴보았는데, 프로그램을 수행할 때마다 컴파일-&amp;gt;링크-&amp;gt;로딩 순서를 오퍼레이터가 직접 입력해주었다. 이러한 과정을 자동화한 것이 batch processing system 이다. 위 과정을 하나의 프로그램으로 작성하여 프로세서의 메모리안에 할당해주었는데, 이 프로그램을 resident monitor라고 불렀다.&lt;/p&gt;

&lt;p&gt;resident는 “거주” 라는 의미로 이 프로그램이 항상 프로세서안에서 거주한다는 의미로 이러한 이름을 사용하였다. 그리고 이것이 &lt;strong&gt;최초의 운영체제&lt;/strong&gt;로 알려져 있다.&lt;/p&gt;

&lt;h1 id=&quot;3-multiprogramming-system다중-프로그래밍&quot;&gt;3. Multiprogramming system(다중 프로그래밍)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;CPU가 노는 시간이 너무 많은데? 쉴 동안 다른일을 시켜버리자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;과거에는 컴퓨터가 매우 비싼 장비였다. 그리고 초창기 메모리의 상태는 resident monitor를 제외하고 &lt;strong&gt;단 하나의 애플리케이션만을 할당하여 사용&lt;/strong&gt;하였다. 하지만 이는 매우 비효율적인 방법이었다.&lt;/p&gt;

&lt;p&gt;프로그램을 수행하는 도중에는 계산을 하는 CPU 외에도 입출력을 담당하는 I/O장치가 수행한다. 즉, &lt;strong&gt;CPU와 I/O장치가 교대로 동작&lt;/strong&gt;하는데 I/O장치가 수행하는 동안에는 &lt;strong&gt;CPU가 아무것도 할 일이 없었다.&lt;/strong&gt; CPU가 아무일도 안하는 상태를 &lt;strong&gt;&lt;em&gt;idle&lt;/em&gt;&lt;/strong&gt; 상태라고 말한다. 그리고 I/O장치는 CPU에 비해 매우 느리기때문에 idle 상태의 비율이 너무 높았다. 이러한 비효율적인 수행을 해결하기 위해 multiprogramming system이 나왔다. &lt;del&gt;즉 CPU를 못놀게 하자&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;방법&quot;&gt;방법&lt;/h2&gt;

&lt;p&gt;Multiprogramming system은 메모리에 여러 애플리케이션(프로그램)을 올리는 시스템이다. 예를 들어 a, b 두 개의 애플리케이션이 있을 떄, 처음에는 a에서 CPU 수행을 하다가 I/O장치 수행으로 넘어간다. 이 순간 CPU는 idle 상태에 있지 않고 b가 있다는 것을 보고 b의 CPU 수행을 시작한다. 이렇게 &lt;strong&gt;idle상태의 시간을 최대한 줄이고자 하였다.&lt;/strong&gt; 이런 동작을 가능하게 하려면 앞서 말했듯, 메모리에 여러 어플리케이션을 올린 상태여야만 한다.&lt;/p&gt;

&lt;h2 id=&quot;한계-및-문제&quot;&gt;한계 및 문제&lt;/h2&gt;

&lt;p&gt;하지만 메모리에 여러 프로그램을 올리면서 많은 문제점이 발생했다. 가장 큰 문제점은 CPU가 &lt;strong&gt;어느 프로그램을 수행해야하는지 선택&lt;/strong&gt;하는 것이다. 이러한 작업을 &lt;strong&gt;&lt;em&gt;CPU 스케줄링&lt;/em&gt;&lt;/strong&gt;이라고 하며, 이는 운영체제의 중요한 역할 중 하나이다. 그리고 여러 어플리케이션의 공간을 할당한다는 전제 조건 때문에, 새롭데 들어온 어플리케이션에 대해 &lt;strong&gt;어느 메모리 공간에 할당&lt;/strong&gt;해야하는지도 큰 문제였다. 이러한 문제도 운영체제가 다뤄야 하는 중요한 과제로 남았다.&lt;/p&gt;

&lt;h1 id=&quot;4-time-sharing-system시분할-시스템&quot;&gt;4. Time-sharing system(시분할 시스템)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;하나 다 끝날 때까지 기다리지 말고 Interval을 주자!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;시간이 지나 모니터와 키보드를 사용하면서 사용자와 컴퓨터 사이에 대화 형식이 가능해졌다. 하지만 여전히 컴퓨터 자체가 너무 비쌌기 때문에 아래와 같이 단말기(terminal) 형태로 사용하였다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1026&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77890996-43c24280-72ab-11ea-9987-b9384ebb4975.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 사용자(User)들은 모니터와 키보드만을 가지고, 실제 프로세서는 하나의 단말기에 존재하여 이를 공유하여 사용하였다. 멀티 프로그래밍에서는 이와 같은 단말기 형태에서 문제가 생긴다.&lt;/p&gt;

&lt;p&gt;예를 들어, 단말기 메모리에 User1 프로그램, User2 프로그램, User3 프로그램이 할당되어 있고 User1이 먼저 CPU를 사용한다고 하자. &lt;strong&gt;멀티프로그래밍에서는 User1이 CPU를 수행하고 있는 도중에는 다른 사용자는 CPU자체를 사용할 수 없다.&lt;/strong&gt; (CPU가 하나인 환경) 그러므로 다른 사용자들은 User1이 CPU수행을 모두 마칠 때까지(또는 I/O를 만날 때까지) 기다려야한다. 하지만 이는 매우 비효율적이다.&lt;/p&gt;

&lt;h2 id=&quot;해결&quot;&gt;해결&lt;/h2&gt;

&lt;p&gt;이를 해결하기 위해 나온 것이 time-sharing system이다. 시분할 시스템은 CPU가 하나의 프로그램을 수행하는 &lt;strong&gt;시간을 제한&lt;/strong&gt;하는 것이다. 예를 들어, User1 프로그램을 일정 시간 수행하면 반드시 다음 프로그램으로 넘어가서(스위칭, switching) 또 다시 일정 시간을 수행한다. 이렇게 일정 시간을 두어 프로그램들을 번갈아 수행하면서 모든 프로그램이 공평하게 수행이 되도록 한다. 그리고 이 일정 시간은 매우 짧은 시간(ms)이므로 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 가져온다. 가장 대표적인 시분할 시스템은 Unix가 있었다.&lt;/p&gt;

&lt;h2 id=&quot;한계-및-문제-1&quot;&gt;한계 및 문제&lt;/h2&gt;

&lt;p&gt;시분할 시스템을 사용하면서 여러 사용자(프로세스)간에 통신이 가능해졌다. 하지만 여기서도 여전히 멀티프로그래밍에서와 같은 스케줄링과 메모리 문제가 있었다. 이를 해결하기 위해 동기화 기술, 가상 메모리 등이 이후에 나왔다.&lt;/p&gt;

&lt;h1 id=&quot;5-고등-운영체제&quot;&gt;5. 고등 운영체제&lt;/h1&gt;

&lt;h2 id=&quot;51-다중-프로세서-시스템-multiprocessor-system&quot;&gt;5.1 다중 프로세서 시스템 (Multiprocessor system)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;CPU가 여러개&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img width=&quot;1123&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77924855-2f983880-72df-11ea-858c-e0b5edd81195.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;병렬 시스템 (parallel system)
    &lt;ul&gt;
      &lt;li&gt;여러개의 CPU가 동시에 처리할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;강결합 시스템 (tightly-coupled system)
    &lt;ul&gt;
      &lt;li&gt;메모리에 여러 CPU가 연결되어 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3가지 장점: performance, cost, reliability
    &lt;ul&gt;
      &lt;li&gt;여러 일꾼을 쓰니 빠르다.&lt;/li&gt;
      &lt;li&gt;싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.&lt;/li&gt;
      &lt;li&gt;하나가 망가져도 작동할 수 있다. 신뢰도가 높다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다중 프로세서 운영체제 (Multiprocessor OS)
    &lt;ul&gt;
      &lt;li&gt;CPU가 늘어났기 때문에, 다른 처리 방법이 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;52-분산-시스템-distributed-system&quot;&gt;5.2 분산 시스템 (Distributed system)]&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;컴퓨터가 여러대, 근데 묶여있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img width=&quot;1074&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77925028-56ef0580-72df-11ea-9300-1c34d22eeb67.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다중 컴퓨터 시스템 (multi-computer system)
여러대의 컴퓨터로 만든 시스템이다.&lt;/li&gt;
  &lt;li&gt;소결합 시스템 (loosely-coupled system)
    &lt;ul&gt;
      &lt;li&gt;메모리가 느슨하게 연결되어 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3가지 장점: performance, cost, reliability
    &lt;ul&gt;
      &lt;li&gt;여러 일꾼을 쓰니 빠르다.&lt;/li&gt;
      &lt;li&gt;싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.&lt;/li&gt;
      &lt;li&gt;하나가 망가져도 작동할 수 있다. 신뢰도가 높다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;분산 운영체제 (Distributed OS)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;다른 컴퓨터들을 관리해야 하기 때문에 새로운 처리 방법이 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;53-실시간-시스템-real-time-system&quot;&gt;5.3 실시간 시스템 (Real-time system)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;시간 제약: Deadline&lt;/li&gt;
  &lt;li&gt;공장 자동화 (FA), 군사, 항공, 우주&lt;/li&gt;
  &lt;li&gt;실시간 운영체제 (Real-time OS = RTOS)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-인터럽트-기반-시스템interrupt-based-system&quot;&gt;6. 인터럽트 기반 시스템(Interrupt based system)&lt;/h1&gt;

&lt;p&gt;현대 운영체제는 인터럽트 기반 시스템이다. 그렇다면 인터럽트는 무엇인가?&lt;/p&gt;

&lt;h2 id=&quot;61-인터럽트&quot;&gt;6.1 인터럽트&lt;/h2&gt;

&lt;p&gt;컴퓨터에 전원이 들어오면 위에서 말했듯이 부팅이 시작된다. 먼저, POST과정이 시작되고 그 후에 부트 로더가 하드 디스크에 있는 운영체제 프로그램을 RAM에 가져와 할당한다. 할당된 운영체제는 컴퓨터의 전원이 꺼질 때까지 상주(resident)한다.&lt;/p&gt;

&lt;p&gt;부팅이 끝나고 운영체제가 동작하는 동안 수 많은 인터럽트가 발생할 수 있다. 예를 들어, 사용자가 마우스를 움직인다고 가정하자. 이 동작을 컴퓨터는 어떻게 알 수 있을까? 바로 &lt;strong&gt;인터럽트&lt;/strong&gt;를 통해 알 수 있다. 마우스를 움직이는 순간, 마우스에서 인터럽트 전기 신호가 발생하여 이를 CPU에게 보낸다. CPU는 이를 감지하고, 자신이 하던 일을 멈춘 후에 이 인터럽트 신호를 처리하기 위해 운영체제 내부에 있는 &lt;strong&gt;인터럽트를 처리하는 코드(interrupt service routine, ISR)&lt;/strong&gt;로 이동한다. 이 곳에 마우스가 움직일 때 어떻게 동작해야하는지가 내포되어 있어 이를 수행한다.&lt;/p&gt;

&lt;h2 id=&quot;62-인터럽트의-종류와-동작방법&quot;&gt;6.2 인터럽트의 종류와 동작방법&lt;/h2&gt;

&lt;p&gt;이러한 하드웨어에서 발생한 인터럽트를 &lt;strong&gt;하드웨어 인터럽트(Hardwore Interrupt)&lt;/strong&gt; 라고 한다. 인터럽트라고 하면 기본적으로 하드웨어 인터럽트를 말하지만, 소프트웨어에서도 인터럽트를 요청을 할 수 있다. 이를 &lt;strong&gt;소프트웨어 인터럽트(Software Interrupt)&lt;/strong&gt; 라고 한다. 소프트웨어 인터럽트는 명령어로 직접 인터럽트 전기 신호를 CPU에게 보낼 수 있다. 즉, 프로그램에서 swi, int 와 같은 어셈블리어 명령어를 수행하는 것이다. (명령어는 운영체제마다 다르다. 위의 명령어는 CPU에서 어셈블리어 코드 중 일종으로, interupt를 처리하라는 명령어이다.)&lt;/p&gt;

&lt;p&gt;예를 들어, 마우스로 워드 작성 프로그램을 실행시킨다고 하자. 워드 작성 프로그램을 실행시키는 것까지는 &lt;strong&gt;하드웨어 인터럽트&lt;/strong&gt;가 수행된다.(마우스가 이동하여 더블 클릭으로 실행하는 경우이다.) 이 프로그램에서 사용자가 하드디스크에 있는 다른 워드 파일을 읽고 싶은 경우, &lt;strong&gt;소프트웨어 인터럽트&lt;/strong&gt;를 발생시킨다. 소프트웨어 인터럽트 역시 하드웨어 인터럽트와 동일하게 운영체제 내부에 해당 인터럽트를 처리하는 코드(ISR)가 존재하여 이 곳으로 이동한다. 여기서 하드디스크에서 읽을 파일을 찾아서 반환해주는 수행을 처리하는 것이다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;strong&gt;내부 인터럽트(Internal Interrupt)&lt;/strong&gt;가 있다. 내부 인터럽트는 프로그램을 수행하는 도중에 발생하는 예외 상황을 처리한다. 대표적인 예로 0으로 나누는 동작이다. 프로그램의 내부에 result = a / 0; 이와 같은 코드가 있을 때, CPU는 내부 인터럽트를 발생시켜 운영체제안에 있는 ISR로 이동한다. 이 경우에는 DividedByZero 라는 ISR로 이동한다. 여기서 잘못된 동작을 수행한 프로그램을 강제로 종료시킨다.&lt;/p&gt;

&lt;p&gt;운영체제는 평소에는 대기 상태에 있으면서 인터럽트가 발생하는 순간 작업을 수행한다. 그 인터럽트의 종류에 따라 운영체제 내부에 위치한 ISR로 이동하여 그에 맞는 처리를 한다. 위에서 설명한 하드웨어 인터럽트 과정을 그림으로 간단히 표현하면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1158&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77916530-281f6200-72d4-11ea-8c3e-1a9211cce460.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 사용자 애플리케이션을 실행하기 위해 하드웨어를 사용하는 모습이다. 애플리케이션이 실행하는 중에도 계속해서 인터럽트는 발생한다. 워드 작성 프로그램을 예를 들면 키보드로 글을 작성하는 경우, 하드디스크에 있는 파일을 불러오는 경우 모두 인터럽트가 발생한다. 그러므로 CPU는 애플리케이션과 운영체제 내부를 교대로 수행하는 모습을 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;

&lt;p&gt;정리하면, 인터럽트는 CPU에게 보내는 전기 신호로서 인터럽트가 발생하면 CPU는 하던 일을 중지하고 해당 인터럽트를 처리하기 위해 운영체제 내부에 있는 ISR로 이동하여 수행한다. 그리고 수행이 끝나면 원래 위치로 돌아간다. 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부 인터럽트로 총 세 가지가 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>01: 운영체제란 무엇인가?</title>
        <link>/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-01-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html</link>
        <guid isPermaLink="true">/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-01-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html</guid>
        <description>&lt;p&gt;운영체제에 대한 정의, 역할에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;운영체제는 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어이다. 일반적으로 사용하는 모든 프로그램은 운영체제에서 그 자원을 관리한다.&lt;/p&gt;

&lt;h1 id=&quot;목적&quot;&gt;목적&lt;/h1&gt;

&lt;p&gt;운영체제를 사용하는 가장 큰 목적은 하드웨어의 관리이다. 컴퓨터를 나타내는 가장 상징적인 장치는 CPU이지만, 추가적으로 많은 장치와 상호작용하며 동작한다. 그렇기에 이러한 하드웨어를 관리하는 소프트웨어가 있어야 효율적으로 컴퓨터를 사용할 수 있다. 하드웨어를 직접적으로 사용하는 것이 아니기 때문에, 이를 효율적으로 사용하기 위해서는 운영체제의 성능이 좋아야 한다.&lt;/p&gt;

&lt;p&gt;두번째로는 사용자에게 편의를 제공하는 것이다. 운영체제가 없을 경우, 우리는 하드웨어 단에서 하드 코딩으로 원하는 작업을 실행해야 한다. 이는 매우 생산성이 떨어지는 방법이다. 그렇기 때문에 이런 자원 관리 측면을 자동으로 해주는 소프트웨어를 통해, 원하는 작업에만 몰두할 수 있는 환경을 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;

&lt;p&gt;운영체제는 컴퓨터의 성능을 높히고(&lt;strong&gt;performance&lt;/strong&gt;), 사용자에게 편의성을 제공(&lt;strong&gt;Convenience&lt;/strong&gt;)을 목적으로 하는 컴퓨터 하드웨어 관리 프로그램이다.&lt;/p&gt;

&lt;h1 id=&quot;부팅-booting&quot;&gt;부팅 (Booting)&lt;/h1&gt;

&lt;p&gt;컴퓨터를 사용하기 위해서 가장 먼저하는 행동은 전원버튼을 누르는 것이다. 그렇다면, 전원을 눌렀을 때, 시작해야 하는 작업들이 있을 것이다. 우리가 실제로 사용할 수 있는 운영체제가 실행되기 이전에 다양한 작업을 해야하는데, 이 작업을 부팅 이라 한다.&lt;/p&gt;

&lt;h2 id=&quot;어떻게-실행할-수-있을까&quot;&gt;어떻게 실행할 수 있을까?&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;1106&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77884826-c72a6680-72a0-11ea-995c-7e6c612ac194.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본적인 컴퓨터 구조는 위와 같다. 이 상황에서 부팅을 한다고 생각해보자. 컴퓨터는 원하는 작업을 실행할 때, Disk, RAM, CPU, RAM, Disk 순의 과정을 거치며 작동하게 된다. 그런데, 부팅을 하는 경우에는 어떻게 해야할까? 사실 Disk는 컴퓨터 입장에서는 보조 장치이다. 컴퓨터라고 부를 수 있는 실질적인 부분은 CPU, RAM이 전부이기 때문에 처음 부팅을 시작하면 CPU 에 부팅시 필요한 작업을 넘겨줄 수 없다.&lt;/p&gt;

&lt;p&gt;따라서 우리는 일반적으로 프로그램이 동작하는 방식인 Disk, RAM, CPU 과정을 거칠 수 없기 때문에, 부팅에 한해서 RAM에 항상 저장된 공간을 필요로하게 되었는데, 그것이 ROM이다.&lt;/p&gt;

&lt;p&gt;RAM과 ROM을 함께 Main Memory라 부른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ROM: 비휘발성 으로 메모리에서 극히 일부를 차지한다.(수 KB)&lt;/li&gt;
  &lt;li&gt;RAM: 휘발성 으로 메모리의 대부분을 차지하며 실제 프로그램이 할당되는 곳이다.(수 MB ~ 수 GB)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;부팅시-하는-작업엄밀한-정의의-부팅&quot;&gt;부팅시 하는 작업(엄밀한 정의의 부팅)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;ROM의 정보를 읽는다.&lt;/li&gt;
  &lt;li&gt;ROM안에 있는 POST(Power-On-Self-Test), 부트 로더(Boot-Loader)를 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;POST는 전원이 켜지면 가장 처음에 실행되는 프로그램으로, 현재 컴퓨터의 상태를 검사한다. 이 것에는 장치가 연결되어 있는지, 멀쩡한 지 등의 상태를 뜻한다.&lt;/p&gt;

&lt;p&gt;부트 로더는 하드디스크에 저장되어 있는 운영체제를 찾아서 메인 메모리(RAM)에 가지고 온다. 이러한 부트 로더의 과정을 부팅이라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1121&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77885825-b24ed280-72a2-11ea-99b4-aaf7e15f367e.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 메모리에 올라온 OS는 컴퓨터를 종료하기 전까지 계속 메모리에 상주한다.&lt;/p&gt;

&lt;h1 id=&quot;구조&quot;&gt;구조&lt;/h1&gt;

&lt;p&gt;운영체제는 크게 커널(Kernel)과 명령어 해석기(Command interpreter, shell)로 나뉜다.&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77887017-cf84a080-72a4-11ea-8810-b0918da5327c.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;커널(Kernel)은 운영체제의 핵심인 하드웨어를 다루는 코드를 말한다. 이 부분이 핵심이 때문에, Kernel에 따라 운영체제가 달라진다. 예를 들어 페도라, 우분투 등이 리눅스 운영체제라 부르는 것은, 이 운영체제가 리눅스 커널을 사용하기 때문이다.&lt;/p&gt;

&lt;p&gt;명령어 해석기(Command interpreter, shell)는 이 커널로 만들어진 코드를 동작하기 위해 만들어진 부분이다. Interface라고 볼 수 있다. GUI(Graphical User Interface)나 CLI(Command Line Interface) 같은 방식으로 운영체제에 명령을 요청할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;위치&quot;&gt;위치&lt;/h1&gt;

&lt;p&gt;사용자 프로그램(Application)은 특정 운영체제에 맞춰서 만든다. 그러므로 한 애플리케이션은 서로 다른 운영체제에서 수행할 수 없다. (하드웨어가 같은 것은 전혀 상관이 없다.) 예를 들면 Windows에서 수행하는 프로그램을 그대로 Linux에 옮기면 수행되지 않는다. 이전 글에서 보았듯이 &lt;strong&gt;사용자 프로그램은 자원을 OS를 통해 요청&lt;/strong&gt;한다. 그렇기 때문에 해당 운영체제의 Interface를 따라야 하고, 그렇기 때문에 운영체제가 다를 경우 동작할 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;947&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77887354-63ef0300-72a5-11ea-9231-1c571b962db6.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;추가적으로 국가에 비유하여 생각해 볼 수도 있다.&lt;br /&gt;
&lt;a href=&quot;https://wansook0316.github.io/cs/structure/2020/03/21/컴퓨터구조-용어정리.html&quot;&gt;영토, 정부, 가족, 개인 비유&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>07: 운영 체제가 하는 일</title>
        <link>/cs/structure/2020/03/27/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C%EA%B0%80-%ED%95%98%EB%8A%94-%EC%9D%BC.html</link>
        <guid isPermaLink="true">/cs/structure/2020/03/27/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C%EA%B0%80-%ED%95%98%EB%8A%94-%EC%9D%BC.html</guid>
        <description>&lt;p&gt;운영 체제가 하는 일을 간단하게 알아보자.&lt;/p&gt;

&lt;p&gt;최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.&lt;/p&gt;

&lt;h1 id=&quot;운영체제가-하는-일&quot;&gt;운영체제가 하는 일&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;접근 제어 + 동기화 + 관리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;전산 자원을 관리한다. 대표적인 전산 자원은 CPU, RAM 등이 있다. &lt;del&gt;스타판 프로게이머&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로그램들-관리하기&quot;&gt;프로그램’들’ 관리하기&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process를 관리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;한정된 자원으로 많은 프로그램들이 동작해야 한다. 어쩔 수 없이 나눠서 사용해야 한다.&lt;/p&gt;

&lt;p&gt;아래 단어들의 의미를 모른다면, 용어를 알고 다시 읽자.
&lt;a href=&quot;https://wansook0316.github.io/cs/architecture/2020/03/25/컴퓨터구조-용어정리.html&quot;&gt;하드웨어, 운영체제, 프로세스, 스레드 용어 정리&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;scheduling&quot;&gt;Scheduling&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;멀티 프로세스 운영체제에서 하나의 CPU가 복수의 프로세스를 실행하기 위해 CPU를 사용하는 순서를 정해주는 작업&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img width=&quot;1210&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/77846957-870daa00-71f4-11ea-85a8-4de42f067d62.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 다양한 프로세스를 동시에 작업하게 되면, 스레드가 CPU를 사용하고 있을 떄, 사용하고 있다고 알려주는 &lt;strong&gt;&lt;em&gt;동기화&lt;/em&gt;&lt;/strong&gt;가 매우 중요하다.&lt;/p&gt;

&lt;h2 id=&quot;virtual-memory-system&quot;&gt;Virtual Memory System&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;RAM과 HDD를 하나의 논리적 메모리로 추상화시킨 메모리 관리 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로세스가 운영체제로 부터 메모리를 할당 받는 일은 시간이 많이 걸리는 일이다. 그렇기 때문에 최대한 RAM 공간에 할당 받은 채로 존재하는 것이 속도를 높일 수 있는 방법이다. 또한 여러개의 프로세스를 사용할 경우, RAM 공간을 초과하여 프로세스가 동작하지 않는다. 이런 부분들을 해결하기 위해 HDD 공간을 활용한 것이 가상 메모리 시스템이다.&lt;/p&gt;

&lt;h3 id=&quot;단위&quot;&gt;단위&lt;/h3&gt;

&lt;p&gt;이 곳에서 모든 메모리는 &lt;strong&gt;Page&lt;/strong&gt;라는 단위로 관리된다. HDD와 RAM을 왔다갔다 하는 단위이다. 이 중에는 Paged 될 수 있는 &lt;strong&gt;페이징 풀&lt;/strong&gt; 영역과 절대로 Paged 되면 안되는 &lt;strong&gt;비 페이징 풀&lt;/strong&gt; 영역이 있다.&lt;/p&gt;

&lt;h3 id=&quot;virtual-memory의-구성&quot;&gt;Virtual Memory의 구성&lt;/h3&gt;

&lt;p&gt;집의 공간을 가족 구성원들이 나눠쓰듯이 프로세스의 가상 메모리 공간을 thread가 나눠서 사용한다. 이 나눠서 사용하는 공간을 &lt;strong&gt;Stack&lt;/strong&gt;이라 한다. 이 thread에 할당된 메모리 공간이 stack을 사용하여 관리되기 때문에 Stack이라 불린다.&lt;/p&gt;

&lt;p&gt;프로세스는 Heap과 실행 코드 영역을 갖는다.&lt;br /&gt;
&lt;a href=&quot;http://127.0.0.1:4000/cs/os/2020/04/01/운영체제-정리-05-운영체제-프로세스-관리.html&quot;&gt;운영체제 정리 05: 프로세스 관리&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;동작-방법&quot;&gt;동작 방법&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;RAM이 꽉찼는 지 확인한다.&lt;/li&gt;
  &lt;li&gt;꽉찼다면 현재 RAM 공간 중에 사용하지 않는 프로세스가 할당된 공간이 있다면 이것을 HDD 공간에 복사해둔다. &lt;strong&gt;Page Out&lt;/strong&gt;(&lt;em&gt;Swap Out&lt;/em&gt;)&lt;/li&gt;
  &lt;li&gt;RAM 공간이 비게 될 경우 복사해 둔 공간을 다시 RAM으로 복사한다. &lt;strong&gt;Page in&lt;/strong&gt;(&lt;em&gt;Swap in&lt;/em&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;프로세스-별-가상-메모리의-크기&quot;&gt;프로세스 별 가상 메모리의 크기&lt;/h3&gt;

&lt;p&gt;이러한 가상 메모리 시스템이 있기 때문에, 프로세스가 실행 되고 할당 받는 메모리 공간은 4GB로 할당한다. 이 크기는 현실적으로 RAM만 사용한다면 말이 안되는 소리지만, 가상 메모리를 사용하게 되면 문제없다.&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>window resize event</title>
        <link>/dv/javascripts/2020/03/26/javascript-window-event.html</link>
        <guid isPermaLink="true">/dv/javascripts/2020/03/26/javascript-window-event.html</guid>
        <description>&lt;p&gt;자바스크립트의 window 이벤트를 알아본다.&lt;/p&gt;

&lt;h2 id=&quot;resize&quot;&gt;resize&lt;/h2&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;changeContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;changeContent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;js-cat&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;category-cv&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;math&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;category-math&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;category-ds&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;category-cs&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;category-dv&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;about&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;category-about&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerWidth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;710&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;📜&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;✖&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;📈&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;💾&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;📱&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;about&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;😎&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;justifyContent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;space-around&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;CV&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Data Science&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Computer Science&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Development&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;about&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;About&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;justifyContent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 내 블로그 카테고리를 수정할 때 만든 코드이다.&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Mar 2020 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
