<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>완숙의 에그머니🍳</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>개발, 데이터, 통계, 수학를 좋아하는 반항아의 블로그</description>
    <pubDate>Thu, 09 Apr 2020 14:56:14 +0900</pubDate>
    
      <item>
        <title>03: HTTP</title>
        <link>/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-03-HTTP.html</link>
        <guid isPermaLink="true">/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-03-HTTP.html</guid>
        <description>&lt;p&gt;Application Layer인 HTTP를 알아본다.&lt;/p&gt;

&lt;h2 id=&quot;http-protocol-특징-간략&quot;&gt;HTTP Protocol 특징 (간략)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;HyperText Transport Protocol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78854354-09e7fd80-7a5c-11ea-9d5d-98aac430e6ea.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Message 종류 두 가지
    &lt;ul&gt;
      &lt;li&gt;Request &amp;amp; Response&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TCP 사용
    &lt;ul&gt;
      &lt;li&gt;Transport Layer 위에 Application Layer 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;stateless protocol
    &lt;ul&gt;
      &lt;li&gt;상대방 상태정보를 저장하지 않음&lt;/li&gt;
      &lt;li&gt;그냥 request, response후 아무것도 저장 안한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;non-persistent-http&quot;&gt;Non-Persistent HTTP&lt;/h3&gt;

&lt;p&gt;Request Message 를 서버로 보내기 위해선 우선 TCP Connection이 선행되어야 한다. 그리고 request msg 에 대해서 response msg 를 받게되면 TCP Connection 은 끊기며 다시 웹사이트의 리소스를 들고오기 위해선 TCP Connection 을 재차 맺어야한다. Connection 이 지속적인 상태가 아니다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78854421-3f8ce680-7a5c-11ea-8919-88b33a400873.png&quot; class=&quot;center&quot; /&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78854426-44ea3100-7a5c-11ea-9aac-368f8e5ba373.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTTP client가 IP/PORT에 TCP 연결을 시작한다.&lt;/li&gt;
  &lt;li&gt;HTTP server의 host는 80번 포트에서 TCP 연결을 기다리다가 문제가 없으면 “accept” 라고 client에게 알린다.&lt;/li&gt;
  &lt;li&gt;HTTP client는 HTTP request 메시지를 TCP 연결 Socket에 보낸다.&lt;/li&gt;
  &lt;li&gt;HTTP server는 요청을 받고 response를 socket에 넣는다.&lt;/li&gt;
  &lt;li&gt;HTTP sever는 TCP 연결을 끊는 준비를 한다.&lt;/li&gt;
  &lt;li&gt;HTTP client는 응답을 받고 화면에 보여준다.&lt;/li&gt;
  &lt;li&gt;HTTP client가 다 받았다면 다 받았다는 메시지를 보낸다.&lt;/li&gt;
  &lt;li&gt;함께 Connection을 끊는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;persistent-http&quot;&gt;Persistent HTTP&lt;/h3&gt;

&lt;p&gt;웹클라이언트 (브라우저) 는 보통 같은 사이트에 여러 개의 TCP 커넥션을 맺는다. 예를 들어 웹 페이지에 첨부된 이미지들 대부분은 같은 웹사이트에 있으며, 여러 하이퍼링크도 같은 사이트를 가리키는 경우가 있다. 여기서 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹 페이지의 다른 이미지 등을 가져오기 위해서 그 서버에 또 다시 요청하는 경우가 생기는데, 이 속성을 사이트 지역성(Site Locality)이라고 부른다. 하지만 이러한 TCP 커넥션을 계속 유지하여 앞으로도 있을 HTTP 요청에 재사용할 수 있도록 하는 것이다. 처리가 완료된 이후에도 계속 연결된 상태로 있는 TCP 커넥션을 Persistent Connection 이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=1169634&quot;&gt;KOCW 이석복 교수님 - 컴퓨터네트워크&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>02: 네트워크 넓게 보기 Part 2</title>
        <link>/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-02-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%93%EA%B2%8C-%EB%B3%B4%EA%B8%B0-2.html</link>
        <guid isPermaLink="true">/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-02-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%93%EA%B2%8C-%EB%B3%B4%EA%B8%B0-2.html</guid>
        <description>&lt;p&gt;네트워크에 대해 깊게 알아보기 전에 큰 그림을 보고, 용어를 정리한다.&lt;/p&gt;

&lt;h2 id=&quot;기본-용어-정리&quot;&gt;기본 용어 정리&lt;/h2&gt;

&lt;h3 id=&quot;프로토콜&quot;&gt;프로토콜&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;서로 다른 개체들이 서로 간의 의사소통을 하기 위해 만들어놓은 규약&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;패킷&quot;&gt;패킷&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;한번에 전송할 데이터의 크기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;편지를 내가 썼다. 그 편지를 누군가한테 보내는데, 글자하나하나를 보내지 않는다. 이 때 편지는 우체부 아저씨가 누군가한테 배달하는 단위가 된다. 이와 같은 개념이 패킷이다. 패킷은 데이터를 보내는 데 있어 발생하는 단위이다. 이 패킷의 구조에 대해서는 나중에 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;대역폭&quot;&gt;대역폭&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;수도관의 크기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;결국 데이터는 흐름이다. 그렇기 때문에 어떤 관을 따라간다고 생각할 수 있다. 이 때 관의 지름이 대역폭이다. 한번에 보낼 수 있는 데이터의 양이라 생각하면 된다. 이 크기가 클수록 많은 데이터를 초 당 전송할 수 있는 양이 늘어난다. 인터넷 속도와 직결된다.&lt;/p&gt;

&lt;h3 id=&quot;트래픽&quot;&gt;트래픽&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 통신장치나 시스템에 걸리는 부하(전송량)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요청에 대해 전송해주는 시간 대비 데이터의 총량을 말한다.&lt;/p&gt;

&lt;h2 id=&quot;네트워크-구조&quot;&gt;네트워크 구조&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78849399-57aa3900-7a4f-11ea-9002-7c36366b34cb.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;네트워크-엣지network-edge&quot;&gt;네트워크 엣지(Network Edge)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;말단 device, 우리가 사용하는 대부분의 기기에 해당한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;네트워크-코어network-core&quot;&gt;네트워크 코어(Network Core)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;엔드 시스템을 연결하기 위한 중간의 매개들을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;물리적-링크&quot;&gt;물리적 링크&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;코어와 엣지 사이에 존재하는 데이터 전송 선과 같은 것들을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;네트워크의-내부&quot;&gt;네트워크의 내부&lt;/h2&gt;

&lt;h3 id=&quot;라우터&quot;&gt;라우터&lt;/h3&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78850080-39453d00-7a51-11ea-9c62-fb505b277520.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;네트워크 내부에 존재하는 장치(네트워크 코어)들로써, 라우터는 사용자들이 보낸 메세지를 목적지까지 전달하는 역할을 가지고 있다. 결국 라우터는 데이터를 전달하는 장치이다.&lt;/p&gt;

&lt;h3 id=&quot;라우터의-데이터-전달방식&quot;&gt;라우터의 데이터 전달방식&lt;/h3&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78850098-46622c00-7a51-11ea-9a96-ee16e706412f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Circuit Switching&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;출발지부터 목적지까지의 대역폭을 예약해놓은 상태로써, 한번에 데이터를 전달하는 것이다. 하나의 회선을 할당받아 (회선을 독점하여) 데이터를 전달하기 때문에 아무런 방해없이 한번에 전달할 수 있다. 예시로 전화망이 있다. 전화를 걸게되면 전화를 건 송신자로부터 수신자의 전화기에 이르기까지의 경로를 찾아내고, 한번 설정된 송신자와 수신자의 경로는 데이터(음성) 이 전송되는 동안 계속 유지되는 것이다. 이 예로 부터 Circuit Switching은 언제든지 계속 사용하는 시스템에 적합하다는 것을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;장점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;단점&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;대역폭이 결정되므로, delay가 발생할 수 없다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;일정 사용자에게 할당해주므로 낭비가 발생한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78850098-46622c00-7a51-11ea-9a96-ee16e706412f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Packet Switching&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;사용자가 보내는 데이터가 패킷단위로 잘게 나뉘어서 전달되는 것이다. 패킷은 출발지에서 다음 라우터로 전송하기 이전에 저장하고 어느 경로로 갈지 결정하는 Store and Forward 방식을 취한다. 패킷의 헤더에는 출발지(source) 와 목적지(destination) 에 대한 정보가 들어있다. 대부분의 경우는 이 사용법을 택한다. 인터넷을 사용하는 패턴이 Packet Switching 에 적합하기 때문이다. 연속된 요청이 필요없기 때문에 대역폭을 할당할 필요가 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;장점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;단점&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;짧게 사용하는 다수의 사용자도 커버가 가능하다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;짧은 시간에 많은 요청이 들어올 경우 delay가 발생한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;packet-delay&quot;&gt;Packet Delay&lt;/h2&gt;

&lt;p&gt;패킷스위칭을 시 라우터는 패킷단위의 데이터를 전달받고 목적지로 전달하는 역할을 수행한다. 이 과정에서 라우터가 보낼 수 있는 대역폭보다 더 많은 유저가 더 빠른 속도로 데이터를 보낸다면 딜레이가 생길 수 밖에 없다. 톨게이트에 사람이 마구 몰리는 상황을 상상해보자.&lt;/p&gt;

&lt;h3 id=&quot;delay의-구분&quot;&gt;Delay의 구분&lt;/h3&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78851120-fafd4d00-7a53-11ea-816a-e8a55610944a.png&quot; class=&quot;center&quot; /&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78851127-00f32e00-7a54-11ea-8e6a-b73f35bb50be.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;processing-delay&quot;&gt;Processing Delay&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;패킷 자체를 평가한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;필연적인 딜레이 중 하나로써, 목적지에 따른 어느 라우터로 전송할 지 결정하는 것에 대한 지연이다. 이 과정에서는 패킷의 형식을 검사하고, 목적지를 판단하는 과정을 수행한다.&lt;/p&gt;

&lt;h4 id=&quot;queueing-delay&quot;&gt;Queueing Delay&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;들어온 패킷들을 줄세운다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;데이터를 전달하는 라우터의 큐에 들어가서 앞서서 도착해 큐에 대기중인 패킷들이 모두 나갈때까지 걸리는 지연이다. (큐에 얼마나 많이 들어가있는지에 따라서 큐잉 딜레이는 가변적)&lt;/p&gt;

&lt;h4 id=&quot;transmission-delay&quot;&gt;Transmission Delay&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;패킷하나가 모두 전송되기 까지 걸리는 시간&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라우터의 큐 제일 앞에 배치되어서 패킷 하나가 온전하게 마지막 비트까지 최종 목적지로 가는데까지의 지연이다. 패킷은 전송의 한 단위이기 때문에, 하나의 패킷이 모두 전송이 되어야 sender는 전송이 되었다고 판단한다. 예를 들면 패킷의 bit가 100bits이고 대역폭이 1bps 이면 1초당 1bit만 전송할 수 있기 때문에 100초 후에 이 패킷은 전송되었다고 판단할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;propagation-delay&quot;&gt;Propagation Delay&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;실제로 비트가 선을 따라 전송되는데 걸리는 시간&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마지막 비트까지 대역폭에 올라오고, 이후에 마지막 비트가 최종 목적지까지 도달하는 물리적 시간이다. 이 속도는 전자기파의 속도라 사실 많은 영향을 주지는 않는다. ( 가까우면 빨리, 거리가 멀면 오래 걸림)&lt;/p&gt;

&lt;p&gt;결과적으로 라우터에서 패킷을 받을 때 걸리는 nodal delay 는 위 4가지의 지연의 합으로 표현된다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;nodal = proc + queue + trans + prop&lt;/script&gt;

&lt;h3 id=&quot;delay-줄이기&quot;&gt;Delay 줄이기&lt;/h3&gt;

&lt;h4 id=&quot;processing-delay-1&quot;&gt;Processing Delay&lt;/h4&gt;

&lt;p&gt;라우터에 좋은 처리장치를 달아서 패킷에 대해 판단하는 속도를 향상시킨다.&lt;/p&gt;

&lt;h4 id=&quot;queueing-delay-1&quot;&gt;Queueing Delay&lt;/h4&gt;

&lt;p&gt;사용자의 패턴에 의존하기 때문에 불가능하다. 통계적 기법을 사용해야 한다.&lt;/p&gt;

&lt;h4 id=&quot;transmission-delay-1&quot;&gt;Transmission Delay&lt;/h4&gt;

&lt;p&gt;패킷하나가 빠져나가는 시간을 줄인다. 초당 선송할 수 있는 양을 늘리면 된다. 마치 톨게이트에서 5차선이었던 것을 10차선으로 바꾸면 한번에 빠져나갈 수 있는 차량의 수가 증가한다. 이 때, 이 차선에 대응되는 개념이 &lt;strong&gt;대역폭&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h4 id=&quot;propagation-delay-1&quot;&gt;Propagation Delay&lt;/h4&gt;

&lt;p&gt;빛의 속도는 세상에서 가장 빠르다.. 불가능하다.&lt;/p&gt;

&lt;h2 id=&quot;packet-loss&quot;&gt;Packet Loss&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;큐에 패킷이 가득차있는 경우 버려진다.
라우터의 큐에 삽입되기 이전에 큐에 패킷이 가득차있는 경우 큐의 저장공간이 없기 때문에 Packet Loss 가 발생하며, 패킷은 버려진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;tcp-작동&quot;&gt;TCP 작동&lt;/h3&gt;

&lt;p&gt;이런 경우 안전한 전송을 담당하는 Client 쪽의 TransportLayer 계층의 TCP 프로토콜이 해당 패킷을 재전송한다. 잘 몰라도 된다. 나중에 배운다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=1169634&quot;&gt;KOCW 이석복 교수님 - 컴퓨터네트워크&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>01: 네트워크 넓게 보기 Part 1</title>
        <link>/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-01-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%93%EA%B2%8C-%EB%B3%B4%EA%B8%B0-1.html</link>
        <guid isPermaLink="true">/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-01-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%93%EA%B2%8C-%EB%B3%B4%EA%B8%B0-1.html</guid>
        <description>&lt;p&gt;네트워크에 대해 깊게 알아보기 전에 큰 그림을 보고, 용어를 정리한다.&lt;/p&gt;

&lt;h2 id=&quot;기본-용어-정리&quot;&gt;기본 용어 정리&lt;/h2&gt;

&lt;h3 id=&quot;프로토콜&quot;&gt;프로토콜&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;서로 다른 개체들이 서로 간의 의사소통을 하기 위해 만들어놓은 규약&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사람이 대화를 하는 과정에도 일정한 흐름과 규약이 존재한다. 어떠한 객체가 소통하기 위해서는 서로의 방식을 맞추어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;패킷&quot;&gt;패킷&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;한번에 전송할 데이터의 크기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;편지를 내가 썼다. 그 편지를 누군가한테 보내는데, 글자하나하나를 보내지 않는다. 이 때 편지는 우체부 아저씨가 누군가한테 배달하는 단위가 된다. 이와 같은 개념이 패킷이다. 패킷은 데이터를 보내는 데 있어 발생하는 단위이다. 이 패킷의 구조에 대해서는 나중에 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;대역폭&quot;&gt;대역폭&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;수도관의 크기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;결국 데이터는 흐름이다. 그렇기 때문에 어떤 관을 따라간다고 생각할 수 있다. 이 때 관의 지름이 대역폭이다. 한번에 보낼 수 있는 데이터의 양이라 생각하면 된다. 이 크기가 클수록 많은 데이터를 초 당 전송할 수 있는 양이 늘어난다. 인터넷 속도와 직결된다.&lt;/p&gt;

&lt;h3 id=&quot;트래픽&quot;&gt;트래픽&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 통신장치나 시스템에 걸리는 부하(전송량)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요청에 대해 전송해주는 시간 대비 데이터의 총량을 말한다.&lt;/p&gt;

&lt;h2 id=&quot;네트워크-구조&quot;&gt;네트워크 구조&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78849399-57aa3900-7a4f-11ea-9002-7c36366b34cb.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;네트워크-엣지network-edge&quot;&gt;네트워크 엣지(Network Edge)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;말단 device, 우리가 사용하는 대부분의 기기에 해당한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;네트워크-코어network-core&quot;&gt;네트워크 코어(Network Core)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;엔드 시스템을 연결하기 위한 중간의 매개들을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;물리적-링크&quot;&gt;물리적 링크&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;코어와 엣지 사이에 존재하는 데이터 전송 선과 같은 것들을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;네트워크의-내부&quot;&gt;네트워크의 내부&lt;/h2&gt;

&lt;h3 id=&quot;라우터&quot;&gt;라우터&lt;/h3&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78850080-39453d00-7a51-11ea-9c62-fb505b277520.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;네트워크 내부에 존재하는 장치(네트워크 코어)들로써, 라우터는 사용자들이 보낸 메세지를 목적지까지 전달하는 역할을 가지고 있다. 결국 라우터는 데이터를 전달하는 장치이다.&lt;/p&gt;

&lt;h3 id=&quot;라우터의-데이터-전달방식&quot;&gt;라우터의 데이터 전달방식&lt;/h3&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78850098-46622c00-7a51-11ea-9a96-ee16e706412f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Circuit Switching&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;출발지부터 목적지까지의 대역폭을 예약해놓은 상태로써, 한번에 데이터를 전달하는 것이다. 하나의 회선을 할당받아 (회선을 독점하여) 데이터를 전달하기 때문에 아무런 방해없이 한번에 전달할 수 있다. 예시로 전화망이 있다. 전화를 걸게되면 전화를 건 송신자로부터 수신자의 전화기에 이르기까지의 경로를 찾아내고, 한번 설정된 송신자와 수신자의 경로는 데이터(음성) 이 전송되는 동안 계속 유지되는 것이다. 이 예로 부터 Circuit Switching은 언제든지 계속 사용하는 시스템에 적합하다는 것을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;장점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;단점&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;대역폭이 결정되므로, delay가 발생할 수 없다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;일정 사용자에게 할당해주므로 낭비가 발생한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78850098-46622c00-7a51-11ea-9a96-ee16e706412f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Packet Switching&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;사용자가 보내는 데이터가 패킷단위로 잘게 나뉘어서 전달되는 것이다. 패킷은 출발지에서 다음 라우터로 전송하기 이전에 저장하고 어느 경로로 갈지 결정하는 Store and Forward 방식을 취한다. 패킷의 헤더에는 출발지(source) 와 목적지(destination) 에 대한 정보가 들어있다. 대부분의 경우는 이 사용법을 택한다. 인터넷을 사용하는 패턴이 Packet Switching 에 적합하기 때문이다. 연속된 요청이 필요없기 때문에 대역폭을 할당할 필요가 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;장점&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;단점&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;짧게 사용하는 다수의 사용자도 커버가 가능하다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;짧은 시간에 많은 요청이 들어올 경우 delay가 발생한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;packet-delay&quot;&gt;Packet Delay&lt;/h2&gt;

&lt;p&gt;패킷스위칭을 시 라우터는 패킷단위의 데이터를 전달받고 목적지로 전달하는 역할을 수행한다. 이 과정에서 라우터가 보낼 수 있는 대역폭보다 더 많은 유저가 더 빠른 속도로 데이터를 보낸다면 딜레이가 생길 수 밖에 없다. 톨게이트에 사람이 마구 몰리는 상황을 상상해보자.&lt;/p&gt;

&lt;h3 id=&quot;delay의-구분&quot;&gt;Delay의 구분&lt;/h3&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78851120-fafd4d00-7a53-11ea-816a-e8a55610944a.png&quot; class=&quot;center&quot; /&gt;
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78851127-00f32e00-7a54-11ea-8e6a-b73f35bb50be.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;processing-delay&quot;&gt;Processing Delay&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;패킷 자체를 평가한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;필연적인 딜레이 중 하나로써, 목적지에 따른 어느 라우터로 전송할 지 결정하는 것에 대한 지연이다. 이 과정에서는 패킷의 형식을 검사하고, 목적지를 판단하는 과정을 수행한다.&lt;/p&gt;

&lt;h4 id=&quot;queueing-delay&quot;&gt;Queueing Delay&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;들어온 패킷들을 줄세운다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;데이터를 전달하는 라우터의 큐에 들어가서 앞서서 도착해 큐에 대기중인 패킷들이 모두 나갈때까지 걸리는 지연이다. (큐에 얼마나 많이 들어가있는지에 따라서 큐잉 딜레이는 가변적)&lt;/p&gt;

&lt;h4 id=&quot;transmission-delay&quot;&gt;Transmission Delay&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;패킷하나가 모두 전송되기 까지 걸리는 시간&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라우터의 큐 제일 앞에 배치되어서 패킷 하나가 온전하게 마지막 비트까지 최종 목적지로 가는데까지의 지연이다. 패킷은 전송의 한 단위이기 때문에, 하나의 패킷이 모두 전송이 되어야 sender는 전송이 되었다고 판단한다. 예를 들면 패킷의 bit가 100bits이고 대역폭이 1bps 이면 1초당 1bit만 전송할 수 있기 때문에 100초 후에 이 패킷은 전송되었다고 판단할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;propagation-delay&quot;&gt;Propagation Delay&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;실제로 비트가 선을 따라 전송되는데 걸리는 시간&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마지막 비트까지 대역폭에 올라오고, 이후에 마지막 비트가 최종 목적지까지 도달하는 물리적 시간이다. 이 속도는 전자기파의 속도라 사실 많은 영향을 주지는 않는다. ( 가까우면 빨리, 거리가 멀면 오래 걸림)&lt;/p&gt;

&lt;p&gt;결과적으로 라우터에서 패킷을 받을 때 걸리는 nodal delay 는 위 4가지의 지연의 합으로 표현된다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;nodal = proc + queue + trans + prop&lt;/script&gt;

&lt;h3 id=&quot;delay-줄이기&quot;&gt;Delay 줄이기&lt;/h3&gt;

&lt;h4 id=&quot;processing-delay-1&quot;&gt;Processing Delay&lt;/h4&gt;

&lt;p&gt;라우터에 좋은 처리장치를 달아서 패킷에 대해 판단하는 속도를 향상시킨다.&lt;/p&gt;

&lt;h4 id=&quot;queueing-delay-1&quot;&gt;Queueing Delay&lt;/h4&gt;

&lt;p&gt;사용자의 패턴에 의존하기 때문에 불가능하다. 통계적 기법을 사용해야 한다.&lt;/p&gt;

&lt;h4 id=&quot;transmission-delay-1&quot;&gt;Transmission Delay&lt;/h4&gt;

&lt;p&gt;패킷하나가 빠져나가는 시간을 줄인다. 초당 선송할 수 있는 양을 늘리면 된다. 마치 톨게이트에서 5차선이었던 것을 10차선으로 바꾸면 한번에 빠져나갈 수 있는 차량의 수가 증가한다. 이 때, 이 차선에 대응되는 개념이 &lt;strong&gt;대역폭&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h4 id=&quot;propagation-delay-1&quot;&gt;Propagation Delay&lt;/h4&gt;

&lt;p&gt;빛의 속도는 세상에서 가장 빠르다.. 불가능하다.&lt;/p&gt;

&lt;h2 id=&quot;packet-loss&quot;&gt;Packet Loss&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;큐에 패킷이 가득차있는 경우 버려진다.
라우터의 큐에 삽입되기 이전에 큐에 패킷이 가득차있는 경우 큐의 저장공간이 없기 때문에 Packet Loss 가 발생하며, 패킷은 버려진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;tcp-작동&quot;&gt;TCP 작동&lt;/h3&gt;

&lt;p&gt;이런 경우 안전한 전송을 담당하는 Client 쪽의 TransportLayer 계층의 TCP 프로토콜이 해당 패킷을 재전송한다. 잘 몰라도 된다. 나중에 배운다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=1169634&quot;&gt;KOCW 이석복 교수님 - 컴퓨터네트워크&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>백준(2343번): 기타 레슨</title>
        <link>/cs/algorithm/2020/04/08/%EB%B0%B1%EC%A4%80-%EA%B8%B0%ED%83%80-%EB%A0%88%EC%8A%A8.html</link>
        <guid isPermaLink="true">/cs/algorithm/2020/04/08/%EB%B0%B1%EC%A4%80-%EA%B8%B0%ED%83%80-%EB%A0%88%EC%8A%A8.html</guid>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;실버1&lt;/em&gt;&lt;/strong&gt; : 이분 탐색, Parametric Search 문제이다.&lt;br /&gt;
&lt;a href=&quot;https://www.acmicpc.net/problem/2343&quot;&gt;백준(2343번) - 기타 레슨&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;생각&quot;&gt;생각&lt;/h1&gt;

&lt;p&gt;처음에 이 문제를 풀 때, 세그먼트 트리로 풀려고 했다. 그런데, 문제가 생겼다. 그렇게 구현하려면, 100000개 를 50000개의 블루레이에 담으려고 한다면 계속해서 재귀 함수를 타고 들어가며 구해야 한다. 시간 제한이 2초이고, 또한 재귀함수의 depth가 너무 깊어져 이 방향으로 문제를 해결하면 안된다고 판단했다.&lt;/p&gt;

&lt;p&gt;고민을 하던 중, 답을 먼저 제안하고, 이 답을 기반으로 역으로 추적하면 어떨까하는 생각이 들었다. 이 방법을 파라메트릭 서치(parametric Search)라 한다.&lt;/p&gt;

&lt;h2 id=&quot;parametric-search&quot;&gt;Parametric Search&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;최적화 문제를 결정 문제로 바꾸어 해결한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이진 탐색과 비슷한 방법이다. 그런데 어떤 상황에서 사용하는지 알아야 한다. 위의 문제는 결국, N개의 입력이 들어왔을 때, 이걸 M개로 나누고, M개로 나눈 각각의 뭉텅이들 사이에서 최댓값들을 뽑아 그것의 최솟값을 구하는 문제이다. (&lt;del&gt;응?&lt;/del&gt;)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;입력 N을 M개의 집합으로 자른다. 다양한 가지수로 자를 수 있다. 이 가지수를 K라 하자.&lt;/li&gt;
  &lt;li&gt;그 집합들의 합을 갖고 있는다.&lt;/li&gt;
  &lt;li&gt;그 요소들을 가지는 집합 L를 만든다. (K의 요소 개수는 M개, 발생하는 집합 L의 개수는 K개)&lt;/li&gt;
  &lt;li&gt;발생한 모든 L 집합에 대해 요소들의 최댓값을 구한다. 그 최댓값을 모은 집합을 P라 하자. (P의 요소 개수는 K개)&lt;/li&gt;
  &lt;li&gt;P집합의 요소들 중 최소값을 구한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;완전 탐색을 한다면 위와 같이 할 수 있을 것이다. 그런데, 결국 이 문제는 최적의 디스크 크기를 구하는 문제이다. 이런 문제에서 새로운 발상을 할 수 있는데, &lt;strong&gt;답은 제안하는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;방법&quot;&gt;방법&lt;/h3&gt;

&lt;p&gt;이 문제에서 내가 원하는 것은 disk 크기를 구하는 것이다. 이 disk 크기가 될 수 있는 최솟값과 최댓값을 계산해보자. N = 100000 이고, 각각의 동영상 용량은 10000이 최대이므로, 이 동영상 모두를 한 disk에 넣는다면 1000000000크기가 최대이다. 일단 이해를 하는 과정이기에 최댓값을 100이라 가정하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78757524-97bddd00-79b7-11ea-80a7-55be7dfe0702.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;과정은 이분 탐색과 비슷하다. 답이 될 수 있는 최소, 최대에서 반이 답이 되는지 되지 않는지 판단한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78757533-9db3be00-79b7-11ea-94cb-f5f388927caa.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;너무 디스크 크기가 작다면 오른쪽을 탐색한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78757558-a4dacc00-79b7-11ea-906e-afbf9571fe5d.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;너무 디스크 크기가 크다면 왼쪽을 탐색한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78757569-aad0ad00-79b7-11ea-8fc0-84a902def739.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 과정을 반복하여 답을 도출한다.&lt;/p&gt;

&lt;p&gt;결국 위 방법의 핵심은, &lt;strong&gt;원하는 답의 범위를 설정하고 이 값이 되는지 안되는지를 파악한다.&lt;/strong&gt; 이다. 이러한 방법을 사용하기로 마음 먹었다면, 어떠한 조건에서 탐색의 방향을 바꿀 수 있는지, 해당 문제의 특징은 무엇인지 확인해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;문제의-특징&quot;&gt;문제의 특징&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;M개의 disk를 사용했을 때, disk 크기가 가장 줄어들 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;만약 10개의 disk를 사용할 수 있다고 하자. 그렇다면 답은 N을 10개로 나누었을 때 가장 작게 나눌 수 있다.&lt;/li&gt;
  &lt;li&gt;물론 10개보다 적은 수의 disk를 사용해서 나누었을 때 10개를 사용했을 때의 답과 같게 나올 수는 있다.&lt;/li&gt;
  &lt;li&gt;따라서 10개보다 적은 수의 disk를 사용할 경우에도 답을 업데이트 해주는 대상이 된다.&lt;/li&gt;
  &lt;li&gt;또한 &lt;strong&gt;M개의 disk를 사용할 수 있는 모든 경우의 수를 비교&lt;/strong&gt;해야 한다. &lt;del&gt;처음에 M개로만 나뉘면 답이라 해서 틀렸다. ㅠ&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;탐색-조건&quot;&gt;탐색 조건&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;제시한 블루레이 Size를 가지고 만들었을 때 나온 값이 M보다 크면 Size를 키운다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;제시한 Size를 가지고 N를 최대한 나눈 결과 가지고 있는 블루레이 갯수(M)보다 disk가 더 필요하다는 결론이 나오면, 현재 disk 사이즈가 너무 작아 더 필요로 한다는 결론이다. 따라서 disk 크기를 키워야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;제시한 블루레이 Size를 가지고 만들었을 때 나온 값이 M보다 작으면 지금 제시한 값을 업데이트 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;나온 값과 이전에 탐색한 답 중 최솟값으로 업데이트 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;제시하는 답은 video의 값보다는 항상 같거나 커야한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 2 3 4 5&lt;/code&gt; 라는 video가 들어온다고 가정하자. 이 때, 내가 제시하는 답은 5보다 항상 같거나 커야 한다. 만약 3이라는 답을 제시한다면 4와 5는 disk에 들어갈 수도 없으므로 논리에서 벗어난다.&lt;/p&gt;

&lt;h1 id=&quot;code&quot;&gt;Code&lt;/h1&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;algorithm&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isOk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isOk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 08 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>20: 디스크 스케쥴링 알고리즘</title>
        <link>/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-20-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-20-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
        <description>&lt;p&gt;하드 디스크의 구조를 바탕으로 스케쥴링을 하는 방법에 대해 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;1-디스크-스케줄링&quot;&gt;1. 디스크 스케줄링&lt;/h1&gt;

&lt;p&gt;보조기억장치는 현재 여러 가지 존재하지만 아직까지는 하드 디스크가 주로 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78574512-0d656400-7865-11ea-9b48-ccb8e23b1d65.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하드 디스크의 구조는 앞서 살펴봤듯이 위 그림과 같다. 디스크에 접근하는 시간은 &lt;strong&gt;Seek time(탐색 시간)&lt;/strong&gt; + rotational delay + transfer time 으로 계산할 수 있는데, 이 중에서 seek time(head를 움직이는 시간)이 가장 크다.&lt;/p&gt;

&lt;p&gt;현재 컴퓨터 환경은 대부분 다중 프로그래밍 환경이다. 그러므로 여러 프로세스가 메인 메모리에서 실행 중에 있는데, 이러한 여러 프로세스가 동시에 디스크를 읽으려는 요청이 올 수 있다. 이와 같은 요청이 오면 디스크 역시 CPU와 같이 &lt;strong&gt;디스크 큐(dist queue)&lt;/strong&gt;에서 요청을 저장해두고 이를 처리해야 한다.&lt;/p&gt;

&lt;p&gt;여기서 컴퓨터의 성능을 위해 여러 요청들을 효율적으로 처리해야 한다. 디스크를 읽는 시간은 매우 오래 걸리는 작업이고 특히 탐색 시간이 오래걸리므로 최대한 이 시간을 줄이는 것이 중요하다. 이러한 방법들을 &lt;strong&gt;디스크 스케줄링 알고리즘&lt;/strong&gt;이라 한다.&lt;/p&gt;

&lt;h2 id=&quot;11-fcfsfirst-come-first-served&quot;&gt;1.1 FCFS(First-Come First-Served)&lt;/h2&gt;

&lt;p&gt;이 방법은 어느 스케줄링 알고리즘에서도 존재하는 가장 간단하고 가장 공평한 방법이다. 바로 예제를 살펴보자.&lt;/p&gt;

&lt;h3 id=&quot;111-예제&quot;&gt;1.1.1 예제&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;200 cylinder dist: 0, 1, 2, ..., 199
Disk queue: 98, 183, 37, 122, 14, 124, 65, 67
현재 헤드가 가리키는 실린더(cylinder) 위치: 53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78577820-9c747b00-7869-11ea-9777-c784b57730e8.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예제를 그림으로 나타내면 위 그림과 같다. 가로축은 0번부터 199번까지 실린더의 위치를 나타낸다. 여기서 파란색 선이 dist queue를 FCFS 방법으로 처리한 결과이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;헤드가 움직인 총 거리
    &lt;ul&gt;
      &lt;li&gt;= (98 - 53) + (183 - 98) + (183 - 37) + (122 - 37) + (122 - 14) + (124 - 14) + (124 - 65) + (67 - 65) = &lt;strong&gt;640 cylinders&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 그림의 결과를 본 것처럼 큐에 들어온 순서가 큰 값, 작은 값이 반복한다면 헤드가 움직이는 거리가 매우 커짐을 알 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;12-sstfshortest-seek-time-first&quot;&gt;1.2 SSTF(Shortest-Seek-Time-First)&lt;/h2&gt;

&lt;p&gt;SSTF 스케줄링 알고리즘은 가장 짧은 탐색 시간을 먼저 선택하는 것이다. 다시 말하면 현재 헤드가 다음 요청을 처리하기 위해 움직여야 하는 거리가 가장 짧은 것을 선택하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;121-예제&quot;&gt;1.2.1 예제&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;200 cylinder dist: 0, 1, 2, ..., 199
Disk queue: 98, 183, 37, 122, 14, 124, 65, 67
현재 헤드가 가리키는 실린더(cylinder) 위치: 53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제는 FCFS 스케줄링에서 본 예제와 같은 것이다. 처음 헤드 위치 53을 시작으로 dist queue에 있는 실린더 번호 중 53과 가장 가까운 65번 실린더를 선택한다. 65번에서는 가장 가까운 67번을 선택하고 같은 과정을 반복한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;헤드가 움직인 총 거리
    &lt;ul&gt;
      &lt;li&gt;= (65 - 53) + (67 - 65) + (67 - 37) + (37 - 14) + (98 - 14) + (122 - 98) + (124 - 122) + (183 - 124) = &lt;strong&gt;236 cylinders&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SSTF 스케줄링 알고리즘의 결과는 위 예제에서 FCFS 스케줄링보다 훨씬 적은 수의 실린더를 움직이는 것을 볼 수 있다. 하지만 SSTF 스케줄링의 큰 단점은 &lt;strong&gt;기아(starvation)가 발생&lt;/strong&gt;할 수 있다. dist queue에는 지속적으로 새로운 프로세스의 요청이 들어오기 때문에 헤드와 멀리 떨어져 있는 실린더는 끝내 수행하지 못하는 현상이 발생하는데, 이를 starvation이라고 한다.&lt;/p&gt;

&lt;p&gt;그리고 SSTF 스케줄링이 현재와 가장 가까운 실린더를 선택한다고 해서 &lt;strong&gt;최적의 알고리즘은 아니다.&lt;/strong&gt; 위 예제에서도 가장 처음 위치인 53번 실린더에서 65번이 아닌 37번으로 이동한 후에 SSTF 알고리즘을 수행하면 208 cylinders 가 나온다.&lt;del&gt;그리디가 아니다&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;13-scan&quot;&gt;1.3 Scan&lt;/h2&gt;

&lt;p&gt;Scan 스케줄링은 말그대로 헤드가 지속적으로 디스크를 앞뒤로 검사하는 것이다. 그래서 헤드가 앞으로 스캔할 때(번호가 작은 실린더 방향)와 뒤로 스캔할 때(번호가 큰 실린더 방향) 선택하는 실린더가 서로 다르다. &lt;strong&gt;즉 관성을 고려하여 한방향으로 쭉 가다가 끝이면 반대 방향으로 돈다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;131-예제&quot;&gt;1.3.1 예제&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;200 cylinder dist: 0, 1, 2, ..., 199
Disk queue: 98, 183, 37, 122, 14, 124, 65, 67
현재 헤드가 가리키는 실린더(cylinder) 위치: 53
스캔 방향: 0번 방향으로 움직임(번호가 작은 실린더 방향)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 결과에서 볼 수 있듯이 스캔 방향이 0번 실린더 방향이므로 53번에서 작은 번호의 실린더로 향한 후에 큰 번호 실린더로 움직인 것을 볼 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;헤드가 움직인 총 거리
    &lt;ul&gt;
      &lt;li&gt;= (53 - 37) + (37 - 14) + (14 - 0) + (65 - 0) + (67 - 65) + (98 - 67) + (122 - 98) + (124 - 122) + (183 - 124) = &lt;strong&gt;236 cylinders&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 한 가지 생각해 볼 점은 일반적으로 프로세스들이 디스크에 요청할 때 그 위치를 종합해보면 실린더에 &lt;strong&gt;골고루 퍼져있다&lt;/strong&gt;. 그러므로 Scan 스케줄링 알고리즘처럼 앞뒤로 움직이는 것이아니라 처음부터 한 방향으로 끝까지 움직이고 다시 처음으로 되돌아가서 같은 방향으로 끝까지 움직이는 것이 더욱 효과적이다.&lt;/p&gt;

&lt;p&gt;이러한 아이디어에서 나온 것이 &lt;strong&gt;Circular Scan&lt;/strong&gt; 스케줄링 알고리즘이다.&lt;/p&gt;

&lt;h2 id=&quot;14-c-scan&quot;&gt;1.4 C-Scan&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78578737-e14ce180-786a-11ea-8b53-3e8438b21bf6.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 방식은 위에서 말한 Circular Scan 스케줄링 알고리즘이다. 즉 한 방향으로 계속 움직이는 것이다. Scan 방식은 끝에 다다랐을 때 반대방향으로 가는데, 굳이 그럴 필요가 없다. 물론 오른쪽에서 왼쪽 끝으로 갈 때 한바퀴를 돌기 때문에 움직이는 거리는 더 길어질 수 있지만 다시 처음 위치로 되돌아갈 때는 &lt;strong&gt;데이터를 읽지 않으므로 더 빠른 속도&lt;/strong&gt;로 움직일 수 있다. (그냥 모터로 슝 긁으면 된다.)&lt;/p&gt;

&lt;h2 id=&quot;15-look&quot;&gt;1.5 Look&lt;/h2&gt;

&lt;p&gt;이 알고리즘은 위 Scan 스케줄링 예제에서 0번 실린더가 존재하지 않지만 0번까지 가는 모습을 보았다. (찍턴하기 위해서) 이러한 비효율적인 움직임을 없애기 위해 존재하는 실린더의 최소와 최대 범위만 움직이는 알고리즘을 Look 스케줄링 알고리즘이라고 한다. 하지만 이 범위를 알기 위해서 미리 큐를 검사해야한다. (어디가 가장 근접한 끝인지 알아야 하기 때문)&lt;/p&gt;

&lt;h2 id=&quot;16-c-look&quot;&gt;1.6 C-Look&lt;/h2&gt;

&lt;p&gt;C-Look은 Circular Look 을 말한다. Look은 위에서 Scan 스케줄링이 0번 부터 끝 실린더까지 움직이지 않고 존재하는 실린더의 최소에서 최대 범위를 움직인다고 하였는데, C-Look은 이 범위에서 C-Scan과 같이 한 방향으로만 움직이는 것을 말한다. 즉, 최대 실린더에서 최소 실린더 방향으로 움직인다고 할 때 최소 범위에 도달하면 다시 최대 범위로 되돌아가서 같은 방향으로 움직인다.&lt;/p&gt;

&lt;h2 id=&quot;17-elevator-algorithm&quot;&gt;1.7 Elevator Algorithm&lt;/h2&gt;

&lt;p&gt;Elevator Algorithm은 Scan과 파생되어 나온 알고리즘(C-scan, Look, C-Look)을 부르는 다른 용어이다. 위 Scan 스케줄링 알고리즘 예제 그림을 90도로 회전하면 엘리베이터의 모습과 유사하여 붙여진 이름이다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>19: 파일 할당 (Allocation of file)</title>
        <link>/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-19-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-19-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9.html</guid>
        <description>&lt;p&gt;보조 기억 장치에 저장되는 파일의 할당에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;컴퓨터 시스템 자원 중 가장 중요한 것은 CPU이다. CPU 자원 관리에 대해서는 맨 처음 부분에서 다루었으며 CPU 스케줄링, 프로세스 동기화 등에 대해서 배웠다. CPU 다음으로 중요한 자원은 메인 메모리와 같은 주기억장치이다. 메인 메모리 관리에 대한 주요 이슈는 페이징, 가상 메모리(요구 페이징) 등이 있었다.&lt;/p&gt;

&lt;p&gt;CPU, 주기억장치 다음 중요한 컴퓨터 시스템 자원은 하드디스크와 같은 보조기억장치이다. 하드디스크가 데이터를 관리하는 방식은 &lt;strong&gt;파일 시스템&lt;/strong&gt;이다. 파일은 컴퓨터에서 운영체제를 사용해본 사용자라면 매우 익숙한 단어일 것이다. 대표적인 windows 운영체제를 보면 폴더(디렉토리) 내부에 또 다른 폴더 또는 어떠한 파일이 존재한다. 이러한 폴더 및 파일은 트리 구조로 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;이번 장에서는 보조기억장치 중 컴퓨터에서 주로 사용하는 하드디스크의 파일이 할당되는 방법에 대해서 살펴볼 것이다.&lt;/p&gt;

&lt;h1 id=&quot;1-hdd-구조&quot;&gt;1. HDD 구조&lt;/h1&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78574512-0d656400-7865-11ea-9b48-ccb8e23b1d65.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 하드디스크의 구조이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;platter
    &lt;ul&gt;
      &lt;li&gt;실제 데이터를 기록하는 자성을 가진 원판이다. platter는 그림과 같이 여러 개가 존재하고 앞뒤로 사용할 수 있다. 한 platter는 여러 개의 track으로 이루어져 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;track
    &lt;ul&gt;
      &lt;li&gt;platter의 동심원을 이루는 하나의 영역이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;sector
    &lt;ul&gt;
      &lt;li&gt;하나의 track을 여러 개로 나눈 영역을 sector라 한다. sector size는 일반적으로 512 bytes이며 주로 여러 개를 묶어서 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cylinder
    &lt;ul&gt;
      &lt;li&gt;한 cylinder는 모든 platter에서 같은 track 위치의 집합을 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;앞서 sector는 여러 개로 묶어서 사용한다고 했는데, 이를 &lt;strong&gt;블록(block)&lt;/strong&gt;이라 한다. 하드디스크는 블록 단위로 읽고 쓰기 때문에 &lt;strong&gt;block device&lt;/strong&gt; 라고 불리기도 한다.&lt;/p&gt;

&lt;p&gt;하드디스크가 블록 단위로 읽고 쓰는 것을 확인할 수 있는 간단한 방법은 메모장 프로그램에서 알파벳 a만을 적고 저장해보자. a는 character로 1byte 크기를 갖는데, 실제 저장된 텍스트 파일의 속성을 확인하면 디스크에 &lt;strong&gt;4KB(하나의 block size)&lt;/strong&gt; 가 할당되는 것을 확인할 수 있다.(실제 디스크 할당 크기는 운영체제마다 다르다.)&lt;/p&gt;

&lt;p&gt;따라서 디스크는 비어있는 블록들의 집합이라고 볼 수 있다.(pool of free blocks) 그렇다면 운영체제는 각각의 파일에 대해 &lt;strong&gt;free block&lt;/strong&gt;을 어떻게 할당할까?&lt;/p&gt;

&lt;h1 id=&quot;2-파일-할당&quot;&gt;2. 파일 할당&lt;/h1&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78574790-79e06300-7865-11ea-8871-317826c3f865.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 pool of free blocks를 논리적인 그림으로 나타낸 모습이고 블록마다 인덱스 번호를 설정하였다. 블록들이 위와 같이 있을 때 파일을 할당하는 방법은 크게 연속 할당, 연결 할당, 색인 할당 세 가지가 존재한다.&lt;/p&gt;

&lt;h2 id=&quot;21-연속-할당-contiguous-allocation&quot;&gt;2.1 연속 할당 (Contiguous Allocation)&lt;/h2&gt;

&lt;p&gt;연속 할당은 말그대로 &lt;strong&gt;연속된 블록에 파일을 할당&lt;/strong&gt; 하는 것이다. 예를 들어, 블록 크기가 1KB이고, 할당할 파일은 f1, f2, f3 3개가 있고 각각의 크기는 5KB, 3KB, 4KB이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78574911-a3998a00-7865-11ea-82bb-0354d4700b7d.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞선 예제로 연속 할당을 수행하면 위의 그림과 같은 모습이 나온다.&lt;/p&gt;

&lt;h3 id=&quot;211-연속할당의-장점&quot;&gt;2.1.1 연속할당의 장점&lt;/h3&gt;

&lt;p&gt;연속 할당에는 세 가지 특징이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연속 할당의 장점은 디스크 헤더의 이동을 최소화 할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;I/O 성능을 높일 수 있다. 이 방식은 예전의 IBM에서 사용하던 방법이며 주로 동영상, 음악, VOD 등에 적합하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;순차 접근(Sequential Access)이 가능하다.
    &lt;ul&gt;
      &lt;li&gt;이는 말그대로 순서대로 파일을 읽을 수 있다는 의미이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;직접 접근(Direct Access)이 가능하다.
    &lt;ul&gt;
      &lt;li&gt;운영체제는 파일의 정보를 디렉토리(directory) 라는 테이블에 저장한다. 디렉토리에서 사용자가 접근가능한 정보는 파일의 이름, 크기, 날짜 등이 있고, 운영체제 내부에서 접근하는 정보는 해당 파일의 시작 블록 번호와 같은 것이 있다. 예를 들어, 위 예제의 f1 파일의 디렉토리 정보는 아래와 같다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file name: f1
file size: 5 bytes
...
-----------------
block number: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;연속 할당은 순차적으로 저장되어 있으므로 운영체제는 디렉토리에서 얻은 시작 블록 번호로 원하는 블록에 바로 접근할 수 있다. 예를 들어, 위 예제에서 f1 파일의 3번째 블록에 접근하고 싶다고 가정하자. 운영체제는 f1의 시작 블록 번호가 0번인 것을 알고 있기 때문에 2번 블록에 접근하면 f1의 3번째 블록이라는 것을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;212-연속할당의-단점&quot;&gt;2.1.2 연속할당의 단점&lt;/h3&gt;

&lt;p&gt;연속 할당은 현재에는 거의 사용하지 않는 방식인데, 이 방법에는 큰 단점이 존재하기 때문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부 단편화 문제가 발생한다.
    &lt;ul&gt;
      &lt;li&gt;파일을 할당하고 지우고를 반복하다보면 중간 중간에 빈 공간(hole)이 생기는데 연속 할당은 연속된 공간을 찾아야 하기 때문에 이전 메인 메모리 할당에서 살펴본 것과 같이 외부 단편화 문제가 발생한다.&lt;/li&gt;
      &lt;li&gt;외부 단편화로 인해 디스크 공간의 낭비가 매우 심해진다. 이전 메모리 할당에서 외부 단편화로 인해 메모리의 약 1/3을 낭비한다고 하였는데, 디스크의 연속 할당도 같은 낭비가 발생한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일을 저장할 때 실제 크기를 알 수 없다.
    &lt;ul&gt;
      &lt;li&gt;특히, 계속해서 사용하는 파일의 경우 &lt;strong&gt;크기가 계속 증가&lt;/strong&gt; 할 수 있기 때문에 이를 지속해서 연속적으로 할당하기에는 매우 부적절하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;22-연결-할당-linked-allocation&quot;&gt;2.2 연결 할당 (Linked Allocation)&lt;/h2&gt;

&lt;p&gt;연결 할당은 연속 할당의 문제점을 해결하기 위해 나온 방법으로, 연속적으로 할당하는 것이 아니라 링크드 리스트(linked list) 와 같은 방식으로 파일을 할당한다&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78574943-abf1c500-7865-11ea-925b-b56f70ec6dd5.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 block 크기가 1 byte, 파일 f1의 크기가 5 bytes 일 때 연결 할당을 수행한 모습이다. 각 블록의 마지막에 &lt;strong&gt;주소를 저장하는 포인터 공간(4bytes)&lt;/strong&gt;이 존재하며, 여기서 다음 블록을 가리키고 있다. 마지막 블록의 포인터 공간에는 끝임을 나타내는 값이 저장되어 있다.&lt;/p&gt;

&lt;p&gt;이러한 파일을 &lt;strong&gt;linked list of data blocks&lt;/strong&gt; 라고 하며, f1의 파일 디렉토리 정보는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file name: f1
file size: 5 bytes
...
-----------------
block number: 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;221-연결할당의-장점&quot;&gt;2.2.1 연결할당의 장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;위치와 상관없이 할당이 가능하므로 외부 단편화 문제가 없다. (= 디스크 낭비가 없다.)
    &lt;ul&gt;
      &lt;li&gt;연결 할당을 사용해서 새로운 파일을 할당할 때는 비어있는 임의의 블록을 첫 블록으로 선택하며, 만약 파일이 커지는 경우 다른 블록을 할당해서 기존의 블록과 연결만 해주면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;222-연결할당의-단점&quot;&gt;2.2.2 연결할당의 단점&lt;/h3&gt;

&lt;p&gt;하지만, 연결 할당 역시 여러 문제점을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;순차 접근은 가능하지만 직접 접근은 불가능하다.
    &lt;ul&gt;
      &lt;li&gt;파일의 블록들은 모두 흩어져 있으므로 시작 블록 번호를 가지고는 원하는 위치의 블록에 바로 접근할 수는 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;포인터를 저장하는 4 bytes 이상의 손해가 발생한다.&lt;/li&gt;
  &lt;li&gt;낮은 신뢰성
    &lt;ul&gt;
      &lt;li&gt;중간 블록의 포인터가 끊어지면 그 이후의 모든 블록에 접근하지 못한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;느린 속도
    &lt;ul&gt;
      &lt;li&gt;블록이 모두 흩어져 있으므로 디스크 헤더의 움직임이 그 만큼 많이 발생한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;223-fatfile-allocation-table-시스템&quot;&gt;2.2.3 FAT(File Allocation Table) 시스템&lt;/h3&gt;

&lt;p&gt;위 문제점을 개선하기 위해 나온 것이 같은 연결 할당 방식인 FAT(File Allocation Table) 시스템이다. FAT 시스템은 다음 블록으르 가리키는 포인터들만 모아서 하나의 테이블(FAT)을 만들어 한 블록에 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78574974-b3b16980-7865-11ea-8889-b32c54adfd52.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 앞선 예제의 f1 파일을 FAT 파일 시스템 방식으로 저장한 모습이다. 0번 블록에 저장된 FAT를 보면 테이블의 인덱스는 전체 디스크의 블록 번호이며, 각 &lt;strong&gt;인덱스마다 다음 블록 번호를 저장&lt;/strong&gt;하고 있다.&lt;/p&gt;

&lt;p&gt;FAT 시스템을 사용하면 기존의 연결 할당의 문제점 대부분을 해결할 수 있다. FAT를 한 번만 읽으면 &lt;strong&gt;직접 접근이 가능&lt;/strong&gt;하고, FAT만 문제가 없다면 중간 블록에 문제가 생겨도 FAT를 통해 그 다음 블록은 여전히 읽을 수 있다. 그리고 FAT는 일반적으로 메모리 캐싱을 사용하여 블록 위치를 찾는데는 빠르지만 실제 디스크 헤더가 움직는 것은 블록이 흩어져 있으므로 여전히 느리다고 볼 수 있다. 마지막으로 FAT는 매우 중요한 정보이므로 &lt;strong&gt;손실 시 복구를 위해 이중 저장&lt;/strong&gt;을 한다.&lt;/p&gt;

&lt;p&gt;FAT의 각 인덱스 크기는 전체 블록의 개수를 저장할 만큼의 크기를 가지고 있어야 하는데, 현재는 일반적으로 32bit 크기를 사용($2^{32}$)한다. 이를 FAT32라고 부른다.(이전에는 FAT16, FAT12 등이 있었다.)&lt;/p&gt;

&lt;h2 id=&quot;23-색인-할당-indexed-allocation&quot;&gt;2.3 색인 할당 (Indexed Allocation)&lt;/h2&gt;

&lt;p&gt;색인 할당 역시 연결 할당과 같이 데이터를 랜덤한 블록 번호에 할당하지만 할당된 블록 번호(포인터)를 하나의 블록에 따로 저장한다. 이러한 블록을 &lt;strong&gt;인덱스 블록&lt;/strong&gt;이라고 부르며, 파일 당 하나의 인덱스 블록이 존재한다. 색인 할당은 디렉토리 정보가 다른 할당과 다른데, 시작 블록 번호를 저장하는 것이 아니라 &lt;strong&gt;인덱스 블록 번호를 저장&lt;/strong&gt;한다.&lt;/p&gt;

&lt;h3 id=&quot;231-예제&quot;&gt;2.3.1 예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;block size&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;f1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;f2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2byte&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78575000-bc09a480-7865-11ea-9c93-3287ea0e764f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file name: f1
file size: 5 bytes
...
-----------------
index block number: 11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file name: f2
file size: 2 bytes
...
-----------------
index block number: 27
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그림을 보면, 블록 하나를 지정하여, 파일의 인덱스를 저장하는 인덱스 블록으로 사용한다.&lt;/p&gt;

&lt;p&gt;색인 할당은 인덱스 블록에 할당된 블록을 순서대로 저장하기 때문에 직접 접근이 가능하다. 그리고 연속적으로 할당할 필요가 없으므로 외부 단편화 문제 또한 발생하지 않는다. 색인 할당은 Unix/Linux에서 주로 사용한다.&lt;/p&gt;

&lt;p&gt;색인 할당의 단점은 작은 크기의 파일인 경우에도 하나의 블록을 인덱스 블록으로 사용하기 때문에 저장 공간이 손실된다. 그리고 &lt;strong&gt;하나의 인덱스 블록을 가지고는 크기가 큰 파일을 저장할 수 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 하나의 블록 크기가 512 bytes인 블록은 최대 저장할 수 있는 블록의 인덱스 개수가 512 / 4 bytes(포인터 크기) = 128개이다. 즉 파일의 최대 크기는,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;128(인덱스 블록에서 저장할 수 있는 블록의 포인터 개수의 최대값) x 512bytes(블록 하나의 크기) = 64KB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로 아주 작은 크기이다. 블록 크기가 1KB이라 하더라도 최대 인덱스 개수는 256개(1000/4)이고 최대 파일의 크기는 256KB이다.&lt;/p&gt;

&lt;h3 id=&quot;232-해결-방법&quot;&gt;2.3.2 해결 방법&lt;/h3&gt;

&lt;p&gt;이를 해결하기 위한 여러 가지 방법이 있다.&lt;/p&gt;

&lt;h4 id=&quot;2321-linked&quot;&gt;2.3.2.1 Linked&lt;/h4&gt;

&lt;p&gt;이 방식은 인덱스 블록을 여러 개 만들어 연결 할당을 하는 것과 같다. 즉, 각 인덱스 블록의 마지막은 다음 인덱스 블록을 가리키는 포인터가 저장되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78577110-8dd99400-7868-11ea-8731-7e6acf48c817.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2322-multilevel-index&quot;&gt;2.3.2.2 Multilevel index&lt;/h4&gt;

&lt;p&gt;이 방식은 계층을 두는 방법으로 하나의 인덱스 블록의 모든 포인터가 다른 인덱스 블록을 가리킨다. 만약 이것으로 부족하면 계층을 더 만들어 간다.
&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78577132-97fb9280-7868-11ea-968e-43c95f7d7ccb.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2323-combined&quot;&gt;2.3.2.3 Combined&lt;/h4&gt;

&lt;p&gt;이 방식은 Linked와 Multilevel index를 합친 방법으로 한 인덱스 블록의 포인터들은 데이터 블록과 또 다른 인덱스 블록 둘 다 가리킬 수 있다.(리눅스는 combined 방식을 사용한다.)&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>18: 프레임 할당 (Allocation of frame)</title>
        <link>/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-18-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-18-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9.html</guid>
        <description>&lt;p&gt;page를 메모리에 할당하는 프레임 할당에 대해 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;1-global-vs-local-replacement&quot;&gt;1. Global VS Local Replacement&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Global Replacement
    &lt;ul&gt;
      &lt;li&gt;메모리 상의 모든 프로세스 페이지에 대한 교체 작업을 수행한다.&lt;/li&gt;
      &lt;li&gt;앞에서 배운 FIFO, OPT, LRU 등은 Victim을 정할 때, 모든 메모리에 올려져 있는 frame을 다 확인 후에 교체를 수행했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Local Replacement
    &lt;ul&gt;
      &lt;li&gt;메모리 상의 자기 자신의 프로세스 페이지에 대해서만 교체 작업을 수행한다.&lt;/li&gt;
      &lt;li&gt;지금 요청이 들어온 page가 p1이라면, 메모리상에 올라가 있는 frame 중 p1 frame만 교체의 대상으로 간주한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메모리 사용 효율은 일반적으로 Global Replacement가 좋다.&lt;/p&gt;

&lt;h1 id=&quot;2-프레임-할당allocation-of-frames&quot;&gt;2. 프레임 할당(Allocation of Frames)&lt;/h1&gt;

&lt;p&gt;어떻게 할당하는 것이 좋은지에 대한 고민을 해본다.&lt;/p&gt;

&lt;h2 id=&quot;21-쓰레싱thrashing&quot;&gt;2.1. 쓰레싱(Thrashing)&lt;/h2&gt;

&lt;p&gt;일반적으로 메모리에 올라가는 프로세스 개수가 증가할수록 CPU의 이용률은 올라갈 것이라 예상한다. 왜냐하면 프로세스가 많을 수록 CPU의 할 일 역시 증가하기때문이다. 이는 일정 범위까지는 맞는 예상이지만, 그 범위를 넘어서면 오히려 CPU 이용률이 감소하는 현상이 나타난다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78570069-6cc07580-785f-11ea-9baf-9b31b77dc452.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 이러한 현상을 그래프로 나타낸 것이다. 이와 같은 현상이 발생하는 이유는 프로세스가 증가할수록 메인 메모리의 비어있는 프레임 개수는 줄어들게 되고 결국 모든 프레임이 가득 차게 된다. 그 후에도 계속 프로세스가 증가한다면 &lt;strong&gt;메모리와 backing store 사이에 page in/out 작업이 발생&lt;/strong&gt;하는데, 프로세스가 많아질수록 이 작업 역시 증가한다. p&lt;strong&gt;age in/out은 디스크 I/O 작업&lt;/strong&gt;으로 CPU를 사용하지 않는 작업이다. 그러므로 이 작업이 많아질수록 CPU는 그동안 아무것도 하지 않게 된다.&lt;/p&gt;

&lt;p&gt;위 그래프에서도 나와있듯이, I/O 작업이 증가하여 CPU 이용률이 떨어지는 현상을 Thrashing 이라 한다.&lt;/p&gt;

&lt;h3 id=&quot;211-해결-방법&quot;&gt;2.1.1 해결 방법&lt;/h3&gt;

&lt;p&gt;쓰레싱을 해결하는 방법은 크게 두 가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Global Replacement보다 Local Replacement를 사용하는 것이다.
    &lt;ul&gt;
      &lt;li&gt;하지만 이 경우에는 메모리 사용 효율이 떨어지는 단점이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스당 &lt;strong&gt;충분한/적절한 수의 프레임(메모리)을 할당&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그렇다면, 적절한 프레임의 수는 어떻게 정하는 것일까?&lt;/p&gt;

&lt;h2 id=&quot;22-프레임-할당의-방법&quot;&gt;2.2 프레임 할당의 방법&lt;/h2&gt;

&lt;p&gt;프레임 할당은 크게 정적 할당과 동적 할당으로 나뉜다.&lt;/p&gt;

&lt;h3 id=&quot;221-정적-할당static-allocation&quot;&gt;2.2.1 정적 할당(Static Allocation)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;동일 할당(Equal Allocation)
    &lt;ul&gt;
      &lt;li&gt;모든 프로세스에게 똑같은 수의 프레임을 할당한다. 이 방식은 프로세스의 크기에 따라 매우 비효율적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비례 할당(Proportional Allocation)
    &lt;ul&gt;
      &lt;li&gt;프로세스의 크기에 따라 프레임을 할당한다. 이 방식 역시 단점이 있다. 프로세스 크기가 크더라도 모든 기능을 사용하지 않기 때문에 이 방식 또한 비효율적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 정적 할당은 한계가 뚜렷하다. 따라서 동적 할당의 방법을 사용하는 것이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;222-동적-할당dynamic-allocation&quot;&gt;2.2.2 동적 할당(Dynamic Allocation)&lt;/h3&gt;

&lt;h4 id=&quot;2221-working-set-model&quot;&gt;2.2.2.1 Working Set Model&lt;/h4&gt;

&lt;p&gt;프로세스가 실행 중일 때 어느 페이지를 사용하는지 실험한 결과에서 Locality 성질이 성립한다는 것을 발견할 수 있었다. 즉, 특정 시간 대에 참고하는 부분은 일부분이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78571424-2409bc00-7861-11ea-9385-e411e0c69f4f.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그래프는 프로세스가 실행 중에 어떤 프로세스를 사용하는지 표시한 것으로, 특정 시간에는 일정 범위의 페이지를 주로 참조하는 것을 알 수 있다. 이러한 성질은 캐시에서도 볼 수 있다. 이를 통해 &lt;strong&gt;특정 시간에 따라 사용하는 페이지의 개수만큼 프레임을 할당&lt;/strong&gt;해줄 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 어떻게 locality를 조사할 수 있을까? 여기서 치명적인 단점이 있다. 바로 프로세스를 미리 수행해봐야 할 수 있다는 것이다. 그리고 프로세스를 수행할 때마다 사용하는 기능이 달라질 수 있으므로, Locality를 이용하는 방법은 비현실적이다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 나온 것이 &lt;strong&gt;working set&lt;/strong&gt; 이다. working set은 위의 locality의 방식과 유사한데, 미래가 아닌 과거를 보는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78572017-e48f9f80-7861-11ea-8ef0-df1a62f20411.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 working set을 사용하는 모습이다. working set은 현재 시간에서 일정 시간($\Delta$) 이전동안 사용되었던 페이지의 집합이다. $\Delta$(델타)는 운영체제 내부에서 정하는 기준에 따라 다르며, 이를 working set window 라 한다. 마지막으로 working set의 개수만큼 프레임을 할당한다.&lt;/p&gt;

&lt;p&gt;만약 현재 시간이 t1이라면 working set = {1, 2, 5, 6, 7}이다. 이 때 working set의 개수는 총 5개이므로 프레임 역시 5개를 할당해주면 된다.&lt;/p&gt;

&lt;h4 id=&quot;2222-page-fault-frequencypff&quot;&gt;2.2.2.2 Page-Fault Frequency(PFF)&lt;/h4&gt;

&lt;p&gt;페이지 부재의 비율은 프로세스에 할당된 프레임의 수에 반비례한다. 즉, 할당된 프레임의 수가 적을수록 페이지 부재 비율은 늘어난다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78572483-7dbeb600-7862-11ea-9bbd-1b5afdcf91eb.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 이와 같은 현상을 그래프로 나타낸 것이다. 세로축은 페이지 부재 비율이고, 가로축은 할당된 프레임의 수이다. 여기서 운영체제 내부에서 해당 프로세스의 페이지 부재 횟수를 계속 검사한다. 그러면 위와 같은 그래프처럼 나오는데, 여기서 &lt;strong&gt;상한선(upper bound)과 하한선(lower bound)&lt;/strong&gt;를 설정한다.&lt;/p&gt;

&lt;p&gt;만약 상한선보다 많은 페이지 부재가 발생하면 프레임을 더 많이 할당해주고, 하한선보다 적게 페이지 부재가 발생하면 할당된 프레임 개수를 줄여준다.&lt;/p&gt;

&lt;h1 id=&quot;3-페이지-크기page-size&quot;&gt;3. 페이지 크기(Page Size)&lt;/h1&gt;

&lt;p&gt;현재 페이지의 일반적인 크기는 4KB ~ 4MB 이다. 이는 과거에서부터 점점 커져왔고, 현재에도 메모리 크기가 증가하면서 커지고 있다.&lt;/p&gt;

&lt;p&gt;페이지 크기에 따라 성능에는 어떤 영향을 미치는지 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;31-페이지-크기에-따른-성능&quot;&gt;3.1 페이지 크기에 따른 성능&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;내부단편화
    &lt;ul&gt;
      &lt;li&gt;내부단편화를 줄이려면 페이지 크기는 작은 것이 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Page-in, page-out 시간
    &lt;ul&gt;
      &lt;li&gt;페이지의 in/out 시간을 결정하는 가장 큰 요인은 하드디스크 기준으로 하드디스크의 헤더가 움직이는 시간이다.(seek time) 페이지 크기가 크면 클수록 한 번의 seek time마다 큰 페이지를 읽을 수 있으므로, 페이지 부재 빈도가 줄어든다.(데이터를 읽는 시간은 크기에 따라 차이가 매우 적다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페이지 테이블 크기
    &lt;ul&gt;
      &lt;li&gt;페이지 크기가 클수록 페이지 개수가 줄어들기 때문에 그만큼 페이지 테이블 크기도 줄일 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Memory resolution(해상도)
    &lt;ul&gt;
      &lt;li&gt;Memory resolution은 &lt;strong&gt;해당 메모리에 필요한 데이터가 있는 확률&lt;/strong&gt;이다. 이는 페이지 크기가 작을수록 resolution을 높일 수 있다. 만약 페이지 크기가 크면 다른 필요없는 부분이 있을 확률이 크기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Page fault 발생 확률
    &lt;ul&gt;
      &lt;li&gt;Page fault 발생 확률을 줄이려면 페이지 크기가 큰 것이 좋다. 이는 locality 성질과도 관련이 있는데, 대부분 프로세스는 필요한 부분이 일정 범위 이내인 경우가 많으므로 &lt;strong&gt;페이지 크기가 클수록 필요한 부분이 있을 확률이 크다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;big&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;small&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Page fault 발생 확률 ▼&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;내부 단편화 ▼&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;페이지 테이블 크기 ▼&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Page-in, page-out 시간 ▼&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Memory resolution(해상도) ▲&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;32-페이지-테이블&quot;&gt;3.2 페이지 테이블&lt;/h2&gt;

&lt;p&gt;반도체 기술의 발달로 TLB 역시 CPU의 내장 칩 형태로 만들어져있다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>17: 페이지 교체 알고리즘</title>
        <link>/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-17-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-17-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html</guid>
        <description>&lt;p&gt;페이지 교체 알고리즘에 대해 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;1-page-reference-string&quot;&gt;1. Page reference string&lt;/h1&gt;

&lt;p&gt;페이지 교체 알고리즘을 살펴보기 전에 &lt;strong&gt;Page reference string&lt;/strong&gt; 이라는 용어를 알아야 한다. CPU가 내는 주소는 이진수 단위이지만, 페이지 교체 알고리즘을 계산하기 위해서는 이진수 주소 단위가 아닌 페이지 단위로 계산해야한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;CPU 논리 주소&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;요청할 페이지 번호&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;101&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;432&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;612&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;103&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;104&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;611&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;612&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;예를 들어, CPU가 내는 주소를 위와 같이 표현해보자. 편의를 위해 주소는 십진수로 표현했다. 만약 페이지 크기를 100이라 하면, 우측과 같이 된다. 주소 100번지는 1번 페이지에서 offset이 0인 위치이고, 101은 1번 페이지의 offset 1인 위치라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;마지막으로 페이지 번호로 나타낸 것을 page reference string으로 나타내면 {1, 4, 6, 1, 6}이다. 이는 간단히 말하면 &lt;strong&gt;연속된 페이지는 생략하고 하나의 페이지 번호만 나타낸 것&lt;/strong&gt;으로 볼 수 있다. 이 이유는 연속된 페이지를 참조할 때는 한 번 page fault가 발생하면 같은 페이지를 사용하는 동안에는 절대 page fault가 발생할 수 없기 때문이다. 즉, CPU가 가리키는 page의 번호가 연속적으로 동일하다면, disk로 가서 page를 가져올 필요가 없으므로, 위의 번호들만 가지고 판단하는 것이 바람직하다.&lt;/p&gt;

&lt;h1 id=&quot;2-first-in-first-outfifo&quot;&gt;2. First-In First-Out(FIFO)&lt;/h1&gt;

&lt;p&gt;FIFO은 가장 간단한 알고리즘이다. 가장 먼저 page-in 한 페이지를 먼저 page-out 시킨다. 이를 사용한 이유는 초기화 코드가 더 이상 사용되지 않을 것이라는 아이디어에서 시작되었다.&lt;/p&gt;

&lt;h2 id=&quot;21-예제&quot;&gt;2.1 예제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 참조열(page reference string)
    &lt;ul&gt;
      &lt;li&gt;{7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용가능한 프레임 개수(number of frame): 3&lt;/li&gt;
  &lt;li&gt;최초의 메모리는 비어있는 상태이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;7&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;8&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;9&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;11&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;12&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;13&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;14&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;15&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;16&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;17&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;18&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;19&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78565911-7d6ded00-7859-11ea-9118-aa6c7231d533.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;order&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page-in&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;frame states&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Page fault count&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page-out&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;first page&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 0}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 3, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;0&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;0&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 3, 0}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{4, 3, 0}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{4, 2, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{4, 2, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{0, 2, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{0, 2, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{0, 2, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{0, 1, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{0, 1, 2}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{0, 1, 2}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;17&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 1, 2}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;18&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 0, 2}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;19&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;결과는 최종 page fault 수는 15이다. 예제를 수행하면서, &lt;strong&gt;이전에 page-out한 페이지를 그 다음 바로 page-in을 하려한다면 다시 page fault가 발생&lt;/strong&gt;하기 때문에 비효율적인 모습을 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;22-beladys-anomaly&quot;&gt;2.2 Belady’s Anomaly&lt;/h2&gt;

&lt;p&gt;프레임 수가 증가하면(= 메모리 용량이 증가하면) page fault 수가 줄어드는 것이 정상적이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78566093-b73ef380-7859-11ea-8256-1b3cf6722f03.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 위의 FIFO를 사용했을 때, 그래프를 그려보면 다음과 같은 결과가 나온다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78566141-c160f200-7859-11ea-9513-bfddb0216a14.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이와 같이 특정한 페이지 참조열에 대해서는 프레임 수가 증가해도 page fault 수가 오히려 증가하는 이상 현상이 발생한다. 이를 Belady’s Anomaly라 한다.&lt;/p&gt;

&lt;h1 id=&quot;3-optimalopt&quot;&gt;3. Optimal(OPT)&lt;/h1&gt;

&lt;p&gt;OPT는 말그대로 가장 효율적인 페이지 교체 알고리즘이다. 이 알고리즘은 &lt;strong&gt;가장 오랫동안 사용되지 않을 페이지&lt;/strong&gt;를 희생양 페이지로 선택한다.&lt;/p&gt;

&lt;h2 id=&quot;31-예제&quot;&gt;3.1 예제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 참조열(page reference string)
    &lt;ul&gt;
      &lt;li&gt;{7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용가능한 프레임 개수(number of frame): 3&lt;/li&gt;
  &lt;li&gt;최초의 메모리는 비어있는 상태이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 가장 오랫동안 사용되지 않을 페이지를 계산하기 위해 &lt;strong&gt;현재 시점 에서 그 이후에 최초로 나타나는 시점의 거리&lt;/strong&gt; 를 dist로 둔다. 이 값이 가장 큰 페이지가 가장 오랫동안 사용되지 않은 페이지로 정한다.(해당 페이지가 이후에 나오지 않는 경우는 INF로 가장 큰 값으로 한다.)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;6&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;7&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;8&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;9&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;11&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;12&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;13&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;14&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;15&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;16&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;17&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;18&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;19&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78566299-fa996200-7859-11ea-80c4-57a831a371a8.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;order&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page-in&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;frame states&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Page fault count&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;page-out&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;dist&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{15}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 0}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{14, 3}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{13, 2, 11}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{5, 1, 10}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{4, 2, 9}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{3, 1, 4}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 4, 3}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 4, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{1, INF, 2}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 4, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{4, INF, 1}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 4, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{3, INF, 2}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 5, 1}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{1, 4, INF}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 3}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 3, INF}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{1, 2, 5}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{INF, 1, 4}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{2, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{INF, 2, 3}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;17&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{INF, 1, 2}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;18&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{INF, INF, 1}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;19&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{7, 0, 1}&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;{INF, INF, INF}&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;OPT의 결과는 총 &lt;strong&gt;9번&lt;/strong&gt;의 page fault가 발생했다. 이는 FIFO의 15번보다 크게 줄어든 모습을 볼 수 있다. 하지만 OPT의 방법은 &lt;strong&gt;현실적으로 불가능&lt;/strong&gt;하다. 실제 컴퓨터에서는 미래에 어떤 프로세스가 사용되는지 알 수 없다. 그러므로 어느 프로세스가 가장 오래 사용안되는 지를 계산할 수 없다.&lt;/p&gt;

&lt;h1 id=&quot;4-least-recently-usedlru&quot;&gt;4. Least-Recently-Used(LRU)&lt;/h1&gt;

&lt;p&gt;OPT는 최적해를 구할 수 있지만 미래를 알 수 없으므로 현실적으로 불가능한 방법이었는데, 최적의 해는 아니더라도 근사의 해를 구하기 위해서 LRU가 나왔다. LRU는 &lt;strong&gt;최근에 사용되지 않으면 나중에도 사용되지 않을 것&lt;/strong&gt;이라는 개념으로 과거의 페이지 기록을 통해 희생양 페이지를 선택한다.&lt;/p&gt;

&lt;h2 id=&quot;41-예제&quot;&gt;4.1 예제&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78567504-c1fa8800-785b-11ea-9427-f6f611c2998e.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LRU는 근사 해를 구하므로 OPT보다는 page fault가 많이 발생하지만, FIFO보다는 일반적으로 적게 일어난다. 그러므로 현재 대부분 환경에서는 LRU를 사용하고 있다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>16: 가상 메모리 (Virtual Memory)</title>
        <link>/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-16-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-16-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC.html</guid>
        <description>&lt;p&gt;가상 메모리(Virtual Memory)에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 즉, 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다. 예를 들어, 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행할 수 있도록 하는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;1-demanding-paging&quot;&gt;1. Demanding Paging&lt;/h1&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78536382-b80b6180-7828-11ea-9117-f86dfd77f2e1.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 방식이 어떻게 가능할까? 앞서 메모리 낭비 방지의 동적 할당에서도 봤듯이, &lt;strong&gt;필요한 부분만 메모리에 적재&lt;/strong&gt;하는 것이다. 프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올리는 것이다. 이러한 프로세스의 일부분은 페이지 단위일 수도 있고, 세그먼트 단위일 수도 있지만 현재 대부분은 페이지 단위를 사용한다.&lt;/p&gt;

&lt;p&gt;이처럼 현재 필요한(요구되어지는) 페이지만 메모리에 올리는 것을 &lt;strong&gt;Demanding Paging(요구 페이징)&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;11-동작&quot;&gt;1.1 동작&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;700&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78536519-f012a480-7828-11ea-9b4e-1fd1c7e3c7c4.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CPU가 page table에 가서 해당 page에 접근한다.&lt;/li&gt;
  &lt;li&gt;이 때, Memory에 올라온 상태가 아니면(invaild), Interupt를 발생한다.&lt;/li&gt;
  &lt;li&gt;OS 내부의 ISR에서 이 인터럽트를 처리하러 Disk에서 page를 찾는다.&lt;/li&gt;
  &lt;li&gt;찾은 Page를 Memory에 올려 Frame화 한다.&lt;/li&gt;
  &lt;li&gt;page table을 업데이트 한다.&lt;/li&gt;
  &lt;li&gt;CPU에게 다시 수행하라고 명령한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;가상 메모리를 만드는 방법은 대표적으로 두 가지가 존재하지만, 대부분 요구 페이징을 사용하므로 가상 메모리와 요구 페이징을 같은 용어로 사용하는 경우가 많다.&lt;/p&gt;

&lt;h2 id=&quot;12-page-fault페이지-부재&quot;&gt;1.2 Page Fault(페이지 부재)&lt;/h2&gt;

&lt;p&gt;페이지 부재는 위에서 살펴본 CPU가 접근하려는 페이지가 메모리에 없는 경우이다. 즉, 페이지 테이블의 valid bit값이 0인 경우이다.&lt;/p&gt;

&lt;p&gt;위에서 이러한 경우를 처리하는 방법을 알아보았다. 실질적으로 이 부분이 가상 메모리의 핵심적인 기능이라 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;121-pure-demanding-paging&quot;&gt;1.2.1 Pure Demanding Paging&lt;/h3&gt;

&lt;p&gt;Pure Demanding Paging은 프로세스가 최초로 실행될 때는 어떤 페이지가 필요한지 알 수 없으므로, 아무 페이지도 올리지 않는다. 그러므로 프로그램을 실행하자마자 page fault가 발생한다. 즉, 순수하게 필요한 페이지만 올리는 것을 말한다. Pure Demanding Paging의 장점은 메모리를 &lt;strong&gt;최대한 효율적으로 사용&lt;/strong&gt;할 수 있다. 하지만 시작부터 page fault가 발생하므로 &lt;strong&gt;속도면에서 느리다&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;122-prepaging&quot;&gt;1.2.2 Prepaging&lt;/h3&gt;

&lt;p&gt;Prepaging은 pure demanding paging과 반대대는 개념이다. 프로그램을 실행할 때 필요할 것이라 판단되는 &lt;strong&gt;페이지를 미리 올리는 것&lt;/strong&gt;이다. 이것의 장점은 page fault가 발생할 확률이 적으므로 &lt;strong&gt;속도&lt;/strong&gt;면에서 빠르지만, 단점으로 미리 올라간 페이지를 사용하지 않는다면 &lt;strong&gt;메모리가 낭비&lt;/strong&gt;된다.&lt;/p&gt;

&lt;h3 id=&quot;123-swapping-vs-demanding-paging&quot;&gt;1.2.3 Swapping VS Demanding Paging&lt;/h3&gt;

&lt;p&gt;Swapping와 Demanding Paging의 공통점은 둘 다 메모리와 backing store 사이를 서로 오고 가는 기능을 수행하지만, Swapping은 &lt;strong&gt;프로세스 단위&lt;/strong&gt;로 이동하고 Demanding Paging은 &lt;strong&gt;페이지 단위&lt;/strong&gt;로 이동하는 차이점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;124-유효-접근-시간effective-access-time&quot;&gt;1.2.4 유효 접근 시간(Effective Access Time)&lt;/h3&gt;

&lt;p&gt;Demending Paging은 페이지 테이블에 해당 페이지가 없으면 backing store에서 메모리로 가져오는 과정이 있다. 그렇기 때문에 페이지 테이블에 해당 페이지가 있을 때와 없을 때 시간 차이가 발생한다. 이러한 시간 차이를 고려하여 평균적으로 어느정도 소요되는지 계산하는 것을 유효 접근 시간이라 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;p
    &lt;ul&gt;
      &lt;li&gt;페이지 부재 확률(probability of a page fault = page fault rate)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tm
    &lt;ul&gt;
      &lt;li&gt;메모리를 읽는 시간(DRAM)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tp
    &lt;ul&gt;
      &lt;li&gt;Page fault가 발생했을 때 소요되는 시간(대부분 backing store(하드디스크)를 읽는 시간이 차지한다. (seek time + rotational delay + transfer time)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T = (1-p)Tm + p \cdot Tp&lt;/script&gt;

&lt;h4 id=&quot;p--11000&quot;&gt;p = 1/1,000&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;용어&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;정의&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;값&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;p&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;페이지 부재 확률&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1/1000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Tm&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;메모리를 읽는 시간&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;200nsec&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Tp&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Disk 탐색 시간&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8msec&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T = 8200usec&lt;/script&gt;

&lt;p&gt;메모리를 읽는 시간에 비해 40배 정도 느리다.&lt;/p&gt;

&lt;h4 id=&quot;p--1399990&quot;&gt;p = 1/399,990&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;용어&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;정의&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;값&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;p&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;페이지 부재 확률&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1/399,990&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Tm&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;메모리를 읽는 시간&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;200nsec&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Tp&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Disk 탐색 시간&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8msec&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T = 220nsec&lt;/script&gt;

&lt;p&gt;메모리를 읽는 시간에 비해 10% 느리다.&lt;/p&gt;

&lt;h4 id=&quot;지역성의-원리locality-of-reference&quot;&gt;지역성의 원리(Locality of reference)&lt;/h4&gt;

&lt;p&gt;위의 예제를 보았을 때, page fault는 매우 적은 확률로 발생해야 효율적이다. 그러면 현실적으로 페이지 부재는 어느정도로 발생할까? 이는 &lt;strong&gt;지역성의 원리(Locality of reference)&lt;/strong&gt;로 인해 페이지 부재 확률은 매우 낮다. 지역성의 원리는 ‘&lt;strong&gt;메모리 접근은 시간적 지역성과 공간적 지역성을 가진다&lt;/strong&gt;‘는 의미이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시간적 지역성
    &lt;ul&gt;
      &lt;li&gt;CPU는 어느 메모리 공간을 읽은 후, 시간이 지나도 그 공간을 다시 읽을 확률이 매우 높다는 것을 말한다.&lt;/li&gt;
      &lt;li&gt;대표적인 예로 반복문이 있다. 반복문은 하나의 코드 공간을 여러 번 읽는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공간적 지역성
    &lt;ul&gt;
      &lt;li&gt;CPU가 메모리 공간을 읽을 때는 인접한 범위 내에서 읽는다는 의미이다.&lt;/li&gt;
      &lt;li&gt;프로그램은 대부분 절차적인 순서로 구현되어 있어 순서대로 읽는 경우가 빈번하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이와 같이 페이지 부재가 현실적으로 발생할 확률은 매우 낮으므로 예제와 같이 40배로 느려지는 일을 거의 없다. 여기서 더 효율적으로 사용하기 위해서는 페이지 부재일 때 소요되는 시간을 줄일 수 있는데, backing store로 HDD를 사용하기 보다는 더욱 빠르게 동작하는 SSD나 저가 DRAM과 같은 것을 사용하는 방법이 있다.&lt;/p&gt;

&lt;h2 id=&quot;13-페이지-교체page-replacement&quot;&gt;1.3 페이지 교체(Page Replacement)&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78538479-066e2f80-782c-11ea-97e6-94ed4e8ee699.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Demanding Paging은 요구되어지는 페이지만 backing store에서 가져온다. 하지만 프로그램들이 계속 실행함에 따라 요구 페이지도 계속 늘어나고, 언젠가는 메모리가 가득 차게 될 것이다.(memory full) 여기서 다른 프로그램이 새로 실행되거나 실행중인 프로세스가 다른 페이지를 요구한다면 &lt;strong&gt;이미 메모리에 있는 페이지 중 하나를 다시 backing store에 보내고(page-out), 새로운 페이지를 메모리에 올려야한다.(page-in)&lt;/strong&gt; 이를 페이지 교체라고 한다. 여기서 backing store로 page-out이 된 페이지를 &lt;strong&gt;victim page&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;121-victim-page희생양-페이지&quot;&gt;1.2.1 Victim Page(희생양 페이지)&lt;/h3&gt;

&lt;p&gt;희생양 페이지는 어떤 페이지로 하는 것이 좋을까? 먼저 생각할 수 있는 것은 메모리에 올라가 있는 페이지 중 CPU에 수정(modify)되지 않는 페이지를 고르는 것이 효율적으로 보인다. 즉, 읽기만 수행하는 페이지를 고르는 것이 이상적이다. 수정되지 않은 페이지는 page-out이 될 때 backing store에 쓰기(write) 연산을 할 필요가 없기 때문이다. backing store는 읽는 시간도 느리지만, 거기에 더해 쓰기 작업까지 한다면 더욱 비효율적일 것이다.&lt;/p&gt;

&lt;p&gt;그러면 해당 페이지가 수정되었는지 안되었는지를 판단할 수 있어야 하는데, 이를 위해 페이지 테이블에 &lt;strong&gt;modified bit(=dirty bit)&lt;/strong&gt;를 추가하여 이를 검사한다. 해당 페이지가 수정되었다면 이 비트를 1로 두고, 수정되지 않으면 0으로 둔다. 이를 이용해서 victim page는 최대한 수정되지 않은 페이지를 선택한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78538693-5c42d780-782c-11ea-9f59-09c204d9de90.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 modified bit를 추가한 페이지 테이블의 모습이다. 여기서 수정되지 않은 페이지는 0, 2, 3번 3개의 페이지가 존재하는데 이 중에서는 어떤 페이지를 선택해야 할까?&lt;/p&gt;

&lt;p&gt;제일 간단한 방법은 랜덤하게 선택하는 것이지만, 이는 성능을 보장할 수 없다. 그 다음은 가장 먼저 메모리에 올라온 페이지를 희생양 페이지로 선택하는 것이다. 이는 아주 유명한 FIFO(First-In First-Out) 방식이다. 이 외에도 여러가지 방법이 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>15: 세그멘테이션 (Segmentation)</title>
        <link>/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-15-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-15-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98.html</guid>
        <description>&lt;p&gt;프르세스를 논리적 내용을 기반으로 나누는 세그멘테이션(Segmentation)에 대해 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;segmentation&quot;&gt;Segmentation&lt;/h1&gt;

&lt;p&gt;지금까지 살펴본 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하였다. 여기서 물리적이라 함은 말 그래도 프로세스를 일정한 크기로 자른 것이다. 반면에 세그먼테이션은 프로세스를 &lt;strong&gt;논리적 내용을 기반&lt;/strong&gt;으로 나눠서 메모리에 배치하는 것을 말한다. 논리적 내용은, 어떤 의미론적 단위를 의미한다. 돼지고기를 그냥 1cm 간격으로 나누는 것이 Paging, 목살, 삼겹살, 갈비와 같이 나누는 것이 Segmentation이다. 따라서 각 세그먼트의 크기는 일반적으로 같지 않다.&lt;/p&gt;

&lt;p&gt;세그먼테이션은 프로세스를 세그먼트(segment)의 집합으로 생각한다. 앞에서도 말했듯, Process는 Code, Data, Stack 과 같은 구조로 나뉜다. 물론 code, data, stack 각각 내부에서 더 작은 세그먼트로 나눌 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;1-segment-table&quot;&gt;1. Segment Table&lt;/h2&gt;

&lt;p&gt;이번에는 page size가 동일하지 않기 때문에, frame 번호로 논리 주소와 물리 주소를 연결할 수 없다. 이번에는 table이 bound를 가지고 있어야 한다. 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limit)를 엔트리로 갖는다. 페이징과 마찬가지로 논리 주소의 규약을 가지며, 이번에는 p가 아니고 s로 표기한다.&lt;/p&gt;

&lt;p&gt;한 가지 주의할 점은 세그먼트의 크기는 일정하지 않기 때문에, 테이블에 limit 정보가 주어진다. 그리고 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78534732-e20f5480-7825-11ea-975f-c4cd252fccfc.png&quot; class=&quot;center&quot; /&gt;
&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78534794-ff442300-7825-11ea-8f18-601020433f12.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습이다. 페이징 주소변환과 동일하게 d는 논리주소와 물리주소가 동일하다. 물리주소 a는 &lt;strong&gt;base[s] + d&lt;/strong&gt; 로 계산된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;논리주소 (2, 100)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2(4300) + 100 = 4400 &amp;lt; 4700(base+limit)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;논리주소 (1, 500)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1(6300) + 500 = 6800 &amp;gt; 6700(base+limit)&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;=&amp;gt; 인터럽트로 인해 프로세스 강제 종료(범위를 벗어남)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-세그먼테이션에서-보호와-공유&quot;&gt;2. 세그먼테이션에서 보호와 공유&lt;/h2&gt;

&lt;p&gt;먼저, 결론부터 말하면 페이징보다 세그먼테이션에서의 보호와 공유는 더 효율적이다.&lt;/p&gt;

&lt;p&gt;보호에서는 세그먼테이션 역시 r, w, x 비트를 테이블에 추가하는데, 세그먼테이션은 논리적으로 나누기 때문에 해당 비트를 설정하기 매우 간단하고 안전하다. 페이징은 code + data + stack 영역이 있을 때 이를 일정한 크기로 나누므로 두 가지 영역이 &lt;strong&gt;섞일 수가 있다&lt;/strong&gt;. 그러면 비트를 설정하기가 매우 까다롭다.&lt;/p&gt;

&lt;p&gt;공유에서도 마찬가지다. 페이징에서는 code 영역을 나눈다해도 다른 영역이 포함될 확률이 매우 높다. 하지만 세그먼테이션은 정확히 code 영역만 나누기 때문에 더 &lt;strong&gt;효율적으로 공유&lt;/strong&gt;를 수행할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;3-세그먼테이션과-페이징&quot;&gt;3. 세그먼테이션과 페이징&lt;/h2&gt;

&lt;p&gt;세그먼테이션은 페이징과 유사하고 보호와 공유에서는 더 나은 성능을 보여주었지만, 현재 대부분은 &lt;strong&gt;페이징 기법을 사용&lt;/strong&gt;한다. 그 이유는 세그먼테이션에는 치명적인 단점이 있기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;31-외부-단편화&quot;&gt;3.1 외부 단편화&lt;/h3&gt;

&lt;p&gt;메모리 할당을 처음 시작할 때 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다. 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 했었다.&lt;/p&gt;

&lt;p&gt;세그먼테이션도 똑같은 문제점이 발생한다. 왜냐하면 세그먼테이션은 논리적인 단위로 나누기 때문에 세그먼트의 크기가 다양하다. 이로 인해 다양한 크기의 hole이 발생하므로 &lt;strong&gt;외부 단편화의 문제가 발생&lt;/strong&gt;한다.&lt;/p&gt;

&lt;h3 id=&quot;32-paged-segmentation&quot;&gt;3.2 Paged segmentation&lt;/h3&gt;

&lt;p&gt;결론적으로 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다. 그러므로 두 가지를 합쳐서 사용하는 방법이 나왔다. 두 장점을 합치기 위해서는 &lt;strong&gt;세그먼트를 페이징 기법으로 나누는 것&lt;/strong&gt;이다.(Paged segmentation)&lt;/p&gt;

&lt;p&gt;하지만 이 역시 단점이 존재한다. 세그먼트와 페이지가 동시에 존재하기 때문에 &lt;strong&gt;주소 변환도 두 번&lt;/strong&gt;해야한다. 즉 CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야한다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>14: 페이징 (Paging)</title>
        <link>/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-14-%ED%8E%98%EC%9D%B4%EC%A7%95.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-14-%ED%8E%98%EC%9D%B4%EC%A7%95.html</guid>
        <description>&lt;p&gt;외부 단편화를 해결하는 방법인 페이징(Paging)에 대해 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;1-페이징paging&quot;&gt;1. 페이징(Paging)&lt;/h1&gt;

&lt;p&gt;외부 단편화로 인한 메모리 낭비는 매우 심하다는 것을 살펴보았다. Compaction을 사용하면 외부 단편화는 해결할 수 있지만, 그로 인해 발생하는 오버헤드와 비효율적인 성능으로 사용하기는 어렵다. 그 이후에 연구를 통해 나온 것이 &lt;strong&gt;페이징&lt;/strong&gt;이다. 페이징은 hole을 가지고 해결하려 한 것이 아니라 프로세스를 작은 크기로 나눠서 외부 단편화를 해결하려고 하였다.&lt;/p&gt;

&lt;p&gt;페이징은 프로세스를 일정한 작은 크기로 나누는데, 프로세스뿐아니라 hole도 같은 크기로 나눈다. 이러한 작은 조각들의 크기를 맞춰서 메모리에 할당한다. 하지만, 하나의 프로세스는 연속적인 동작을 수행하는데 이를 작은 조각으로 나누어서 여기저기 흩어진다면 프로세스가 &lt;strong&gt;정상적으로 동작할까?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리상에 여러 곳에 흩어진 프로세스를 수행하기 위해 &lt;strong&gt;CPU를 속여야한다.&lt;/strong&gt; 이전 다중프로그래밍을 살펴봤을 때 MMU를 통해 논리 주소와 물리 주소를 나눠서 사용한다고 했었다. 이 역시 CPU를 속이는 행동이다. 실제 메모리는 전혀 연속적이지 않는데, CPU는 연속적으로 사용하고 있다는 것을 보장받으며 정상적으로 수행한다.&lt;/p&gt;

&lt;p&gt;페이징으로 작은 크기로 나눈 것도 위와 같은 방법으로 할 수 있다. 만약 50byte 크기의 프로세스가 있다고 하자. 페이징의 크기는 각 10byte로 나눈다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78529761-4da0f400-781d-11ea-955b-697e56b2e6bc.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같이 프로세스 P1은 5개의 페이지로 나눌 수 있다. 이를 메인 메모리 5곳에 나눠서 할당하였다. CPU는 논리 주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기전에 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경되어야 한다.&lt;/p&gt;

&lt;p&gt;프로세스를 나눈 조각을 &lt;strong&gt;page&lt;/strong&gt; 라 하고, 메모리를 나눈 조각을 &lt;strong&gt;frame&lt;/strong&gt; 이라 한다. 프로세스는 페이지의 집합이고, 메모리는 프레임의 집합이다. 프로세스를 정상적으로 사용하기 위해 MMU의 재배치 레지스터를 여러개 사용해서 위의 그림과 같이 각 페이지의 실제 주소로 변경해준다. 이러한 여러 개의 재배치 레지스터를 &lt;strong&gt;페이지 테이블(Page Table)&lt;/strong&gt; 이라 한다.&lt;/p&gt;

&lt;h2 id=&quot;11-주소-변환address-translation&quot;&gt;1.1. 주소 변환(Address Translation)&lt;/h2&gt;

&lt;p&gt;페이징 기법을 사용하기 위해서는 여러 개로 흩어진 페이지에 CPU가 접근하기 위해서 페이지 테이블을 통해 주소를 변환해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;111-논리-주소logical-address&quot;&gt;1.1.1 논리 주소(Logical address)&lt;/h3&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78530376-7ecdf400-781e-11ea-8d7d-d3d0995b55ec.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU가 내는 주소는 2진수로 표현된다. 이 주소가 m비트로 표현된다고 가정하자. 여기서 하위 n비트는 오프셋(offset) 또는 변위(displacement)라고 한다. 그리고 상위 m-n 비트는 페이지의 번호에 해당한다.(n = d, m-n = p)&lt;/p&gt;

&lt;p&gt;논리주소를 물리주소(physical address)로 변환하기 위해서 &lt;strong&gt;페이지 번호(p)는 페이지 테이블의 인덱스 값&lt;/strong&gt;이고, &lt;strong&gt;p에 해당되는 테이블 내용은 메모리의 프레임 번호&lt;/strong&gt;이다. &lt;strong&gt;변위(d)는 변하지 않는 값&lt;/strong&gt;이다. d는 페이지 크기에 따라 달라진다. 만약 현재 페이지 크기를 16byte이라고 한다면, 이는 2^4이므로 d = 4 이다.&lt;/p&gt;

&lt;p&gt;만약 논리주소가 50번째로 주어진다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50=110010&lt;/code&gt; 이고, page size가 16byte라 주어졌을 때, 4자리를 제외한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p=11&lt;/code&gt;이고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d=0010&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&quot;112-동작-예시&quot;&gt;1.1.2 동작 예시&lt;/h3&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78530526-c3598f80-781e-11ea-8445-14bca2d5b5e2.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림을 보면, 어떻게 동작하는 지 한눈에 확인 할 수 있다. 우리가 해야할 일은, 논리 주고가 들어왔을 때, 이것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;displacement&lt;/code&gt;로 나누고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page&lt;/code&gt; 변수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frame&lt;/code&gt; 변수로 바꿔주는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page table&lt;/code&gt;을 통과하여 나온 값을 가지고 물리 주소를 찾으면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78530736-2c410780-781f-11ea-8186-50e4a90a2691.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78531119-cdc85900-781f-11ea-8dee-72647ea0ca01.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림으로 부터 따라해 볼 수 있다. p와 d만 잘 생각하면 쉬운 아이디어임을 알 수 있다. 이 페이징으로부터 연속 메모리 할당을 하면서 외부 단편화가 발생하는 문제는 해결했다. &lt;del&gt;하지만..&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-내부단편화internal-fragment&quot;&gt;1.2 내부단편화(Internal Fragment)&lt;/h2&gt;

&lt;p&gt;페이징은 외부 단편화가 아닌 내부 단편화가 발생한다. 내부단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채울 수 없다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다.&lt;/p&gt;

&lt;p&gt;예를 들어, 15bytes 크기의 프로세스 P가 있다. 페이지 크기(프레임 크기)를 4bytes라 하면, P를 페이지로 나눈 결과인 &lt;strong&gt;4, 4, 4, 3 의 크기로 총 4개의 페이지&lt;/strong&gt;가 만들어진다. 여기서 마지막 3bytes 페이지는 프레임 크기보다 1byte작으므로, 이 만큼 메모리 공간이 비게 된다. 이렇게 비어진 공간은 프로세스 P에서도 쓰지 않고, 다른 프로세스에서도 쓰지 못하는 낭비되는 공간이 된다.&lt;/p&gt;

&lt;p&gt;내부단편화는 해결할 방법이 없다. 하지만 내부단편화는 외부단편화에 비해 낭비되는 메모리 공간은 매우 적다. 내부단편화의 최대 낭비되는 크기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page size - 1&lt;/code&gt; 이 된다.(외부 단편화는 최대 전체 메모리의 1/3이 낭비된다고 이전에 살펴봤다.) 이는 무시할 정도로 작은 크기이다.&lt;/p&gt;

&lt;h2 id=&quot;13-페이지-테이블-만들기&quot;&gt;1.3 페이지 테이블 만들기&lt;/h2&gt;

&lt;p&gt;페이지 테이블을 만드는 방법은 여러 가지가 있다. 먼저, CPU 내부에 페이지 테이블을 만들 수 있다. CPU 내부의 기억장치는 레지스터로, 여러 개의 레지스터로 페이지 테이블을 만드는 것이다. CPU 내부에 페이지 테이블을 만들면, 장점은 주소 변환 속도가 빠르다. 하지만 단점은 &lt;strong&gt;CPU 내부에 사용할 수 있는 레지스터는 한정&lt;/strong&gt;되어 있으므로 페이지 테이블의 크기가 매우 제한된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU
    &lt;ul&gt;
      &lt;li&gt;장점 : 주소 변환 속도가 빠르다.&lt;/li&gt;
      &lt;li&gt;단점 : CPU 내부에 사용할 수 있는 레지스터는 한정되어 테이블의 크기가 제한된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;반대로, 페이지 테이블을 메모리 내부에서 만들 수도 있다. 메모리 내부에 만드는 것의 장단점은 CPU와 정 반대이다. 즉, 장점은 &lt;strong&gt;페이지 테이블의 크기에 제한이 없는 것&lt;/strong&gt;이고, 단점은 &lt;strong&gt;주소 변환 속도가 느리다&lt;/strong&gt;는 것이다. CPU는 프로세스의 주소에 접근하기 위해서 메모리에 위치한 페이지 테이블에 한 번, 실제 주소로 접근하는데 한 번해서 &lt;strong&gt;메모리에 총 2번 접근해야하므로 속도 역시 2배로 느려진다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Memory
    &lt;ul&gt;
      &lt;li&gt;장점 : 페이지 테이블의 크기에 제한이 없다.&lt;/li&gt;
      &lt;li&gt;단점 : 주소 변환 속도가 느리다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;131-tlbtranslation-look-aside-buffer&quot;&gt;1.3.1 TLB(Translation Look-aside Buffer)&lt;/h3&gt;

&lt;p&gt;페이지 테이블을 CPU에 만들 때나 메모리에 만들 때 둘 다 장단점이 확실하기 때문에, 이를 해결하기 위해 페이지 테이블도 캐시로 만들어 해결하였다. 페이지 테이블을 별도의 칩(SRAM)으로 만들어서 CPU와 메모리 사이에 위치시키는 것이다. 이러한 테이블을 &lt;strong&gt;TLB(Translation Look-aside Buffer)&lt;/strong&gt; 라고 부른다. 이는 CPU보다 변환 속도는 느리고 메모리보다 테이블 크기는 작지만, CPU보다 테이블 크기가 크고 메모리보다 변환 속도가 빠르다.&lt;/p&gt;

&lt;p&gt;TLB는 캐시와 역할이 동일하므로, 실제 전체 페이지 테이블은 메모리에 위치해 있고 테이블의 일부를 TLB에 가져와서 사용한다. 그러므로 TLB에 유효한 페이지가 있을 때와 없을 때의 속도 차이가 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;132-tlb의-효율&quot;&gt;1.3.2 TLB의 효율&lt;/h3&gt;

&lt;p&gt;그렇다면, TLB의 효율을 알아보기 위해 Effective Memory Access Time을 계산해보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;용어&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;정의&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;값&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Tm&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;메모리를 읽는 시간&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Tb&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TLB를 읽는 시간&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20ns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;hit ratio&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TLB에 유효한 페이지 엔트리가 있을 확률&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;80%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;먼저, EMAT의 정형화된 식을 보자. 가중 평균의 식이다. h는 hit ratio이다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;EMAT = h(Tb + Tm) + (1 - h)(Tb + Tm + Tm)&lt;/script&gt;

&lt;p&gt;실제 유효한 메모리에 접근하는 시간은 위와 같다. 없을 경우 2번 읽어야 하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tm&lt;/code&gt;을 두번 더해주었다. TLB에 유효한 페이지가 있다면 TLB를 읽는 시간과 실제 메모리를 읽는 시간만 있으면 된다. 하지만, TLB에 유효한 페이지가 없다면 이를 다시 메모리에서 가져와야 하므로 메모리를 총 2번 읽어야 한다.&lt;/p&gt;

&lt;p&gt;예제를 계산해보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.8 * (20 + 100) + 0.2 * (20 + 100 + 100) = 140ns&lt;/code&gt; 이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hit ratio&lt;/code&gt;는 실제로 평균 95%이상이므로 충분히 효율적으로 동작한다고 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;14-보호protection&quot;&gt;1.4 보호(Protection)&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78532750-bccd1700-7822-11ea-8cac-9418512d3e39.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 주소는 페이지 테이블을 경유하므로, 테이블을 이용해서 보호 기능을 수행할 수 있다. 접근이 유효한지 그렇지 않은지를 구분하는 bit를 추가하여 켜져있을 때 수행하도록 한다. 대표적으로 페이지 테이블마다 r(read), w(write), x(execute) 비트를 두어, 해당 비트가 켜져있을 때 그 수행이 가능하도록한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78532908-fa31a480-7822-11ea-9bf2-b7b9fdbfad3a.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 페이지 테이블에 r,w,x 비트를 추가한 모습이다. 만약, 1번 페이지 엔트리처럼 쓰기 비트가 꺼져있는 페이지에 쓰기 작업을 시도하면 CPU에 인터럽트가 발생하여 ISR에서 강제로 해당 프로세스를 종료시킨다.&lt;/p&gt;

&lt;h2 id=&quot;15-공유sharing&quot;&gt;1.5 공유(Sharing)&lt;/h2&gt;

&lt;p&gt;공유는 메모리 낭비를 방지하기 위함이다. 같은 프로그램을 쓰는 복수 개의 프로세스가 있다면, 프로세스의 메모리는 code + data + stack 영역으로 나뉘는데 프로그램이 같다면 code 영역은 같을 것이다. 그러므로 하나의 code 영역을 복수 개의 프로세스가 공유하여 메모리 낭비를 줄이는 것이다. 단, code가 공유되려면 code가 변하지 않는 프로그램이어야 한다. 이를 &lt;strong&gt;non-self-modifying code = reentrant code(재진입가능 코드) = pure code&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>정적 변수 (static)</title>
        <link>/dv/c++/2020/04/05/%EC%A0%95%EC%A0%81%EB%B3%80%EC%88%98.html</link>
        <guid isPermaLink="true">/dv/c++/2020/04/05/%EC%A0%95%EC%A0%81%EB%B3%80%EC%88%98.html</guid>
        <description>&lt;p&gt;c++에서 static 키워드를 갖는 정적 변수에 대해서 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;필요성&quot;&gt;필요성&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;지역이 사라져도 변수는 유지되어야 해!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;지역 변수, 전역 변수 말고 c++에는 이상한 녀석이 하나 더 있다. 정적 변수라는 것이 그것인데, 아니 이게 왜 필요하지..?&lt;/p&gt;

&lt;p&gt;함수를 호출했는데, 이 함수를 몇 번 호출했는지 알고 싶다. 그러면, 사실 가능한 방법은 전역변수로 이 함수가 호출되었을 때 값을 증가시키면 된다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만, 이렇게 되면 프로그램의 안정성이 너무 떨어진다. 이름이 겹치는 문제도 생기고, 해당 변수의 역할은 함수의 호출 횟수만을 체크하는 것인데, 너무 범위가 크게 잡혀있기 때문이다. 결국 Scope를 줄이고 싶은 것이다.&lt;/p&gt;

&lt;p&gt;이런 경우 static을 적어주면, 전역변수처럼 행동하되, 이 녀석의 Scope는 해당 함수를 호출했을 때로 줄어들게 된다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;특징-정리&quot;&gt;특징 정리&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;메모리 공간에서 정적 변수는 전역 변수가 저장되는 Data 영역에 저장된다.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://wansook0316.github.io/cs/os/2020/04/01/운영체제-정리-05-운영체제-프로세스-관리.html&quot;&gt;프로세스 구조&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;초기값을 주지 않을 경우 항상 0으로 초기화 되며 프로그램을 실행시킬 때 한번만 초기화 된다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이 부분은 매우 중요한데, 실제로 함수가 실행될 때, 값이 변하는 것 같지만, 영향을 주지 않는다. 그렇기 때문에 원하는 결과인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1, 2, 3, 4 ,5&lt;/code&gt;가 출력된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 05 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>13: 주기억 장치 관리</title>
        <link>/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-13-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-13-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC.html</guid>
        <description>&lt;p&gt;운영체제에서 중요한 부분인 메모리 관리 기능에 대해 알아보자.&lt;/p&gt;

&lt;p&gt;메모리는 CPU 자원만큼 컴퓨터를 사용하는데 매우 중요한 자원 중 하나이다. 이전에는 운영체제에서 CPU 자원을 관리하는 프로세스 관리에 대해 살펴보았고, 지금부터는 메인 메모리를 관리하는 기능에 대해 살펴볼 것이다. 특히, 과거에는 메모리가 매우 비싼 자원이었고 크기 또한 작았기 때문에, 운영체제에서 메모리에 대한 관리가 지금보다 더 중요하였다.&lt;/p&gt;

&lt;p&gt;현재에는 과거보다 훨씬 큰 메모리를 저렴하게 사용하지만, &lt;strong&gt;지금도 메모리는 부족&lt;/strong&gt;하다. 메모리가 커져온 만큼 프로그램의 크기와 처리하는 데이터의 크기는 그보다 더욱 빠른 속도로 커져왔다. 그러므로 현재에도 여전히 메모리를 최대한 효율적으로 사용하기 위해 여러 방법들이 연구되고 있고, 운영체제 기능에서도 매우 중요한 위치를 차지하고 있다.&lt;/p&gt;

&lt;h1 id=&quot;1-메모리에-프로그램-할당하기&quot;&gt;1. 메모리에 프로그램 할당하기&lt;/h1&gt;

&lt;p&gt;메모리는 기본적으로 &lt;strong&gt;주소(Address)&lt;/strong&gt;와 &lt;strong&gt;데이터(Data)&lt;/strong&gt;로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78501942-59e36d80-7799-11ea-95cc-40df34531ab7.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU와 메모리는 양방향으로 위 그림과 같이 주고 받는다. CPU는 주소를 가지고 메인 메모리에 요청을하거나 해당 주소에 계산 결과를 저장하고, 메모리는 요구하는 주소에 저장되어 있는 데이터를 CPU에게 전달한다.&lt;/p&gt;

&lt;h2 id=&quot;11-프로그램을-빌드하는-과정&quot;&gt;1.1 프로그램을 빌드하는 과정&lt;/h2&gt;

&lt;p&gt;프로그램을 빌드하는 과정은 소스파일, 목적파일, 실행파일 순서로 생성된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;소스파일(Source file)
    &lt;ul&gt;
      &lt;li&gt;고수준언어 또는 어셈블리어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;목적파일(Object file)
    &lt;ul&gt;
      &lt;li&gt;컴파일 또는 어셈블 결과&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행파일(Executable file)
    &lt;ul&gt;
      &lt;li&gt;링크 결과&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78501973-91521a00-7799-11ea-8f84-f78fc7154487.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 프로그램이 만들어지는 과정을 그림으로 표현한 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;소스파일은 컴파일러(compiler)에 의해 컴파일 수행 결과로 목적 파일을 생성한다.
    &lt;ul&gt;
      &lt;li&gt;어셈블리어는 어셈블러가 어셈블을 수행하여 기계어로 변환한다. 프로그래밍을 하면서 외부의 라이브러리를 사용할 때가 빈번한데, 컴파일 단계에서는 이를 추가하지 않기 때문에 목적파일에는 이에 대한 정보가 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;링크 단계에서 하드디스크에서 프로그래머가 추가한 라이브러리를 찾아 정보를 추가하여, 실행 파일을 만든다.
    &lt;ul&gt;
      &lt;li&gt;링크 단계는 링커(linker)가 수행한다. 이 프로그램을 실행하면 로더(loader)에 의해 메인 메모리에 할당된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그리고 생성된 프로그램은 code, data, stack 영역으로 나뉘어져 있다. 단순히 생성된 프로그램에는 code와 data영역만 존재한다. 실제로 실행을 하는 과정에서는 함수를 실행하기 때문에, 돌아올 return address 등을 저장하는 stack도 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;12-mmumemory-management-unit&quot;&gt;1.2 MMU(Memory Management Unit)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;메모리 관리를 효율적으로 해주는 OS 서비스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그렇다면, 프로그램을 실제로 메모리에 올리기 위해서는 좀 더 복잡한 과정이 필요하다. 먼저, 이 프로그램은 메모리에 몇 번지에 할당될까? 만약 운영체제가 없다면, 프로그래머가 직접 이를 처리해주어야 할 것이다. 하지만 운영체제가 존재하므로 실제 프로그래머는 이를 신경쓸 필요가 없다. 그러므로 프로그래밍을 할 때 주소를 사용하는 경우가 있는데, 프로그램이 메모리에 올라가는 주소를 고려하지 않고 프로그래밍이 가능한 것이다.(고수준언어에서는 직접 주소를 다루지 않는 경우가 많다.)&lt;/p&gt;

&lt;p&gt;또한, 다중 프로그래밍 환경에서는 여러 프로그램이 메모리에 올라가고 내려가고를 반복하기 때문에, 한 프로그램은 고정적인 공간을 사용할 수 없다. 이러한 여러 고려 사항을 해결해주는 것이 전에도 살펴봤던 &lt;strong&gt;MMU(Memory Management Unit)&lt;/strong&gt;이다. 그리고 MMU에는 프로그램이 메모리에 할당될 때마다 다른 주소공간을 사용하기 때문에 &lt;strong&gt;재배치 레지스터(Relocation register)가 별도로 존재&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78502282-594bd680-779b-11ea-9ecb-945f4623be1c.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 MMU의 모습이다. 프로그램은 메인 메모리에 해당 주소를 사용할 수 있는지 여부를 생각하지 않고 주소를 사용한다. 만약 해당 프로그램이 사용하는 시작주소가 0번지라고 할 때, 실제 메인 메모리에서는 할당되는 주소가 유동적이기 때문에 0번지이라는 주소를 실제 할당된 주소로 변경해주어야 한다. 이때 재배치 레지스터를 이용한다.&lt;/p&gt;

&lt;p&gt;만약, 프로그램이 메인 메모리 500번지에 할당되어 재배치 레지스터값이 500으로 설정되었다면, CPU에서 프로그램의 0번지를 사용할 때 MMU를 통과하면 재배치 레지스터에 의해 500번지로 변경된다. 그 결과 CPU는 0번지를 사용하는 것으로 알고 있지만, 실제 메모리에서는 MMU에 의해 500번지를 사용하고 있는 것이다. &lt;strong&gt;CPU를 속인다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;600&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78501877-da559e80-7798-11ea-8d23-16da01ef74d6.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MMU(Memory Management Unit)의 기능을 살펴보면, 이전에 메모리 보호를 위해 base와 limit 레지스터가 있었다. 이는 CPU에서 주소를 사용하는데 이 주소가 해당 프로그램의 base나 limit 범위를 벗어나면 인터럽트가 발생하여 그 프로그램을 강제로 종료시킨다.&lt;/p&gt;

&lt;p&gt;MMU는 이 기능 이외에도 재배치 레지스터를 사용해서 프로그램이 어느 주소를 사용하더라도 실제 메인 메모리에 할당된 주소를 찾아갈 수 있도록 &lt;strong&gt;address translation&lt;/strong&gt; 동작을 수행한다. 즉, CPU는 프로그램에 설정된 주소를 계속 사용하고 메모리에 명령을 보내지만, MMU에 의해 실제로 프로그램이 할당된 메모리 주소로 변환해서 사용할 수 있는 것이다. 그 결과, &lt;strong&gt;프로그램의 실제 메모리 주소 공간의 위치는 CPU에 전혀 영향을 미치지 않고 정상적으로 사용&lt;/strong&gt;할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78502288-6072e480-779b-11ea-8ae4-4315e8e8de05.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MMU에 의해 위 그림과 같이 주소는 두 가지로 구분된다. &lt;strong&gt;CPU에서 사용하는 주소는 논리 주소(logical address)&lt;/strong&gt;라고 하고, &lt;strong&gt;메모리가 사용하는 주소는 물리 주소(physical address)&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;h1 id=&quot;2-메모리-낭비-방지&quot;&gt;2. 메모리 낭비 방지&lt;/h1&gt;

&lt;p&gt;운영체제는 메모리를 효율적으로 사용하기 위해 메모리 공간을 낭비하지 않는 것이 중요하다.&lt;/p&gt;

&lt;h2 id=&quot;21-동적-적재dynamic-loading&quot;&gt;2.1. 동적 적재(Dynamic Loading)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로그램이 실행하는데 반드시 필요한 루틴/데이터만 적재(load)하는 것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그램의 전체 코드에서 모든 루틴이 다 사용되는 것은 아니다. 대표적으로 오류 처리 구문이다. 오류 처리 구문은 if문과 같이 오류가 발생할 때만 해당 내부 코드가 실행되는 것을 말한다. 그러므로 동적 적재를 수행하면 프로그램의 실제 메모리에는 이러한 오류 구문을 제외하고 적재한다. 이러한 상태에서 실행하다가 &lt;strong&gt;오류가 발생하면 그 때 해당 오류 구문을 찾아 메모리에 올린다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;데이터도 마찬가지다. 모든 데이터가 반드시 사용되는 것이 아니기 때문에, 특히 배열과 클래스의 경우는 필요한 부분만 메모리에 올려두고, 실행 도중 필요할 때마다 해당 부분을 찾아 메모리에 올려준다.&lt;/p&gt;

&lt;p&gt;반대로, 모든 루틴과 데이터를 적재하는 것을 정적 적재(static loading)이라고 한다. 현대 운영체제는 대부분 동적 적재를 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;22-동적-연결dynamic-linking&quot;&gt;2.2. 동적 연결(Dynamic Linking)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;공통으로 사용하는 라이브러리는 하나만 올리자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;동적 연결은 여러 프로그램에 공통으로 사용되는 라이브러리를 중복으로 메모리에 올리는 것이 아니라 하나만 올리도록 하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 아래와 같은 코드의 P1, P2 프로세스가 있다고 하자.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// P1&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// P2&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 두 소스파일을 컴파일하면 목적파일이 생성되고, 여기서 사용된 라이브러리를 링크하여 실행파일을 만든 다음 메모리에 적재한다. 두 프로세스가 적재되었을 때, printf() 를 사용하는 라이브러리는 메모리에 중복되어서 적재되어있다.&lt;/p&gt;

&lt;p&gt;이와 같이, 똑같은 라이브러리를 사용하는 프로그램은 흔히 볼 수 있다. 이러한 같은 라이브러리를 하나만 메모리에 올린 후, 이를 사용하는 프로그램이 하나의 메모리에 접근하도록 하면 메모리 낭비를 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;동적 연결은 같은 라이브러리가 중복으로 메모리에 올라가는 것을 방지하기 위해 &lt;strong&gt;프로그램이 메모리에 적재된 후에 링크(link) 작업을 수행&lt;/strong&gt;한다. 기존에는 실행 파일이 만들어지기 전에 링크 과정을 수행하였는데, 이를 정적 연결이라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78502660-299dce00-779d-11ea-942e-c729b32be80a.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 예제에서 살펴 본 P1, P2 프로세스가 동적 연결을 통해 공통 라이브러리(printf() 라이브러리)를 연결한 모습을 볼 수 있다. 이러한 라이브러리를 Linux에서는 &lt;strong&gt;공유 라이브러리(Shared Library)&lt;/strong&gt;, Windows에서는 &lt;strong&gt;동적 연결 라이브러리(Dynamic Linking Library, DLL)&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;h2 id=&quot;23-swapping&quot;&gt;2.3 Swapping&lt;/h2&gt;

&lt;p&gt;Swapping은 메모리에 적재되어 있는 프로세스 중에서 오랫동안 사용하지 않은 프로세스를 프로세스 이미지 형태로 만든 후 하드디스크(Backing store)에 내려보낸다. 메모리에서 Backing store로 가는 것을 &lt;strong&gt;swap-out&lt;/strong&gt;, 다시 Backing store에서 메모리로 가는 것을 &lt;strong&gt;swap-in&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;여기서, 프로세스 이미지는 해당 프로그램이 메모리에 적재된 후 실행되면서 데이터를 추가하거나 변경하는 등의 과정을 거치는데, 현재 &lt;strong&gt;데이터의 상태를 프로세스 이미지&lt;/strong&gt;라고 부른다. 그러므로 이는 단순히, 하드디스크에 존재하는 &lt;strong&gt;프로그램(exe파일)과는 전혀 다른 데이터&lt;/strong&gt;이므로, 따로 저장해야한다. 이와 같은 swapping 과정으로 인한 프로세스 이미지를 저장하기 위해 하드디스크의 일부분을 분리하여 사용하는데, 이를 &lt;strong&gt;backing store 또는 swap device&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;Backing store의 크기는 대략 메인 메모리 크기 정도로 예상할 수 있다. 메모리의 모든 프로세스가 쫓겨난다고 해도 메인 메모리 크기를 넘지 않기 때문이다. 메인 메모리 크기가 크지 않는 PC나 스마트폰은 하드디스크의 일부를 backing store로 사용하지만, 메모리 크기가 크다면 따로 하드디스크 자체를 backing store로 사용하는 경우도 있다.&lt;/p&gt;

&lt;p&gt;Swap-out된 프로세스는 다시 swap-in을 할 때, 이전의 메모리 주소 공간이 아닌 새로운 주소 공간으로 갈 수도 있다. 이는 해당 프로세스가 backing store에 있는 동안 다른 프로세스가 해당 주소 공간을 사용할 수 있기 때문에다. 하지만 이는 MMU의 재배치 레지스터로 인해 어디에 적재되는지 상관없이 정상적으로 수행할 수 있다.&lt;/p&gt;

&lt;p&gt;현재는 프로세스의 크기가 커지고, 하드디스크는 메인 메모리보다 속도면에서 매우 느리므로 &lt;strong&gt;swapping 동작의 오버헤드는 크다&lt;/strong&gt;고 볼 수 있다. 하지만 이로 인해 얻는 이득이 더 많으므로 대부분 운영체제는 이를 사용하고 있고, 속도가 중요한 서버 컴퓨터나 슈퍼 컴퓨터는 backing store를 하드디스크가 아닌 좀 더 빠른 저장 장치를 사용하기도 한다.&lt;/p&gt;

&lt;h1 id=&quot;3-연속-메모리-할당contiguous-memory-allocation&quot;&gt;3. 연속 메모리 할당(Contiguous Memory Allocation)&lt;/h1&gt;

&lt;p&gt;과거에는 메모리에 프로세스가 하나만 올라가는 형태였다. 하지만 현재에는 메모리에 여러 프로세스가 할당되는 다중 프로그래밍 환경이 되었다.&lt;/p&gt;

&lt;p&gt;부팅 직후에 메모리 상태를 살펴보면, 운영체제만 할당되어 있고 비어있는 상태일 것이다. 이러한 비어있는 공간을 &lt;strong&gt;hole&lt;/strong&gt; 이라 부른다. 즉, 부팅 직후에는 운영체제와 big single hole이 있는 상태이다. 시간이 지나면서 프로세스가 생성되고 종료하고를 반복하면, 여러 곳에 서로 다른 크기의 홀(hole)이 존재할 것이다. 이러한 상태를 &lt;strong&gt;scattered holes&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78502757-96b16380-779d-11ea-8b8d-6f478f6e3796.png&quot; /&gt;{}:.center}&lt;/p&gt;

&lt;p&gt;위 그림은 부팅 직후 상태에서 시간이 경과하면서 프로세스들이 생성, 종료를 반복한 후의 상태이다. 이와 같이 hole들이 불연속하게 흩어져 있는 상태를 &lt;strong&gt;메모리 단편화(Memory fragmentation)&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;p&gt;메모리 단편화로 인해서 여러 곳에 hole이 흩어져 있는 상태에서 하나의 프로세스가 메모리에 할당되려하면 문제가 발생할 수 있다. 예를 들어, hole이 3개가 있고 각 크기는 50byte, 50byte, 80byte이다. 그런데 할당하려는 프로세스의 크기는 150byte이다. 각 hole들을 하나로 합치면 230byte로 이 프로세스를 할당할 수 있는데 실재로는 나누어져 있으므로 할당되지 못한다. 이러한 현상을 &lt;strong&gt;외부 단편화(External fragmentation)&lt;/strong&gt; 라고 한다. 외부 단편화를 줄이기 위해서는 어떤 해결 방법이 있을까?&lt;/p&gt;

&lt;h2 id=&quot;31-연속-메모리-할당-방식&quot;&gt;3.1. 연속 메모리 할당 방식&lt;/h2&gt;

&lt;p&gt;외부 단편화의 해결방법을 살펴보기 전에 연속 메모리 할당 방식을 먼저 살펴보자. 연속 메모리 할당 방식에는 3가지가 있다. First-fit, Best-fit, Worst-fit 이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;First-fit(최초 적합)
    &lt;ul&gt;
      &lt;li&gt;최초 적합은 할당할 프로세스 크기보다 크거나 같은 hole을 탐색하는 순서 중에서 가장 먼저 찾은 hole에 프로세스를 할당하는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Best-fit(최적 적합)
    &lt;ul&gt;
      &lt;li&gt;최적 적합은 할당할 프로세스 크기와 hole 크기의 차이가 가장 작은 hole에 프로세스를 할당하는 것이다.(hole크기는 프로세스 크기보다 반드시 커야 한다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Worst-fit(최악 적합)
    &lt;ul&gt;
      &lt;li&gt;최적 적합과 반대로, 할당할 프로세스 크기와 hole 크기의 차이가 가장 큰 hole에 프로세스를 할당하는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;예제&quot;&gt;예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Hole id&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;HoleSize&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Process Name&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Size&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100kb&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;212kb&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;500kb&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;417kb&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;600kb&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;112kb&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;300kb&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;426kb&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;200kb&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;first-fit&quot;&gt;First-fit&lt;/h4&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78502985-d9277000-779e-11ea-9229-2cc48b543f99.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;best-fit&quot;&gt;Best-fit&lt;/h4&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78502990-de84ba80-779e-11ea-9cc2-d5cc46a05cf8.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;worst-fit&quot;&gt;Worst-fit&lt;/h4&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78502993-e3e20500-779e-11ea-9823-cbf41d06ac5a.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 3가지 방식대로 프로세스를 할당한 모습을 볼 수 있다. 예제의 결과를 보면 Best-fit은 4개의 프로세스를 모두 할당할 수 있었고, 나머지 2개는 마지막 P4를 할당하지 못했다. 모든 hole을 합치면 P4를 할당할 수 있지만, hole들은 각각 나눠져 있기 때문에 할당할 수 없다.(외부 단편화)&lt;/p&gt;

&lt;p&gt;각 할당 방식의 일반적인 성능을 비교해보면, 속도면에서는 first-fit이 가장 빠르다. 메모리 이용률면에서는 first-fit, best-fit이 비슷한 성능을 낸다고 알려져있다. 하지만 여러 실험을 통해 best-fit을 사용하더라도 외부 단편화로 인해 &lt;strong&gt;전체 메모리의 1/3 정도를 낭비&lt;/strong&gt;한다고 한다. 이는 거의 사용이 불가능한 수준이다.&lt;/p&gt;

&lt;p&gt;이를 해결하는 방법 중 하나는 Compaction 이다. compaction은 여러 곳에 흩어져있는 hole들을 강제로 하나로 합치는 것이다. 하지만 hole을 옮기는 오버헤드가 너무 크고, hole과 process 두개를 하기 때문에 어떻게 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않는 큰 단점이 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>12: 프로세스 동기화 Part 5</title>
        <link>/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-12-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-5.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-12-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-5.html</guid>
        <description>&lt;p&gt;현재 사용하는 동기화 도구인 모니터(Monitor)에 대해서 알아본다.&lt;/p&gt;

&lt;p&gt;세마포는 실제로 매우 오래된 동기화 도구이다. 현재에는 모니터(monitor)라는 동기화 도구를 주로 사용하며, 이는 좀 더 고수준의 동기화 기능을 제공한다.&lt;/p&gt;

&lt;h1 id=&quot;1-모니터-구조&quot;&gt;1. 모니터 구조&lt;/h1&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78479060-1cbeb180-7780-11ea-9d5b-6d9350b51d67.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Semaphore의 구조는 위와 같았다. 그렇다면 monitor는 무엇이 다를까?&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78484316-91deb680-7781-11ea-8a61-4c0c5e332bed.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위는 모니터의 구조를 간단히 나타낸 그림이다. 모니터는 공유 자원 + 공유 자원 접근함수로 이루어져 있고, 2개의 큐를 가지고 있다. 각각 &lt;strong&gt;mutual exclusion(상호배타) queue&lt;/strong&gt;, &lt;strong&gt;conditional synchronization(조건동기) queue&lt;/strong&gt;이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상호배타 큐는 말그대로 공유 자원에 하나의 프로세스만 진입하도록 하기 위한 큐이다.&lt;/li&gt;
  &lt;li&gt;조건동기 큐는 이미 공유자원을 사용하고 있는 프로세스가 특정한 호출 wait()을 통해 조건동기 큐로 들어갈 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;조건동기 큐에 들어가 있는 프로세스는 공유자원을 사용하고 있는 다른 프로세스에 의해 깨워줄 수 있다. 이 역시 깨워주는 프로세스에서 특정한 호출 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify()&lt;/code&gt;을 해주며, 깨워주더라도 이미 공유자원을 사용하고 있는 프로세스가 해당 구역을 나가야 비로소 큐에 있던 프로세스가 실행된다.&lt;/p&gt;

&lt;h1 id=&quot;2-monitor-in-java&quot;&gt;2. monitor in java&lt;/h1&gt;

&lt;p&gt;자바는 모니터를 제공하는 대표적인 언어이며, 자바의 모든 개체는 모니터가 될 수 있다. 그렇다면 자바를 통해 모니터에 대한 예제를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 공유 변수&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 배타동기&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Goo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 모니터를 사용하고 있는 클래스이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt;와 같은 변수들은 여러 쓰레드가 공유하고 있는 변수로 볼 수 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 키워드는 배타동기를 수행하는 함수를 말한다. 즉, 해당 함수에는 단 하나의 쓰레드만 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo()&lt;/code&gt; 함수와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Goo()&lt;/code&gt; 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 키워드를 통해 상호배타 함수로 선언하였는데, 이는 &lt;strong&gt;“둘 다 같은 임계구역을 갖는다”&lt;/strong&gt;는 의미이다. 다시 말해서, Foo() 함수에 한 쓰레드가 수행 중이라면, Foo() 함수뿐 아니라 Goo() 함수에도 다른 쓰레드는 접근할 수 없다. 반면에 H() 함수는 일반 함수인데, 이 함수에서는 공통 변수에 대한 업데이트를 하지 않는다는 것을 예상할 수 있다. (여러 쓰레드가 동시에 접근가능하다.)&lt;/p&gt;

&lt;p&gt;조건동기는 특정한 메서드 호출로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;wait(): 호출한 쓰레드를 조건동기 큐에 삽입한다.
notify(): 조건동기 큐에 있는 하나의 쓰레드를 깨워준다.
notifyAll(): 조건동기 큐에 있는 모든 쓰레드를 깨워준다.&lt;/p&gt;

&lt;p&gt;모니터 역시, 세마포에서 할 수 있는 기능인 Mutual exclusion, Ordering을 모두 할 수 있다. 예제를 통해 이를 살펴보자.&lt;/p&gt;

&lt;h1 id=&quot;3-problem-solving-by-monitor&quot;&gt;3. Problem Solving by Monitor&lt;/h1&gt;

&lt;p&gt;monitor를 사용하여 지금까지 배운 문제들을 해결하는 방법에 대해 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;31-bankaccount-problem&quot;&gt;3.1 BankAccount Problem&lt;/h2&gt;

&lt;p&gt;이전에 세마포에서 살펴본 은행계좌 문제를 통해 세마포 대신 모니터를 사용해서 Mutual exclusion, Ordering을 구현해보자.&lt;/p&gt;

&lt;h3 id=&quot;311-mutual-exclusion&quot;&gt;3.1.1 Mutual Exclusion&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;\nbalance = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBalance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBalance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드가 매우 간단해졌다..!{:.center-text}&lt;/p&gt;

&lt;p&gt;위 코드에서 볼 수 있듯이, 세마포를 사용할 때보다 모니터를 사용하면 매우 간결하게 코드를 구현할 수 있다. 세마포를 선언하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;number of permit&lt;/code&gt; 값을 설정하는 대신, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 키워드 하나로 이를 대체한 것을 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+++++++++++++++++++++++------------------------------------------+++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------------------
----------------------------------------
balance = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행 결과는 위와 같고, balance값이 정상적으로 0을 출력한다.&lt;/p&gt;

&lt;h3 id=&quot;312-mutual-ordeing&quot;&gt;3.1.2 Mutual Ordeing&lt;/h3&gt;

&lt;p&gt;은행계좌 문제를 살펴보기전에, ordering을 하기 위해 모니터를 어떻게 사용하는지 보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;P1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;P2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;wait()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;section 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;section 2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;notify()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 구조는 프로세스 순서를 P1, P2 순서로 실행하기 원하는 경우이며, 이는 세마포와 매우 유사한 것을 알 수 있다. 그러면 은행계좌 문제를 모니터로 구현하는데, 입금 먼저 수행, 출금 먼저 수행, 입금 출금 반복 수행 3가지를 각각 구현해보자. 그리고 위 코드에서 수정하는 부분은 순서를 정하는 입금, 출금함수이므로 이 부분을 대변하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BankAccount&lt;/code&gt;만 수정하자.&lt;/p&gt;

&lt;h4 id=&quot;입금-먼저-수행하기&quot;&gt;입금 먼저 수행하기&lt;/h4&gt;

&lt;p&gt;먼저 입금시작하면 기다리라고 하면된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBalance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++------------------------------------------------------------
----------------------------------------
balance = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;출금-먼저-수행하기&quot;&gt;출금 먼저 수행하기&lt;/h4&gt;

&lt;p&gt;먼저 출금시작하면 기다리라고 하면된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBalance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--------------------------------------------------------------------------------
--------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++
balance = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;입금-출금-반복-수행하기&quot;&gt;입금 출금 반복 수행하기&lt;/h4&gt;

&lt;p&gt;입금 넣고 기다리고 출금 넣고 기다리고를 반복하면 된다!&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p_turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p_turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p_turn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p_turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBalance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
balance = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;32-전통적-동기화-문제&quot;&gt;3.2 전통적 동기화 문제&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wansook0316.github.io/cs/os/2020/04/05/운영체제-정리-10-프로세스-동기화-3.html&quot;&gt;10: 전통적인 동기화 문제들&lt;/a&gt;을 수정해본다!&lt;/p&gt;

&lt;h3 id=&quot;21-producer-consumer-problem&quot;&gt;2.1 Producer-Consumer Problem&lt;/h3&gt;

&lt;p&gt;Semaphore를 사용하면 상호 배제 sem, 가득 차있을 때 block하는 sem, 비어있을 때 block하는 sem 총 3개를 사용했어야 했다. 하지만 이번에는 코드가 간단해진다!&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Buffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Number of items in the buf is &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Number of items in the buf is 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;22-the-dining-philosopher-problem&quot;&gt;2.2 The Dining Philosopher Problem&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Philosopher&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// philosopher id&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;Chopstick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Philosopher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Chopstick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Chopstick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lstick&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;rstick&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;lstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;rstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;lstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;rstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;] eating&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;] thinking&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Chopstick&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inUse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inUse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;inUse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;inUse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// number of philosphers &amp;amp; chopsticks&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* chopsticks */&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Chopstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stick&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Chopstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;stick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Chopstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* philosophers */&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Philosopher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Philosopher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;phil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Philosopher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/* let philosophers eat and think */&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;phil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 교착상태를 해결하지 않은 상태이다. 해결 하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;circular wait&lt;/code&gt; 조건을 불만족하도록 만들면 된다. 이 부분에서는 쉽게 동기화 문제를 해결할 수 있음을 보고가면 된다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>11: 프로세스 동기화 Part 4</title>
        <link>/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-11-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-4.html</link>
        <guid isPermaLink="true">/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-11-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-4.html</guid>
        <description>&lt;p&gt;프로세스 동기화에서 발생하는 논리적 오류인 교착 상태(Deadlock)에 대해 알아본다.&lt;/p&gt;

&lt;h1 id=&quot;deadlock-교착-상태&quot;&gt;Deadlock (교착 상태)&lt;/h1&gt;

&lt;p&gt;교착 상태는 어떠한 자원을 갖고 있는 상황에서 문제가 발생한다. 자동차 교차로를 생각해보자. A자동차도 신호를 받았고, B 자동차도 신호를 받았다. 그래서 두 자동차가 움직이는 것에 논리적 오류가 없지만, 두 자동차가 갈 수 없는 상황이 발생한다. 바로 출근 시간 길 막힘이다. 길이 막혀 아무런 동작도 수행할 수 없다. 이런 상황을 교착상태라 한다.&lt;/p&gt;

&lt;p&gt;프로세스는 실행을 위해 CPU, 메모리, 파일 등 여러 하드웨어 자원이 필요하다. 이를 운영체제에서 프로세스가 요구하는 자원을 적절히 분배해준다. 예를 들어, 한 프로세스가 A 자원을 가지고 있는 상태에서 B 자원을 요구하고 있다. 하지만 B 자원은 다른 프로세스 역시 요구하고 있는 자원인데, 이러한 상황에서 자원을 분배하는 순서가 잘못되면 교착상태에 빠지게 된다.&lt;/p&gt;

&lt;h2 id=&quot;1-교착상태-필요-조건necessary-conditions&quot;&gt;1. 교착상태 필요 조건(Necessary Conditions)&lt;/h2&gt;

&lt;p&gt;교착상태가 일어나기 위한 필요 조건이 네 가지가 존재한다. 이는 &lt;strong&gt;필요 조건&lt;/strong&gt;이므로, &lt;strong&gt;네 가지가 모두 해당된다고 해서 반드시 교착상태가 일어나는 것은 아니다.&lt;/strong&gt; 단지 일어날 가능성이 발생한다.&lt;/p&gt;

&lt;p&gt;하지만 &lt;strong&gt;네가지 조건 중 하나라도 해당되지 않으면 교착 상태는 일어나지 않는다.&lt;/strong&gt; 즉, 4가지 조건에 모두 해당되면 Deadlock의 가능성이 있으나, 그렇지 않다면 Deadlock은 일어나지 않는다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Mutual exclusion (상호배타)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다.
        &lt;ul&gt;
          &lt;li&gt;젓가락은 한 철학자가 사용하고 있으면 이 젓가락은 사용할 수 없으므로 상호배타적이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No Preemption (비선점)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.
        &lt;ul&gt;
          &lt;li&gt;한 철학자가 젓가락을 집은 상태에서 다른 철학자가 이 젓가락을 뺏을 수 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Hold and wait (보유 및 대기)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한 프로세스가 자원을 가지고 있는 상태에서 대기한다.
        &lt;ul&gt;
          &lt;li&gt;철학자는 왼쪽 젓가락을 가지고 있는 상태에서 오른쪽 젓가락을 집기 위해 대기한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Circular wait (환형대기)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스가 요구하는 자원의 방향이 원형을 이룬다.
        &lt;ul&gt;
          &lt;li&gt;모든 철학자는 왼쪽 젓가락부터 집을 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;교착상태는 위 네 가지 조건을 모두 만족하더라도 매우 드물게 일어나는 현상이지만, 한 번 교착상태에 빠지면 프로세스가 &lt;strong&gt;무한 루프&lt;/strong&gt;에 빠져 수행하지 못하고 해당 프로세스가 가지고 있는 자원은 아무도 사용하지 못한다. 이는 전체 컴퓨터 환경에 매우 &lt;strong&gt;치명적&lt;/strong&gt;이다. 그리고 교착상태에 의한 오류를 해결하기는 매우 힘들다.&lt;/p&gt;

&lt;h2 id=&quot;2-자원resources&quot;&gt;2. 자원(Resources)&lt;/h2&gt;

&lt;p&gt;교착 상태가 발생하는 가장 큰 원인은 결국 자원의 문제이다. 따라서 이 자원을 어떻게 이용하고 있는 지 파악하는 것이 중요하다.&lt;/p&gt;

&lt;p&gt;하드웨어 자원은 여러 개가 존재하고 동일한 &lt;strong&gt;형식(type)&lt;/strong&gt;의 자원이 존재할 수 있다. 예를 들어, 같은 CPU가 2개있는 환경이 있다. 이러한 자원 하나하나를 &lt;strong&gt;instance&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;자원은 프로세스가 직접적으로 사용할 수 없고, 운영체제에 &lt;strong&gt;요청(request)&lt;/strong&gt;하면 운영체제가 제공해준다. 그 후 프로세스는 이 자원을 &lt;strong&gt;사용(use)&lt;/strong&gt;하고 모든 사용이 끝나면 이를 &lt;strong&gt;반납(release)&lt;/strong&gt;한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;요청(request) -&amp;gt; 사용(use) -&amp;gt; 반납(release)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;21-자원-할당도resource-allocation-graph&quot;&gt;2.1 자원 할당도(Resource Allocation Graph)&lt;/h3&gt;

&lt;p&gt;자원 할당도는 어떤 자원이 어떤 프로세스에 할당되었는지 또는 어느 프로세스가 어느 자원을 할당 받으려고 기다리는지를 그림으로 나타낸 것이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;용어&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;모양&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Resource(자원)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사각형&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Instance(인스턴스)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;점&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Process(프로세스)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;할당&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;화살표&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78472151-94391480-7771-11ea-8d55-09554e950cdd.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;R1은 P1에 할당되어 있는 상태이고, P2는 R1을 요청하고 있는 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78472103-49b79800-7771-11ea-9ac0-4edac746123d.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원 할당도를 사용하는 이유는 교착상태의 필요조건을 한 눈에 볼 수 있기 때문이다. 자원 할당도를 분석할 때 mutual exclusion(한번에 하나)과 no-preemption(강제로 못 뺏는다.)은 기본으로 적용된다.&lt;/p&gt;

&lt;p&gt;Hold and wait는 화살표를 통해 한 프로세스가 인스턴스를 할당받았고 다른 자원을 가리키고 있다면, 이 상황은 Hold and wait인 상태이다.&lt;/p&gt;

&lt;p&gt;Circular wait 역시 화살표 방향이 원형을 이루고 있다면 이는 환형대기인 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78472261-4e308080-7772-11ea-8fce-8de411567b55.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 그림을 보면 Circular wait 조건을 가지고 있어 교착 상태의 가능성을 가지고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78472610-47573d00-7775-11ea-9eb0-567f6692bff1.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.&lt;/p&gt;

&lt;h2 id=&quot;4-교착상태-처리&quot;&gt;4. 교착상태 처리&lt;/h2&gt;

&lt;h3 id=&quot;41-교착상태-방지-deadlock-prevention&quot;&gt;4.1 교착상태 방지 (Deadlock Prevention)&lt;/h3&gt;

&lt;p&gt;교착상태 방지는 교착상태 필요조건 &lt;strong&gt;네 가지 중 최소 한 가지&lt;/strong&gt;를 만족시키지 않도록 만드는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상호배타(Mutual exclusion)
    &lt;ul&gt;
      &lt;li&gt;상호배타를 없애기 위해서는 자원을 공유 가능하게 만들어야 한다. 하지만 현실적으로 이러한 방법이 불가능한 경우가 많다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비선점(No preemption)
    &lt;ul&gt;
      &lt;li&gt;비선점을 없애러면 반대로 선점이 가능하도록 만들어야 한다. 이 역시 대부분의 자원에게는 불가능한 방법이다. CPU는 강제로 스위칭하는 것이 가능한 경우가 있지만, 대부분의 경우에는 불가능하다. 가령 프린터를 수행하는 중간에 다른 프로세스가 이를 선점하는 것은 불가능하다고 볼 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보유 및 대기(Hold &amp;amp; Wait)
    &lt;ul&gt;
      &lt;li&gt;이 조건을 없애려면 자원을 가지고 있는 상태에서 다른 자원을 기다리지 않도록 만든다. 만약 여러 개의 자원이 필요하다면 필요한 모든 자원을 얻을 수 있는 경우에만 해당 자원을 요청한다. 또는 필요한 자원 중 일부만 가지는 경우 할당받은 자원을 모두 운영체제에 반납한다. 하지만 이와 같은 방법은 자원의 활용률을 저하시키고, starvation 현상이 발생하는 단점이 있다.&lt;/li&gt;
      &lt;li&gt;왼쪽 젓가락을 가진 상태에서 오른쪽 젓가락을 요청했는데, 이미 할당되어 있다면, 왼쪽 젓가락도 할당해제 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;환형대기(Circular wait)
    &lt;ul&gt;
      &lt;li&gt;이 조건을 없애는 것은 위 세 가지 조건보다는 할 수 있는 확률이 높다. 대표적인 예는 모든 자원에 번호를 부여하여 이 번호에 대한 오름차순으로 자원을 요청하는 것이다. 이 역시 자원의 활용률을 저하시키는 단점이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;네 가지 방법을 살펴본 결과 가장 현실적인 방법은 hold &amp;amp; wait나 circular wait 조건을 없애는 것이다. 하지만 둘 다 자원을 비효율적으로 사용하게 되는 단점을 가지고 있다. 그래서 이와 같이 &lt;strong&gt;교착상태 방지 방법은 군사, 우주, 의료와 같은 크리티컬한 곳에서 사용&lt;/strong&gt;하는 것이 좋다.&lt;/p&gt;

&lt;h4 id=&quot;철학자-문제에-적용&quot;&gt;철학자 문제에 적용&lt;/h4&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78472610-47573d00-7775-11ea-9eb0-567f6692bff1.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.&lt;/p&gt;

&lt;p&gt;Circular wait 조건을 없애기 위해 짝수 번호 철학자는 왼쪽 젓가락, 오른쪽 젓가락 순서로, 홀수 번호 철학자는 반대 순서인 오른쪽 젓가락, 왼쪽 젓가락 순서로 집는다고 하자.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/37871541/78472763-6f936b80-7776-11ea-825c-1aae6243a708.png&quot; class=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 circular wait 조건을 없앤 식사하는 철학자 문제의 자원 할당도이다. 화살표가 원형을 만들지 않는 것을 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Philosopher Thread run function&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;lstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;rstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;rstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;lstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;lstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;rstick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이전 글에서 있던 철학자가 젓가락을 집는 코드를 수정했다. 위와 같이 코드를 변경하고 실제로 수행하면 무한 반복문이 끝나지않고 정상적으로 계속되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;42-교착상태-회피-deadlock-avoidance&quot;&gt;4.2 교착상태 회피 (Deadlock Avoidance)&lt;/h3&gt;

&lt;p&gt;교착상태 회피와 방지의 차이점은 교착상태를 다르게 접근하는 것이다. 교착상태 회피에서는 교착상태를 &lt;strong&gt;자원 요청에 대한 잘못된 승인으로 판단&lt;/strong&gt;한다. OS단에서 요청에 대해 잘 관리를 해주었다면 해결할 수 있다고 생각하는 것이다.&lt;/p&gt;

&lt;p&gt;이러한 접근은 은행과 비슷하다. 은행이 투자를 할 때, 안전한 곳과 안전하지 않은 곳을 잘 분리하여 투자해야, 위기 상황에서 부도가 나지 않을 것이다. 마찬가지로, OS에서 deadlock이 나지 않는 방법으로 할당해주는 방법이 교착 상태 회피이다.&lt;/p&gt;

&lt;p&gt;따라서, 교착상태 회피에서는 안전한 할당(Safe allocation)과 불안정한 할당(Unsafe allocation) 두 가지로 나뉜다.&lt;/p&gt;

&lt;h4 id=&quot;안전한-할당&quot;&gt;안전한 할당&lt;/h4&gt;

&lt;p&gt;현재 운영체제에는 magnetic tape 자원이 총 12개가 있고, 이를 요청하는 3개의 프로세스가 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Max needs&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Current needs&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Current needs
    &lt;ul&gt;
      &lt;li&gt;한 프로세스가 한 번 요청을 할 때 요구하는 개수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Max needs
    &lt;ul&gt;
      &lt;li&gt;프로세스를 정상적으로 끝내기 위해 필요한 총 개수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;운영체제 입장에서 3개의 프로세스가 모두 수행될 때까지 자원을 분배해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;order : 순서&lt;/li&gt;
  &lt;li&gt;process : 프로세스 이름&lt;/li&gt;
  &lt;li&gt;needs : 프로세스가 필요로 하는 tape의 개수&lt;/li&gt;
  &lt;li&gt;possible : 할당이 가능한지 판단하는 변수&lt;/li&gt;
  &lt;li&gt;state : 해당 프로세스의 진행 상태&lt;/li&gt;
  &lt;li&gt;dealloc : 할당 해제 되었는지 확인하는 변수&lt;/li&gt;
  &lt;li&gt;tapeSize : 현재까지 할당되어 사용할 수 있는 tape의 개수&lt;/li&gt;
  &lt;li&gt;wait : 할당 받지 못해 대기하는 지 유무&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;order&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;needs&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;possible&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;state&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;dealloc&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;tapeSize&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;wait&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5/10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12-&amp;gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2/4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7-&amp;gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5-&amp;gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5/10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4/4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3-&amp;gt;1-&amp;gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10/10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5-&amp;gt;0-&amp;gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10-&amp;gt;8-&amp;gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12-&amp;gt;10-&amp;gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12-&amp;gt;10-&amp;gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12-&amp;gt;11-&amp;gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;P0에게 5개를 할당한다.(5/10) =&amp;gt; 현재 magnetic tape 개수: 7&lt;/li&gt;
  &lt;li&gt;P1에게 2개를 할당한다.(2/4) =&amp;gt; 현재 magnetic tape 개수: 5&lt;/li&gt;
  &lt;li&gt;P2에게 2개를 할당한다.(2/9) =&amp;gt; 현재 magnetic tape 개수: 3&lt;/li&gt;
  &lt;li&gt;다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 3개이므로 할당해줄 수 없다.&lt;/li&gt;
  &lt;li&gt;P1에게 2개를 할당한다.(4/4) =&amp;gt; 현재 magnetic tape 개수: 1
    &lt;ul&gt;
      &lt;li&gt;P1은 필요한 4개의 magnetic tape을 받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&amp;gt; 현재 magnetic tape 개수: 5&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대기하고 있던 P0에게 5개를 할당한다.(10/10) =&amp;gt; 현재 magnetic tape 개수: 0
    &lt;ul&gt;
      &lt;li&gt;P0 역시 필요한 자원을 모두 할당받았으므로, 종료 후 자원을 반납한다. =&amp;gt; 현재 magnetic tape 개수: 10&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;P2는 현재 필요한 magnetic tape 개수가 7개이고, 현재 남아있는 magnetic tape 개수 10개이므로 정상적으로 수행가능하다. (7~10)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 예제에서는 3개의 프로세스가 모두 정상적으로 자원을 할당받고 종료할 수 있었다. 이를 안전한 할당이라 한다. 다음 예제를 보자.&lt;/p&gt;

&lt;h4 id=&quot;불안전한-할당&quot;&gt;불안전한 할당&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Max needs&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Current needs&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 예제 역시 운영체제가 보유하고 있는 총 magnetic tape 개수는 12개이고, 3개의 프로세스가 존재한다. 자원을 분배해보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;order&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;process&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;needs&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;possible&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;state&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;dealloc&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;tapeSize&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;wait&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5/10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12-&amp;gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2/4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7-&amp;gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5-&amp;gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5/10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4/4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2-&amp;gt;0-&amp;gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5/10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4-&amp;gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5/10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5/10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6/9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$\vdots$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;P0에게 5개를 할당한다.(5/10) =&amp;gt; 현재 magnetic tape 개수: 7&lt;/li&gt;
  &lt;li&gt;P1에게 2개를 할당한다.(2/4) =&amp;gt; 현재 magnetic tape 개수: 5&lt;/li&gt;
  &lt;li&gt;P2에게 3개를 할당한다.(3/9) =&amp;gt; 현재 magnetic tape 개수: 2&lt;/li&gt;
  &lt;li&gt;다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 2개이므로 할당해줄 수 없다.&lt;/li&gt;
  &lt;li&gt;P1에게 2개를 할당한다.(4/4) =&amp;gt; 현재 magnetic tape 개수: 0
    &lt;ul&gt;
      &lt;li&gt;P1은 필요한 자원을 모두 할당받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&amp;gt; 현재 magnetic tape 개수: 4&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대기하고 있던 P0는 아직 할당받으르 수 없다.&lt;/li&gt;
  &lt;li&gt;P2에게 3개를 할당한다.(6/9) =&amp;gt; 현재 magnetic tape 개수: 1&lt;/li&gt;
  &lt;li&gt;현재 남아있는 magnetic tape 개수는 1개이고, P0가 요구하는 개수는 5개, P2는 3개이므로 두 프로세스 모두 할당받을 수 없다. (8~)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 예제에서 남은 magnetic tape 개수가 요구하는 개수보다 적으므로 자원을 할당해줄 수 없다. 그러므로 P0, P2 프로세스는 자원을 하염없이 기다리게 된다. 이를 불안전한 할당이라 하고, 그 결과 교착상태에 빠지게 된다.&lt;/p&gt;

&lt;p&gt;교착상태 회피는 마치 대출전문 은행과 유사하게 동작하므로, 해결 방법을 &lt;strong&gt;Banker’s Algorithm&lt;/strong&gt;이라 한다. &lt;del&gt;돈이 있어야 값지&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;43-교착상태-검출-및-복구-deadlock-detection--recovery&quot;&gt;4.3 교착상태 검출 및 복구 (Deadlock Detection &amp;amp; Recovery)&lt;/h2&gt;

&lt;p&gt;교착상태 검출 및 복구는 교착상태 자체가 매우 드문 현상이므로 자유롭게 자원을 분배하다가 교착상태가 발생하면 이를 정상적인 상태로 복구하는 것이다.&lt;/p&gt;

&lt;p&gt;1번과 2번 방법은 사전에 교착상태를 일어나지 않도록 하는 방법이지만, 교착상태 검출 및 복구 방법은 교착상태가 일어나는 것을 허용한다. 그 대신, 교착상태가 일어났을 때 이를 인지하고 복구를 해야 한다.&lt;/p&gt;

&lt;p&gt;교착상태가 일어나는 것을 감지하기 위해 운영체제 내부에서 주기적으로 교착상태가 발생하였는지 검사해야한다. 그 주기의 길이가 짧으면 그 만큼 오버헤드가 크고, 주기가 길면 오버헤드는 줄일 수 있지만 복구 가능성이 낮아진다.&lt;/p&gt;

&lt;p&gt;복구하는 방법은 교착상태가 발생하는지 주기적으로 검사하듯이 메모리의 상태를 주기적으로 메모리에 저장해놓고 만약 교착상태가 발생하면 그 이전 상태로 되돌리는 방법이 있다. 그 외에도 일부 프로세스를 강제로 종료하거나 자원을 강제로 선점하여 프로세스에게 할당해주는 방법 등이 있다.&lt;/p&gt;

&lt;p&gt;정상적인 상태로 복구한다는 장점이 있지만, 복구를 제대로 하지 못할 수도 있고, 검출을 위해 추가적인 오버헤드가 발생한다는 단점이 있다.&lt;/p&gt;

&lt;h2 id=&quot;34-교착상태-무시&quot;&gt;3.4 교착상태 무시&lt;/h2&gt;

&lt;p&gt;교착상태의 필요조건 네 가지를 모두 만족하더라도 교착상태가 반드시 일어나는 것이 아니라고 했듯이, 교착상태는 매우 드문 상황이다. 그러므로 이를 위해 오버헤드를 감수하는 것이 비효율적인 환경도 존재한다. 그러한 환경은 교착상태에 대한 아무런 조치를 하지 않는 방법도 있다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot;&gt;KOCW 양희재 교수님 - 운영체제&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/PostList.nhn?blogId=hjyang0&amp;amp;categoryNo=13&quot;&gt;양희재 교수님 블로그(시험 기출 문제)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@codemcd/&quot;&gt;codemcd 님의 정리글&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/wndrlf2003/220011819891&quot;&gt;세마포 사진&lt;/a&gt;&lt;br /&gt;
Operating System Concepts, 9th Edition - Abraham Silberschatz&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Apr 2020 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
