<!DOCTYPE html>
<head>
  
</head>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | 완숙의 에그머니🍳</title>
	<meta name="description"
		content="얼떨결에 들어왔으니 이것도 인연😌">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="완숙의 에그머니🍳"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Nanum+Gothic|Jua|Nanum+Gothic+Coding|Source+Code+Pro|Nanum+Myeongjo:400|Noto+Sans+KR:100,300" rel="stylesheet"
		type="text/css">
	

	<!-- naver web mater tool -->
	<meta name="naver-site-verification" content="da86adfc2aa8cdd5f1d573b50497f3e29de44cd5" />

	<!-- KaTeX -->
    <!--
	

    -->
	<!-- Google Analytics -->
	
	<script>
		(function (i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date(); a = s.createElement(o),
			m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'UA-156961472-1', 'auto');
		ga('send', 'pageview');
	</script>
	
  
  <!-- Latex -->
<!--
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
-->
  
    
	<script>
console.log(window)

window.addEventListener("resize", changeContent);
window.addEventListener("load", changeContent);

function changeContent(event){
  const width = window.innerWidth;
  console.log(event);
  const cat = document.getElementById("js-cat");
  const cv = document.getElementById("category-cv");
  const math = document.getElementById("category-math");
  const ds = document.getElementById("category-ds");
  const cs = document.getElementById("category-cs");
  const dv = document.getElementById("category-dv");
  const about = document.getElementById("category-about");
  if (width < 710) {
    cv.innerText = "📜"
    math.innerText = "✖"
    ds.innerText = "📈"
    cs.innerText = "💾"
    dv.innerText = "📱"
    about.innerText = "😎"
    cat.style.justifyContent = "space-around"
  } else {
    cv.innerText = "CV"
    math.innerText = "Math"
    ds.innerText = "Data Science"
    cs.innerText = "Computer Science"
    dv.innerText = "Development"
    about.innerText = "About"
    cat.style.justifyContent = "center"
  }
  
}

</script>

	 
</head>
  <body>
    <header class="site-header">
  <div class="site-title-nav">
    <div class="branding">
      
      <a href="/">
        <img
          class="avatar"
          src="/assets/img/avatar.png"
          alt=""
        />
      </a>
      
      <h1 class="site-title">
        <a href="/">완숙의 에그머니🍳</a>
      </h1>
    </div>
  </div>
  <nav class="site-nav">
    <ul>
      <!--
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                <li>
                    <a class="page-link" href="/about/">
                        About Me
                    </a>
                </li>
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
-->
      <!-- Social icons from Font Awesome, if enabled  -->
      <!--                


<li>
	<a href="mailto:wansook0316@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/wansook0316" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>





























-->

      <!-- Search bar -->
      <li>


<li>
	<a href="mailto:wansook0316@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/wansook0316" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>





























</li>
      
      <li>
        <form action="/search.html" method="get">
          <input
            type="text"
            id="search-box"
            name="query"
            placeholder="Search"
            class=""
          />
          <button type="submit" class="">
            <i class="fa fa-fw fa-search"></i>
          </button>
        </form>
      </li>
      
    </ul>
  </nav>
</header>

<div class="site-category">
  <ul class="cat1" id="js-cat">
    <li>
      <a id="category-cv" href="/"> </a>
      <ul>
        <li><a href="/CV/Projects">Projects</a></li>
        <li><a href="/CV/Awards">Awards</a></li>
        <li><a href="/CV/Papers">Papers</a></li>
        <li><a href="/CV/ExtraAct">ExtraCurricular Act</a></li>
        <li><a href="/CV/InternShip">InternShip</a></li>
        <li><a href="/CV/Language">Language</a></li>
        <li><a href="/CV/Education">Education</a></li>
        <li><a href="/CV/Cources">Cources</a></li>
      </ul>
    </li>

    <li>
      <a id="category-math" href="/"> </a>
      <ul>
        <li><a href="/Math/Statistics">Statistics</a></li>
        <li><a href="/Math/Linear Algebra">Linear Algebra</a></li>
        <li><a href="/Math/Calculus">Calculus</a></li>
        <li><a href="/Math/Finance">Finance</a></li>
      </ul>
    </li>

    <li>
      <a id="category-ds" href="/"> </a>
      <ul>
        <li><a href="/DS/R">R</a></li>
        <li><a href="/DS/ESL">ESL</a></li>
        <li><a href="/DS/DL">Deep Learning</a></li>
        <li><a href="/DS/ML">Machine Learning</a></li>
        <li><a href="/DS/Visualization">Visualization</a></li>
      </ul>
    </li>

    <li>
      <a id="category-cs" href="/"> </a>
      <ul>
        <li><a href="/CS/Network">Network</a></li>
        <li><a href="/CS/Database">Database</a></li>
        <li><a href="/CS/Algorithm">Algorithm</a></li>
        <li><a href="/CS/Structure">Structure</a></li>
        <li><a href="/CS/Parallel">Parallel</a></li>
        <li><a href="/CS/OS">OS</a></li>
      </ul>
    </li>

    <li>
      <a id="category-dv" href="/"> </a>
      <ul>
        <li><a href="/DV/Server">Server</a></li>
        <li><a href="/DV/Linux">Linux</a></li>
        <li><a href="/DV/Python">Python</a></li>
        <li><a href="/DV/C++">C++</a></li>
        <li><a href="/DV/JavaScript">JavaScript</a></li>
        <li><a href="/DV/HTML-CSS">HTML/CSS</a></li>
        <li><a href="/DV/React">React</a></li>
        <li><a href="/DV/Django">Django</a></li>
        <li><a href="/DV/Docker">Docker</a></li>
        <li><a href="/DV/Git">Git</a></li>
        <li><a href="/DV/Tips">Tips</a></li>
        <li><a href="/DV/SP">Side Project</a></li>
      </ul>
    </li>

    <li><a id="category-about" href="/about/"> </a></li>

    <!--    <ul class="cat2">-->

    <!--  </ul>-->
  </ul>
</div>

    <div class="content"><article class="feature-image">
  <header style="background-image: url('/assets/img/30.jpg')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">

    <div id="search-results"></div> 
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "ds-dl-2020-09-07-computer-vision-07-mask-rcnn-html": {
        "title": "05: Faster R-CNN",
        "tags": "DS, paper review",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "핵심 아이디어  Region Proposal도 Network안에 포함시키자!Faster R-CNN의 핵심 아이디어는 Resion Proposal Network(이하 RPN)이다. 기존 Fast R-CNN구조를 계승하면서 selective search를 제거하고 RPN을 통해서 Roi를 계산한다. 이를 통해서 GPU를 통해 Roi를 계산할 수 있게 되었고, 이 RoI를 추출하는 것 역시 학습시켜 정확도를 높일 수 있다. 결과적으로 selective search가 2000개 RoI를 계산하는데 반해, 800개 정도로 더 높은 정확도를 가진다.Faster R-CNN structure그림을 보면 알겠지만, feature map으로 부터 selective search를 거치치 않고 이를 RPN에 전달하여 계산을 진행한다. 여기서 얻은 RoI로 RoI Pooling을 진행한 다음 object detection을 진행한다.Region Proposal NetworkRegion Proposal Network structure이 그림보다는 순차적으로 된 그림으로 이해하는 것이 쉽다.Region Proposal Network structureCNN을 통해 뽑아낸 feature map을 입력으로 받는다. 어떤 pretrained model을 사용할 지 모르므로 이를 HxWxC로 둔다.feature map에 (3x3)x256 또는 (3x3)x512 conv 연산을 수행한다. 엄밀히 말하면 C와 256, 512는 같아야 한다. 일단 연산이 가능하다고 가정하자. 이 때, HxW가 보존될 수 있게 padding을 1로 설정한다.전 과정에서 나온 feature map을 가지고 classification을 위한 확률값과, bounding box regression 값을 뽑아낸다. 이 과정에서 너무 많은 연산을 진행하게 되면 모델이 지나치게 무거워 진다. 저자들은 1 x 1 conv만을 수행하여 예측값을 뽑아내고자 하였다.Anchor먼저 Classification의 경우, 더욱 가볍게 진행하기 위해 물체인지 아닌지를 구분하는 binary classification을 진행하고자 하였다. 하지만 이 문제는 bounding box와 엮어서 이를 생각해야 하는데, 저자들은 이 단계에서 Anchor라는 개념을 도입하여 이를 진행하였다. Anchor는 간단하게 사전에 정의해 둔 Box들이다. 총 9개를 사용하였다.이 모든 내용을 정리하면, classification의 결과는 총 (HxW)의 각각의 위치에 제안된 Anchor(9개)에 대해 물체의 여부(2)를 나타내는 총 18개의 Node를 가져야 한다. 그러기 위해 (1x1)x(2x9)의 conv 연산을 진행하였다. 결과적으로 (HxW)x(2x9)의 Feature map이 나오고, 각각의 노드는 순서대로 (h, w) 위치에 있는 1번 anchor가 물체일 logit, (h, w) 위치에 있는 1번 anchor가 물체가 아닐 logit … 로 정의된다. 최종적으로 이를 확률 값으로 변경해주기 위해 적절히 reshape 해준 다음 Softmax를 적용한다.두번째로 Bounding Box Regression을 진행한다. 같은 방법을 사용한다. 이번에는 9개 anchor에 대해 총 4개의 좌표를 수정하기 위한 조절값을 예측해야 하므로 (H W)x(4x9)의 결과를 얻어야 한다. 이번에는 regression이기 때문에 그대로 결과값으로 사용하면 된다.앞선 과정은 순차적으로 진행된다. 즉, classification을 먼저 진행하고, 이 결과를 기반으로 물체일 확률을 sorting한다. 이 중 높은 순으로 K개의 anchor를 후보군으로 선정한다. 이 후보군에 각각 bounding Box Regression을 진행한다. 마지막으로 Non-Maximum-Suppression을 적용하고, 이것을 기반으로 RoI를 제안한다.이러한 방법을 통해서 RoI를 제안하는 Network를 만들었다. 이 후 과정은, 이렇게 만들어진 RoI를 첫번째 Feature map (HxWxC) 에 투영하는 과정을 거친다. 이 부분은 Fast R-CNN 구조와 같다.RPN’s Loss functionRPN은 앞서서 Classification과 Bouding Box Regression을 수행했다. 로스 펑션은 이 두 가지 테스크에서 얻은 로스를 엮은 형태를 취하고 있다.여기서 i는 하나의 anchor를 말한다. $p_i$는 classification을 통해서 얻은 해당 anchor가 object일 확률을 의미한다. $t_i$는 bounding box regression을 통해서 얻은 박스 조정 값 벡터를 의미한다. *이 붙은 변수는 ground truth label에 해당된다.classification은 binary cross entropy, regression은 smooth L1 loss를 사용한다.주목해야 할 점은 각각 $N_{cls}$와 $N_{reg}$를 가진다는 점이다. $N_{cls}$는 minibatch 사이즈이며 논문에서는 256입니다. $N_{reg}$는 엥커 개수에 해당하며 약 2400개 (256 x 9)에 해당한다. 실제 실험을 진행했을 떄 이부분이 큰 부분을 담당하지는 않는다고 말한다. \\lambda는 Classifiaction Loss와 Regression Loss 사이에 가중치를 조절해주는 부분인데 논문에서는 10으로 설정되어 있어, 사실상 두 로스는 동일하게 가중치가 매겨진다. 이후는 Fast R-CNN 구조와 같다. 이제 남은 것은 어떻게 이 두 네트워크를 학습시키느냐에 대한 것이다.Training Method하지만 전체 모델을 한번에 학습시키기란 매우 어려운 작업이다. RPN이 제대로 RoI를 계산해내지 못하는데 뒷 단의 Classification 레이어가 학습될 리가 없다. 여기서 저자들은 4단계에 걸쳐서 모델을 번갈아서 학습시키는 Alternating Training 기법을 취한다. 말이 어렵지 그냥 따로 하고 지지고 볶으면서 학습시킨거다.  ImageNet pretrained 모델을 불러온 다음, RPN을 학습시킨다.  1 단계에서 학습시킨 RPN에서 기본 CNN을 제외한 Region Proposal 레이어만 가져온다. 이를 활용하여 Fast RCNN을 학습시킨다. 이 때 , 처음 피쳐맵을 추출하는 CNN까지 fine tune 시킨다.  앞서 학습시킨 Fast RCNN과 RPN을 불러온 다음, 다른 웨이트들은 고정하고 RPN에 해당하는 레이어들만 fine tune 시킨다. 여기서부터 RPN과 Fast RCNN이 컨볼루션 웨이트를 공유하게 된다.  마지막으로 공유하는 CNN과 RPN은 고정시킨 채, Fast R-CNN에 해당하는 레이어만 fine tune 시킨다.의의  region proposal을 한번에 수행한계  여전히 real time이라고 하기에는 무리가 있음  여전히 학습과정이 복잡하고 2step 임Reference갈아먹는 Object Detection [4] Faster R-CNN",
        
        "url": "/ds/dl/2020/09/07/computer-vision-07-Mask-RCNN.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-07-learning-deconvolutional-network-for-semantic-segmentation-html": {
        "title": "05: Faster R-CNN",
        "tags": "DS, paper review",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "핵심 아이디어  Region Proposal도 Network안에 포함시키자!Faster R-CNN의 핵심 아이디어는 Resion Proposal Network(이하 RPN)이다. 기존 Fast R-CNN구조를 계승하면서 selective search를 제거하고 RPN을 통해서 Roi를 계산한다. 이를 통해서 GPU를 통해 Roi를 계산할 수 있게 되었고, 이 RoI를 추출하는 것 역시 학습시켜 정확도를 높일 수 있다. 결과적으로 selective search가 2000개 RoI를 계산하는데 반해, 800개 정도로 더 높은 정확도를 가진다.Faster R-CNN structure그림을 보면 알겠지만, feature map으로 부터 selective search를 거치치 않고 이를 RPN에 전달하여 계산을 진행한다. 여기서 얻은 RoI로 RoI Pooling을 진행한 다음 object detection을 진행한다.Region Proposal NetworkRegion Proposal Network structure이 그림보다는 순차적으로 된 그림으로 이해하는 것이 쉽다.Region Proposal Network structureCNN을 통해 뽑아낸 feature map을 입력으로 받는다. 어떤 pretrained model을 사용할 지 모르므로 이를 HxWxC로 둔다.feature map에 (3x3)x256 또는 (3x3)x512 conv 연산을 수행한다. 엄밀히 말하면 C와 256, 512는 같아야 한다. 일단 연산이 가능하다고 가정하자. 이 때, HxW가 보존될 수 있게 padding을 1로 설정한다.전 과정에서 나온 feature map을 가지고 classification을 위한 확률값과, bounding box regression 값을 뽑아낸다. 이 과정에서 너무 많은 연산을 진행하게 되면 모델이 지나치게 무거워 진다. 저자들은 1 x 1 conv만을 수행하여 예측값을 뽑아내고자 하였다.Anchor먼저 Classification의 경우, 더욱 가볍게 진행하기 위해 물체인지 아닌지를 구분하는 binary classification을 진행하고자 하였다. 하지만 이 문제는 bounding box와 엮어서 이를 생각해야 하는데, 저자들은 이 단계에서 Anchor라는 개념을 도입하여 이를 진행하였다. Anchor는 간단하게 사전에 정의해 둔 Box들이다. 총 9개를 사용하였다.이 모든 내용을 정리하면, classification의 결과는 총 (HxW)의 각각의 위치에 제안된 Anchor(9개)에 대해 물체의 여부(2)를 나타내는 총 18개의 Node를 가져야 한다. 그러기 위해 (1x1)x(2x9)의 conv 연산을 진행하였다. 결과적으로 (HxW)x(2x9)의 Feature map이 나오고, 각각의 노드는 순서대로 (h, w) 위치에 있는 1번 anchor가 물체일 logit, (h, w) 위치에 있는 1번 anchor가 물체가 아닐 logit … 로 정의된다. 최종적으로 이를 확률 값으로 변경해주기 위해 적절히 reshape 해준 다음 Softmax를 적용한다.두번째로 Bounding Box Regression을 진행한다. 같은 방법을 사용한다. 이번에는 9개 anchor에 대해 총 4개의 좌표를 수정하기 위한 조절값을 예측해야 하므로 (H W)x(4x9)의 결과를 얻어야 한다. 이번에는 regression이기 때문에 그대로 결과값으로 사용하면 된다.앞선 과정은 순차적으로 진행된다. 즉, classification을 먼저 진행하고, 이 결과를 기반으로 물체일 확률을 sorting한다. 이 중 높은 순으로 K개의 anchor를 후보군으로 선정한다. 이 후보군에 각각 bounding Box Regression을 진행한다. 마지막으로 Non-Maximum-Suppression을 적용하고, 이것을 기반으로 RoI를 제안한다.이러한 방법을 통해서 RoI를 제안하는 Network를 만들었다. 이 후 과정은, 이렇게 만들어진 RoI를 첫번째 Feature map (HxWxC) 에 투영하는 과정을 거친다. 이 부분은 Fast R-CNN 구조와 같다.RPN’s Loss functionRPN은 앞서서 Classification과 Bouding Box Regression을 수행했다. 로스 펑션은 이 두 가지 테스크에서 얻은 로스를 엮은 형태를 취하고 있다.여기서 i는 하나의 anchor를 말한다. $p_i$는 classification을 통해서 얻은 해당 anchor가 object일 확률을 의미한다. $t_i$는 bounding box regression을 통해서 얻은 박스 조정 값 벡터를 의미한다. *이 붙은 변수는 ground truth label에 해당된다.classification은 binary cross entropy, regression은 smooth L1 loss를 사용한다.주목해야 할 점은 각각 $N_{cls}$와 $N_{reg}$를 가진다는 점이다. $N_{cls}$는 minibatch 사이즈이며 논문에서는 256입니다. $N_{reg}$는 엥커 개수에 해당하며 약 2400개 (256 x 9)에 해당한다. 실제 실험을 진행했을 떄 이부분이 큰 부분을 담당하지는 않는다고 말한다. \\lambda는 Classifiaction Loss와 Regression Loss 사이에 가중치를 조절해주는 부분인데 논문에서는 10으로 설정되어 있어, 사실상 두 로스는 동일하게 가중치가 매겨진다. 이후는 Fast R-CNN 구조와 같다. 이제 남은 것은 어떻게 이 두 네트워크를 학습시키느냐에 대한 것이다.Training Method하지만 전체 모델을 한번에 학습시키기란 매우 어려운 작업이다. RPN이 제대로 RoI를 계산해내지 못하는데 뒷 단의 Classification 레이어가 학습될 리가 없다. 여기서 저자들은 4단계에 걸쳐서 모델을 번갈아서 학습시키는 Alternating Training 기법을 취한다. 말이 어렵지 그냥 따로 하고 지지고 볶으면서 학습시킨거다.  ImageNet pretrained 모델을 불러온 다음, RPN을 학습시킨다.  1 단계에서 학습시킨 RPN에서 기본 CNN을 제외한 Region Proposal 레이어만 가져온다. 이를 활용하여 Fast RCNN을 학습시킨다. 이 때 , 처음 피쳐맵을 추출하는 CNN까지 fine tune 시킨다.  앞서 학습시킨 Fast RCNN과 RPN을 불러온 다음, 다른 웨이트들은 고정하고 RPN에 해당하는 레이어들만 fine tune 시킨다. 여기서부터 RPN과 Fast RCNN이 컨볼루션 웨이트를 공유하게 된다.  마지막으로 공유하는 CNN과 RPN은 고정시킨 채, Fast R-CNN에 해당하는 레이어만 fine tune 시킨다.의의  region proposal을 한번에 수행한계  여전히 real time이라고 하기에는 무리가 있음  여전히 학습과정이 복잡하고 2step 임Reference갈아먹는 Object Detection [4] Faster R-CNN",
        
        "url": "/ds/dl/2020/09/07/computer-vision-07-Learning-Deconvolutional-Network-for-Semantic-Segmentation.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-06-fully-convolutional-networks-html": {
        "title": "05: Faster R-CNN",
        "tags": "DS, paper review",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "핵심 아이디어  Region Proposal도 Network안에 포함시키자!Faster R-CNN의 핵심 아이디어는 Resion Proposal Network(이하 RPN)이다. 기존 Fast R-CNN구조를 계승하면서 selective search를 제거하고 RPN을 통해서 Roi를 계산한다. 이를 통해서 GPU를 통해 Roi를 계산할 수 있게 되었고, 이 RoI를 추출하는 것 역시 학습시켜 정확도를 높일 수 있다. 결과적으로 selective search가 2000개 RoI를 계산하는데 반해, 800개 정도로 더 높은 정확도를 가진다.Faster R-CNN structure그림을 보면 알겠지만, feature map으로 부터 selective search를 거치치 않고 이를 RPN에 전달하여 계산을 진행한다. 여기서 얻은 RoI로 RoI Pooling을 진행한 다음 object detection을 진행한다.Region Proposal NetworkRegion Proposal Network structure이 그림보다는 순차적으로 된 그림으로 이해하는 것이 쉽다.Region Proposal Network structureCNN을 통해 뽑아낸 feature map을 입력으로 받는다. 어떤 pretrained model을 사용할 지 모르므로 이를 HxWxC로 둔다.feature map에 (3x3)x256 또는 (3x3)x512 conv 연산을 수행한다. 엄밀히 말하면 C와 256, 512는 같아야 한다. 일단 연산이 가능하다고 가정하자. 이 때, HxW가 보존될 수 있게 padding을 1로 설정한다.전 과정에서 나온 feature map을 가지고 classification을 위한 확률값과, bounding box regression 값을 뽑아낸다. 이 과정에서 너무 많은 연산을 진행하게 되면 모델이 지나치게 무거워 진다. 저자들은 1 x 1 conv만을 수행하여 예측값을 뽑아내고자 하였다.Anchor먼저 Classification의 경우, 더욱 가볍게 진행하기 위해 물체인지 아닌지를 구분하는 binary classification을 진행하고자 하였다. 하지만 이 문제는 bounding box와 엮어서 이를 생각해야 하는데, 저자들은 이 단계에서 Anchor라는 개념을 도입하여 이를 진행하였다. Anchor는 간단하게 사전에 정의해 둔 Box들이다. 총 9개를 사용하였다.이 모든 내용을 정리하면, classification의 결과는 총 (HxW)의 각각의 위치에 제안된 Anchor(9개)에 대해 물체의 여부(2)를 나타내는 총 18개의 Node를 가져야 한다. 그러기 위해 (1x1)x(2x9)의 conv 연산을 진행하였다. 결과적으로 (HxW)x(2x9)의 Feature map이 나오고, 각각의 노드는 순서대로 (h, w) 위치에 있는 1번 anchor가 물체일 logit, (h, w) 위치에 있는 1번 anchor가 물체가 아닐 logit … 로 정의된다. 최종적으로 이를 확률 값으로 변경해주기 위해 적절히 reshape 해준 다음 Softmax를 적용한다.두번째로 Bounding Box Regression을 진행한다. 같은 방법을 사용한다. 이번에는 9개 anchor에 대해 총 4개의 좌표를 수정하기 위한 조절값을 예측해야 하므로 (H W)x(4x9)의 결과를 얻어야 한다. 이번에는 regression이기 때문에 그대로 결과값으로 사용하면 된다.앞선 과정은 순차적으로 진행된다. 즉, classification을 먼저 진행하고, 이 결과를 기반으로 물체일 확률을 sorting한다. 이 중 높은 순으로 K개의 anchor를 후보군으로 선정한다. 이 후보군에 각각 bounding Box Regression을 진행한다. 마지막으로 Non-Maximum-Suppression을 적용하고, 이것을 기반으로 RoI를 제안한다.이러한 방법을 통해서 RoI를 제안하는 Network를 만들었다. 이 후 과정은, 이렇게 만들어진 RoI를 첫번째 Feature map (HxWxC) 에 투영하는 과정을 거친다. 이 부분은 Fast R-CNN 구조와 같다.RPN’s Loss functionRPN은 앞서서 Classification과 Bouding Box Regression을 수행했다. 로스 펑션은 이 두 가지 테스크에서 얻은 로스를 엮은 형태를 취하고 있다.여기서 i는 하나의 anchor를 말한다. $p_i$는 classification을 통해서 얻은 해당 anchor가 object일 확률을 의미한다. $t_i$는 bounding box regression을 통해서 얻은 박스 조정 값 벡터를 의미한다. *이 붙은 변수는 ground truth label에 해당된다.classification은 binary cross entropy, regression은 smooth L1 loss를 사용한다.주목해야 할 점은 각각 $N_{cls}$와 $N_{reg}$를 가진다는 점이다. $N_{cls}$는 minibatch 사이즈이며 논문에서는 256입니다. $N_{reg}$는 엥커 개수에 해당하며 약 2400개 (256 x 9)에 해당한다. 실제 실험을 진행했을 떄 이부분이 큰 부분을 담당하지는 않는다고 말한다. \\lambda는 Classifiaction Loss와 Regression Loss 사이에 가중치를 조절해주는 부분인데 논문에서는 10으로 설정되어 있어, 사실상 두 로스는 동일하게 가중치가 매겨진다. 이후는 Fast R-CNN 구조와 같다. 이제 남은 것은 어떻게 이 두 네트워크를 학습시키느냐에 대한 것이다.Training Method하지만 전체 모델을 한번에 학습시키기란 매우 어려운 작업이다. RPN이 제대로 RoI를 계산해내지 못하는데 뒷 단의 Classification 레이어가 학습될 리가 없다. 여기서 저자들은 4단계에 걸쳐서 모델을 번갈아서 학습시키는 Alternating Training 기법을 취한다. 말이 어렵지 그냥 따로 하고 지지고 볶으면서 학습시킨거다.  ImageNet pretrained 모델을 불러온 다음, RPN을 학습시킨다.  1 단계에서 학습시킨 RPN에서 기본 CNN을 제외한 Region Proposal 레이어만 가져온다. 이를 활용하여 Fast RCNN을 학습시킨다. 이 때 , 처음 피쳐맵을 추출하는 CNN까지 fine tune 시킨다.  앞서 학습시킨 Fast RCNN과 RPN을 불러온 다음, 다른 웨이트들은 고정하고 RPN에 해당하는 레이어들만 fine tune 시킨다. 여기서부터 RPN과 Fast RCNN이 컨볼루션 웨이트를 공유하게 된다.  마지막으로 공유하는 CNN과 RPN은 고정시킨 채, Fast R-CNN에 해당하는 레이어만 fine tune 시킨다.의의  region proposal을 한번에 수행한계  여전히 real time이라고 하기에는 무리가 있음  여전히 학습과정이 복잡하고 2step 임Reference갈아먹는 Object Detection [4] Faster R-CNN",
        
        "url": "/ds/dl/2020/09/07/computer-vision-06-Fully-Convolutional-Networks.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-05-faster-rcnn-html": {
        "title": "05: Faster R-CNN",
        "tags": "DS, paper review, Object Detection",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "핵심 아이디어  Region Proposal도 Network안에 포함시키자!Faster R-CNN의 핵심 아이디어는 Resion Proposal Network(이하 RPN)이다. 기존 Fast R-CNN구조를 계승하면서 selective search를 제거하고 RPN을 통해서 Roi를 계산한다. 이를 통해서 GPU를 통해 Roi를 계산할 수 있게 되었고, 이 RoI를 추출하는 것 역시 학습시켜 정확도를 높일 수 있다. 결과적으로 selective search가 2000개 RoI를 계산하는데 반해, 800개 정도로 더 높은 정확도를 가진다.Faster R-CNN structure그림을 보면 알겠지만, feature map으로 부터 selective search를 거치치 않고 이를 RPN에 전달하여 계산을 진행한다. 여기서 얻은 RoI로 RoI Pooling을 진행한 다음 object detection을 진행한다.Region Proposal NetworkRegion Proposal Network structure이 그림보다는 순차적으로 된 그림으로 이해하는 것이 쉽다.Region Proposal Network structureCNN을 통해 뽑아낸 feature map을 입력으로 받는다. 어떤 pretrained model을 사용할 지 모르므로 이를 HxWxC로 둔다.feature map에 (3x3)x256 또는 (3x3)x512 conv 연산을 수행한다. 엄밀히 말하면 C와 256, 512는 같아야 한다. 일단 연산이 가능하다고 가정하자. 이 때, HxW가 보존될 수 있게 padding을 1로 설정한다.전 과정에서 나온 feature map을 가지고 classification을 위한 확률값과, bounding box regression 값을 뽑아낸다. 이 과정에서 너무 많은 연산을 진행하게 되면 모델이 지나치게 무거워 진다. 저자들은 1 x 1 conv만을 수행하여 예측값을 뽑아내고자 하였다.Anchor먼저 Classification의 경우, 더욱 가볍게 진행하기 위해 물체인지 아닌지를 구분하는 binary classification을 진행하고자 하였다. 하지만 이 문제는 bounding box와 엮어서 이를 생각해야 하는데, 저자들은 이 단계에서 Anchor라는 개념을 도입하여 이를 진행하였다. Anchor는 간단하게 사전에 정의해 둔 Box들이다. 총 9개를 사용하였다.이 모든 내용을 정리하면, classification의 결과는 총 (HxW)의 각각의 위치에 제안된 Anchor(9개)에 대해 물체의 여부(2)를 나타내는 총 18개의 Node를 가져야 한다. 그러기 위해 (1x1)x(2x9)의 conv 연산을 진행하였다. 결과적으로 (HxW)x(2x9)의 Feature map이 나오고, 각각의 노드는 순서대로 (h, w) 위치에 있는 1번 anchor가 물체일 logit, (h, w) 위치에 있는 1번 anchor가 물체가 아닐 logit … 로 정의된다. 최종적으로 이를 확률 값으로 변경해주기 위해 적절히 reshape 해준 다음 Softmax를 적용한다.두번째로 Bounding Box Regression을 진행한다. 같은 방법을 사용한다. 이번에는 9개 anchor에 대해 총 4개의 좌표를 수정하기 위한 조절값을 예측해야 하므로 (H W)x(4x9)의 결과를 얻어야 한다. 이번에는 regression이기 때문에 그대로 결과값으로 사용하면 된다.앞선 과정은 순차적으로 진행된다. 즉, classification을 먼저 진행하고, 이 결과를 기반으로 물체일 확률을 sorting한다. 이 중 높은 순으로 K개의 anchor를 후보군으로 선정한다. 이 후보군에 각각 bounding Box Regression을 진행한다. 마지막으로 Non-Maximum-Suppression을 적용하고, 이것을 기반으로 RoI를 제안한다.이러한 방법을 통해서 RoI를 제안하는 Network를 만들었다. 이 후 과정은, 이렇게 만들어진 RoI를 첫번째 Feature map (HxWxC) 에 투영하는 과정을 거친다. 이 부분은 Fast R-CNN 구조와 같다.RPN’s Loss functionRPN은 앞서서 Classification과 Bouding Box Regression을 수행했다. 로스 펑션은 이 두 가지 테스크에서 얻은 로스를 엮은 형태를 취하고 있다.여기서 i는 하나의 anchor를 말한다. $p_i$는 classification을 통해서 얻은 해당 anchor가 object일 확률을 의미한다. $t_i$는 bounding box regression을 통해서 얻은 박스 조정 값 벡터를 의미한다. *이 붙은 변수는 ground truth label에 해당된다.classification은 binary cross entropy, regression은 smooth L1 loss를 사용한다.주목해야 할 점은 각각 $N_{cls}$와 $N_{reg}$를 가진다는 점이다. $N_{cls}$는 minibatch 사이즈이며 논문에서는 256입니다. $N_{reg}$는 엥커 개수에 해당하며 약 2400개 (256 x 9)에 해당한다. 실제 실험을 진행했을 떄 이부분이 큰 부분을 담당하지는 않는다고 말한다. \\lambda는 Classifiaction Loss와 Regression Loss 사이에 가중치를 조절해주는 부분인데 논문에서는 10으로 설정되어 있어, 사실상 두 로스는 동일하게 가중치가 매겨진다. 이후는 Fast R-CNN 구조와 같다. 이제 남은 것은 어떻게 이 두 네트워크를 학습시키느냐에 대한 것이다.Training Method하지만 전체 모델을 한번에 학습시키기란 매우 어려운 작업이다. RPN이 제대로 RoI를 계산해내지 못하는데 뒷 단의 Classification 레이어가 학습될 리가 없다. 여기서 저자들은 4단계에 걸쳐서 모델을 번갈아서 학습시키는 Alternating Training 기법을 취한다. 말이 어렵지 그냥 따로 하고 지지고 볶으면서 학습시킨거다.  ImageNet pretrained 모델을 불러온 다음, RPN을 학습시킨다.  1 단계에서 학습시킨 RPN에서 기본 CNN을 제외한 Region Proposal 레이어만 가져온다. 이를 활용하여 Fast RCNN을 학습시킨다. 이 때 , 처음 피쳐맵을 추출하는 CNN까지 fine tune 시킨다.  앞서 학습시킨 Fast RCNN과 RPN을 불러온 다음, 다른 웨이트들은 고정하고 RPN에 해당하는 레이어들만 fine tune 시킨다. 여기서부터 RPN과 Fast RCNN이 컨볼루션 웨이트를 공유하게 된다.  마지막으로 공유하는 CNN과 RPN은 고정시킨 채, Fast R-CNN에 해당하는 레이어만 fine tune 시킨다.의의  region proposal을 한번에 수행한계  여전히 real time이라고 하기에는 무리가 있음  여전히 학습과정이 복잡하고 2step 임Reference갈아먹는 Object Detection [4] Faster R-CNN",
        
        "url": "/ds/dl/2020/09/02/computer-vision-05-Faster-RCNN.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-04-fast-rcnn-html": {
        "title": "04: Fast R-CNN",
        "tags": "DS, paper review",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "핵심 아이디어  Feature Extraction, classification, bounding box regression까지 한번에 학습할 수 있는 모델을 만들자!Fast R-CNN은 이전 SSP Net이 가지는 한계점을 극복하는 시도에서 출발한다. SSP Net은 1) Multi stage model이고 2) FC layer 만 학습 시킬 수 있다는 한계점이 있었다.Fast R-CNN Architecture알고리즘  pretrained model로 부터 feature map을 추출한다.  Selective Search를 통해 찾은 각각의 ROI에 대해 *ROI Pooling을 진행한다. 그 결과로 고정된 크기의 feature vector를 얻는다.  feature vector는 FC layer를 통과하고 두개의 branch로 나뉜다.  하나의 branch에서는 softmax를 통과하여 해당 ROI가 어떤 물체인지 clasification을 진행한다.  다른 branch에서는 bounding box regression을 통해 selective search로 찾은 박스의 위치를 조정한다.핵심 의의는 multi stage model에서 end-to-end로 model을 구성했다는 것에 있다. 결과적으로도 속도, 정확도, 학습 속도 모두를 향상시켰다는데 의의가 있다.ROI pollingRoi pooling의 아이디어는 앞서 보았던 SPP Net과 유사하다. SPP Net은, pretrained model으로 부터 도출되는 feature map으로 부터, 피라미드 filter를 거친 후 이를 vectorize 하여 고정된 개수의 vector를 얻을 수 있었다. 이 아이디어를 조금 변경하여 제시하는 것이 Roi pooling이다.ROI pooling  feature map에서 Selective search를 통해 Resion Proposal을 진행한다.  이 proposal에 Roi pooling을 진행하여 고정된 형태의 작은 feature map을 만든다.Roi pooling은, Resion Proposal을 고정된 형태의 output 모양으로 바꾼다. (H x W) 크기의 feature map을 output으로 원한다면, proposal을 이에 맞게 칸을 나눈 후, max pooling을 진행한다. 이렇게 되면 항상 같은 크기의 결과를 얻을 수 있다.Multi Task Loss딥러닝을 공부하면서 가장 새롭고 즐거웠던 부분은 손실함수 부분이었다. object detection은 기본적으로 bounding box regression과 classication을 동시에 진행해야 하는 Task이다. 그래서 예전 접근은 multi stage로 이루어졌었다. 하지만 이 Fast R-CNN에서 처음으로 이 두가지 task를 하나로 엮는 방법이 고안된다.우리는 이미지로 부터 feature map을 추출했고, 이 feature map에서 Roi를 제안 받아 Roi pooling을 통해 feature vector를 만들었다. 이제 이 벡터로 classification과 bounding box regression을 적용하여 각각의 loss를 얻어내고, 이를 back propagation하여 전체 모델을 학습시키면 된다. 이 두 Task 모두를 반영한 손실함수를 보자.각 변수 하나하나에 대해서 알아보자. 먼저, $p$ 는, Softmax를 통해 얻어낸 $K+1$ 개의 확률값이다.(이산 확률 분포) $K+1$인 이유는 K개의 object와 배경(아무 물체도 아님)을 추가한 것이다. $u$는 해당 Roi의 ground truth label 벡터이다.다음으로는 bounding box regression을 진행한다. 고정 처리된 feature map을 가지고 regression을 했을 때 결과는, 각각의 class (K + 1) 에 대해 각각 x, y, w, h를 조정하는 파라미터 $t^k$를 리턴한다. 말로 풀어보면 다음과 같다. feature map으로 부터 1번 클래스 일 때 (x, y, w, h)를 ($t_x$, $t_y$, $t_w$, $t_h$) 로 변화시켜. 2번 클래스 일때는 …(중략). 이 중에서 우리가 하고 싶은 것은, 이 결과를 바탕으로 이를 수정하는 loss function을 만들고 싶은 것이므로 이 결과들 중 ground truth에 속하는 u번째 t만 가져와서 사용한다. $v$는 ground truth bounding box 조절 값에 해당한다.그렇다면 이제 각각의 loss function에 대해서 알아보자. 먼저 classification loss 는 log loss를 사용한다. 못맞출 수록 패널티를 크게 준다.location을 담당하는 loss는 아래와 같다.bounding box를 만들기 위한 예측 조절값에서 실제 조절값을 smooth L1을 통과시킨 것의 합을 사용한다.저자들은 실험 과정에서 라벨 값과 지나치게 차이가 많이 나는 outlier가 많았고, 이런 outlier에 민감하게 반응하는 L2 loss를 그대로 사용할 경우 gradient explode현상이 발생하는 것을 확인했다고 한다. 이를 제어하기 위해 custom한 loss function을 사용했다.Backpropagation through RoI Pooling Layer이제 네트워크를 학습하면 된다. 그런데 이전의 SSP Net을 보면, feature map을 뽑아낸 후, SSP를 거쳐 나온 vector들에 대해 FC layer를 구성하고, 이 단계만 학습시켰던 것을 기억할 거다.(fine tuning) 위 논문에서 저자들은, 이미지의 특징을 추출하는 가장 중요한 역할인 CNN이 학습될 수 없다는 것에 집중한다. 즉, 어느 단계까지 fine tuning을 진행할 것인지, 또 그 fine funing을 진행할 경우 학습이 진행이 되는지(역전파가 전달이 되는지)를 이론적으로 검증한다.$x_i$라고 하는 것은 CNN을 통해 추출된 feature map에서 하나의 feature를 의미하고 이는 실수이다. 전체 Loss에 대해서 이 피쳐 값의 편미분 값을 구하면 그 값이 곧 xi에 대한 loss 값이 되며 역전파 알고리즘을 수행할 수 있다. 이제 피쳐 맵에서 RoI를 찾고 RoI Pooling을 적용하기 위해서 H x W 크기의 grid로 나눈다. 이 그리드들을 sub-window라 부르며, 위 수식에서 j란 몇번째 sub-window인지를 나타내는 인덱스이다. $y_{rj}$는 이 Roi Pooling 을 통과하여 최종적으로 얻어진 ouput의 값이며 이 역시 실수이다.Back Propagation through RoI Pooling$x_i$ 가 최종 prediction 값에 영향을 주려면 $x_i$가 속하는 모든 Roi의 sub-window 에서 해당 $x_i$가 최댓값이 되야 한다. $i^*(r, j)$란 Roi와 sub-window index j가 주어졌을 때, 최대 피쳐 값의 인덱스를 말한다.즉 수식을 보면 $[i = i^*(r, j)]$ 이렇게 표현되어 있는데, 최대 패쳐 인덱스가 내가 구하길 원하는 피쳐와 같을 때는 1을 return, 아니면 0 을 return 하라는 의미이다. 결과적으로 우리는 $\\partial L \\over \\partial y_{rj}$ 이 값을 가지고 있고, 발생하는 모든 이 값을 더해서 적용시켜주면 $x_i$에 대한 gradient를 구할 수 있다.종합하면, 우리는 앞서 구한 multitask loss를 RoI Pooling layer를 통과하여 CNN 단까지 fine-tuning 할 수 있다. 저자드은 실험을 통해서 실제로 CNN단 까지 fine tuning 하는 것이 성능 향상에 도움이 되었다는 실험 결과를 보여준다.fine tuning depth에 따른 성능 변화위 실험 결과는 fine-tuning 하는 깊이를 조절해가며 성능 변화를 실험한 것이다. CNN의 단을 깊이 학습시킬 수록 성능이 향상되었으며, 이 때 테스트에 소요되는 시간 변화는 거의 없는 것을 확인할 수 있다. 즉, CNN 단을 Object Detection에 맞게끔 fine-tuning 하는 것이 성능 향상의 키 포인트였다.의의  end-to-end 모델 제안  학습 단계 간소화  정확도, 성능 개선한계  region proposal을 selective search를 사용          이는 CPU 연산으로만 가능하기 때문에 병목이 발생      이 부분이 inference를 수행하는데 있어 가장 많은 시간을 차지함      Reference갈아먹는 Object Detection [3] Fast R-CNN",
        
        "url": "/ds/dl/2020/09/02/computer-vision-04-Fast-RCNN.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-03-spatial-pyramid-pooling-network-html": {
        "title": "03: Spatial Pyramid Pooling Network",
        "tags": "DS, paper review",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "핵심 아이디어  입력 이미지의 크기나 비율에 관계없이 CNN 학습은 불가한가?Fast R-CNN으로 넘어가기전 상당히 많은 아이디어를 가져온 논문이다. 이전의 R-CNN을 보게되면, proposal roi가 CNN에 들어가기 전에 입력 이미지를 바꿔주어야 하는 한계가 존재했다. 여기서 저자들은 의문을 갖는다. 이 제한 요소를 없앤 상태로 CNN을 학습시키는 것이다.SPPNet의 핵심 아이디어사실 CNN의 입력이미지 크기는 고정될 필요가 없다. CNN의 핵심 아이디어는 filter를 가지고 연산을 수행하는 것이고, 이것의 연산 방식은 sliding window 방식으로 진행된다. 하지만, 이 입력 이미지의 크기가 고정이어야 하는 이유는, 마지막에 도출되는 fully connected layer의 크기가 고정적으로 나와야 하기 때문이다. 이 문제점으로 부터 SPPNet가 제안된다.  입력 이미지 상관 없이 통과시키고, FC 전에 polling을 통해서 동일한 크기로 만들자!굉장히 단순한 방법을 제안하였다. (…) 이런 방식을 사용할 경우, 원본 이미지의 특징을 고스란히 간직한 feature map을 얻을 수 있다. 추가적으로 비율도 조절하지 않기 때문에, 사물의 크기에 따른 변화도 감지가 가능하다.위의 그림을 보면 Crop 후 conv에 넣는 것이 아니고, feature map을 만든 후, 이를 SSPNet에 넣어 모양을 맞춘 후에 output을 만드는 것을 볼 수 있다.알고리즘  전체 이미지를 pretrained model을 통과시켜 feature map을 추출한다.  해당 feature map으로 부터 selective search를 통해 ROI를 뽑아낸다. 이 때 발생하는 ROI는 모두 크기와 비율이 다르다. 여기서 SSPNet을 적용하여 고정된 크기의 feature vector를 추출한다.  FC layer를 통과시킨다.  앞서 추출한 벡터로 각 이미지 클래스 별로 SVM을 학습시킨다.  마찬가지로 해당 벡터로 bounding box regressor를 학습시킨다.Spatial Pyramid Pooling출처 : http://kaiminghe.com/eccv14sppnet/index.html그렇다면 어떤 방식으로 SPP가 돌아가는지 이해해야 한다. 먼저 CNN을 거친 feature map을 input으로 받는다. 그리고 이것을 미리 정해져 있는 영여긍로 나누어 준다. 위의 예시에서는 4x4, 2x2, 1x1 3개의 영역이 적용되어 있고, 이 각각을 하나의 피라미드라 부른다. 즉, 3개의 피라미드를 설정한 것.이 피라미드는 4x4 짜리 고정된 CNN 필터 같은 것이 아니다. 어떠한 input이 들어오더라도 4x4 격자로 만든다는 표현이 더 맞는 표현이다. 예를 들어 입력이 64 x 64 x 256 크기의 피쳐 맵이 들어온다고 했을 때, 4x4의 피라미드의 bin의 크기는 16x16이 된다.이제 이 각각의 bin에서 가장 큰 값만 추출하는 max pooling을 수행하고, 그 결과를 쭉 이어 붙인다. 입력 feature map의 채널 크기가 k, bin의 개수를 M이라 한다면, 해당 SSP의 output은 k x M의 크기를 가진 1차원의 벡터가 될 것이다.한계  여전히 multi stage model이다.  여전히 SVM, selective search를 사용한다.  feature map을 만들어내는 network를 학습시키지 못한다.ReferencePR-012: Faster R-CNN : Towards Real-Time Object Detection with Region Proposal Networks",
        
        "url": "/ds/dl/2020/09/02/computer-vision-03-Spatial-Pyramid-Pooling-Network.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-02-rcnn-html": {
        "title": "02: R-CNN",
        "tags": "DS, paper review",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "Computer Vision의 Task이중 Object Detection에 해당하는 문제이다.속도가 느려보여도 정확도 측면에서 높은 것을 알 수 있다.R-CNN  region proposal을 진행한다.  CNN에 각각 넣는다. -&gt; 느리다, CNN을 사용하기 때문에 입력 크기가 동일해야 한다.(warpping)  CNN의 마지막 feature map에서 SVM을 사용하여 구분한다.  또한 입력으로 주어진 bounding box를 조정하기 위해 regression을 진행한다.Region Proposalinitial bounding box를 selective search를 사용하여 뽑아낸다. -&gt; 느리다.Training  pretrained model = alexnet for ImageNet classification dataset          이미지넷에서 사전 훈련된 알렉스 넷을 사용했다. 마지막단을 잘라서 사용한다.        가지고 있는 데이터를 넣어서 훈련한다.  여기서 발생한 마지막 feature map을 가지고 와서 classification, bounding box regression 을 진행한다.이러한 방법은, 두가지 문제를 발생시킨다.  속도  마지막 단의 feature map을 사용하기 때문에 back propagation을 통한 학습이 불가하다.Bounding-Box RegressionBox는 centerX, centerY, Width, Height로 표현된다.우리의 목적은 $P^i$ 박스를 최대한 G에 가깝게 이동시키는 함수를 학습시키는 것이다. 이를 표현해보면 다음과 같다.x, y의 경우는 평행이동이 연산의 전부이기 때문에 linear 연산으로 처리가 가능하다. 반면 너비와 높이는 확대, 축소 변환이 필요하다. 단순한 확대 축소 연산을 사용하게 되면, 추후에 backpropagation을 통한 학습이 어려워지기 때문에 여기서는 exp를 사용했다.왜 굳이 식을 이렇게 만들었냐 보다는, 이러한 방식으로 제안을 하려고 했다고 생각해보자. P에 대한 변수는 초기에 제안하는 것이므로, 우리는 함수 $d_*(P)$ 가 어떤 녀석인지 아는 것이 목표이다. 그리고 이 함수를 알아내는 과정은 deep learning network를 사용하여 만들 것이다.여기서 $\\phi_5(P)$는 pretraioned model의 가장 마지막 feature map을 의미한다. 결국 feature맵에 선형 연산을 추가하여 원하는 함수를 구한다.그렇다면, 이제는 문제가 변화했다. ground truth에서 발생하는 함수와 제안된 방법의 함수 $w^T_* \\phi_5(P)$ 의 가중치 $w^T_*$ 를 구하는 문제이다.ground truth에서 발생하는 값인 $t^i_*$는 각각의 사진 한장에 대해서 고정되어 있다. 이를 반영한 손실 함수는 다음과 같다. 저자들은 람다를 1000으로 설정하였다.한계  느리다.  SVM은 CNN을 훈련시키지 못한다.  Multostage Training Pipeline이다.ReferencePR-012: Faster R-CNN : Towards Real-Time Object Detection with Region Proposal Networks",
        
        "url": "/ds/dl/2020/09/02/computer-vision-02-RCNN.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-01-ec-9a-a9-ec-96-b4-ec-a0-95-eb-a6-ac-html": {
        "title": "01: 컴퓨터 비전 용어 정리",
        "tags": "DS, paper review, terms",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "Descripter  이미지를 비교하기 위해 동일한 방법을 통해 하나의 비교 대상으로 만드는 것descripter두 가지 이미지가 있다. 이 두가지 이미지가 비슷한지 아닌지를 구분하기 위해 만든 것이 descripter이다. 위의 그림에서는 픽셀의 값들을 기반으로 gradients를 구해 이를 grid에 plot하여 표현하였다. 여기서 이 gradients를 descripter로 사용했다고 말한다.HOG algorithm예를 들어 HOG 알고리즘은 각 pixel에서 gradient를 구하고 이 값들을 총 8가지 방향으로 매핑한 후, 히스토그램을 생성한다. 이렇게 추출돈 Feature vector는 keypoint이고 이를 기반으로 bounding box등을 만드는데 활용한다. 요즘은 이 feature mapCNN을 통해 생성한다.Region Proposal  이미지로부터 영역을 선택하기 위해 사용되는 알고리즘기존의 sliding window방식은 매우 비효율적이었고, 이를 개선한 방법이다. “물체가 있을 법한” 영역을 빠른 속도로 찾아내는 알고리즘이다. 보편적으로 selective search, edge box algorithm이 있다. 하지만 이 역시도 추후에 end-to-end 방식으로 개선된다.RoI(Region of Interest)  이미지내에서의 관심 영역원래 input에서 잘라낸 관심 영역들을 RoI라 한다.Caption generation  이미지로 부터 문장을 생성하는 것이 연구는 Human-object interaction에 기초하여 연구되고 있다.Smooth L1 LossL1, L2 Loss는 생략하였다. 수식에서의 x는 $|y-\\hat{y}|$로 정답 label과 차이이다. 오차가 작은 부분은 제곱을 사용했고, 그렇지 않은 부분에서는 직선을 사용했다. 이러한 방식은 L1 Loss와 L2 Loss의 장점을 결합한 형태이다. 즉, error가 클경우 안정적으로 loss를 감소시키고($x$), 작을 경우에는 L2 Loss를 사용하여 업데이트 과정중 진동을 감소시킨다.IOU (Intersection over union)  예측한 bounding box와 ground truth box간의 겹치는 넓이 비율IOU이것은 사진으로 직관적으로 이해할 수 있다.Ablation study  기존 모델에서 feature를 제거하면서 영향력을 확인하는 것여기서 feature는 변수보다는 network, layer등을 말한다.Jittered examples  IoU를 기준으로 사용하겠다고 판단한 bounding boxbounding box regression을 진행한 후에 각각의 proposal에 대해 예측한 결과 중 학습에 재사용하기 위한 샘플을 걸러낼 때 사용되는 개념이다. 예를 들어 IoU가 0.5이상 인 샘플을 positive sample이라 정의할 경우, 이 샘플을 Jittered examples이라 한다.Non-maximum suppression (NMS)  동일한 클래스라 판명된 bounding box들 중 중복을 제거하는 방법Non-maximum suppression (NMS)알고리즘은 다음과 같다.  동일한 클래스에 대해 검출된 bounding box들을 confidence 순서로 정렬한다.  가장 confidence가 높은 bounding box와 IoU가 일정 이상인 bounding box는 동일 물체를 detect했다 판단하여 지운다.          가장 confidence높은것만 남기고 보통 0.5이상 box들을 지운다.      OHEM (Online Hard Example Mining)먼저, Hard Example과 Easy Example의 개념부터 알아보자. 사람인지 아닌지를 분류하는 모델이 있다고 하자. 우리의 목적은 이 모델을 훈련시키는 것이다. 대부분의 사람 이미지는 분류하도록 만들었다. 하지만 사람 동상과 같은 샘플에 대해서는 모델이 구분하기 어려울 것이다. 이러한 상황에서 일반적으로 잘 동작하는 샘플을 Easy Example, 사람 동상 이미지를 Hard Example 이라 한다. 이런 것들을 제대로 훈련하기 위해서는 Hard Example에 대해 가중치를 주거나 해서 모델을 훈련시켜야 할 것이다.다음은 positive와 negative에 대한 개념이다. positive는 문제에서 내가 원하는 클래스를 의미한다. positive sample은 bounding box의 label이 사람인 것을 의미하고, negative sample은 배경임을 의미한다.그렇다면 hard negative란, 실제로는 배경인데, 사람이라고 예측한 sample이다. 반대로 easy negative는 실제로 배경이며 배경으로 예측했음을 의미한다.즉, hard negative sample은, 네거티브 샘플이라고 보기 어렵다라는 의미이다. 해당 샘플에 대해 배경이라고 말해야 하는데, confidence는 높게 나오는 상황을 말한다.우리가 알아볼 object detection문제에서는 resion proposal을 통해 여러가지 후보를 선택하게 된다. 이 후보군의 대부분은 배경이라고 말해야 하는 easy negative sample이 차지하고 있다. 또한 사람이라고 말해야 하는 positive sample의 개수는 매우 부족하다. 보통 이러한 상황에서는 모집단의 balance를 맞추는 resampling을 진행하거나, boosting알고리즘으로 진행하게 된다. 하지만 이것은 label의 불균형을 알고있고, 이를 처리할 수 있을 때 가능하다. detection문제는 후보군의 label을 모르기 때문에 이 방법은 사용할 수 없다. 그렇다면 만약 이 상황에서 그대로 훈련을 진행하게 되면, easy negative sample의 양이 너무 많기 때문에 배경을 배경이라 하는 예측만이 대다수를 이루고, 이에 대해서만 학습을 진행하게 된다.Cross Entropy &amp; Binary Cross Entropy일반적으로 Classification에서 사용하는 Loss 함수는 Cross Entropy 이다. 이러한 imbalance를 고려하여 업데이트를 하지 않기 때문에, 기존의 방식을 사용할 경우, background만 잘 맞추는 요상한 모델이 결과로 도출된다.OHEM (Online Hard Example Mining)우리는 결과적으로 배경은 배경이라하고, 사람은 사람이라고 하는 좋은 모델을 제작해야 한다. 그러기 위해서는 후보군의 대부분을 차지하고 있는 easy negative sample에 대해서 업데이트는 줄이고, 배경인데 배경이 아니라고 하는 hard negative sample에 대해 주된 업데이트를 진행해야 한다. 이를 위해 제안된 방법이 OHEM (Online Hard Example Mining)이다. 결과적으로 positive sample과 hard negative sample을 가지고 문제를 해결한다. 이와 같은 불균형 문제를 Class Imbalance라 한다.Focal Loss위의 OHEM과 비슷하게 class Imbalance를 해결하기 위한 방법이다. loss function을 수정하여 이를 해결한다.이런 loss funtion을 이해하는 가장 좋은 방법은 양 극단치를 넣어보는 것이다. y=1일 경우, ground truth가 사람인 경우에는 해당 class가 나올 확률을 그대로 넣어준다. 즉 $p_t = p$ 이다. 그렇다면 만약 잘 맞췄을 경우에는 loss가 0에 가까워진다. 결과적으로 postitive에 대해 잘 예측할 경우 loss를 작게 주고, 그렇지 않은 경우 loss를 크게 준다.y!=1인 경우, $p_t = 1-p$이고, 그렇게 될 경우 $FL(p_t) = -p\\gamma log(1-p)$이다. cross entropy식에서 앞항과 뒤 항의 변형을 통해 log함수가 가지는 특징을 사용했다. 잘 예측할 경우 loss를 크게 주고, 그렇지 않을 경우 loss를 작게준다. 다만 log 함수에 엮여 있는 부분은 잘 예측했을 경우에 더 큰 loss값을 주게 되므로, 이 식의 의도는, 너무 잘 예측하는 데이터(p가 계속 너무 높게 나옴)의 영향력을 줄이기 위한 것이 강하다. 실제로 OHEM 보다 성능이 더 좋다고 한다.Contextual feature2d image에서 contextual based classification은 pixel의 주변 neighborhood 과의 relationship에 초점을 맞춘 approach를 뜻한다. 즉, 어떤 특정 pixel의 contextual feature는 주변 pixel들과의 relationship에 기반해서 추출한 feature를 뜻한다.Reference컴퓨터비전에서의 기본 용어 및 개념 정리",
        
        "url": "/ds/dl/2020/09/02/computer-vision-01-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC.html"
      }
      ,
    
      "ds-server-2020-09-01-server-01-nginx-html": {
        "title": "01: Nginx",
        "tags": "DS, python, nginx",
        "date": "September 1, 2020",
        "author": "",
        "category": "DS/Server",
        "content": "nginx란?  트래픽이 많은 웹사이트를 위해 설계한 비동기 이벤트 기반 구조의 웹서버 소프트웨어러시아의 프로그래머,이고르 시쇼브가 Apache의 C10K Problem(하나의 웹서버에 10,000개의 클라이언트의 접속을 동시에 다룰 수 있는 기술적인 문제)를 해결하기 위해 만든 Event-driven구조의 HTTP, Reverser Proxy, IMAP/POP PROXY server를 제공하는오픈소스 서버 프로그램이다.Apache vs nginx  Apache  쓰레드 / 프로세스 기반 구조로 요청 하나당 쓰레드 하나가 처리하는 구조  사용자가 많으면 많은 쓰레드 생성, 메모리 및 CPU 낭비가 심함  하나의 쓰레드 : 하나의 클라이언트 라는 구조  nginx  비동기 Event-Driven 기반 구조.  다수의 연결을 효과적으로 처리가능.  대부분의 코어 모듈이 Apache보다 적은 리소스로 더 빠르게 동작가능  더 작은 쓰레드로 클라이언트의 요청들을 처리가능thread와 Event-driven 방식그림만 봐도 딱 알겠지만, Event-driven 방식은 java-script에서와 같이 비동기 이벤트를 처리하는 방식으로 구동된다. 그렇기 때문에 자원을 효율적으로 사용한다.그렇지 않아도 node.js의 창시자 라이언 달은 nginx를 프록시 서버로 앞단에 두고, node.js를 뒤쪽에 놓는게 버퍼 오버플로우 공격을 방지할 수 있다고 하였다.버퍼 오버플로우버퍼는 보통 데이타가 저장되는 메모리 공간을 뜻한다. 이 때, 메모리 공간을 벗어나는 경우 오버플로우가 되고 이 때 사용되지 않아야 할 영역에 데이터가 덮어씌워져 주소, 값을 바꾸는 공격이다.​버퍼 오버플로우로 인한 큰 이슈 : 하트블리드사태즉, 실제포트를 숨기고 nginx의 80포트를 통해서 프록시하면 보안적으로 막을 수 있다는 것인데 이것 말고도 정적자료에 대한 gzip압축, 그리고 앞단에서의 로그를 저장할 수 있다.",
        
        "url": "/ds/server/2020/09/01/Server-01-Nginx.html"
      }
      ,
    
      "ds-docker-2020-09-01-docker-04-image-ec-83-9d-ec-84-b1-ec-97-85-eb-a1-9c-eb-93-9c-html": {
        "title": "03: image 생성, 업로드",
        "tags": "DS, python, docker, image",
        "date": "September 1, 2020",
        "author": "",
        "category": "DS/Docker",
        "content": "ReferenceDocker와 쿠버네티스의 이해",
        
        "url": "/ds/docker/2020/09/01/Docker-04-image%EC%83%9D%EC%84%B1-%EC%97%85%EB%A1%9C%EB%93%9C.html"
      }
      ,
    
      "ds-docker-2020-09-01-docker-03-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-a0-80-ec-9e-a5-html": {
        "title": "03: 데이터 저장 (Volume, Mount)",
        "tags": "DS, python, docker, image",
        "date": "September 1, 2020",
        "author": "",
        "category": "DS/Docker",
        "content": "Volume과 MountDocker Conatiner에 쓰여진 데이터는 컨테이너가 삭제될 때 함께 사라진다. 하지만 이에 관계없이 우리는 데이터를 영속적으로 저장할 필요가 있다. 또한 여러개의 컨테이너를 생성하여 사용할 경우, 하나의 폴더를 공유해야 하는 일이 빈번하다.이러한 필요성에 대해 Docker는 두가지 옵션을 제공한다. 첫째가 Volume, 둘째가 Mount이다.Volume이 방법은 Docker에서 권장하는 방법이다.Volume의 생성$ docker volume create hellohelloVolume의 조회$ docker volume lsDRIVER              VOLUME NAMElocal               hello$ docker volume inspect hello[    {        \"CreatedAt\": \"2020-05-09T17:03:46Z\",        \"Driver\": \"local\",        \"Labels\": {},        \"Mountpoint\": \"/var/lib/docker/volumes/our-vol/_data\",        \"Name\": \"our-vol\",        \"Options\": {},        \"Scope\": \"local\"    }]Mountpoint를 보면 해당 볼륨이 어디에 있는지 알 수 있다.볼륨을 컨테이너에 마운트하기$ docker run -v hello:/home/app --name one hugojuhel/notebook touch /app/test.txtdocker run -v &lt;볼륨 이름&gt;:&lt;컨테이너 내의 절대 경로&gt; --name &lt;컨테이너 이름&gt; &lt;image 이름&gt; &lt;명령&gt; &lt;파라미터&gt; 형식으로 구성되어 있다.$ docker inspect hello(...생략...)    \"Mounts\": [        {            \"Type\": \"volume\",            \"Name\": \"our-vol\",            \"Source\": \"/var/lib/docker/volumes/our-vol/_data\",            \"Destination\": \"/app\",            \"Driver\": \"local\",            \"Mode\": \"z\",            \"RW\": true,            \"Propagation\": \"\"        }    ],(...생략...)실제로 생성된 컨테이너를 조사하면 다음과 같이 뜨며, Type이 volume으로 지정된 것을 확인할 수 있다.이러한 방법은 다른 컨테이너에 마운트할 때에도 동일하게 적용된다.Volume 삭제$ docker volume rm helloError response from daemon: remove hello: volume is in use - [f73130c9dad14644ac46b89fe4018e561a7bcbfa4118d637949642d0d5d742e4, 666dda54f6be8ca852f3150b9741a9cab5a4659fa2e83fe6ca339550072c861ex]삭제할 때는 mount 된 컨테이너를 모두 삭제한 뒤에야 삭제가 가능하다.삭제를 수행했다면 에러가 뜨지 않을 것이다.Volume 청소$ docker volume pruneWARNING! This will remove all local volumes not used by at least one container.Are you sure you want to continue? [y/N] y마운트 되지 않은 모든 볼륨을 한번에 정리할 수 있다.Bind-Mount위의 Volume 방법을 보면, 경로를 docker가 제시한 경로에 맞춰서 생성된다. 하지만 시스템의 특정 경로를 기반으로 작업하고 싶은 경우도 많다. 이런 필요성에 대해 docker는 Bind-Mount를 제공한다.사용법은 매우 간단하다. 위의 Volume 명이 들어가는 자리에, 원하는 호스트 경로를 적어주는 것으로 끝난다.docker run -it --name jpt -v /Users/Choiwansik/Documents/internship/image_processing/share:/home/jovyan/share -p 28888:8888 hugojuhel/notebook /bin/bash이 때 역시나 container의 절대 경로를 써주어야 한다.\"Mounts\": [            {                \"Type\": \"bind\",                \"Source\": \"/Users/Choiwansik/Documents/internship/image_processing/share\",                \"Destination\": \"/home/jovyan/share\",                \"Mode\": \"\",                \"RW\": true,                \"Propagation\": \"rprivate\"            }        ],...Type이 bind로 묶여있음을 확인할 수 있다.Volume vs Bind-Mount  경로(Mount Point) 관리해 줄까? 말까?둘의 가장 큰 차이점은, docker가 mount point를 관리해 주느냐의 여부로 나뉜다. 그냥 막 사용하고 싶은 경우애는 volume이 맞을 수 있지만, 컨테이너화된 개발 환경을 구축하고 싶을 때는 bind-mount가 더 유리하다.ReferenceDocker 컨테이너에 데이터 저장 (볼륨/바인드 마운트)",
        
        "url": "/ds/docker/2020/09/01/Docker-03-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%80%EC%9E%A5.html"
      }
      ,
    
      "ds-docker-2020-09-01-docker-02-eb-aa-85-eb-a0-b9-ec-96-b4-eb-aa-a8-ec-9d-8c-html": {
        "title": "02: 명령어 모음",
        "tags": "DS, python, docker, Jupeter Notebook",
        "date": "September 1, 2020",
        "author": "",
        "category": "DS/Docker",
        "content": "설치brew install dockermac 용 도커 설치하기Docker image downloaddocker pull hugojuhel/notebook  Docker Hub 에서 원하는 docker 이미지를 다운로드  혹은 아래 예제와 같이 명령어로 다운받을 수도 있음  사용한 이미지Docker image 확인docker images설치한 이미지들을 볼 수 있다.Docker container 생성 및 실행docker run -it --name jpt -v /Users/Choiwansik/Documents/internship/image_processing/share:/home/jovyan/share -p 28888:8888 hugojuhel/notebook /bin/bash사용자 상황에 맞게 옵션 골라 사용  명령어는 항상 root 권한으로 실행한다.  -i(interactive), -t(Pseudo-try) 옵션 : 실행된 Bash 셸에 입력 및 출력을 할 수 있다.  -v, --volume 옵션 : host folder와 공유할 수 있다.jupyter notebook 실행jupyter notebook --ip=0.0.0.0 --allow-root실행하게 되면, 아까 연결해 두었던 로컬 포트로 접속할 경우 사용할 수 있다.Docker 명령어도커 명령어 Cheat Cheet이다. 나중에 이거만 보고 사용하도록 하자.프로세스 보기sudo docker ps -a-a 옵션을 사용하면 정지된 컨테이너까지 모두 출력하고, 옵션을 사용하지 않으면 실행되고 있는 컨테이너만 출력한다.컨테이너 시작하기sudo docker container start hello이름 대신 container_id를 사용해도 된다.컨테이너 재부팅sudo docker container restart hello운영체제 재부팅과 유사하다.컨테이너 접속하기sudo docker container attach hellobash에서 exit 혹은 Ctrl+D 를 입력하면 컨테이너가 정지된다.exec 명령으로 컨테이너 외부에서 명령 실행하기현재 hello 컨테이너의 bin/bash를 실행한 상태라고 가정하자. 그리고 해당 컨테이너에 접속하지 않은 상태로, hello 컨테이너 안의 명령을 실행해보자.sudo docker container exec hello echo \"Hello World\"docker container exec &lt;컨테이너 이름&gt; &lt;명령&gt; &lt;매개변수&gt; 형식이다. 컨테이너 대신 컨테이너 id를 사용할 수 있다. 이 명령어는 컨테이너가 실행되고 있는 상태에서만 사용할 수 있으며 정지된 상태에서는 사용할 수 없다.docker exec 명령은 이미 실행된 컨테이너에 apt-get, yum 과 같은 명령으로 패키지를 설치하거나 각종 데몬을 실행할 때 활용할 수 있다.컨테이너 정지하기sudo docker container stop hello정지한 경우 다시 attach하고 싶으면 start후 가능하다.컨테이너 삭제하기sudo docker container rm hellocontainer 명령어를 쓰지 않아도되지만 최신 버전에서는 권장한다.컨테이너 실행 상태로 빠져나오기컨테이너 안에서 ctrl+pq을 누르면 된다.컨테이너 내 사용자 비밀번호를 모를 때docker container exec -u 0 -it jpt /bin/bash-u는 default user라 password를 필요로 하지 않는다.이미지 삭제하기sudo docker rmi ubuntu:latestdocker rmi &lt;이미지 이름&gt;:&lt;태그&gt; 형식이다. 이미지 이름 대신 id를 사용해도 된다. 태그를 주는 이유는 같은 이름 인 경우 모두 삭제되기 때문이다.정리            명령      Code                  버전 확인      $ docker -v              이미지 다운로드      $ docker pull [이미지 명]              다운로드된 이미지 목록      $ docker images              컨테이너 생성      $ docker create [옵션] [이미지 명]              컨테이너 생성 및 실행      $ docker run [옵션] [이미지 명]              컨테이너 실행      $ docker start [컨테이너 명]              컨테이너 재실행      $ docker restart [컨테이너 명]              컨테이너 접속      $ docker attach [컨테이너 명]              컨테이너 정지      $ docker stop [컨테이너 명]              실행중인 컨테이너 목록      $ docker ps              정지된 컨테이너 목록      $ docker ps -a              컨테이너 명 변경      $ docker rename [기존 컨테이너 명] [새로운 컨테이너 명]              컨테이너 삭제      $ docker rm [컨테이너 명]      Reference[Docker] 설치, 다운로드, 실행, jupyter notebook 연동, 삭제, 기타 등등pre.highlight margin-top 1emul margin-bottom 0p margin-bottm 1emp margin-top 1em",
        
        "url": "/ds/docker/2020/09/01/Docker-02-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%AA%A8%EC%9D%8C.html"
      }
      ,
    
      "ds-docker-2020-09-01-docker-01-ea-b0-9c-ec-9a-94-html": {
        "title": "01: 개요",
        "tags": "DS, python, docker",
        "date": "September 1, 2020",
        "author": "",
        "category": "DS/Docker",
        "content": "도커란? (되게 귀엽다)개념  개발자와 시스템 관리자가 컨테이너 기술을 사용하여 어플리케이션을 개발, 배포, 실행하기 위한 플랫폼컨테이너 기술을 리눅스에서 사용되던 기술이다. 이 때, 이 기술을 사용하여 응용프로그램을 배포하는 것을 컨테이화 시킨 것이다. 새로운 기술은 아니지만, 이를 통해 매우 편리하고 간편하게 배포하는 것이 가능하다.컨테이너 기술은 아래와 같은 특징들이 있다.  유연성 (Flexible) : 복잡한 어플리케이션들도 모두 컨테이너화 할 수 있다.  경량화 (Lightweight) : 컨테이너는 호스트 커널을 활용하고 공유한다.  변화 관리 편의성 (InterChangeable) : 업데이트 및 업그레이드를 즉시 배포할 수 있다.  포터블 (Portable) : 로컬로 구축하고, 클라우드와 가상화에 배치가 가능하고, 어디서나 실행할 수 있다.  확장성 (Scalable) : 컨테이너 복제본을 늘리고 자동 배포가 가능하다.  스택화 (Stackable) : 서비스들에 대한 수직적 또는 수평적 디자인이 매우 용이하다.어마무시한 도커 사용량이미지와 컨테이너docker contatiner  이미지          코드, 런타임, 라이브러리, 환경 변수 및 구성 파일 등 응용프로그램을 실행하는 데 필요한 모든 것을 포함하는 실행가능 패키지        컨테이너          이미지의 런타임 인스턴스      이 두개의 개념은 도커를 이해하는 데 매우 중요하다. class는 instance의 설계도이다. 마찬가지로 이 class에 해당하는 것이 바로 image이며, 이를 메모리단에 올린 것을 container라 한다.컨테이너의 동작 방식가상 머신과 도커의 차이점기존에 사용하던 가상 머신은, Host OS위에 Guest OS를 얹어 사용하는 방식이다. 사용법은 간단하지만 느리다라는 치명적인 단점을 갖고 있다.이러한 상황을 개선하기 위해 CPU 가상화 기술을 사용한 KVM(Kernel-based Virtual Machine)이 등장했다. 하지만 여전히 성능 문제가 있었다. 이를 해결한 것이 Docker contatiner이다. 이는 바로 Host OS위에서 격리만하여 프로세스를 처리하는 방식이다.Reference초보를 위한 도커 안내서 - 도커란 무엇인가?",
        
        "url": "/ds/docker/2020/09/01/Docker-01-%EA%B0%9C%EC%9A%94.html"
      }
      ,
    
      "cv-internship-2020-09-01-updater-ec-98-81-ec-83-81-ec-b2-98-eb-a6-ac-ec-9d-b8-ed-84-b4-html": {
        "title": "Updater 영상 처리 intern",
        "tags": "상, CV",
        "date": "September 1, 2020",
        "author": "",
        "category": "CV/Internship",
        "content": "기간 : 0901~1031",
        
        "url": "/cv/internship/2020/09/01/Updater-%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC-%EC%9D%B8%ED%84%B4.html"
      }
      ,
    
      "ds-ml-2020-08-24-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-8b-9c-ea-b0-81-ed-99-94-02-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-03-deckgl-html": {
        "title": "03 : deckgl",
        "tags": "DS, python, deckgl",
        "date": "August 24, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "공간 데이터를 시각화 할 수 있는 deckgl에 대해 알아본다.",
        
        "url": "/ds/ml/2020/08/24/%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-02-%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-03-deckgl.html"
      }
      ,
    
      "ds-ml-2020-08-24-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-8b-9c-ea-b0-81-ed-99-94-02-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-02-folium-html": {
        "title": "02 : folium",
        "tags": "DS, python, folium",
        "date": "August 24, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "공간 데이터를 시각화 할 수 있는 folium에 대해 알아본다.",
        
        "url": "/ds/ml/2020/08/24/%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-02-%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-02-folium.html"
      }
      ,
    
      "ds-ml-2020-08-24-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-8b-9c-ea-b0-81-ed-99-94-01-geopandas-html": {
        "title": "01 : geopandas",
        "tags": "DS, python, geopandas",
        "date": "August 24, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "공간 데이터를 다룰 수 있게 하는 패키지 geopandas에 대해 알아본다.",
        
        "url": "/ds/ml/2020/08/24/%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-01-geopandas.html"
      }
      ,
    
      "cv-projects-2020-08-01-ed-95-ad-ea-b3-b5-ec-a7-80-ec-97-b0-ec-98-88-ec-b8-a1-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-html": {
        "title": "항공 지연 예측 프로젝트",
        "tags": "상, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/08/01/%ED%95%AD%EA%B3%B5-%EC%A7%80%EC%97%B0-%EC%98%88%EC%B8%A1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8.html"
      }
      ,
    
      "cv-projects-2020-08-01-ec-b6-a4-ec-a0-80-ec-9e-91-ea-b6-8c-ec-a0-9c-ec-9e-91-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-html": {
        "title": "춤 저작권 제작 프로젝트",
        "tags": "상, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/08/01/%EC%B6%A4-%EC%A0%80%EC%9E%91%EA%B6%8C-%EC%A0%9C%EC%9E%91-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8.html"
      }
      ,
    
      "cv-projects-2020-08-01-ec-84-9c-ec-9a-b8-ec-8b-9c-ec-b2-ad-ec-8b-9d-ec-88-98-ec-9d-b8-ec-9b-90-ec-98-88-ec-b8-a1-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-html": {
        "title": "서울시청 식수인원 예측 프로젝트",
        "tags": "상, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/08/01/%EC%84%9C%EC%9A%B8%EC%8B%9C%EC%B2%AD-%EC%8B%9D%EC%88%98%EC%9D%B8%EC%9B%90-%EC%98%88%EC%B8%A1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8.html"
      }
      ,
    
      "cv-projects-2020-08-01-ea-b2-b0-eb-a1-9c-eb-b0-9c-ec-83-9d-ec-98-88-ec-b8-a1-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-html": {
        "title": "결로 발생 예측 프로젝트",
        "tags": "상, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/08/01/%EA%B2%B0%EB%A1%9C-%EB%B0%9C%EC%83%9D-%EC%98%88%EC%B8%A1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8.html"
      }
      ,
    
      "cv-extraact-2020-08-01-eb-a9-8b-ec-9f-81-ec-9d-b4-ec-82-ac-ec-9e-90-ec-b2-98-eb-9f-bc-7-ea-b8-b0-ec-9a-b4-ec-98-81-ec-a7-84-html": {
        "title": "멋쟁이 사자처럼 - 7기 운영진",
        "tags": "상, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/ExtraAct",
        "content": "",
        
        "url": "/cv/extraact/2020/08/01/%EB%A9%8B%EC%9F%81%EC%9D%B4-%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC-7%EA%B8%B0-%EC%9A%B4%EC%98%81%EC%A7%84.html"
      }
      ,
    
      "cv-extraact-2020-08-01-eb-a9-8b-ec-9f-81-ec-9d-b4-ec-82-ac-ec-9e-90-ec-b2-98-eb-9f-bc-6-ea-b8-b0-html": {
        "title": "멋쟁이 사자처럼 - 6기",
        "tags": "상, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/ExtraAct",
        "content": "",
        
        "url": "/cv/extraact/2020/08/01/%EB%A9%8B%EC%9F%81%EC%9D%B4-%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC-6%EA%B8%B0.html"
      }
      ,
    
      "cv-awards-2020-08-01-2020-ea-b8-b0-ec-83-81-eb-b9-85-eb-8d-b0-ec-9d-b4-ed-84-b0-eb-8c-80-ed-9a-8c-eb-8d-b0-ec-9d-b4-ed-84-b0-eb-b6-84-ec-84-9d-eb-b6-84-ec-95-bc-ec-9a-b0-ec-88-98-ec-83-81-html": {
        "title": "빅콘테스트 퓨쳐스리그 - 장려상",
        "tags": "상, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/Awards",
        "content": "",
        
        "url": "/cv/awards/2020/08/01/2020-%EA%B8%B0%EC%83%81-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8C%80%ED%9A%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EB%B6%84%EC%95%BC-%EC%9A%B0%EC%88%98%EC%83%81.html"
      }
      ,
    
      "cv-awards-2020-08-01-2019-eb-b9-85-ec-bd-98-ed-85-8c-ec-8a-a4-ed-8a-b8-ed-93-a8-ec-b3-90-ec-8a-a4-eb-a6-ac-ea-b7-b8-ec-9e-a5-eb-a0-a4-ec-83-81-html": {
        "title": "기상 빅데이터 대회 - 우수상",
        "tags": "상, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/Awards",
        "content": "",
        
        "url": "/cv/awards/2020/08/01/2019-%EB%B9%85%EC%BD%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%93%A8%EC%B3%90%EC%8A%A4%EB%A6%AC%EA%B7%B8-%EC%9E%A5%EB%A0%A4%EC%83%81.html"
      }
      ,
    
      "math-finance-2020-07-29-ea-b8-88-ec-9c-b5-ea-b3-b5-eb-b6-80-02-ed-8f-ac-ed-8a-b8-ed-8f-b4-eb-a6-ac-ec-98-a4-ec-9d-b4-eb-a1-a0-html": {
        "title": "02: 포트폴리오 이론",
        "tags": "금융, 포트폴리오 이론",
        "date": "July 29, 2020",
        "author": "",
        "category": "Math/Finance",
        "content": "개요  자산은 분산투자한다.  왜?          위험과 수익은 Trade off 관계이다.      하지만 자산을 섞어 운용할 경우, 최적선을 만들 수 있다.      원리항상 포트폴리오 관리를 하라고 한다. 왜일까? 근본적인 이유는 매우 간단하다.지금부터 이유에 대해 이해해보도록 하자.위험이란?  수익률의 변동성  변동성이란?          자산의 수익률이 평균으로 부터 크게 움직일 때      즉, 표준편차가 큰 경우 변동성이 크다 판단한다.      해당 기준은, 내가 어떤 전략을 원하느냐에 따라 달라진다.      자산의 총 위험  자산의 총 위험 = 개별 자산 특수 위험 + 시장 위험여기서 개인이 할 수 있는 부분은 개별 자산 특수 위험을 줄이는 것이다.이 때, 시장 위험에 따른 개별 자산의 위험도의 정도를 베타라 한다.결론  변동폭이 높은 여러 주식을 섞을 경우 표준편차가 확률적으로 줄어든다.  추가적으로 특정 이벤트가 발생 했을 때, 공분산(상관계수)가 -1을 지향하는 것이 안정적이다.  이벤트에 대해 일정한 수익률을 보장할 수 있는 포트폴리오를 만드는 것이 중요하다이러한 점은, 곧 포트폴리오에 자산을 추가함에 있어서 그 자산이 전체 포트폴리오의 방향성에 어떠한 점을 가져오느냐를 판단하는 것이 중요하다는 것을 의미한다.의문  그렇다면, 자산을 추가할 수록 위험은 0에 수렴하는가?          아니다. 통제불가능한 bias가 존재한다.                  이는 거시 경제 변수(환율, 금리, 통화량)에 의한 위험을 의미한다.                    이 거시 경제 변수는 내가 진행하는 주식 시장에 따라 결정된다.                  예를 들어, 한국 시장이라면 한국 시장 자체가 같은 위험도에 따라 위험도가 결정된다.          즉, 코스피 수익률의 표준편차는 안고 간다는 의미이다.                    약 50개의 자산을 함께 운용 했을 때, 최소점에 다다른다고 한다.        그렇다면, 무조건 적으로 분산 투자를 많이 하는 것이 좋은 것인가?          아니다. 주식에 답은 없다.      많은 수의 자산을 관리하는 것과 수익률과는 어느 정도의 trade off 관계가 존재한다.                  즉, 많은 수의 자산을 관리할 경우 수익률은 떨어지는 경향이 있다.          그렇다고 너무 적은 수의 자산으로 관리할 경우 안정성이 떨어진다.                    ",
        
        "url": "/math/finance/2020/07/29/%EA%B8%88%EC%9C%B5-%EA%B3%B5%EB%B6%80-02-%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4-%EC%9D%B4%EB%A1%A0.html"
      }
      ,
    
      "math-finance-2020-07-29-ea-b8-88-ec-9c-b5-ea-b3-b5-eb-b6-80-01-ec-9a-a9-ec-96-b4-ec-a0-95-eb-a6-ac-html": {
        "title": "01: 용어 정리",
        "tags": "금융, 용어정리",
        "date": "July 29, 2020",
        "author": "",
        "category": "Math/Finance",
        "content": "금융/주식 용어 정리            용어      설명                  주식      기업 설립 후, 기업 가치를 기반으로 한 주식 발행 개수를 기업들이 정해서 처음에 상장함  많이 먹으면 회사 먹었다고 판단 가능              매수      주식을 사는 행위              매도      주식을 파는 행위              체결/미체결      체결이 되야 내가 현금이 생긴다.              MTS      모바일 트레이딩 시스템              HTS      홈 트레이팅 시스템              현재가      현재 해당 주식의 가격              종가      마감 했을 때, 가격              지정가      매도나 매수를 할 때, 내가 원하는 가격을 정해서 내놓을 수 있음              시장가      현재 시장가에 해당하는 가격으로 매도나 매수를 진행할 수 있음              시간외      정규장 이외 시간에 거래를 하는 방법 이 때는 종가 기준으로 거래가 이루어 진다.  정규장 이전 시간 : 8:30~9:00 (전일 종가 기준)  정규장 이후 시간 : 15:40~16:00 (당일 종가 기준)              신용      신용 기준으로 증권회사가 대출해줌 내가 산 주식 가격 기준 70% 금액정도              시가 총액      시가 * 발행주식수 = 현재 기준으로 기업의 가치를 돈으로 매긴 것              주문 번호      같은 금액에 대해 사려는 사람이 5000명,  근데 해당 가격에 매도한 사람이 3000명일 경우,  주문 번호 3000번 까지만 먼저 체결됨              거래 대금      특정 기간에 대해 체결된 양              외인      외국인              기관      주식 거래를 하는 기관              배당      주식을 산다는 건 회사의 일부를 가진다는 것 이 회사가 잘 되었을 때, 그 이익의 일부를 나눠주는 것              차트      주식 가격의 변동성을 기간 별로 파악할 수 있다.              선물 거래      미래 상품의 판매권을 현재에 사고, 해당 시기 가격에 그 판매권에 해당하는 금액을 받음              VI      존나 팍 올라도 스턴, 존나 팍 내려가도 스턴              서킷 브레이크      전체 시장의 변동성이 큰 경우 시장을 멈춰버리는 것              사이드카      변동성 완화장치              프로그램 매매      말 그대로 프로그램을 기반으로 주식을 거래하는 것을 말함              EPS      순이익/주식수 = 주식 1주당 창출한 이익              ROE      자기 자본이익률 = 투입한 자기자본으로 얼마만큼의 이익을 내었는가?      해외 선물 용어 정리            용어      설명                  선물      미래에 발생할 거래에 대해 계약한다.  현재 시점에서 미래에 대한 가치를 정하고, 먼저(선) 물건(물)을 거래한다. 이 때, 미래 가치가 상승한다, 혹은 하락한다에 베팅을 진행할 수 있다.              헷지 거래      앞서 선물 거래는 업다운에 베팅이 가능하다 했다. 그렇기 때문에 위험이 크다. 이러한 손실을 만회할 수단으로 양쪽에 베팅하는 것을 말한다. 물론 이 베팅은 같은 상품에 대해 진행하지 않아도 된다. 상관성이 반대인 상품에 대해 잘 조절해서 베팅한다.              기초 자산      선물 거래의 대상 목록  금융자산(주가지수, 국채 금리, 통화 화폐)  원자재(옥수수, 금, 원유)  딱 봐도 알겠지만 이 기초 자산은 국내를 벗어난다. 그래서 해외 선물 거래다.              레버리지      지렛대.  자본이 많아야 손익폭이 크다. 부채 추가해서 넣는 것              해외 거래소      선물 거래소를 의미  CME Group - 세계 1위 거래소  EUREX - 유럽 최대 거래소  SGX - 아시아 거래소 (싱가폴)              위탁 증거금      선물 거래를 하기 위해서는 레버리지가 필수 불가결하다.  그렇기 때문에 이를 위한 담보가 있어야 한다.              유지 증거금(마진콜)      선물 거래가 지속되기 위해 최소한 유지되어야 하는 담보 금액(보증금)  일정 수준 하회할 경우 추가로 요청한다.              정산가      일일 정산을 위한 기준 가격.  마감 직전 거래량의 가중 평균을 사용한다.              만기일      주식과 다르게, 만기가 존재한다.              만기연장  (롤오버)      다음 종목으로 들어가서 만기를 연장하는 개념      펀드 용어 정리            용어      설명                  펀드      투자를 목적으로 모아진 기금              거치식 펀드      한번에 납입              적립식 펀드      여러번에 나눠 납입              증권 펀드      50% 이상 증권 투자              주식형 펀드      증권 펀드 중 주식 비율이 60% 이상인 경우              채권형 펀드      증권 펀드 중 채권 비율이 60% 이상인 경우              주식혼합형 펀드      증권 펀드 중 주식 비율이 50% 이상인 경우              채권혼합형 펀드      증권 펀드 중 채권 비율이 50% 이상인 경우              부동산 펀드      50%이상 부동산 투자              MMF      100% 단기 금융 상품 투자              공모 펀드      불특정 다수에게 오픈된 펀드              사모 펀드      49명 이하의 투자자로 유지해야 하는 펀드              헤지 펀드      하락 위험에 이익을 발생시키는 상품에 투자하는 펀드 (사모펀드로 구분)              뮤츄얼 펀드      투자 목적으로 설립된 펀드이자 투자회사      펀드 네이밍 법칙            구분      설명                  운용사      판매를 하는 곳과 달리, 펀드를 만들고 운용하고 상태를 투자자에게 보내주는 회사              고유이름      고유의 브랜드명              운용전략      대표 운용전략을 파악할 수 있음 (고배당, 인덱스)              순번      펀드 규모가 커질 경우 붙는 숫자              투자의 대상      주요 투자 대상              수수료 방식      펀드 클래스라 부르며 수수료에 대한 정보를 준다.              설정액/판매액      펀드에 들어온 돈의 총액              기준가      펀드의 현재 가격              설정일      펀드의 생일              환매      투자자가 펀드에 투자한 자본을 회수              모닝스타      펀드를 평가하는 회사, 등급을 매긴다.              보수/수수료      펀드 비용              보수      펀드 운용 회사에 지급하는 보수 비용 등등              환매수수료      펀드 운용의 안정성을 추구하기 위해 기간을 설정하기도 한다. 이 기간보다 빠르게 환매할 경우 환매 수수료를 내야한다.              판매수수료      펀드 판매사들의 수수료      재무 재표 용어            용어      설명                  ROE(Return Of Equity)      주주가 준 돈으로 어느정도의 이익을 올리고 있는지, 투자에 대한 운용 효율을 의미한다. ROE = (당기순이익 / 평균자기자본) * 100              PER(Price Earning Ratio)      주가 / 1주당 예상순이익  = 주가 / (순이익/주식 수)  = (주가 * 주식 수) / 순이익  = 시가총액 / 순이익  = 이 순이익으로 회사를 사려면 몇 년이 걸릴까요?  PER이 크다? 덩치는 큰데 순이익이 적다.  왜? 분자가 크거나 분모가 작거나  얘는 주가에 증권과 같은 다른 요소가 껴있다.              EV(Enterprise Value)      자기자본 + 부채  = 시가총액 + 순부채  = 기업을 사기 위해 지불해야 하는 금액              PBR  (Earnings Before Interest, Taxes, Depreciation and Amortization)      이자, 세금, 감가상각비등을 빼기 전의 순이익  순수하게 벌어드리는 현금 창출 능력              EV/EBITDA      영업활동을 통한 이익의 몇 배가 기업가치인가                                                                                                                                                                                                                                                                              ",
        
        "url": "/math/finance/2020/07/29/%EA%B8%88%EC%9C%B5-%EA%B3%B5%EB%B6%80-01-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC.html"
      }
      ,
    
      "cs-algorithm-2020-07-09-eb-b0-b1-ec-a4-80-ec-98-a4-ec-95-84-ec-8b-9c-ec-8a-a4-ec-9e-ac-ea-b2-b0-ed-95-a9-html": {
        "title": "백준(3015번): 오아시스 재결합",
        "tags": "백준, 알고리즘, stack",
        "date": "July 9, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드1 : stack 문제이다.백준(3015번) - 오아시스 재결합생각아, 어려웠다.. 처음에 dp로 풀생각을 했더니, $O(n^2)$ 이라 500,000인 input에 맞지 않는다. 또한 그 과정에서 세그먼트 트리 혹은 우선 순위 큐를 사용하려 했지만 구현 난이도가 올라가 고민했다.역시 알고리즘 문제는 약간은 컴퓨터 처럼 순차적으로 규칙을 찾는 것이 가장 중요하다는 생각을 한다. 또한, 어떠한 자료구조를 사용하여 문제의 input을 어떠한 규칙을 갖는 무언가를 만드는 것이 매우 중요하다.해당 문제에서 핵심은, i번째 사람의 입장에서 앞을 보았을 때, 보이는 모습을 상상해보는 것이 중요하다. 이를 상상해보면 그 사람은 계속 사람의 키가 올라가는 모양으로 보인다. 이는 index 0에서 부터 생각해 볼때, i까지의 위치까지 감소하는 수열을 갖고 있는다고 생각할 수 있다. 이런 감소하는 수열을 갖고 있다면, i+1 번째의 감소하는 수열을 만드는 과정에서 답안을 도출할 수 있다.물론, 이 문제는 키가 같을 수 있다는 점에서 이를 처리하는 방법이 필요하다. 이를 해결하는 방법은 역시나 i번째 사람의 입장에서 앞을 보았을 때, 어떤 식으로 pair가 구성되는지 시뮬레이션 하는 것이 도움이 된다.Code#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;int N;vector&lt;pair&lt;int, int&gt;&gt; line;long long ans = 0;  // 답의 개수가 무지하게 많이 나오니 이거 꼭 체크!void print(){    for (int i = 0; i &lt; int(line.size()); i++) {        cout &lt;&lt; line[i].first &lt;&lt; \" \";    }cout &lt;&lt; '\\n';    for (int i = 0; i &lt; int(line.size()); i++) {        cout &lt;&lt; line[i].second &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        int nowH;        cin &gt;&gt; nowH;        bool same = false;        // 감소하는 수열을 만들며 규칙에 따라 답을 업데이트한다.        while(!line.empty()){            pair&lt;int, int&gt; near = line.back();            // 현재 키가 가장 근방에 있는 사람보다 클 경우            if (nowH &gt; near.first) {                // 감소하는 수열을 만들어 놓은 상태이기 때문에                // 이 사람은 나와 쌍이 될 수 있다.                ans += near.second;                line.pop_back(); // 답을 추가했으니 뺀다.            } // 현재 키가 가장 근방에 있는 사람보다 작을 경우            else if (nowH &lt; near.first) {                // 이 사람까지 답에 추가할 수 있다. 같은 키를 다 넣을 수는 없고                // 딱 마지막 사람만 가능하다!!!                // 추가하고 나서는 while문을 탈출한다.                ans += 1;                break;            } // 현재 키가 가장 근방에 있는 사람과 같을 경우            else {                // 같은 키를 가진 사람은 답에 추가가능하다.                ans += near.second;                // 현재 가장 뒤에 있는 사람을 빼온다.                int count = near.second;                line.pop_back();                // 뺀뒤에도 비어있지 않다는 얘기는 현재 같은 키 말고 큰 키를 가진 사람이 앞에 있다는 얘기이다.                // 가장 근방에 있는 사람까지 pair가 가능하다.                if (!line.empty()) {                    ans += 1;                }                // 지금 있는 사람의 count 정보에 +1 하여 다시 넣어준다.                line.push_back(make_pair(nowH, count+1));                // 이미 내 현재 높이가 앞 높이와 같으므로 이것보다 작은 키는 나올 수 없다.                same = true;                break;            }        }        // 기존의 line을 업데이트한 후에, 현재 사람의 정보를 추가한다.        if (!same) {            line.push_back(make_pair(nowH, 1));        }//        cout &lt;&lt; ans &lt;&lt; '\\n';//        print();    }    cout &lt;&lt; ans;    return 0;}",
        
        "url": "/cs/algorithm/2020/07/09/%EB%B0%B1%EC%A4%80-%EC%98%A4%EC%95%84%EC%8B%9C%EC%8A%A4%EC%9E%AC%EA%B2%B0%ED%95%A9.html"
      }
      ,
    
      "cs-algorithm-2020-07-09-eb-b0-b1-ec-a4-80-ec-86-8c-ec-88-98-ea-b2-bd-eb-a1-9c-html": {
        "title": "백준(1963번): 소수 경로",
        "tags": "백준, 알고리즘, BFS, 완전탐색",
        "date": "July 9, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드5 : bfs 문제이다.백준(1963번) - 소수 경로생각최소 경로를 묻는 문제로써, 완전 탐색으로 풀이할 수 있다. 이 때, 중요한 점은, 한번의 스텝을 넘어감에 있어서 소수여야 한다는 것, 그리고 불가능하다는 것을 알려주기 위한 visited를 만드는 것이다. 재방문 했을 경우, 탐색을 하지 않을 경우 불가능한 것은 모든 경로를 다 검토했을 때, 답이 없는 경우이다.  소수인가?  방문한 숫자인가?  최종 경로인가?이 세가지 질문을 구현하면 답은 쉽게 나온다.Code#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;bool isPrime[10000];bool isVisit[10000];int T;void SieveOfEratosThenes(){    memset(isPrime, 1, sizeof(isPrime));    isPrime[0] = false;    isPrime[1] = false;    for (int i = 2; i*i &lt; 10000; i++) {        if (!isPrime[i]) continue;        for (int j = i*i; j &lt; 10000; j += i) {            isPrime[j] = false;        }    }}int BFS(int start, int end){    queue&lt;pair&lt;int, int&gt;&gt; q;    q.push(make_pair(start, 0));    while (!q.empty()) {        pair&lt;int, int&gt; now = q.front();        q.pop();        isVisit[now.first] = true;        if (now.first == end) return now.second;        for (int i = 0; i &lt; 4; i++) {            for (int j = 0; j &lt; 10; j++) {                if (i == 0 &amp;&amp; j == 0) continue;                string now_s = to_string(now.first);                int nowDepth = now.second;                now_s[i] = char('0' + j);                int candidate = stoi(now_s);                if (!isVisit[candidate] &amp;&amp; isPrime[candidate]) {                    q.push(make_pair(candidate, nowDepth+1));                }            }        }    }    return -1;}int main(){//    cout &lt;&lt; char('0' + 7);    cin &gt;&gt; T;    SieveOfEratosThenes();    for (int tc = 0; tc &lt; T; tc++) {        memset(isVisit, 0, sizeof(isVisit));        int a, b;        cin &gt;&gt; a &gt;&gt; b;        int result = BFS(a, b);        if (result == -1) cout &lt;&lt; \"Impossible\" &lt;&lt; '\\n';        else cout &lt;&lt; result &lt;&lt; '\\n';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/07/09/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%88%98_%EA%B2%BD%EB%A1%9C.html"
      }
      ,
    
      "ds-ml-2020-07-04-santander-02-eda-html": {
        "title": "02: EDA",
        "tags": "DS, kaggle, ML, Santander",
        "date": "July 4, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Santander Customer Transaction Prediction 데이터의 EDA를 수행한다.EDA  탐험적 데이터 탐색을 통해 재료를 알아보자.Check the data# 모양train_df.shape, test_df.shape((200000, 202), (200000, 201))train_df.head()test_df.head()Train contains:ID_code (string);target;200 numerical variables, named from var_0 to var_199;Test contains:ID_code (string);200 numerical variables, named from var_0 to var_199;Missing Datadef missing_data(data):    total = data.isnull().sum()    percent = (data.isnull().sum()/data.isnull().count()*100)    tt = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])    types = []    for col in data.columns:        dtype = str(data[col].dtype)        types.append(dtype)    tt['Types'] = types    return(np.transpose(tt))%%timemissing_data(train_df)CPU times: user 2.07 s, sys: 134 ms, total: 2.2 sWall time: 2.2 s%%timemissing_data(test_df)CPU times: user 2.2 s, sys: 132 ms, total: 2.33 sWall time: 2.33 s  결측치가 없는 것을 확인했다.Describe%%timetrain_df.describe()%timetest_df.describe()관찰의 결과  train, test 모두 표준 편차가 크다.  train, test 데이터의 mean, std, min 등의 특성치가 매우 근접하다. 즉, 같은 집합을 대변하는 것처럼 보인다.  각 feature의 평균값은 각기 다르다. 범위가 넓다.  train, test의 크기는 같다.변수 상관도Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/07/04/santander-02-EDA.html"
      }
      ,
    
      "ds-ml-2020-07-04-santander-01-eb-ac-b8-ec-a0-9c-ec-a0-95-ec-9d-98-ec-99-80-ec-a4-80-eb-b9-84-html": {
        "title": "01: 문제 정의 &amp; 준비",
        "tags": "DS, kaggle, ML, Santander",
        "date": "July 4, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Santander Customer Transaction Prediction 문제를 분석한다.문제 정의  거래 금액에 관계없이 미래에 어떤 고객이 특정 거래를 할 것인지 파악한다.Load Data, Packageimport gcimport osimport loggingimport datetimeimport warningsimport numpy as npimport pandas as pdimport seaborn as snsimport lightgbm as lgbfrom tqdm import tqdm_notebook # 진행바 표시하기import matplotlib.pyplot as pltfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import roc_auc_score, roc_curvefrom sklearn.model_selection import StratifiedKFoldwarnings.filterwarnings('ignore') # 주피터에서 경고 안뜨게하기IS_LOCAL = Falseif(IS_LOCAL):    PATH=\"../input/Santander/\"else:    PATH=\"../input/\"os.listdir(PATH)['sample_submission.csv', 'test.csv', 'train.csv']캐글에서 한다면 위에 같이 하면 된다.# 읽는데 걸리는 시간 파악하기%%timetrain_df = pd.read_csv(PATH+\"train.csv\")test_df = pd.read_csv(PATH+\"test.csv\")CPU times: user 15.2 s, sys: 2.09 s, total: 17.3 sWall time: 17.4 sReferencekaggle Notebook",
        
        "url": "/ds/ml/2020/07/04/santander-01-%EB%AC%B8%EC%A0%9C%EC%A0%95%EC%9D%98%EC%99%80_%EC%A4%80%EB%B9%84.html"
      }
      ,
    
      "ds-dl-2020-07-04-tf2-02-expert-html": {
        "title": "02: Expert Start Code",
        "tags": "DS, tensorflow 2.0, DL, Expert",
        "date": "July 4, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "Tensorflow 2.0 Tutorials의 Expert Start Code를 정리한다.Code# 파이썬 3에서 쓰던 문법을 파이썬 2에서 사용가능하게 해줌from __future__ import absolute_import, division, print_function, unicode_literals!pip install -q tensorflow-gpu==2.0.0-rc1  # q 옵션은 quiet 이다.. 한참찾았네..import tensorflow as tffrom tensorflow.keras.layers import Dense, Flatten, Conv2Dfrom tensorflow.keras import Modelmnist = tf.keras.datasets.mnist(x_train, y_train), (x_test, y_test) = mnist.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0# 채널을 나타내는 차원을 추가합니다. mnist는 흑백이므로 하나만.x_train = x_train[..., tf.newaxis]x_test = x_test[..., tf.newaxis]x_train.shape (60000, 28, 28, 1)# tf.data에 있는 slices를 사용하여 섞고, batch 단위로 나누자.train_ds = tf.data.Dataset.from_tensor_slices(    (x_train, y_train)).shuffle(10000).batch(32)test_ds = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)# 케라스(Keras)의 모델 서브클래싱(subclassing) API를 사용하여 tf.keras 모델을 만든다.class MyModel(Model):  def __init__(self):    super(MyModel, self).__init__()    self.conv1 = Conv2D(32, 3, activation='relu')    self.flatten = Flatten()    self.d1 = Dense(128, activation='relu')    self.d2 = Dense(10, activation='relu')  def call(self, x):    x = self.conv1(x)    x = self.flatten(x)    x = self.d1(x)    return self.d2(x)model = MyModel()# 훈련에 사용할 optimizer와 loss function을 선택한다.loss_object = tf.keras.losses.SparseCategoricalCrossentropy()optimizer = tf.keras.optimizers.Adam()# metric을 선택한다.train_loss = tf.keras.metrics.Mean(name='train_loss')train_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='train_accuracy')test_loss = tf.keras.metrics.Mean(name='test_loss')test_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='test_accuracy')# tf.GradientTape를 사용하여 모델을 훈련한다.# 이것은 모든 작업을 기록한다는 의미에서 Tape를 사용한 듯하다.@tf.function # decorator를 사용하여 진행한다.def train_step(images, labels):  # with 문은 자주 사용하는 함수를 클래스로 묶은 것을 가져와서 사용할 수 있게한다.  # 재사용에 매우 유리하다.  # 작동 방식은, GradientTape라는 클래스 안에는 시작, 끝을 알리는 행위가 기록되어 있다.  # 우리가 하는 작업 이후에 이를 꼭 해줘야 한다면, with문을 사용할 경우 이를 무조건 보장한다.  # 보통 파일 읽기, 쓰기와 같은 작업에서 많이 사용한다고 보면 된다.  # 여기서는 GradientTape에서 with 문 아래에 있는 context의 내용을 실행하고,  # 모든 연산을 \"기록\"한다.  # 우리는 train data를 넣고, loss를 뽑는 작업 이외에 수행하는 것은 항상 같다.  # 따라서 with 문으로 설계하는 것이 맞다.  with tf.GradientTape() as tape:     predictions = model(images) # 예측 결과를 저장한다.    loss = loss_object(labels, predictions)  # 기록을 완료한뒤, 기록한 gradient를 뽑자. 기록된 tape에서 후진 자동 미분을 수행한다.  gradients = tape.gradient(loss, model.trainable_variables)     # 계산된 gradient를 적용한다.  optimizer.apply_gradients(zip(gradients, model.trainable_variables))  # 현재 loss와 accuracy를 저장한다.  train_loss(loss)  train_accuracy(labels, predictions)여기서 잠깐, trainable_variables은 실제로 model에 데이터가 들어갔을 때,  [  &lt;tf.Variable 'my_model/conv2d/kernel:0' shape=(3, 3, 1, 32) dtype=float32&gt;,   &lt;tf.Variable 'my_model/conv2d/bias:0' shape=(32,) dtype=float32&gt;,  &lt;tf.Variable 'my_model/dense/kernel:0' shape=(21632, 128) dtype=float32&gt;,   &lt;tf.Variable 'my_model/dense/bias:0' shape=(128,) dtype=float32&gt;,   &lt;tf.Variable 'my_model/dense_1/kernel:0' shape=(128, 10) dtype=float32&gt;,   &lt;tf.Variable 'my_model/dense_1/bias:0' shape=(10,) dtype=float32&gt;]위와 같이 배열 형태로 들어가게 된다. 이러한 입력에 대해 loss를 보고 gradient를 계산한다. 업데이트도 마찬가지고 입력과 gradients가 주어져야 할 수 있기 때문에 zip의 형태로 들어간다. 아주 편리하다,,# test에서도 만들어준다.# 이경우는 gradient를 할필요가 없다.@tf.functiondef test_step(images, labels):  predictions = model(images)  t_loss = loss_object(labels, predictions)  test_loss(t_loss)  test_accuracy(labels, predictions)EPOCHS = 5for epoch in range(EPOCHS):  for images, labels in train_ds:    train_step(images, labels)    for test_images, test_labels in test_ds:    test_step(test_images, test_labels)  template = '에포크: {}, 손실: {}, 정확도: {}, 테스트 손실: {}, 테스트 정확도: {}'  print(template.format(epoch+1,                        train_loss.result(),                        train_accuracy.result()*100,                        test_loss.result(),                        test_accuracy.result()*100))에포크: 1, 손실: 2.3113672733306885, 정확도: 9.899853706359863, 테스트 손실: 2.3025553226470947, 테스트 정확도: 9.800000190734863에포크: 2, 손실: 2.3101234436035156, 정확도: 9.895792961120605, 테스트 손실: 2.3025572299957275, 테스트 정확도: 9.800000190734863에포크: 3, 손실: 2.309101104736328, 정확도: 9.892754554748535, 테스트 손실: 2.3025825023651123, 테스트 정확도: 9.800000190734863에포크: 4, 손실: 2.3081705570220947, 정확도: 9.890397071838379, 테스트 손실: 2.3026015758514404, 테스트 정확도: 9.800000190734863에포크: 5, 손실: 2.307427406311035, 정확도: 9.88851261138916, 테스트 손실: 2.3026163578033447, 테스트 정확도: 9.800000190734863ReferenceTensorflow 2.0 tutorials",
        
        "url": "/ds/dl/2020/07/04/TF2-02-Expert.html"
      }
      ,
    
      "ds-dl-2020-07-04-tf2-01-beginner-html": {
        "title": "01: Beginner Start Code",
        "tags": "DS, tensorflow 2.0, DL, beginner",
        "date": "July 4, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "Tensorflow 2.0 Tutorials의 Beginner Start Code를 정리한다.Code!pip install tensorflow-gpu==2.0.0-rc1import tensorflow as tfmnist = tf.keras.datasets.mnist(x_train, y_train), (x_test, y_test) = mnist.load_data()# 픽셀 값을 정수에서 실수로 변경해준다.x_train, x_test = x_train / 255.0, x_test / 255.0# 간단하게 만들 때는 이런 방법도 나쁘지는 않다.# 다만 나중에 관리가 짜증나겠지?model = tf.keras.models.Sequential([    tf.keras.layers.Flatten(input_shape=(28, 28)),    tf.keras.layers.Dense(128, activation='relu'),    tf.keras.layers.Dropout(0.2),    tf.keras.layers.Dense(10, activation='softmax')])model.compile(optimizer='adam',              loss='sparse_categorical_crossentropy',              metrics=[\"accuracy\"])model.fit(x_train, y_train, epochs=5)model.evaluate(x_test, y_test, verbose=2)Epoch 1/51875/1875 [==============================] - 4s 2ms/step - loss: 0.0355 - accuracy: 0.9879Epoch 2/51875/1875 [==============================] - 5s 3ms/step - loss: 0.0323 - accuracy: 0.9886Epoch 3/51875/1875 [==============================] - 5s 2ms/step - loss: 0.0322 - accuracy: 0.9890Epoch 4/51875/1875 [==============================] - 4s 2ms/step - loss: 0.0298 - accuracy: 0.9897Epoch 5/51875/1875 [==============================] - 4s 2ms/step - loss: 0.0289 - accuracy: 0.9901313/313 - 1s - loss: 0.0831 - accuracy: 0.9791[0.08314403146505356, 0.9790999889373779]ReferenceTensorflow 2.0 tutorials",
        
        "url": "/ds/dl/2020/07/04/TF2-01-Beginner.html"
      }
      ,
    
      "cs-algorithm-2020-07-04-eb-b0-b1-ec-a4-80-eb-b6-88-html": {
        "title": "백준(5437번): 불",
        "tags": "백준, 알고리즘, BFS, 시뮬레이션",
        "date": "July 4, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : bfs 문제이다.백준(5437번) - 불생각단순한 구현 문제이다. 이 때, 순서를 잘 파악하는 것이 중요하다. 먼저, 불을 번지게 한 상태에서, 사람의 현재 위치로 부터 어디로 가는 것이 좋은지를 판단해야 한다. 그리고 사람이 가장 자리에 도착한다면, 다음번째에 탈출이 가능하다.Code#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;// BFS를 사용하여 불을 붙인다.// 불을 붙이는 행위는 언제 까지 하면 돼? -&gt; 탈출하면 불 안붙여도 돼// 그렇다면 사람이 움직이는 것에 불을 붙이는 행위는 의존적// 그럼 q를 하나만 사용하면 될까?// 아니야 불은 따로 움직여야해// 이렇게 하자. 불의 시작 위치를 가지고 있는 q, 사람의 시작 위치를 가지고 있는 q를 두개를 만들자.// 그리고 사람 q안이 비어있을 때까지 루프를 돌리는데, 그때 불 q를 돌리자.const int MAX = 1000;struct Dir{    int y;    int x;};Dir moveDir[4] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0}};int W, H;string graph[MAX];bool visited[MAX][MAX];pair&lt;int, int&gt; start;vector&lt;pair&lt;int, int&gt;&gt; fire;void printG(){    for (int i = 0; i &lt; H; i++) {        cout &lt;&lt; graph[i] &lt;&lt; '\\n';    }    cout &lt;&lt; '\\n';}int BFS(){    int ans = 0;    queue&lt;pair&lt;int, int&gt;&gt; q;    queue&lt;pair&lt;int, int&gt;&gt; fire_q;    q.push(start);    for (int i = 0; i &lt; int(fire.size()); i++) {        fire_q.push(fire[i]);    }        while (!q.empty()) {        // 불을 먼저 붙인다.        int fireSize = int(fire_q.size());        for (int i = 0; i &lt; fireSize; i++) {            int y = fire_q.front().first;            int x = fire_q.front().second;            fire_q.pop();                        for (int j = 0; j &lt; 4; j++) {                int nextY = y + moveDir[j].y;                int nextX = x + moveDir[j].x;                                if (0 &lt;= nextY &amp;&amp; nextY &lt; H &amp;&amp; 0 &lt;= nextX &amp;&amp; nextX &lt; W){                    if (graph[nextY][nextX] == '.') {                        graph[nextY][nextX] ='*';                        fire_q.push(make_pair(nextY, nextX));                    }                }            }        }//        printG();                // 사람을 이동시킨다.        int manSize = int(q.size()); //  와 이거 안해주면 q가 동적으로 크기가 바뀌어서 이상하게됨..        for (int i = 0; i &lt; manSize; i++) {            int y = q.front().first;            int x = q.front().second;            q.pop();                        // 가장 자리에 있을 경우에는 다음번에 탈출이다.            if (y == 0 || y == H-1 || x == 0 || x == W-1)                return ans + 1;            for (int i = 0; i &lt; 4; i++) {                int nextY = y + moveDir[i].y;                int nextX = x + moveDir[i].x;                                if (0 &lt;= nextY &amp;&amp; nextY &lt; H &amp;&amp; 0 &lt;= nextX &amp;&amp; nextX &lt; W){                    if (visited[nextY][nextX] == false &amp;&amp; graph[nextY][nextX] != '*' &amp;&amp; graph[nextY][nextX] != '#') {                        visited[nextY][nextX] = true;                        q.push(make_pair(nextY, nextX));                    }                                    }            }                                }        ans++;//        printG();    }    return -1;}int main(){    int T;    cin &gt;&gt; T;        for (int tc = 0; tc &lt; T; tc++) {        // tc 문제에서는 배열을 초기화 해주는 것을 까먹으면 안된다.        fire.clear();        memset(visited, false, sizeof(visited));                cin &gt;&gt; W &gt;&gt; H;                for (int i = 0; i &lt; H; i++) {            cin &gt;&gt; graph[i];            for (int j = 0; j &lt; W; j++) {                if (graph[i][j] == '@') {                    start = make_pair(i, j);                    visited[i][j] = true;                }                else if (graph[i][j] == '*') fire.push_back(make_pair(i, j));            }        }                int ans = BFS();                if (ans == -1) cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; '\\n';        else cout &lt;&lt; ans &lt;&lt; '\\n';            }        return 0;}",
        
        "url": "/cs/algorithm/2020/07/04/%EB%B0%B1%EC%A4%80-%EB%B6%88.html"
      }
      ,
    
      "math-statistics-2020-06-03-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-13-ea-b0-80-ec-84-a4-ea-b2-80-ec-a0-95-html": {
        "title": "12: 가설 검정",
        "tags": "Math, Statistics, sample distribution, 중심 극한 정리, central limit theorem",
        "date": "June 3, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "가설 검정에 대해 이해한다.",
        
        "url": "/math/statistics/2020/06/03/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-13-%EA%B0%80%EC%84%A4-%EA%B2%80%EC%A0%95.html"
      }
      ,
    
      "math-statistics-2020-06-03-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-12-ec-b6-94-eb-a1-a0-html": {
        "title": "11: 통계적 추론",
        "tags": "Math, Statistics, sample distribution, 중심 극한 정리, central limit theorem",
        "date": "June 3, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "통계적 추론에 대해 이해한다.통계적 추론  표본이 갖고 있는 정보를 분석하여 모수에 관한 결론을 유도하고, 모수에 대한 가설의 옳고 그름을 판단하는 것추정의 방법모수를 추정하는 방법에 대해서 알아본다.점 추정  모수를 추정하기 위해 하나의 값을 제안한다.해당 모수를 추정하기 위해 만들어진 통계량을 추정량이라 한다. 그리고 이 추정량으로 부터 하나의 추정치를 제시하는 것이 점 추정이다.구간 추정  모수를 추정하기 위해 모수가 포함될 것이라 예상되는 구간을 제시한다.이 때 제시되는 구간을 신뢰구간이라고 한다. 그리고 해당 신뢰구간에 모수가 들어올 확률을 신뢰 수준이라 한다.신뢰 구간의 의미모평균이 100이라 가정하고 표본의 크기가 15라고 생각하자. 이 때, 95% 신뢰수준을 가지는 신뢰구간을 25번 뽑는다고 생각해보자. 이 경우, 이 25개의 선중 23개(92%)가 모평균을 포함하게 된다. 그렇다면 내가 표본을 뽑는 횟수를 증가하면 할 수록 이는 95%에 가까워 진다.",
        
        "url": "/math/statistics/2020/06/03/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-12-%EC%B6%94%EB%A1%A0.html"
      }
      ,
    
      "math-statistics-2020-06-03-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-11-ed-91-9c-eb-b3-b8-eb-b6-84-ed-8f-ac-html": {
        "title": "11: 표본 분포",
        "tags": "Math, Statistics, sample distribution, 중심 극한 정리, central limit theorem",
        "date": "June 3, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "표본 분포와 통계량에 대해 이해한다.추론  표본을 가지고 모집단의 특성(모수)를 예측하는 것통계학의 핵심은 내가 원하는 집단의 특징을 알아내는 것이다. 즉, 우리가 관측할 수 있는 표본을 가지고, 이 표본의 특징을 통해 모집단의 특징(모수)를 예측하는 것이다.이러한 모수는 수치로 표현되는 모집단의 특성을 말하는데, 이 모수는 내가 모집단의 분포를 가정했을 때, 해당 분포를 나타내기 위한 parameter로 대변될 수 있다.통계량  표본의 관측값들에 의하여 결정되는 수치적인 양표본 평균, 표본 표준 편차와 같이 표본의 값을 기반으로 하여 얻을 수 있는 값을 통계량이라 한다. 이런 통계량을 기반으로 이와 모수와의 관계를 알아내고, 모수를 추론하는 과정을 거친다.이런 통계량을 랜덤변수로 사용할 수 있다. 우리가 표본을 뽑을 때 마다 표본에 해당하는 통계량 값은 변화하기 때문이다. 따라서 우리는 여러번의 표본을 뽑는다는 가정하에 이러한 통계량을 랜덤변수로써 사용할 수 있다.중심 극한 정리  어떠한 모집단이더라도, 모집단의 평균이 $\\mu$ 이고, 분산이 $\\sigma^2$ 일 때, 임의추출된 표본의 표본 평균 $\\bar X$ 는 표본의 크기가 클 경우 정규분포를 따른다.매우 중요한 중심극한 정리이다. 중심극한 정리의 핵심은, 표본을 뽑은 통계량으로 우리는 모집단의 모수를 추론할 것인데, 어떠한 분포에서 표본을 뽑던 간에 무조건 표본 평균이라는 통계량이 따르는 분포가 정해졌다는 것이다. 이러한 점에서 우리는 통계량의 분포를 가지고 모평균을 추론할 수 있게 된다.이 중심극한 정리의 증명은 적률 생성 함수를 가지고 할 수 있다. 자세한 점은 수리 통계학 책을 공부하기 바란다.",
        
        "url": "/math/statistics/2020/06/03/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-11-%ED%91%9C%EB%B3%B8%EB%B6%84%ED%8F%AC.html"
      }
      ,
    
      "math-statistics-2020-06-03-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-10-ec-a0-95-ea-b7-9c-eb-b6-84-ed-8f-ac-html": {
        "title": "10: 정규 분포",
        "tags": "Math, Statistics, normal distribution",
        "date": "June 3, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "정규분포에 대해 이해한다.정규 분포실제로 가장 많이 적용되는 분포는 이항 분포이다. 하지만 이는 이산 확률 변수에 대해 정의되는 변수이다. 이번에는 연속 확률 분포들 중에서 대부분의 통계학 이론의 기본이 되는 정규분포에 대해서 공부한다.정규분포는 종 모양의 확률밀도함수를 가지며, 이는 피에르 라플라스와 칼 가우스가 정리했다.정규분포의 성질  모든 관측치의 68%는 $\\pm \\sigma$ 에 속한다.  모든 관측치의 95%는 $\\pm 2\\sigma$ 에 속한다.  모든 관측치의 99.7%는 $\\pm 3\\sigma$ 에 속한다.이는 앞에서 배운 히스토그램이 종모양 일 때 적용되는 경험 법칙과 맥을 같이 한다.실질적인 계산은 표준정규분포를 가지고 계산하게 된다.이항 분포의 정규분포근사위의 경험 법칙에서 알 수 있듯, 이항 분포는 정규분포에 근사하는 성질이 있다.",
        
        "url": "/math/statistics/2020/06/03/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-10-%EC%A0%95%EA%B7%9C%EB%B6%84%ED%8F%AC.html"
      }
      ,
    
      "ds-visualization-2020-05-31-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-15-ordered-bar-chart-html": {
        "title": "15: Ordered Bar Chart",
        "tags": "DS, python, matplotlib, Diverging lines",
        "date": "May 31, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "feature를 정리한 후 히스토그램을 그려보자.# Useful for:# This is a normal bar chart but ordered in a specific way.# From the lowest to the highest values# It's useful to show comparisons among discrete categories.# More info: # https://en.wikipedia.org/wiki/Bar_chart# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# groupby and create the target x and ygb_df = df.groupby([\"manufacturer\"])[\"cyl\", \"displ\", \"cty\"].mean()gb_df.sort_values(\"cty\", inplace = True)# fitler x and yx = gb_df.indexy = gb_df[\"cty\"]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 8))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# plot the datafor x_, y_ in zip(x, y):    # this is very cool, since we can pass a function to matplotlib    # and it will plot the color based on the result of the evaluation    ax.bar(x_, y_, color = \"red\" if y_ &lt; y.mean() else \"green\", alpha = 0.3)         # add some text    ax.text(x_, y_ + 0.3, round(y_, 1), horizontalalignment = 'center')# ----------------------------------------------------------------------------------------------------# prettify the plot# Add a patch below the x axis line to enphasize that they are below the mean# I had to copy and paste this code, since I didn't manage to figure it out.# red onep2 = patches.Rectangle((.124, -0.005), width = .360, height = .13, alpha = .1, facecolor = 'red', transform = fig.transFigure)fig.add_artist(p2)# green onep1 = patches.Rectangle((.124 + .360, -0.005), width = .42, height = .13, alpha = .1, facecolor = 'green', transform = fig.transFigure)fig.add_artist(p1)# rotate the x ticks 90 degreesax.set_xticklabels(x, rotation=90)# add an y labelax.set_ylabel(\"Average Miles per Gallon by Manufacturer\")# set a titleax.set_title(\"Bar Chart for Highway Mileage\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/31/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-15-Ordered-Bar-Chart.html"
      }
      ,
    
      "ds-visualization-2020-05-31-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-14-area-chart-html": {
        "title": "14: Area chart",
        "tags": "DS, python, matplotlib, Diverging lines",
        "date": "May 31, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "하나 또는 두개의 데이터에 대한 흐름을 파악할 때 유용한 Area chart를 알아보자.  연습 kaggle notebook# Useful for:# Area chart is really useful when you want to drawn the attention about when a series is below a certain point.# The area between axis and line are commonly emphasized with colors, textures and hatchings. # Commonly one compares two or more quantities with an area chart.# More info: # https://en.wikipedia.org/wiki/Area_chart# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/economics.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# create the variation between 2 consecutive rowsdf[\"pce_monthly_change\"] = (df[\"psavert\"] - df[\"psavert\"].shift(1))/df[\"psavert\"].shift(1)# convert todatetimedf[\"date_converted\"] = pd.to_datetime(df[\"date\"])# filter our df for a specific datedf = df[df[\"date_converted\"] &lt; np.datetime64(\"1975-01-01\")]# separate x and y x = df[\"date_converted\"]y = df[\"pce_monthly_change\"]# calculate the max values to annotate on the ploty_max = y.max()# find the index of the max valuex_ind = np.where(y == y_max)# find the x based on the index of maxx_max = x.iloc[x_ind]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (15, 10))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# plot the dataax.plot(x, y, color = \"black\")ax.scatter(x_max, y_max, s = 300, color = \"green\", alpha = 0.3)# annotate the text of the Max valueax.annotate(r'Max value',             xy = (x_max, y_max),              xytext = (-90, -50),              textcoords = 'offset points',              fontsize = 16,             arrowprops = dict(arrowstyle = \"-&gt;\", connectionstyle = \"arc3,rad=.2\")           )# ----------------------------------------------------------------------------------------------------# prettify the plot# fill the area with a specific colorax.fill_between(x, 0, y, where = 0 &gt; y, facecolor='red', interpolate = True, alpha = 0.3)ax.fill_between(x, 0, y, where = 0 &lt;= y, facecolor='green', interpolate = True, alpha = 0.3)# change the ylim to make it more pleasant for the viewerax.set_ylim(y.min() * 1.1, y.max() * 1.1)# change the values of the x axis# extract the first 3 letters of the monthxtickvals = [str(m)[:3].upper() + \"-\" + str(y) for y,m in zip(df.date_converted.dt.year, df.date_converted.dt.month_name())]# this way we can set the ticks to be every 6 months.ax.set_xticks(x[::6])# change the current ticks to be our string month value# basically pass from this: 1967-07-01# to this: JUL-1967ax.set_xticklabels(xtickvals[::6], rotation=90, fontdict={'horizontalalignment': 'center', 'verticalalignment': 'center_baseline'})# add a gridax.grid(alpha = 0.3)# set the titleax.set_title(\"Monthly variation return %\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/31/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-14-Area-Chart.html"
      }
      ,
    
      "ds-visualization-2020-05-31-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-13-diverging-lollipop-chart-with-markers-html": {
        "title": "13: Diverging Lollipop Chart with Markers",
        "tags": "DS, python, matplotlib, Diverging lines",
        "date": "May 31, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "각 카테고리에 대한 값(평균, 중앙값, 표준화 값)을 비교하기 용이한 Diverging Bars를 동그라미로 나타내보자.  연습 kaggle notebook# Useful for:# This plot is really useful to show the different performance of deviation of data.# We use text to annotate the value and make more easy the comparison.# This plot is very similar to the previous 2# But here we don't draw any lines and just play with the size of each point and make it a little bigger# More info: # https://blog.datawrapper.de/divergingbars/# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mtcars.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# here we standarize the data# More info:# https://statisticsbyjim.com/glossary/standardization/df[\"x_plot\"] = (df[\"mpg\"] - df[\"mpg\"].mean())/df[\"mpg\"].std()# sort value and reset the indexdf.sort_values(\"x_plot\", inplace = True)df.reset_index(inplace=True)# create a color list, where if value is above &gt; 0 it's green otherwise redcolors = [\"red\" if x &lt; 0 else \"green\" for x in df[\"x_plot\"]]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 8))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# plot the data# iterate over x and y and annotate text and plot the datafor x, y in zip(df[\"x_plot\"], df.index):        # make a horizontal line from the y till the x value    # this doesn't appear in the original 50 plot challenge    ax.hlines(y = y,                xmin = -3,                 xmax = x,                linewidth = 0.5,               alpha = 0.3,               color = \"red\" if x &lt; 0 else \"green\")        # annotate text    ax.text(x,              y,              round(x, 2),              color = \"black\",             horizontalalignment='center',              verticalalignment='center',             size = 8)        # plot the points    ax.scatter(x,                 y,                 color = \"red\" if x &lt; 0 else \"green\",                 s = 300,                alpha = 0.5)# ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Diverging plot in matplotlib\")# change x limax.set_xlim(-3, 3)# set labelsax.set_xlabel(\"Mileage\")ax.set_ylabel(\"Car Name\")# instead of y = 1, 2, 3...# put the car makers on the y axisax.set_yticks(df.index)ax.set_yticklabels(df.cars)# change the spines to make it nicerax.spines[\"top\"].set_color(\"None\")ax.spines[\"left\"].set_color(\"None\")# with this line, we change the right spine to be in the middle# as a vertical line from the originax.spines['right'].set_position(('data',0))ax.spines['right'].set_color('grey')Patch를 좀 더 간단하게# Useful for:# This plot is really useful to show the different performance of deviation of data.# In this plot we use rectagles and matplotlib patches to draw the attention to specific points# This example shows how to add patches more easily# More info: # https://blog.datawrapper.de/divergingbars/# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mtcars.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# here we standarize the data# More info:# https://statisticsbyjim.com/glossary/standardization/df[\"x_plot\"] = (df[\"mpg\"] - df[\"mpg\"].mean())/df[\"mpg\"].std()# sort value and reset the indexdf.sort_values(\"x_plot\", inplace = True)df.reset_index(inplace = True)# we plot everything with a black color except a specific Fiat model# this way we visually communicate something to the userdf[\"color\"] = df[\"cars\"].apply(lambda car_name: \"orange\" if car_name == \"Fiat X1-9\" else \"black\")# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (8, 12))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# plot the data# plot horizontal lines from the origin to each data pointax.hlines(y = df.index,           xmin = 0,          xmax = df[\"x_plot\"],          color = df[\"color\"],          alpha = 0.6)# plot the dotsax.scatter(x = df[\"x_plot\"],          y = df.index,          s = 100,          color = df[\"color\"],          alpha = 0.6)# add patches more easily# It's easier to draw shapes like rectangles or squares, since this way# we only must specify 2 points, and matplotlib does all the jobp1 = patches.Rectangle((-2.0, -1), width = .3, height = 3, alpha = .2, facecolor = 'red')p2 = patches.Rectangle((1.5, 27), width = .8, height = 5, alpha = .2, facecolor = 'green')ax.add_patch(p1)ax.add_patch(p2)# annotate textax.annotate('Mercedes Models',             xy = (0.0, 11.0),             xytext = (1.5, 11),             xycoords = 'data',             fontsize = 10,             ha = 'center',             va = 'center',            bbox = dict(boxstyle = 'square', fc = 'blue', alpha = 0.1),            arrowprops = dict(arrowstyle = '-[, widthB=2.0, lengthB=1.5', lw = 2.0, color = 'grey'), color = 'black')# ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Diverging Lollipop of Car Mileage\")# autoscaleax.autoscale_view()# change x limax.set_xlim(-3, 3)# set labelsax.set_xlabel(\"Mileage\")ax.set_ylabel(\"Car Name\")# instead of y = 1, 2, 3...# put the car makers on the y axisax.set_yticks(df.index)ax.set_yticklabels(df.cars)# change the spines to make it nicerax.spines[\"right\"].set_color(\"None\")ax.spines[\"top\"].set_color(\"None\")# add a gridax.grid(linestyle='--', alpha=0.5);ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/31/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-13-Diverging-Lollipop-Chart-with-Markers.html"
      }
      ,
    
      "ds-visualization-2020-05-20-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-12-diverging-lines-with-text-html": {
        "title": "12: Diverging lines with text",
        "tags": "DS, python, matplotlib, Diverging lines",
        "date": "May 20, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "각 카테고리에 대한 값(평균, 중앙값, 표준화 값)을 비교하기 용이한 Diverging Bars에 정보를 추가해보자.연습 kaggle notebook# Useful for:# This plot is really useful to show the different performance of deviation of data.# We use text to annotate the value and make more easy the comparison.# More info: # https://blog.datawrapper.de/divergingbars/# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mtcars.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# here we standarize the data# More info:# https://statisticsbyjim.com/glossary/standardization/df[\"x_plot\"] = (df[\"mpg\"] - df[\"mpg\"].mean())/df[\"mpg\"].std()# sort value and reset the indexdf.sort_values(\"x_plot\", inplace = True)df.reset_index(inplace=True)# create a color list, where if value is above &gt; 0 it's green otherwise redcolors = [\"red\" if x &lt; 0 else \"green\" for x in df[\"x_plot\"]]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 8))ax = fig.add_subplot()# plot horizontal lines that go from zero to the value# here we make the linewidht very thin.ax.hlines(y = df.index, xmin = 0 , color = colors,  xmax = df[\"x_plot\"], linewidth = 1)# ----------------------------------------------------------------------------------------------------# plot the data# iterate over x and y and annotate text and plot the datafor x, y in zip(df[\"x_plot\"], df.index):    # annotate text    ax.text(x - 0.1 if x &lt; 0 else x + 0.1,              y,              round(x, 2),              color = \"red\" if x &lt; 0 else \"green\",               horizontalalignment='right' if x &lt; 0 else 'left',              size = 10)    # plot the points    ax.scatter(x,                 y,                 color = \"red\" if x &lt; 0 else \"green\",                 alpha = 0.5)# ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Diverging plot in matplotlib\")# change x limax.set_xlim(-3, 3)# set labelsax.set_xlabel(\"Mileage\")ax.set_ylabel(\"Car Name\")# make a gridax.grid(linestyle='--', alpha=0.5)# instead of y = 1, 2, 3...# put the car makers on the y axisax.set_yticks(df.index)ax.set_yticklabels(df.cars)# change the spines to make it nicerax.spines[\"top\"].set_color(\"None\")ax.spines[\"left\"].set_color(\"None\")# with this line, we change the right spine to be in the middle# as a vertical line from the originax.spines['right'].set_position(('data',0))ax.spines['right'].set_color('black')ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/20/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-12-Diverging-lines-with-text.html"
      }
      ,
    
      "ds-visualization-2020-05-19-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-11-diverging-bars-html": {
        "title": "11: Diverging Bars",
        "tags": "DS, python, matplotlib, Diverging Bars",
        "date": "May 19, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "각 카테고리에 대한 값(평균, 중앙값, 표준화 값)을 비교하기 용이한 Diverging Bars을 알아본다.연습 kaggle notebook# Useful for:# Based on a metric to compare, this plot helps you to see the divergence of the a value # to that metric (it could be mean, median or others).# More info: # https://blog.datawrapper.de/divergingbars/# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mtcars.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# here we standarize the data# More info:# https://statisticsbyjim.com/glossary/standardization/df[\"x_plot\"] = (df[\"mpg\"] - df[\"mpg\"].mean())/df[\"mpg\"].std()# sort value and reset the index# sort를 하게되면 index가 제멋대로 배열된다.# 우리는 배열된 이후의 index를 다시 갖고 싶은 것이기 때문에 index를 정렬후 새로 만들어준다.# 이 때, drop = True, inplace = True가 있는데 drop은 재생성한 후 이전 것을 버리는 것을 의미한다.# inplace는 원본 데이터를 대체할 것인지, 아니면 변경된 객체를 반환할 것인지를 결정한다.df.sort_values(\"x_plot\", inplace = True)df.reset_index(inplace = True)# create a color list, where if value is above &gt; 0 it's green otherwise redcolors = [\"red\" if x &lt; 0 else \"green\" for x in df[\"x_plot\"]]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 8))ax = fig.add_subplot()# plot using horizontal lines and make it look like a column by changing the linewidth# 가로선을 그음으로써 원하는 그래프와 비슷한 모양을 만든다.ax.hlines(y = df.index, xmin = 0 , xmax = df[\"x_plot\"],  color = colors, linewidth = 5)# ----------------------------------------------------------------------------------------------------# prettify the plot# set x and y axisax.set_xlabel(\"Mileage\")ax.set_ylabel(\"Car Name\")# set a titleax.set_title(\"Diverging plot in matplotlib\")# make a grid to help separate the linesax.grid(linestyle='--', alpha=0.5)# change the y ticks# first you set the yticks# 먼저 y에 index를 박고,ax.set_yticks(df.index)# then you change them using the car names# same can be achived using plt.yticks(df.index, df.cars)# 그 index에 맞는 차를 넣어준다.# 이 때, ;를 추가하여 output이 나오지 않게 만들어준다.ax.set_yticklabels(df.cars);ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/19/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-11-Diverging-Bars.html"
      }
      ,
    
      "ds-visualization-2020-05-19-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-10-pair-plot-html": {
        "title": "10: Pair plot",
        "tags": "DS, python, matplotlib, Pair plot",
        "date": "May 19, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "두 변수간의 관계를 한눈에 파악할 수 있는 Pair plot을 알아본다.연습 kaggle notebook# Useful for:# Plot pairwise relationships in a dataset. # Helps you to see in a glance of an eye all distribution and correlation of variables.# More info: # https://seaborn.pydata.org/generated/seaborn.pairplot.html# ----------------------------------------------------------------------------------------------------# get the datadf = sns.load_dataset('iris')# plot the data using seaborn# hue = 색조, 이 변수에 내가 원하는 그룹의 변수를 적어주면 된다.# 이 부분을 안하면, 대각원소에는 히스토그램이 그려진다.sns.pairplot(df,              hue = \"species\" # helps to separate the values by specios            );각각의 산점도에 종마다 회귀선을 그려보자.# Useful for:# Plot pairwise relationships in a dataset. # Helps you to see in a glance of an eye all distribution and correlation of variables.# This plot also plots a regression line to fit each of the data# More info: # https://seaborn.pydata.org/generated/seaborn.pairplot.html# ----------------------------------------------------------------------------------------------------# get the datadf = sns.load_dataset('iris')# plot the data using seabornsns.pairplot(df,              kind = \"reg\", # make a regression line for eac hue and each variables             hue = \"species\"            );ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/19/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-10-Pair-Plot.html"
      }
      ,
    
      "ds-visualization-2020-05-19-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-09-correlation-plot-html": {
        "title": "09: Correlation plot",
        "tags": "DS, python, matplotlib, Correlation plot",
        "date": "May 19, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "변수들의 상관관계를 한눈에 파악할 수 있는 Correlation plot을 알아본다.연습 kaggle notebook# Useful for:# The correlation plot helps us to comparte how correlated are 2 variables between them# More info: # https://en.wikipedia.org/wiki/Covariance_matrix#Correlation_matrix# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mtcars.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))ax = fig.add_subplot()# plot using matplotlib# https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.axes.Axes.imshow.htmlax.imshow(df.corr(), cmap = 'viridis', interpolation = 'nearest')# set the title for the figureax.set_title(\"Heatmap using matplotlib\");단순히 이렇게만 plot하면 알아보는 것이 어려우니, x, y축에 변수이름을 적어 나타내어 보자.# Useful for:# The correlation plot helps us to comparte how correlated are 2 variables between them# More info: # https://en.wikipedia.org/wiki/Covariance_matrix#Correlation_matrix# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mtcars.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# calculate the correlation between all variablescorr = df.corr()# create a mask to pass it to seaborn and only show half of the cells # because corr between x and y is the same as the y and x# it's only for estetic reasonsmask = np.zeros_like(corr) # 0행렬을 만든다.mask[np.triu_indices_from(mask)] = True # upper triangle 부분을 true로 바꾼다.# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))# plot the data using seabornax = sns.heatmap(corr,                  mask = mask,                  vmax = 0.3,                  square = True,                   cmap = \"viridis\")# set the title for the figureax.set_title(\"Heatmap using seaborn\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/19/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-09-Correlation-plot.html"
      }
      ,
    
      "ds-visualization-2020-05-16-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-08-marginal-histogram-html": {
        "title": "08: Marginal Histogram",
        "tags": "DS, python, matplotlib, Marginal Histogram",
        "date": "May 16, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "Scatter Plot에 각각의 histogram을 추가해보자.연습 kaggle notebook# Useful for:# This plot is a combination of 2 plots.# On one side we have a normal scatter plot that is helpful to see the relationship between data (x and y axis)# But we also add a histogram that is useful to see the concentration/bins and the distribution of a series.# More info: # https://en.wikipedia.org/wiki/Histogram# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# separate x and yx = df[\"displ\"]y = df[\"hwy\"]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))# in this case we use gridspec.# check the basics section of this kernel if you need help.gs = fig.add_gridspec(5, 5)ax1 = fig.add_subplot(gs[:4, :-1])# ----------------------------------------------------------------------------------------------------# plot the data# main axis: scatter plot# this line is very nice c = df.manufacturer.astype('category').cat.codes# since it basically generate a color for each category# 이렇게 하면 카테고리별 색상을 구해준다. 총 78개의 category가 있는 것으로 보인다.ax1.scatter(x, y, c = df.manufacturer.astype('category').cat.codes) # set the labels for x and yax1.set_xlabel(\"Dist\")ax1.set_ylabel(\"Hwy\")# set the title for the main plotax1.set_title(\"Scatter plot with marginal histograms\")# prettify the plot# get rid of some of the spines to make the plot nicerax1.spines[\"right\"].set_color(\"None\")ax1.spines[\"top\"].set_color(\"None\")# using familiar slicing, get the bottom axes and plotax2 = fig.add_subplot(gs[4:, :-1])ax2.hist(x, 40, orientation = 'vertical', color = \"pink\")# invert the axis (it looks up side down)ax2.invert_yaxis()# prettify the plot# set the ticks to nullax2.set_xticks([])ax2.set_yticks([])# no axis to make plot nicerax2.axison = False# using familiar slicing, get the left axes and plotax3 = fig.add_subplot(gs[:4, -1])ax3.hist(y, 40, orientation = \"horizontal\", color = \"pink\")# prettify the plot# set the ticks to nullax3.set_xticks([])ax3.set_yticks([])# no axis to make plot nicerax3.axison = False# make all the figures look nicierfig.tight_layout()ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/16/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-08-Marginal-Histogram.html"
      }
      ,
    
      "ds-visualization-2020-05-16-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-08-marginal-boxplot-html": {
        "title": "09: Marginal Boxplot",
        "tags": "DS, python, matplotlib, Marginal Boxplot",
        "date": "May 16, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "Scatter Plot에 각각의 boxplot을 추가해보자.연습 kaggle notebooksns.set_style(\"whitegrid\")# Useful for:# A box plot or boxplot is a method for graphically depicting groups of numerical data through their quartiles.# It helps to see the dispersion of a series, thanks to the whiskers# More info: # https://en.wikipedia.org/wiki/Box_plot# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plottingx = df[\"displ\"]y = df[\"hwy\"]# in this plot we create the colors separatlycolors = df[\"manufacturer\"].astype(\"category\").cat.codes# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))# in this case we use gridspec.# check the basics section of this kernel if you need help.gs = fig.add_gridspec(6, 6)ax1 = fig.add_subplot(gs[:4, :-1])# ----------------------------------------------------------------------------------------------------# plot the data# main axis: scatter plot# this line is very nice c = df.manufacturer.astype('category').cat.codes# since it basically generate a color for each categoryax1.scatter(x, y, c = df.manufacturer.astype('category').cat.codes) # set the labels for x and yax1.set_xlabel(\"Dist\")ax1.set_ylabel(\"Hwy\")# set the title for the main plotax1.set_title(\"Scatter plot with marginal histograms\")# prettify the plot# get rid of some of the spines to make the plot nicerax1.spines[\"right\"].set_color(\"None\")ax1.spines[\"top\"].set_color(\"None\")# using familiar slicing, get the left axes and plotax2 = fig.add_subplot(gs[4:, :-1])ax2.boxplot(x,             vert = False,              whis = 0.75 # make the boxplot lines shorter           )# prettify the plot# set the ticks to nullax2.set_xticks([])ax2.set_yticks([])# left plotax3 = fig.add_subplot(gs[:4, -1])ax3.boxplot(y,              whis = 0.75 # make the boxplot lines shorter           )# prettify the plot# set the ticks to nullax3.set_xticks([])ax3.set_yticks([])# make all the figures look nicierfig.tight_layout()ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/16/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-08-Marginal-Boxplot.html"
      }
      ,
    
      "math-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-09-eb-8b-a4-ec-96-91-ed-95-9c-ed-99-95-eb-a5-a0-eb-b6-84-ed-8f-ac-html": {
        "title": "09: 다양한 확률 분포",
        "tags": "Math, Statistics, probability distribution, parameter",
        "date": "May 15, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "다양한 확률분포에 대해 이해한다.이산 확률 변수의 분포대표적으로 사용하는 이산 확률 변수에 대한 분포를 알아본다. 의미적으로 이해하는 것을 우선으로 한다.베르누이 분포  확률 변수의 값이 성공 혹은 실패로 나타나는 경우에 따른 분포동전을 던졌을 때, 앞면이 나오는 사건에 대한 값을 확률 변수로 잡는 경우가 해당된다. 해당 사건이 나오는 확률을 정의해야 분포가 정의된다.$$P(X=0)=p P(X=1)=q \\0 \\le p \\le 1, q=1-p$$초기하 분포  n번의 시행에서 k번 성공할 확률, 그런데 독립시행이 아닐 경우의 분포주머니에 10개의 공이 있다. 이 때 파란공이 3개, 빨간공이 7개 이다. 이런 상황에서의 확률 실험이 공을 5번 꺼내는 실험이다. 공은 다시 넣지 않는다.(비복원 추출) 이 떄 확률 변수 X를 빨간 공이 나오는 횟수라고 할 경우, 발생하는 확률 분포이다. 이 초기하 분포를 설명하기 위해서는 총 공이 몇개가 있는지(N), 몇개를 뽑을 것인지(n), 그 때 빨간공이 나오는 개수(k) 세가지 파라미터가 필요하다.초기하 분포의 상황에서 n이 특정수 이상으로 큰 경우 이항 분포로 가정하고 풀이한다.이항 분포  확률 변수의 값이 독립 시행의 성공 횟수로 표시되는 경우에 따른 분포동전을 5번 던졌을 때, 앞면이 나오는 횟수를 확률 변수로 잡는 경우이다. 문제에서 알 수 있듯 해당 분포를 설명하기 위해서는 몇번 던지는지(n), 그리고 한번의 시행에서 나오는 확률 얼마인지(p)를 정의해야 한다. 두개의 파라미터를 가진다.이항 분포는 베르누이 확률 변수의 합으로 정의되는 랜덤 변수의 분포로 정의된다.기하 분포  처음으로 성공하는 횟수를 확률 변수로 잡을 경우 나오는 분포동전을 던지는데, 처음으로 앞면이 나오는 시행 횟수를 확률 변수로 잡을 경우 나타나는 분포이다.음이항 분포  특정 횟수를 성공하기 위한 시행 횟수에 대한 분포동전의 앞면이 10번 나오기 위해 던져야 하는 횟수를 확률 변수로 정의했을 때 나타나는 분포이다. 해당 분포를 설명하기 위해서는 몇번 성공할 것인지(k) 그리고 그 독립 시행의 확률이 얼마인지(p)를 주어진 상태에서 x를 정의하고 그에 대한 확률을 정의한다.음이항 분포의 랜덤 변수는 기하 분포의 랜덤 변수의 합으로 정의된다.포아송 분포  단위 시간 안에 사건이 몇 번 발생할 것인지에 대한 분포버스정류장에 버스가 도착한다고 하자. 이 때, 단위 시간을 10분으로 설정했을 때, 10분안에 도착하는 버스의 수를 랜덤 변수로 정의했을 때 정의되는 분포이다. 포아송 분포를 정의하기 위해 필요한 인자는, 정해진 시간 안에 사건이 일어날 횟수에 대한 기댓값($\\lambda$)가 필요하다.연속 확률 변수의 분포대표적으로 사용하는 연속 확률 변수에 대한 분포를 알아본다. 의미적으로 이해하는 것을 우선으로 한다.지수 분포  한번의 사건이 발생하는데 까지 걸리는 시간에 대한 분포포아송 분포에서는 단위 시간에 발생하는 횟수에 대해 궁금했다면, 이번에는 하나의 사건이 발생하는데 까지 걸리는 시간을 확률 변수로 잡는다. 이 때 발생하는 분포가 지수 분포이다. 지수 분포를 정의하기 위해서는 해당 사건이 발생하는 확률(p)가 필요하다.감마 분포  a번째 사건이 발생할 때까지 걸리는 시간에 대한 분포음이항 분포와 매우 비슷하다. 음이항 분포가 기하 분포의 결합으로 설명되었던 것처럼, 감마 분포도 지수 분포의 결합으로 설명되는 확률 변수에 대해 표현된다.스튜던츠 t 분포  모분산을 모를 때, 표본에 대한 분포를 사용할 때 사용한다.사실 t분포는 추정에서 보다 정확히 사용처를 알 수 있다. 일단은, 모평균이 $\\mu$이고, 모분산이 $\\sigma^2$인 경우, 우리는 Z를 사용하여 이것이 표준 정규 분포를 따른다고 알고 있다.그런데, 우리가 하는 행위는 표본을 통하여 모집단을 예측하는 행위를 하는 것이고, 그렇기 때문에 현실에서 하는 모든 행위는 모집단을 알 수 없다. 그렇기 때문에 평균은 알 수 있을 지라도 모분산을 모르기 때문에 내가 뽑은 표본의 분포가 정규 분포라 가정하고 추정을 수행할 수 없다.이러한 문제에 대해 해결하기 위한 방법으로 모분산 대신 표본 분산을 사용하여 분포를 만들었다. 이것을 t 분포라 한다. 표본 분산을 구하는데에 있어서는 자유도가 필요하므로, t 분포를 사용하기 위해서는 자유도라는 매개변수가 필요하다.자세한 내용은 스튜던트 t 분포 를 확인하자.카이제곱 분포  정규 분포 랜덤 변수의 제곱의 합으로 표현되는 랜덤 변수에 관한 분포왜 카이제곱 분포가 필요할까? 기본적으로 카이제곱 분포는 표본의 분산에 관련된 무언가를 만들기 위해 탄생한 분포이다. 실제로 표준 정규 분포의 랜덤 변수를 제곱하여 자유도 만큼 더한 것으로 카이 제곱 분포의 랜덤 변수가 정의된다. 해당 분포는 분산의 특징을 대변한다는 특징이 있다.F 분포  두 확률 변수가 독립인 카이제곱 분포를 따른다고 할 때 다음의 랜덤 변수가 따르는 분포가우시안 분포  이항 분포의 n이 늘어났을 때 근사하는 분포가장 중요한 분포이며, 평균과 표준편차를 매개변수로 갖는 분포이다.",
        
        "url": "/math/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-09-%EB%8B%A4%EC%96%91%ED%95%9C-%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html"
      }
      ,
    
      "math-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-08-ed-99-95-eb-a5-a0-eb-b6-84-ed-8f-ac-html": {
        "title": "08: 확률 변수",
        "tags": "Math, Statistics, random variable",
        "date": "May 15, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "확률분포에 대해 이해한다.왜 배우는가?실생활에서 결국 엔지니어가 수행하는 역할은, 다양한 문제에 대해 이를 다룰 수 있는 문제로 바꾸는 것에 있다. 확률과 같이 애매하게 보이는 개념을 어떻게 수치화하여, 다룰 수 있는 문제로 바꾸는지에 대한 내용이 대부분이다. 다양한 문제에 대해 이에 맞는 분포에 대해 알고 있다면, 비슷한 문제에 대해서 이러한 내용을 적용하여 문제를 모델링 할 수 있다.확률 변수  실험 결과들에 수치를 대응시키는 것우리가 어떠한 실험을 관찰한다고 생각해보자. 예를 들어 동전을 3번 던지는 행위를 하고 있다. 이 때, 내가 관찰하고 싶은 것은 앞면이 몇번 나오는지에 대한 정보이다. 이럴 경우, 3번의 행위 속에 숫자에 대응되는 값은 0, 1, 2, 3으로 4가지이다. 여기서 내가 관찰하고 싶은 것, 앞면이 나오는 수, 가 확률 변수 X가 된다. 이렇게 되면 X는 수치적으로 대응된다. 이 때 발생하는 0, 1, 2, 3은 사건이라 부른다.(event)이산 확률 변수내가 관찰하고 싶은 확률 변수가 이산적으로 나오게 될 경우 이산 확률 변수이다. 위의 예에서 0, 1, 2, 3과 같이 값이 이산적이므로 위의 예는 이산 확률 변수라 할 수 있다.확률 질량 함수이산적으로 나온 확률 변수에 대한 확률이 정의되고, 이를 나타내는 함수가 있을 때 이것을 확률 질량 함수라 말한다.연속 확률 변수내가 관찰하고 싶은 확률 변수가 연속적일 경우 연속 확률 변수라 말한다. 예를 들어 버스한 대가 처음으로 도착했을 때 시간이 궁금하다고 하면(즉 확률 변수가) 이는 연속적으로 나오게 될 것이다.확률 밀도 함수연속적으로 나온 확률 변수에 대해 넓이를 확률로 정의하는 함수를 정의했다면, 이를 확률 밀도 함수라 한다.확률 밀도 함수는 히스토그램으로 연속 변수에 대한 상대 빈도를 나타내면서 만들어진 개념이다. 기본적으로 히스토그램은 구간을 가지고, 그 구간에 대한 빈도를 나타내는 그래프이다.연속 확률 변수에 대해서 하나의 값에 대한 확률을 구하면 0이다. 무한대에 가까운 실수 길이에 대해 하나의 점의 확률을 구하는 것이기 때문에 0에 수렴한다. 그렇기 때문에 히스토그램을 사용하여, 구간에 대한 발생 빈도를 나타내는 것이 하나의 방법이다.그렇다면 우리는 어떠한 구간에 대한 확률을 정의할 수 있다. 즉, 넓이와 같은 개념에 해당하는 것이 확률이고, 이 넓이를 기반으로 확률을 정의하기 위해서는 하나의 값은 밀도와 같은 의미를 가져야 한다. 이러한 점에서 정의된 함수를 확률 밀도 함수라 한다.이 때, 하나의 함수값, 즉 밀도와 대응되는 값을 우리는 우도(likelyhood)라 한다.기댓값과 평균기댓값과 평균은 기본적으로 같은 의미를 가진다. 그런데 나는 약간의 다른 견해를 가지는 편인데, 기본적으로 기댓값은 표본, 또는 새로운 통계량에 대한 평균에 대해 말하는 경향이 있다. 하지만 평균은 아무래도 모집단이 가지는 실제값을 나타내는데 더 많이 사용하는 경향이 있다.결합 확률 분포지금까지 우리는 하나의 확률 변수에 대한 확률을 어떻게 구하고 정의하는지에 대한 얘기를 했다. 그런데, 사실 두가지 확률 변수에 대한 확률이 발생할 수 있다. 예를 들어 확률 실험이 주사위를 하나 던지고 동전을 하나 던지는 실험이라 하자. 이 때 확률 변수 X를 주사위가 나오는 눈을 수, Y를 동전이 앞이 나오는 수라고 할 경우에 X, Y 상황에 따른 확률이 정의 된다. 이렇게 두가지 변수에 대해 확률이 정의되는 함수가 있을 때, 이를 결합 확률 분포라 한다.",
        
        "url": "/math/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-08-%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html"
      }
      ,
    
      "math-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-07-ed-99-95-eb-a5-a0-html": {
        "title": "06: 확률",
        "tags": "Math, Statistics, probability",
        "date": "May 15, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "확률에 대해 이해한다.사건에 확률을 부여하는 방법동전의 앞면이 나오는 것을 사건 A라 정의했을 때, P(A)를 구하는 방법에 대해 알아보자.  고전적 방법          단순히 1/2라 생각한다.      이 생각의 배경에는 앞면과 뒷면이 나오는 가능성이 동일하다 생각하고 부여한다.        상대도수 방법          100번을 던진 후, 앞면이 나온 수를 분자에 올려 정의한다.      실제 행위에 대한 결론을 가지고 확률을 정의한다.        주관적 방법          전문가가 이 사건에 대한 확률을 정의한다.      상호배타적 사건A와 B가 동시에 일어나는 경우가 없을 때 상호배타적이라 한다. 위의 수식을 기반으로 배반 사건이라고도 한다. 한번의 시행을 했을 때, A에 속하면 B에 속하지 못하므로 각각은 서로에게 종속되어 있다. 따라서 배반사건은 종속 사건이다.조건부 확률B가 일어났을 때, A가 일어날 확률이다.Marginal ProbabilityP(A), P(B)를 구하는 방법이다. 이는 결합 확률 밀도함수에서도 활용되는 개념이다. 수식적으로는 상호 배타적인 확률을 모두 더하는 것으로 구할 수 있다.독립 사건(Independent Events)B가 일어났다는 가정하에 A가 일어날 확률과 그냥 A가 일어날 확률이 같다면, A와 B사건은 서로 관련이 없다고 볼 수 있다. 이런 사건을 독립사건이라 한다. 이런 경우, 두 사건이 동시에 일어나는 확률은 두 사건이 발생하는 확률을 곱하여 구할 수 있다.",
        
        "url": "/math/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-07-%ED%99%95%EB%A5%A0.html"
      }
      ,
    
      "math-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-06-ed-91-9c-eb-b3-b8-ec-b6-94-ec-b6-9c-eb-b0-a9-eb-b2-95-html": {
        "title": "05: 표본 추출 방법",
        "tags": "Math, Statistics, sampling",
        "date": "May 15, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "모집단을 추정하기 위한 표본을 추출하는 방법에 대해 알아본다.표본 추출  단순 랜덤 추출          단순히 랜덤하게 모집단에서 추출하는 방법이다. 집단의 분포가 불균형할 경우 모집단의 특성을 대변하지 못한다는 단점이 있다.        층화 랜덤 추출          모집단의 분포를 고려하여 표본을 추출한다.        군집 추출법          대상의 클래스를 알 수 없을 때, 군집화를 한 상태에서 추출한다.      표본 추출 오차, 비표본 추출 오차  표본 추출 오차(sampling error)          표본을 선택하는 데 있어, 모집단을 대변하지 못하여 발생하는 오차이다.      추출하는 표본의 크기를 증가시키면 감소한다.        비표본 추출 오차(nonsampling error)          데이터 수집에 있어 발생하는 실수나 제어할 수 없는 에러를 의미한다.      이 부분은 제어할 수 없기 때문에 안고가야하는 부분이다. 최대한 좋은 데이터를 만드는 것이 좋다.      ",
        
        "url": "/math/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-06-%ED%91%9C%EB%B3%B8%EC%B6%94%EC%B6%9C%EB%B0%A9%EB%B2%95.html"
      }
      ,
    
      "math-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-05-ec-84-a0-ed-98-95-ea-b4-80-ea-b3-84-ec-9d-98-ec-b2-99-eb-8f-84-html": {
        "title": "05: 선형관계의 척도",
        "tags": "Math, Statistics, Covarience, Coefficient of correlation",
        "date": "May 15, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "데이터의 두 변수간 선형관계를 나타내는 척도에 대해서 알아본다.선형관계두 변수의 관계를 알아보는 것은 매우 중요하다. 어떠한 연관성을 통하여 유의미한 정보를 이끌어 낼 수 있기 때문이다. 이러한 선형관계를 알아내는 척도는 3가지 정도가 알려져 있다.공분산(Covarience)공분산을 직관적으로 이해하면 다음과 같다. 식을 보면, 결국 X에서 X의 평균을 빼고, Y에서 Y의 평균을 뺀뒤 곱한 것들을 모두 더한뒤 데이터의 개수로 나누는 것이다. 그렇다면 안에 있는 $(X-\\mu)(Y-\\nu)$ 만 확인해보자.위와 같은 그림이 된다.이러한 특징 때문에, 결과적으로 양의 상관관계를 가지는 경우는 +, 음의 상관관계는 -가 된다.0이 나오는 경우결론부터 말하자면 x, y축에 대해 평행한 직선에 대해 대칭이면 모두 0이 나온다. 실제로 그림을 그려보고 위의 작업을 해보도록 하자.상관계수(Coefficient of correlation)상관 계수는 위의 값을 정규화했다고 보면 된다. 결과적으로 -1~+1의 값으로 만들어 보다 수치적으로 정확히 판단할 수 있다. 이는 벡터의 내적과 동일한 연산이다.",
        
        "url": "/math/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-05-%EC%84%A0%ED%98%95%EA%B4%80%EA%B3%84%EC%9D%98-%EC%B2%99%EB%8F%84.html"
      }
      ,
    
      "math-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-04-ec-83-81-eb-8c-80-ec-9c-84-ec-b9-98-ec-99-80-eb-b0-95-ec-8a-a4-ed-94-8c-eb-a1-af-html": {
        "title": "04: 상대 위치와 boxplot",
        "tags": "Math, Statistics, boxplot",
        "date": "May 15, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "데이터를 설명하는 상대위치와 이를 나타내는 box plot에 대해 알아본다.상대위치중앙값이 50%에 위치하는 분위수라면, 이에 대응하는 다양한 분위수가 존재한다.백분위수분포를 100개로 쪼개어 생각하는 것이다.사분위수분위수 개념중에서 가장 많이 사용하는 개념이며, 25%, 50%, 75%, 100%로 구성된다. 각각을 1, 2, 3, 4분위수라 하며, 2분위수는 중앙값과 대응된다.사분위수간 범위(Interquartile Range)  $Q_3 - Q_1$사분위수간 범위는 관측치들의 중간 50%가 흩어져 있는 정도를 측정한다.Box Plotsboxplot에 대한 글box가 그려지는 부분의 하한, 상한은 $Q_1, Q_3$ 이다. 그 좌우로 선이 나타내는 상한은 수염(Whisker)라 불리며, 사분위수간 범위의 1.5배 범위까지 포함하는 점을 나타낸다. 이 후의 점은 그 범위를 넘어가는 점중 이상치가 아닌 점 중의 마지노선을 나타낸다.Referenceboxplot에 대한 글",
        
        "url": "/math/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-04-%EC%83%81%EB%8C%80%EC%9C%84%EC%B9%98%EC%99%80-%EB%B0%95%EC%8A%A4%ED%94%8C%EB%A1%AF.html"
      }
      ,
    
      "math-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-03-eb-b3-80-eb-8f-99-ec-84-b1-ec-9d-98-ec-b2-99-eb-8f-84-html": {
        "title": "03: 변동성의 척도",
        "tags": "Math, Statistics, variation",
        "date": "May 15, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "데이터를 설명하는 또 다른 척도인 변동성에 대해 알아본다.변동성  데이터의 분포를 나타냄에 있어 퍼진 정도를 측정한다.범위  range = 최대 관측치 - 최소 관측치해당 데이터의 값이 어디서 부터 어디까지인지 나타낸다.분산, 표준 편차얼마나 퍼져있는지에 대한 척도이다. 통계적으로 매우 중요한 역할을 수행한다.경험 법칙(Empirical Rule)가정 : 데이터의 히스토그램(분포)가 종모양이다.  모든 관측치의 68%는 $\\pm \\sigma$ 에 속한다.  모든 관측치의 95%는 $\\pm 2\\sigma$ 에 속한다.  모든 관측치의 99.7%는 $\\pm 3\\sigma$ 에 속한다.체비셰프의 정리위의 경험 법칙을 보다 일반화한 정리이다.  평균으로 부터 $k\\sigma$ ($k &gt; 1$) 이내에 속하는 관측치들의 비율은 적어도 다음과 같다.변동 계수(Coefficient of Variation)  표준 편차를 평균으로 나눈 척도무차원수에 대응되는 값이다. 차원을 갖게 해주어, 어떠한 의미를 갖게하기 위함이다.",
        
        "url": "/math/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-03-%EB%B3%80%EB%8F%99%EC%84%B1%EC%9D%98-%EC%B2%99%EB%8F%84.html"
      }
      ,
    
      "math-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-02-ec-a4-91-ec-8b-ac-ec-9d-84-eb-82-98-ed-83-80-eb-82-b4-eb-8a-94-eb-b0-a9-eb-b2-95-html": {
        "title": "02: 중심을 나타내는 방법",
        "tags": "Math, Statistics, mean, median, mode",
        "date": "May 15, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "데이터의 중심을 나타내는 척도에 대해서 배워본다.평균 (mean)  평균은 대표적으로 집단의 중심위치를 나타내는 척도로 사용된다.이 평균에는 보통 3종류가 사용된다. 각각에는 어떤 기하적의미가 있으며, 데이터를 보고 어떠한 형태인지를 인지하고 그에 맞는 척도로 판단하는 것이 중요하다.산술 평균산술 평균은 보통 평균이라고 불리는 가장 대표적인 방법이다. 하지만 이 수식을 보면, 각각의 $x_i$에 대해 같은 가중치로 내분점을 구하는 식과 같다. 그렇다면 각각의 $x_i$에 대해 같은 가중치이기 때문에 $x_i$가 가지는 값에 민감하게 값이 변하게 된다.즉, 만약 $x_i$의 원소중 값이 튀는 아웃라이어가 포함되어 있는 경우, 평균은 집단의 중심을 대변하기 어렵게 된다. 평균은 아웃라이어에 민감하다. 이점을 꼭 기억하자. 다른 말로 하면, 큰 값에 가중치를 준다. 라고 생각해도 좋다.기하 평균앞에서 얘기한 산술 평균은 각각의 $x_i$ 값이 개수, 값과 같은 column일 때 사용가능하다. 그 이유는, 값이나 개수는 더했을 때 어떠한 의미를 가지기 때문이다. 하지만, 만약 $x_i$ 가 상승률, 감소율과 같은 확률 값이면 어떻게 할까? 만약 첫째날 100%의 증가율, 둘째날 -50%의 증가율을 보였다면, $x(1+1)(1-0.5) = x$ 로 둘째날 까지의 증가율은 0이다. 당연히 평균도 0이다. 하지만 산술 평균으로 계산한다면 이 값은 0.25로 증가한다는 결론이 난다.이런 경우 우리는 첫째날, 둘째날의 확률을 곱하여 판단하는 것이 옳다는 것을 알고 있다. 이렇게 곱하는 연산이 어떤 중요한 의미를 가지는 경우 우리는 기하 평균으로 해당 분포의 중심을 잡는 것이 옳다.조화 평균역수의 산술평균의 역수. 수식적으로 의미를 뜯어보면, 역수를 취한다는 것은 결국 작은 수를 크게, 큰 수를 작게 만들겠다는 의미로 볼 수 있다. 그 다음에 산술평균을 취한다는 것은, 결국 작은 수에 가중치를 준 상태로 값을 구하겠다는 의미이고, 원래 차원을 맞춰주기 위해 다시 역수를 취한다.즉, 작은 수에 가중치를 준 평균으로 볼 수 있다.세 평균 정리두개의 수를 막대기로 생각했을 때, 산술 평균은 두 막대기의 크기의 내분점을 구하는 것과 동일하다. 그렇기 때문에 큰 막대기가 엄청 커지면 그게 맞춰 값도 커지게 된다.조화 평균은 작은 수에 가중치를 주어 구하기 때문에, 항상 작은 수보다 작은 지점에서 평균이 구해지게 된다.기하 평균은, 두 막대기를 각각 한 변으로 잡았을 때 면적을 만족하는 정사각형의 한 변의 길이와 동일한 길이가 책정된다. 이 값은 산술, 기하, 조화 평균의 관계에 의해 산술 평균보다는 작고, 조화 평균보다는 큰 값을 가진다.중앙값  순서 통계량으로, 순서대로 세었을 때 중앙에 있는 값을 의미한다.중앙값의 핵심은 아웃라이어에 민감하지 않다는 것이다. 따라서 사용하기 편리하다. 하지만, 계산 상 거리를 기반으로 한다는 점에서 (절댓값) 추가적인 무언가를 도출할 때 수학적으로 어려운 점이 있다. 따라서 아웃라이어를 제거한 평균을 사용하는 것이 좀더 옳지 않을까 생각한다.최빈값  가장 많이 나온 숫자정의에서 알 수 있듯, 이 값은 범주형에서 의미가 있다.분포에 따른 평균, 중앙값, 최빈값의 위치분포가 대칭일 경우에는 세값이 동일하다.하지만 비대칭일 경우, 중앙값은 평균보다 오른쪽에 있을 수 밖에 없다. 숫자를 세는 행위이기 때문이다.",
        
        "url": "/math/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-02-%EC%A4%91%EC%8B%AC%EC%9D%84-%EB%82%98%ED%83%80%EB%82%B4%EB%8A%94-%EB%B0%A9%EB%B2%95.html"
      }
      ,
    
      "math-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-01-ec-84-9c-eb-a1-a0-html": {
        "title": "01: 주요 개념",
        "tags": "Math, Statistics",
        "date": "May 15, 2020",
        "author": "",
        "category": "Math/Statistics",
        "content": "통계 개념 정리에 앞서 통계학이라는 학문에 대해 알아본다.통계는 왜 공부하는가  미래를 알기 위해서, 집단의 특징을 알기 위해서우리는 군중의 특징에 대해 알 필요가 있다. 예를 들어 물건을 판다고 생각해보자. 이 물건이 많이 팔릴지 아닐지는 해당 소비자의 특징을 분석할 필요가 있다.주요 통계학 개념  모수          모집단 (population)의 특성을 나타내는 척도, 특징        통계량          표본(sample)의 특성을 나타내는 척도, 특징      결과적으로 우리는 표본의 통계량을 기반으로 모수를 추정한다.데이터의 형태  interval data (numerical data)          수치형 데이터. 요금, 발생률 같이 실수 범위의 숫자가 나올 수 있는 것을 말한다.      이런 실수형 데이터는 내가 구간을 나누어 범주형 데이터로 처리를 할 수 있다.        nominal data (categorical data)          범주형 데이터이다. 범주형 데이터에는 서열이 존재하는 데이터, 그렇지 않은 데이터로 나눌 수 있다.      예를 들면, 순위와 같은 서열 데이터와 성별과 같은 데이터가 존재한다.      보통 계산을 위해 숫자로 대체한다.      범주형 데이터는 해당 범주에 대한 빈도수를 세는 도수분포표가 많이 사용된다.      또는 파이차트도 많이 사용된다.      히스토그램  수치형 데이터에서 계급에 대한 빈도수를 나타낼 때 사용한다.왜도(skerness)  히스토그램의 비대칭성의 정도를 나타내는 척도꼬리가 긴 쪽에 치우쳐서 파악하면 된다. 꼬리가 오른쪽이라면 양의 비대칭, 반대는 음의 비대칭이다.",
        
        "url": "/math/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-01-%EC%84%9C%EB%A1%A0.html"
      }
      ,
    
      "ds-visualization-2020-05-14-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-07-count-plot-html": {
        "title": "07: Counts plot",
        "tags": "DS, python, matplotlib, Counts plot",
        "date": "May 14, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "카테고리 변수에 대한 y 갯수를 그려주는 Counts plot에 대해 알아보자.연습 kaggle notebook  카테고리 변수의 갯수 분포를 한눈에!이전의 stripplot이 category 변수를 x, 조사하고 싶은 연속 변수를 y라 했을 때 분포를 본다면, 이번에는 x 변수에 대한 y의 개수를 파악한다. 이 문장에 내포되어 있는 뜻은, x, y가 모두 카테고리 변수라는 얘기로 볼 수 있다. 단, 이산적인 숫자이다. 이것을 코딩하기 위해서 필요한 것은, group과 그 그룹에 속하는 개수를 알아야 한다.# Useful for:# Draw a scatterplot where one variable is categorical. # In this plot we calculate the size of overlapping points in each category and for each y.# This way, the bigger the bubble the more concentration we have in that region.# More info: # https://seaborn.pydata.org/generated/seaborn.stripplot.html# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# we need to make a groupby by variables of interest# cty, hwy에 따른 group을 묶고, 그 카테고리에 해당하는 개수를 갖고 있는다.# 그리고 그 개수의 column 이름을 counts라 한다.gb_df = df.groupby([\"cty\", \"hwy\"]).size().reset_index(name = \"counts\")# sort the valuesgb_df.sort_values([\"cty\", \"hwy\", \"counts\"], ascending = True, inplace = True)# create a color for each group. # there are several way os doing, you can also use this line: # colors = [plt.cm.gist_earth(i/float(len(gb_df[\"cty\"].unique()))) for i in range(len(gb_df[\"cty\"].unique()))]# colors 딕셔너리를 만든다. 각 cty 숫자에 대응하는 3개의 값(list)을 가지고 있는다.# 이 값은 RGB 값에 대응된다.colors = {i:np.random.random(3,) for i in sorted(list(gb_df[\"cty\"].unique()))}# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# iterate over each category and plot the data. This way, every group has it's own color and size.for x in sorted(list(gb_df[\"cty\"].unique())):        # get x and y values for each group    x_values = gb_df[gb_df[\"cty\"] == x][\"cty\"]    y_values = gb_df[gb_df[\"cty\"] == x][\"hwy\"]        # extract the size of each group to plot    size = gb_df[gb_df[\"cty\"] == x][\"counts\"]        # extract the color for each group and covert it from rgb to hex    # 0~1의 실수 범위 색상을 16진수 색상으로 바꿔준다.    color = matplotlib.colors.rgb2hex(colors[x])    # plot the data    ax.scatter(x_values, y_values, s = size*10, c = color)    # ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Count plot\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/14/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-07-Count-plot.html"
      }
      ,
    
      "ds-visualization-2020-05-14-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-06-stripplot-html": {
        "title": "06: Strip plot",
        "tags": "DS, python, matplotlib, Strip plot",
        "date": "May 14, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "카테고리 변수에 대한 y 분포를 그려주는 Strip plot에 대해 알아보자.연습 kaggle notebook  카테고리 변수와의 y 분포를 한눈에!이전의 산점도는 연속, 연속 변수에 대한 그래프로 볼 수 있다. 이번에는 x가 카테고리 변수일 때, 각각의 값에 대한 분포가 어떻게 되는지를 알아보자. 이 때 jitter란, 각각의 카테고리에 대해 산점도를 그린 후 겹치는 점에 대해 파악하기 어려운 점을 해결해주는 도구이다.위 그림은 겹치는 점에 대해 어떤 분포를 갖고 있는 지 알기 어렵다. 그렇기 때문에, 그리는데 있어서 x방향으로 랜덤 수를 주어 겹치지 않게 하는 기능이다.# Useful for:# Draw a scatterplot where one variable is categorical. # This is useful to see the distribution of the points of each category.# More info: # https://seaborn.pydata.org/generated/seaborn.stripplot.html# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# separate x and y variablesx = df[\"cty\"]y = df[\"hwy\"]# ----------------------------------------------------------------------------------------------------# instanciate the figureplt.figure(figsize = (10, 7))# ----------------------------------------------------------------------------------------------------# plot the data using seabornax = sns.stripplot(x, y)# ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Jitter plot\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/14/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-06-Stripplot.html"
      }
      ,
    
      "ds-visualization-2020-05-14-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-05-ec-84-a0-ed-98-95-ed-9a-8c-ea-b7-80-ec-84-a0-ec-9d-84-ed-8f-ac-ed-95-a8-ed-95-9c-ec-82-b0-ec-a0-90-eb-8f-84-html": {
        "title": "05: 선형 회귀 선을 포함한 산점도",
        "tags": "DS, python, matplotlib, scatter plot",
        "date": "May 14, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "선형 회귀 선을 포함한 산점도 그래프를 그려보자.연습 kaggle notebook  산점도에서 추가적으로 간단한 회귀 선을 그려, x, y간의 상관관계를 볼 수 있다.# Useful for:# This is a normal scatter plot but we also plot a simple regression line to see the correlation between the x and the y variables.# More info: # https://visual.ly/m/scatter-plots-regression-lines/# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# filter only 2 clases to separate it more easily on the plot# cyl이 4, 8인 두 그룹에 대해 회귀를 진행한다.df = df[df[\"cyl\"].isin([4,8])]# ----------------------------------------------------------------------------------------------------# plot the data using seaborn# hue가 구분을 결정해주는 변수# x = \"displ\", y = \"hwy\"sns.lmplot(\"displ\", \"hwy\", df, hue = \"cyl\")# ----------------------------------------------------------------------------------------------------# prettify the plot# since we are using seaborn and this library uses matplotlib behind the scenes# you can call plt.gca (get current axes) and use all the familiar matplotlib commands# 저 위까지만 해도 그릴 수 있다. 하지만 내가 plot의 꾸미는 부분을 바꾸고 싶다면,# matplotlib의 axis 단계에 접근하여 수정할 수 있다.ax = plt.gca()# change the upper limit of the plot to make it more pleasantax.set_xlim(0, 10)ax.set_ylim(0, 50)# set titleax.set_title(\"Scatter plot with regression\");분리하여 그리기# Useful for:# This is a normal scatter plot but we also plot a simple regression line to see the correlation between the x and the y variables.# This plot is similar to the previous one but plots each data on separate axes# More info: # https://visual.ly/m/scatter-plots-regression-lines/# sns의 테마 정하기sns.set(color_codes=True)# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# filter only 2 clases to separate it more easily on the plotdf = df[df[\"cyl\"].isin([4,8])]# ----------------------------------------------------------------------------------------------------# plot the data using seabornaxes = sns.lmplot(\"displ\",                   \"hwy\",                   df,                   hue = \"cyl\",                   col = \"cyl\" # by specifying the col, seaborn creates several axes for each group                  # col을 명확하게 적으면 분리하여 그래프를 그려준다.                 )# ----------------------------------------------------------------------------------------------------# prettify the plot# change the upper limit of the plot to make it more pleasantaxes.set( xlim = (0.5, 7.5), ylim = (0, 50))# set title for all axes using pltplt.suptitle(\"Scatter plot with regression lines on different axes\", fontsize = 10);ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/14/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-05-%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80%EC%84%A0%EC%9D%84-%ED%8F%AC%ED%95%A8%ED%95%9C-%EC%82%B0%EC%A0%90%EB%8F%84.html"
      }
      ,
    
      "dv-python-2020-05-13-python-pipenv-ea-b0-80-ec-84-b1-ed-99-98-ea-b2-bd-ec-83-9d-ec-84-b1-ec-8b-a4-ed-8c-a8-html": {
        "title": "가상 환경 생성 실패",
        "tags": "pipenv, mac",
        "date": "May 13, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "pipenv를 사용하다가 가상환경이 생성되지 않는 경우 해결책을 정리한다.갑자기 가상환경 생성이 되지 않았다. 오류를 보니, python3 의 경로를 다른 것을 사용한다는 것을 알아냈다. 내가 원하는 python 버전으로 생성을 위해서는 해당 python의 설치 경로를 명시적으로 적어서 생성할 수 있다.pipenv install --python /usr/local/bin/python3Referencegithub issue",
        
        "url": "/dv/python/2020/05/13/python-pipenv-%EA%B0%80%EC%84%B1%ED%99%98%EA%B2%BD-%EC%83%9D%EC%84%B1-%EC%8B%A4%ED%8C%A8.html"
      }
      ,
    
      "cs-algorithm-2020-05-13-eb-b0-b1-ec-a4-80-ec-88-98-ec-a0-95-eb-a0-ac-ed-95-98-ea-b8-b0-2-html": {
        "title": "백준(2751번): 수 정렬하기 2",
        "tags": "백준, 알고리즘, 정렬",
        "date": "May 13, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버5 : 정렬 문제이다.백준(2751번) - 수 정렬하기 2생각정렬 문제이다. merge sort(합병 정렬)을 구현해보고자 시도했다.알고리즘기본적인 병합 정렬의 알고리즘은 다음과 같다. 위키 백과 - 합병 정렬좀 더 자세한 설명partition나누는 방법은 간단하다. 시작과 끝점을 주고, 반을 자르면서 들어가는 것이다. 가장 작은 단위는 1개의 원소를 가질 때이다. 이 위치에 다다랐을 때 합치는 연산을 수행하면서 거꾸로 올라가면 된다.merge합칠 때는, 두 개의 바구니에 담긴 원소들을 비교하면서 새로운 바구니에 차곡차곡 담아두어야 한다. 이 때, 한 바구니의 최댓값이 다른 바구니의 중간 원소보다 작을 경우에 나머지 원소들을 한꺼번에 밀어 넣어주어야 한다는 것을 잊지 말자. 또한 최종 바구니에 다 넣었다면, 다른 바구니들을 비교하는데 있어 정렬된 바구니가 필요하므로 원래 배열에 밀어넣어준다.Code#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;int N;int *a, *temp;void merge(int start, int end) {    int mid = (start+end)/2;    int i = start, j = mid+1, k = start;        while (i &lt;= mid &amp;&amp; j &lt;= end) {        if (a[i] &lt;= a[j]) temp[k++] = a[i++];        else temp[k++] = a[j++];    }        int restLoc = i &gt; mid ? j : i; // 병합중 한쪽 바구니가 끝난 경우 나머지의 위치를 결정해줌    while (k &lt;= end) temp[k++] = a[restLoc++]; // (end-start)개수만큼을 채워야 하니, 나머지들을 넣어줌    for (int i = start; i &lt;= end; i++)  a[i] = temp[i]; // temp배열에 넣은 녀석들을 원래 것으로 업데이트 해줌}void partition(int start, int end){    if (end &lt;= start) return;        int mid = (start+end)/2;    partition(start, mid);    partition(mid+1, end);    merge(start, end);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);        cin &gt;&gt; N;    a = new int[N+1];    temp = new int[N];    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];        partition(0, N-1);        for (int i = 0; i &lt; N; i++) cout &lt;&lt; a[i] &lt;&lt; '\\n';    }",
        
        "url": "/cs/algorithm/2020/05/13/%EB%B0%B1%EC%A4%80-%EC%88%98-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0-2.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-10-ensemble-html": {
        "title": "10: Ensemble",
        "tags": "DS, kaggle, ML, titanic, hyper parameter",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 모델들을 앙상블하는 방법을 알아본다.앙상블  여러개의 모델을 만들고, 이것들의 결과들을 투표하는 방식으로 합치자.모델의 정확도간의 상관계수#compare algorithm predictions with each other, where 1 = exactly similar and 0 = exactly opposite#there are some 1's, but enough blues and light reds to create a \"super algorithm\" by combining themcorrelation_heatmap(MLA_predict)Hard Vote (다수결) &amp; Soft Vote (가중치)#why choose one model, when you can pick them all with voting classifier#http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.VotingClassifier.html#removed models w/o attribute 'predict_proba' required for vote classifier and models with a 1.0 correlation to another modelvote_est = [    #Ensemble Methods: http://scikit-learn.org/stable/modules/ensemble.html    ('ada', ensemble.AdaBoostClassifier()),    ('bc', ensemble.BaggingClassifier()),    ('etc',ensemble.ExtraTreesClassifier()),    ('gbc', ensemble.GradientBoostingClassifier()),    ('rfc', ensemble.RandomForestClassifier()),    #Gaussian Processes: http://scikit-learn.org/stable/modules/gaussian_process.html#gaussian-process-classification-gpc    ('gpc', gaussian_process.GaussianProcessClassifier()),        #GLM: http://scikit-learn.org/stable/modules/linear_model.html#logistic-regression    ('lr', linear_model.LogisticRegressionCV()),        #Navies Bayes: http://scikit-learn.org/stable/modules/naive_bayes.html    ('bnb', naive_bayes.BernoulliNB()),    ('gnb', naive_bayes.GaussianNB()),        #Nearest Neighbor: http://scikit-learn.org/stable/modules/neighbors.html    ('knn', neighbors.KNeighborsClassifier()),        #SVM: http://scikit-learn.org/stable/modules/svm.html    ('svc', svm.SVC(probability=True)),        #xgboost: http://xgboost.readthedocs.io/en/latest/model.html   ('xgb', XGBClassifier())]#Hard Vote or majority rules, 이 부분 코드가 약간 이해가 안되지만 일단 넘어간다.vote_hard = ensemble.VotingClassifier(estimators = vote_est , voting = 'hard')vote_hard_cv = model_selection.cross_validate(vote_hard, data1[data1_x_bin], data1[Target], cv  = cv_split)vote_hard.fit(data1[data1_x_bin], data1[Target])print(\"Hard Voting Training w/bin score mean: {:.2f}\". format(vote_hard_cv['train_score'].mean()*100)) print(\"Hard Voting Test w/bin score mean: {:.2f}\". format(vote_hard_cv['test_score'].mean()*100))print(\"Hard Voting Test w/bin score 3*std: +/- {:.2f}\". format(vote_hard_cv['test_score'].std()*100*3))print('-'*10)#Soft Vote or weighted probabilitiesvote_soft = ensemble.VotingClassifier(estimators = vote_est , voting = 'soft')vote_soft_cv = model_selection.cross_validate(vote_soft, data1[data1_x_bin], data1[Target], cv  = cv_split)vote_soft.fit(data1[data1_x_bin], data1[Target])print(\"Soft Voting Training w/bin score mean: {:.2f}\". format(vote_soft_cv['train_score'].mean()*100)) print(\"Soft Voting Test w/bin score mean: {:.2f}\". format(vote_soft_cv['test_score'].mean()*100))print(\"Soft Voting Test w/bin score 3*std: +/- {:.2f}\". format(vote_soft_cv['test_score'].std()*100*3))print('-'*10)Hard Voting Training w/bin score mean: 86.61Hard Voting Test w/bin score mean: 82.35Hard Voting Test w/bin score 3*std: +/- 4.91----------Soft Voting Training w/bin score mean: 87.21Soft Voting Test w/bin score mean: 82.43Soft Voting Test w/bin score 3*std: +/- 5.14----------Grid Search#WARNING: Running is very computational intensive and time expensive.#Code is written for experimental/developmental purposes and not production ready!#Hyperparameter Tune with GridSearchCV: http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.htmlgrid_n_estimator = [10, 50, 100, 300]grid_ratio = [.1, .25, .5, .75, 1.0]grid_learn = [.01, .03, .05, .1, .25]grid_max_depth = [2, 4, 6, 8, 10, None]grid_min_samples = [5, 10, .03, .05, .10]grid_criterion = ['gini', 'entropy']ㅁgrid_bool = [True, False]grid_seed = [0]grid_param = [            [{            #AdaBoostClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html            'n_estimators': grid_n_estimator, #default=50            'learning_rate': grid_learn, #default=1            #'algorithm': ['SAMME', 'SAMME.R'], #default=’SAMME.R            'random_state': grid_seed            }],                       [{            #BaggingClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.BaggingClassifier.html#sklearn.ensemble.BaggingClassifier            'n_estimators': grid_n_estimator, #default=10            'max_samples': grid_ratio, #default=1.0            'random_state': grid_seed             }],                [{            #ExtraTreesClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.ExtraTreesClassifier.html#sklearn.ensemble.ExtraTreesClassifier            'n_estimators': grid_n_estimator, #default=10            'criterion': grid_criterion, #default=”gini”            'max_depth': grid_max_depth, #default=None            'random_state': grid_seed             }],            [{            #GradientBoostingClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier            #'loss': ['deviance', 'exponential'], #default=’deviance’            'learning_rate': [.05], #default=0.1 -- 12/31/17 set to reduce runtime -- The best parameter for GradientBoostingClassifier is {'learning_rate': 0.05, 'max_depth': 2, 'n_estimators': 300, 'random_state': 0} with a runtime of 264.45 seconds.            'n_estimators': [300], #default=100 -- 12/31/17 set to reduce runtime -- The best parameter for GradientBoostingClassifier is {'learning_rate': 0.05, 'max_depth': 2, 'n_estimators': 300, 'random_state': 0} with a runtime of 264.45 seconds.            #'criterion': ['friedman_mse', 'mse', 'mae'], #default=”friedman_mse”            'max_depth': grid_max_depth, #default=3               'random_state': grid_seed             }],                [{            #RandomForestClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier            'n_estimators': grid_n_estimator, #default=10            'criterion': grid_criterion, #default=”gini”            'max_depth': grid_max_depth, #default=None            'oob_score': [True], #default=False -- 12/31/17 set to reduce runtime -- The best parameter for RandomForestClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'oob_score': True, 'random_state': 0} with a runtime of 146.35 seconds.            'random_state': grid_seed             }],                [{                #GaussianProcessClassifier            'max_iter_predict': grid_n_estimator, #default: 100            'random_state': grid_seed            }],                        [{            #LogisticRegressionCV - http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegressionCV.html#sklearn.linear_model.LogisticRegressionCV            'fit_intercept': grid_bool, #default: True            #'penalty': ['l1','l2'],            'solver': ['newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'], #default: lbfgs            'random_state': grid_seed             }],                            [{            #BernoulliNB - http://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.BernoulliNB.html#sklearn.naive_bayes.BernoulliNB            'alpha': grid_ratio, #default: 1.0             }],                    #GaussianNB -             [{}],                [{            #KNeighborsClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier            'n_neighbors': [1,2,3,4,5,6,7], #default: 5            'weights': ['uniform', 'distance'], #default = ‘uniform’            'algorithm': ['auto', 'ball_tree', 'kd_tree', 'brute']            }],                            [{            #SVC - http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html#sklearn.svm.SVC            #http://blog.hackerearth.com/simple-tutorial-svm-parameter-tuning-python-r            #'kernel': ['linear', 'poly', 'rbf', 'sigmoid'],            'C': [1,2,3,4,5], #default=1.0            'gamma': grid_ratio, #edfault: auto            'decision_function_shape': ['ovo', 'ovr'], #default:ovr            'probability': [True],            'random_state': grid_seed             }],                [{            #XGBClassifier - http://xgboost.readthedocs.io/en/latest/parameter.html            'learning_rate': grid_learn, #default: .3            'max_depth': [1,2,4,6,8,10], #default 2            'n_estimators': grid_n_estimator,             'seed': grid_seed               }]           ]start_total = time.perf_counter() #https://docs.python.org/3/library/time.html#time.perf_counterfor clf, param in zip (vote_est, grid_param): #https://docs.python.org/3/library/functions.html#zip    #print(clf[1]) #vote_est is a list of tuples, index 0 is the name and index 1 is the algorithm    #print(param)            start = time.perf_counter()            best_search = model_selection.GridSearchCV(estimator = clf[1], param_grid = param, cv = cv_split, scoring = 'roc_auc')    best_search.fit(data1[data1_x_bin], data1[Target])    run = time.perf_counter() - start    best_param = best_search.best_params_    print('The best parameter for {} is {} with a runtime of {:.2f} seconds.'.format(clf[1].__class__.__name__, best_param, run))    clf[1].set_params(**best_param) run_total = time.perf_counter() - start_totalprint('Total optimization time was {:.2f} minutes.'.format(run_total/60))print('-'*10)The best parameter for AdaBoostClassifier is {'learning_rate': 0.1, 'n_estimators': 300, 'random_state': 0} with a runtime of 37.28 seconds.The best parameter for BaggingClassifier is {'max_samples': 0.25, 'n_estimators': 300, 'random_state': 0} with a runtime of 33.04 seconds.The best parameter for ExtraTreesClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'random_state': 0} with a runtime of 68.93 seconds.The best parameter for GradientBoostingClassifier is {'learning_rate': 0.05, 'max_depth': 2, 'n_estimators': 300, 'random_state': 0} with a runtime of 38.77 seconds.The best parameter for RandomForestClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'oob_score': True, 'random_state': 0} with a runtime of 84.14 seconds.The best parameter for GaussianProcessClassifier is {'max_iter_predict': 10, 'random_state': 0} with a runtime of 6.19 seconds.The best parameter for LogisticRegressionCV is {'fit_intercept': True, 'random_state': 0, 'solver': 'liblinear'} with a runtime of 9.40 seconds.The best parameter for BernoulliNB is {'alpha': 0.1} with a runtime of 0.24 seconds.The best parameter for GaussianNB is {} with a runtime of 0.05 seconds.The best parameter for KNeighborsClassifier is {'algorithm': 'brute', 'n_neighbors': 7, 'weights': 'uniform'} with a runtime of 5.56 seconds.The best parameter for SVC is {'C': 2, 'decision_function_shape': 'ovo', 'gamma': 0.1, 'probability': True, 'random_state': 0} with a runtime of 30.49 seconds.The best parameter for XGBClassifier is {'learning_rate': 0.01, 'max_depth': 4, 'n_estimators': 300, 'seed': 0} with a runtime of 43.57 seconds.Total optimization time was 5.96 minutes.----------vote로 들어간 추정기 각각에 대해 최적 param을 찾는다.앙상블최적의 추정기들에 대해 마지막으로 Voting을 수행한다.#Hard Vote or majority rules w/Tuned Hyperparametersgrid_hard = ensemble.VotingClassifier(estimators = vote_est , voting = 'hard')grid_hard_cv = model_selection.cross_validate(grid_hard, data1[data1_x_bin], data1[Target], cv  = cv_split)grid_hard.fit(data1[data1_x_bin], data1[Target])print(\"Hard Voting w/Tuned Hyperparameters Training w/bin score mean: {:.2f}\". format(grid_hard_cv['train_score'].mean()*100)) print(\"Hard Voting w/Tuned Hyperparameters Test w/bin score mean: {:.2f}\". format(grid_hard_cv['test_score'].mean()*100))print(\"Hard Voting w/Tuned Hyperparameters Test w/bin score 3*std: +/- {:.2f}\". format(grid_hard_cv['test_score'].std()*100*3))print('-'*10)#Soft Vote or weighted probabilities w/Tuned Hyperparametersgrid_soft = ensemble.VotingClassifier(estimators = vote_est , voting = 'soft')grid_soft_cv = model_selection.cross_validate(grid_soft, data1[data1_x_bin], data1[Target], cv  = cv_split)grid_soft.fit(data1[data1_x_bin], data1[Target])print(\"Soft Voting w/Tuned Hyperparameters Training w/bin score mean: {:.2f}\". format(grid_soft_cv['train_score'].mean()*100)) print(\"Soft Voting w/Tuned Hyperparameters Test w/bin score mean: {:.2f}\". format(grid_soft_cv['test_score'].mean()*100))print(\"Soft Voting w/Tuned Hyperparameters Test w/bin score 3*std: +/- {:.2f}\". format(grid_soft_cv['test_score'].std()*100*3))print('-'*10)#12/31/17 tuned with data1_x_bin#The best parameter for AdaBoostClassifier is {'learning_rate': 0.1, 'n_estimators': 300, 'random_state': 0} with a runtime of 33.39 seconds.#The best parameter for BaggingClassifier is {'max_samples': 0.25, 'n_estimators': 300, 'random_state': 0} with a runtime of 30.28 seconds.#The best parameter for ExtraTreesClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'random_state': 0} with a runtime of 64.76 seconds.#The best parameter for GradientBoostingClassifier is {'learning_rate': 0.05, 'max_depth': 2, 'n_estimators': 300, 'random_state': 0} with a runtime of 34.35 seconds.#The best parameter for RandomForestClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'oob_score': True, 'random_state': 0} with a runtime of 76.32 seconds.#The best parameter for GaussianProcessClassifier is {'max_iter_predict': 10, 'random_state': 0} with a runtime of 6.01 seconds.#The best parameter for LogisticRegressionCV is {'fit_intercept': True, 'random_state': 0, 'solver': 'liblinear'} with a runtime of 8.04 seconds.#The best parameter for BernoulliNB is {'alpha': 0.1} with a runtime of 0.19 seconds.#The best parameter for GaussianNB is {} with a runtime of 0.04 seconds.#The best parameter for KNeighborsClassifier is {'algorithm': 'brute', 'n_neighbors': 7, 'weights': 'uniform'} with a runtime of 4.84 seconds.#The best parameter for SVC is {'C': 2, 'decision_function_shape': 'ovo', 'gamma': 0.1, 'probability': True, 'random_state': 0} with a runtime of 29.39 seconds.#The best parameter for XGBClassifier is {'learning_rate': 0.01, 'max_depth': 4, 'n_estimators': 300, 'seed': 0} with a runtime of 46.23 seconds.#Total optimization time was 5.56 minutes.Hard Voting w/Tuned Hyperparameters Training w/bin score mean: 85.22Hard Voting w/Tuned Hyperparameters Test w/bin score mean: 82.31Hard Voting w/Tuned Hyperparameters Test w/bin score 3*std: +/- 5.26----------Soft Voting w/Tuned Hyperparameters Training w/bin score mean: 84.76Soft Voting w/Tuned Hyperparameters Test w/bin score mean: 82.28Soft Voting w/Tuned Hyperparameters Test w/bin score 3*std: +/- 5.42----------실제 validation에 적용 (for submit)#prepare data for modelingprint(data_val.info())print(\"-\"*10)#data_val.sample(10)#handmade decision tree - submission score = 0.77990data_val['Survived'] = mytree(data_val).astype(int)#decision tree w/full dataset modeling submission score: defaults= 0.76555, tuned= 0.77990#submit_dt = tree.DecisionTreeClassifier()#submit_dt = model_selection.GridSearchCV(tree.DecisionTreeClassifier(), param_grid=param_grid, scoring = 'roc_auc', cv = cv_split)#submit_dt.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_dt.best_params_) #Best Parameters:  {'criterion': 'gini', 'max_depth': 4, 'random_state': 0}#data_val['Survived'] = submit_dt.predict(data_val[data1_x_bin])#bagging w/full dataset modeling submission score: defaults= 0.75119, tuned= 0.77990#submit_bc = ensemble.BaggingClassifier()#submit_bc = model_selection.GridSearchCV(ensemble.BaggingClassifier(), param_grid= {'n_estimators':grid_n_estimator, 'max_samples': grid_ratio, 'oob_score': grid_bool, 'random_state': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_bc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_bc.best_params_) #Best Parameters:  {'max_samples': 0.25, 'n_estimators': 500, 'oob_score': True, 'random_state': 0}#data_val['Survived'] = submit_bc.predict(data_val[data1_x_bin])#extra tree w/full dataset modeling submission score: defaults= 0.76555, tuned= 0.77990#submit_etc = ensemble.ExtraTreesClassifier()#submit_etc = model_selection.GridSearchCV(ensemble.ExtraTreesClassifier(), param_grid={'n_estimators': grid_n_estimator, 'criterion': grid_criterion, 'max_depth': grid_max_depth, 'random_state': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_etc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_etc.best_params_) #Best Parameters:  {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'random_state': 0}#data_val['Survived'] = submit_etc.predict(data_val[data1_x_bin])#random foreset w/full dataset modeling submission score: defaults= 0.71291, tuned= 0.73205#submit_rfc = ensemble.RandomForestClassifier()#submit_rfc = model_selection.GridSearchCV(ensemble.RandomForestClassifier(), param_grid={'n_estimators': grid_n_estimator, 'criterion': grid_criterion, 'max_depth': grid_max_depth, 'random_state': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_rfc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_rfc.best_params_) #Best Parameters:  {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'random_state': 0}#data_val['Survived'] = submit_rfc.predict(data_val[data1_x_bin])#ada boosting w/full dataset modeling submission score: defaults= 0.74162, tuned= 0.75119#submit_abc = ensemble.AdaBoostClassifier()#submit_abc = model_selection.GridSearchCV(ensemble.AdaBoostClassifier(), param_grid={'n_estimators': grid_n_estimator, 'learning_rate': grid_ratio, 'algorithm': ['SAMME', 'SAMME.R'], 'random_state': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_abc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_abc.best_params_) #Best Parameters:  {'algorithm': 'SAMME.R', 'learning_rate': 0.1, 'n_estimators': 300, 'random_state': 0}#data_val['Survived'] = submit_abc.predict(data_val[data1_x_bin])#gradient boosting w/full dataset modeling submission score: defaults= 0.75119, tuned= 0.77033#submit_gbc = ensemble.GradientBoostingClassifier()#submit_gbc = model_selection.GridSearchCV(ensemble.GradientBoostingClassifier(), param_grid={'learning_rate': grid_ratio, 'n_estimators': grid_n_estimator, 'max_depth': grid_max_depth, 'random_state':grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_gbc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_gbc.best_params_) #Best Parameters:  {'learning_rate': 0.25, 'max_depth': 2, 'n_estimators': 50, 'random_state': 0}#data_val['Survived'] = submit_gbc.predict(data_val[data1_x_bin])#extreme boosting w/full dataset modeling submission score: defaults= 0.73684, tuned= 0.77990#submit_xgb = XGBClassifier()#submit_xgb = model_selection.GridSearchCV(XGBClassifier(), param_grid= {'learning_rate': grid_learn, 'max_depth': [0,2,4,6,8,10], 'n_estimators': grid_n_estimator, 'seed': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_xgb.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_xgb.best_params_) #Best Parameters:  {'learning_rate': 0.01, 'max_depth': 4, 'n_estimators': 300, 'seed': 0}#data_val['Survived'] = submit_xgb.predict(data_val[data1_x_bin])#hard voting classifier w/full dataset modeling submission score: defaults= 0.75598, tuned = 0.77990#data_val['Survived'] = vote_hard.predict(data_val[data1_x_bin])data_val['Survived'] = grid_hard.predict(data_val[data1_x_bin])#soft voting classifier w/full dataset modeling submission score: defaults= 0.73684, tuned = 0.74162#data_val['Survived'] = vote_soft.predict(data_val[data1_x_bin])#data_val['Survived'] = grid_soft.predict(data_val[data1_x_bin])#submit filesubmit = data_val[['PassengerId','Survived']]submit.to_csv(\"../working/submit.csv\", index=False)print('Validation Data Distribution: \\n', data_val['Survived'].value_counts(normalize = True))submit.sample(10)&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 418 entries, 0 to 417Data columns (total 21 columns):PassengerId      418 non-null int64Pclass           418 non-null int64Name             418 non-null objectSex              418 non-null objectAge              418 non-null float64SibSp            418 non-null int64Parch            418 non-null int64Ticket           418 non-null objectFare             418 non-null float64Cabin            91 non-null objectEmbarked         418 non-null objectFamilySize       418 non-null int64IsAlone          418 non-null int64Title            418 non-null objectFareBin          418 non-null categoryAgeBin           418 non-null categorySex_Code         418 non-null int64Embarked_Code    418 non-null int64Title_Code       418 non-null int64AgeBin_Code      418 non-null int64FareBin_Code     418 non-null int64dtypes: category(2), float64(2), int64(11), object(6)memory usage: 63.1+ KBNone----------Validation Data Distribution:  0    0.6339711    0.366029Name: Survived, dtype: float64결론신기하게도 다른 알고리즘 보다, 내가 만든 트리의 정확도가 실제 제출시에 더 높았다. 이것은, 훈련 데이터 셋의 분포와 제출 데이터 셋의 분포가 다름을 나타낸다. 즉, CV를 통해 모델을 학습한다 할지라도 제출용 데이터의 분포가 성능에 지대한 역할을 미친다는 것이다. 알고리즘에 의존하는 것이 아닌, 전처리와 feature engineering이 더 중요한 경우도 많다.Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-10-Ensemble.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-09-hyper-parameter-tuning-html": {
        "title": "09: Hyper Parameter Tuning",
        "tags": "DS, kaggle, ML, titanic, hyper parameter",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 모델 파라미터를 튜닝한다.Hyper Parameter Tuning지금까지 돌린 모델은, default setting을 가지고 수행했다. 이제 해당 모델의 세팅값을 변경하면서 결과를 도출해볼 것이다. 그런데, 문제가 있다. 기기를 다루기 위해서는 그 기기에 대해서 이해해야 한다는 것이다. 위에서 handmade 모델을 간단하게 구현해 본 이유가 그것이다. 추후에, 다양한 알고리즘의 세팅값을 변경하고 싶다면 알고리즘에 대해 어느정도 공부해야 한다. 이번에는 아까 구현한 decision tree 기법을 토대로, 해당 알고리즘에 대해 알아본다.Decision Trees  계속 되는 분기를 설정하여 예측을 하는 방법장점  이해하고 해석하기 편리하다. 시각화 할 수 있다.  데이터 준비가 거의 필요없다. 정규화 X, Dummy화 X. 하지만 결측치(NULL)을 지원하지 않는다.  트리를 학습하기 위한 Cost는 log(# of data) 이다.  수치 및 범주형 데이터를 모두 처리 가능하다. 일반적으로는 한가지 유형의 변수에 대해 분석을 수행한다.  multi-output 문제를 다룰 수 있다.  white box 모델이다. 즉, 결과에 대해 쉽게 설명이 가능하다.  통계적 검증을 test를 통해 검증이 가능하다. 모델의 설명력을 측정할 수 있다.단점  지나치게 깊은 트리를 사용하여 일반화를 놓치는 모델을 만들 수 있다. 즉 오버피팅이다. 최대 트리의 깊이나, 잎의 수와 같은 제약을 거는 것이 좋다.  결정 트리는 상당히 불안정하다. 데이터에서 약간의 변동이 생긴다면 즉각 적용이 되어 다른 트리가 생성되기 때문이다. 이러한 부분은 여러개의 트리를 앙상블하여 완화시킬 수 있다.  최적의 결정 트리를 학습하는 문제는 NP 문제이다. 따라서 트리를 만드는데 있어서는 Greedy 알고리즘을 사용한다. 그렇기 때문에 만들어진 트리는 최적의 결과라고 보장할 수 없다. 마찬가지로 앙상블을 통해 완화할 수 있다.  결정 트리로는 배타적 논리합이나 패리티, 멀티플렉서와 같은 문제를 학습하기 어렵다.  각각 서로 다른 수의 단계로 분류가 가능한 변수를 포함하는 데이터에 대하여 더 많은 단계를 가지는 속성 쪽으로 정보 획득량이 편향되는 문제가 있다. 데이터의 균형을 맞추는 것이 좋다. 하지만 이 문제는 조건부 추론을 통해 해결이 가능하다.sklearn parametersclass sklearn.tree.DecisionTreeClassifier(criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weight=None, presort=False)우리는 여기서 ParameterGrid, GridSearchCV, 그리고 sklearn scoring을 사용할 것이다.추가적으로 ROC_AUC scores에 대해서 배우고 오자. Click here to learn more about ROC_AUC scores. 다음으로는 graphviz을 사용하여 결정 트리를 시각화할 것이다.Grid search#base modeldtree = tree.DecisionTreeClassifier(random_state = 0)base_results = model_selection.cross_validate(dtree, data1[data1_x_bin], data1[Target], cv = cv_split)dtree.fit(data1[data1_x_bin], data1[Target])print('BEFORE DT Parameters: ', dtree.get_params())print(\"BEFORE DT Training w/bin score mean: {:.2f}\". format(base_results['train_score'].mean()*100)) print(\"BEFORE DT Test w/bin score mean: {:.2f}\". format(base_results['test_score'].mean()*100))print(\"BEFORE DT Test w/bin score 3*std: +/- {:.2f}\". format(base_results['test_score'].std()*100*3))#print(\"BEFORE DT Test w/bin set score min: {:.2f}\". format(base_results['test_score'].min()*100))print('-'*10)#tune hyper-parameters: http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifierparam_grid = {'criterion': ['gini', 'entropy'],  #scoring methodology; two supported formulas for calculating information gain - default is gini              #'splitter': ['best', 'random'], #splitting methodology; two supported strategies - default is best              'max_depth': [2,4,6,8,10,None], #max depth tree can grow; default is none              #'min_samples_split': [2,5,10,.03,.05], #minimum subset size BEFORE new split (fraction is % of total); default is 2              #'min_samples_leaf': [1,5,10,.03,.05], #minimum subset size AFTER new split split (fraction is % of total); default is 1              #'max_features': [None, 'auto'], #max features to consider when performing split; default none or all              'random_state': [0] #seed or control random number generator: https://www.quora.com/What-is-seed-in-random-number-generation             }#print(list(model_selection.ParameterGrid(param_grid)))#choose best model with grid_search: #http://scikit-learn.org/stable/modules/grid_search.html#grid-search#http://scikit-learn.org/stable/auto_examples/model_selection/plot_grid_search_digits.htmltune_model = model_selection.GridSearchCV(tree.DecisionTreeClassifier(), param_grid=param_grid, scoring = 'roc_auc', cv = cv_split)tune_model.fit(data1[data1_x_bin], data1[Target])#print(tune_model.cv_results_.keys())#print(tune_model.cv_results_['params'])print('AFTER DT Parameters: ', tune_model.best_params_)#print(tune_model.cv_results_['mean_train_score'])print(\"AFTER DT Training w/bin score mean: {:.2f}\". format(tune_model.cv_results_['mean_train_score'][tune_model.best_index_]*100)) #print(tune_model.cv_results_['mean_test_score'])print(\"AFTER DT Test w/bin score mean: {:.2f}\". format(tune_model.cv_results_['mean_test_score'][tune_model.best_index_]*100))print(\"AFTER DT Test w/bin score 3*std: +/- {:.2f}\". format(tune_model.cv_results_['std_test_score'][tune_model.best_index_]*100*3))print('-'*10)#duplicates gridsearchcv#tune_results = model_selection.cross_validate(tune_model, data1[data1_x_bin], data1[Target], cv  = cv_split)#print('AFTER DT Parameters: ', tune_model.best_params_)#print(\"AFTER DT Training w/bin set score mean: {:.2f}\". format(tune_results['train_score'].mean()*100)) #print(\"AFTER DT Test w/bin set score mean: {:.2f}\". format(tune_results['test_score'].mean()*100))#print(\"AFTER DT Test w/bin set score min: {:.2f}\". format(tune_results['test_score'].min()*100))#print('-'*10)BEFORE DT Parameters:  {'class_weight': None, 'criterion': 'gini', 'max_depth': None, 'max_features': None, 'max_leaf_nodes': None, 'min_impurity_decrease': 0.0, 'min_impurity_split': None, 'min_samples_leaf': 1, 'min_samples_split': 2, 'min_weight_fraction_leaf': 0.0, 'presort': False, 'random_state': 0, 'splitter': 'best'}BEFORE DT Training w/bin score mean: 89.51BEFORE DT Test w/bin score mean: 82.09BEFORE DT Test w/bin score 3*std: +/- 5.57----------AFTER DT Parameters:  {'criterion': 'gini', 'max_depth': 4, 'random_state': 0}AFTER DT Training w/bin score mean: 89.35AFTER DT Test w/bin score mean: 87.40AFTER DT Test w/bin score 3*std: +/- 5.00----------grid search를 통해 최적의 파라미터를 찾았다.Feature Selection모든 변수를 찾는 것이 좋은 모델을 찾는 것으로 이어지지 않는다고 얘기했었다. 따라서 이번에는 많은 feature중 어떤 것을 선택했을 때 가장 좋은 성능을 가지는지 알아본다. sklearn에는 다양한 선택지가 있다. 그 중에서  recursive feature elimination (RFE) with cross validation (CV)를 사용할 것이다.#base modelprint('BEFORE DT RFE Training Shape Old: ', data1[data1_x_bin].shape) print('BEFORE DT RFE Training Columns Old: ', data1[data1_x_bin].columns.values)print(\"BEFORE DT RFE Training w/bin score mean: {:.2f}\". format(base_results['train_score'].mean()*100)) print(\"BEFORE DT RFE Test w/bin score mean: {:.2f}\". format(base_results['test_score'].mean()*100))print(\"BEFORE DT RFE Test w/bin score 3*std: +/- {:.2f}\". format(base_results['test_score'].std()*100*3))print('-'*10)#feature selectiondtree_rfe = feature_selection.RFECV(dtree, step = 1, scoring = 'accuracy', cv = cv_split)dtree_rfe.fit(data1[data1_x_bin], data1[Target])#transform x&amp;y to reduced features and fit new model#alternative: can use pipeline to reduce fit and transform steps: http://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.htmlX_rfe = data1[data1_x_bin].columns.values[dtree_rfe.get_support()] # get_support()는 feature에서 사용한 것만 t/f로 표현해준다.rfe_results = model_selection.cross_validate(dtree, data1[X_rfe], data1[Target], cv  = cv_split)#print(dtree_rfe.grid_scores_)print('AFTER DT RFE Training Shape New: ', data1[X_rfe].shape) print('AFTER DT RFE Training Columns New: ', X_rfe)print(\"AFTER DT RFE Training w/bin score mean: {:.2f}\". format(rfe_results['train_score'].mean()*100)) print(\"AFTER DT RFE Test w/bin score mean: {:.2f}\". format(rfe_results['test_score'].mean()*100))print(\"AFTER DT RFE Test w/bin score 3*std: +/- {:.2f}\". format(rfe_results['test_score'].std()*100*3))print('-'*10)# feature selection을 기본 모델로 평가하고, 그 모델로 부터 나온 feature를 가지고 모델의 입력으로 넣어# 다시 파라미터 튜닝을 한다.#tune rfe modelrfe_tune_model = model_selection.GridSearchCV(tree.DecisionTreeClassifier(), param_grid=param_grid, scoring = 'roc_auc', cv = cv_split)rfe_tune_model.fit(data1[X_rfe], data1[Target])#print(rfe_tune_model.cv_results_.keys()) # 어떤 메소드가 있는지 확인#print(rfe_tune_model.cv_results_['params']) # 파라미터 확인print('AFTER DT RFE Tuned Parameters: ', rfe_tune_model.best_params_)#print(rfe_tune_model.cv_results_['mean_train_score'])print(\"AFTER DT RFE Tuned Training w/bin score mean: {:.2f}\". format(rfe_tune_model.cv_results_['mean_train_score'][tune_model.best_index_]*100)) #print(rfe_tune_model.cv_results_['mean_test_score'])print(\"AFTER DT RFE Tuned Test w/bin score mean: {:.2f}\". format(rfe_tune_model.cv_results_['mean_test_score'][tune_model.best_index_]*100))print(\"AFTER DT RFE Tuned Test w/bin score 3*std: +/- {:.2f}\". format(rfe_tune_model.cv_results_['std_test_score'][tune_model.best_index_]*100*3))print('-'*10)BEFORE DT RFE Training Shape Old:  (891, 7)BEFORE DT RFE Training Columns Old:  ['Sex_Code' 'Pclass' 'Embarked_Code' 'Title_Code' 'FamilySize' 'AgeBin_Code' 'FareBin_Code']BEFORE DT RFE Training w/bin score mean: 89.51BEFORE DT RFE Test w/bin score mean: 82.09BEFORE DT RFE Test w/bin score 3*std: +/- 5.57----------AFTER DT RFE Training Shape New:  (891, 6)AFTER DT RFE Training Columns New:  ['Sex_Code' 'Pclass' 'Title_Code' 'FamilySize' 'AgeBin_Code' 'FareBin_Code']AFTER DT RFE Training w/bin score mean: 88.16AFTER DT RFE Test w/bin score mean: 83.06AFTER DT RFE Test w/bin score 3*std: +/- 6.22----------AFTER DT RFE Tuned Parameters:  {'criterion': 'gini', 'max_depth': 4, 'random_state': 0}AFTER DT RFE Tuned Training w/bin score mean: 89.39AFTER DT RFE Tuned Test w/bin score mean: 87.34AFTER DT RFE Tuned Test w/bin score 3*std: +/- 6.21----------FareBinfeature가 삭제된 후, 성능이 올라갔다.Graph 그리기#Graph MLA version of Decision Tree: http://scikit-learn.org/stable/modules/generated/sklearn.tree.export_graphviz.htmlimport graphviz dot_data = tree.export_graphviz(dtree, out_file=None,                                 feature_names = data1_x_bin, class_names = True,                                filled = True, rounded = True)graph = graphviz.Source(dot_data) graphReferencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-09-Hyper-parameter-tuning.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-08-eb-aa-a8-eb-8d-b8-ed-8f-89-ea-b0-80-ed-95-98-ea-b8-b0-html": {
        "title": "08: 모델링 평가하기",
        "tags": "DS, kaggle, ML, titanic, evaluation",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제를 모델링한 결과를 바탕으로 모델을 평가한다.모델 성능 평가현재까지의 상황을 보면, baseline 코드로 82%의 정확도를 가지는 모델을 만들었다. 여기서 중요한 것은, 데이터 과학자가 사업적 측면을 생각하고 만든다는 것에 있다. 즉, 투자대비 성능(ROI)를 고민하는 것이 좋다. 연구하는 사람이 아니라면 지나친 성능확대는 시간 낭비일 뿐이기 때문이다.기준 정확도 결정동전 뒤집기를 생각해보자. 우리가 맞춰야 하는 것은 특정 상황에서 이 동전이 앞면이 나올지 뒷면이 나올지를 예측해야 한다. 그 예측값을 위해, 바람, 힘의 크기와 같은 변수들이 주어졌다고 하자. 그런데, 내가 만든 모델이 50%확률로 동전의 앞, 뒤를 맞춘다면, 이만큼 쓸모없는 모델도 없을 것이다. 왜냐하면, 이 정보는 그저 동전을 던지면서 발생하는 빈도수로도 예측이 가능한 결과이기 때문이다.이번에는 타이타닉 문제에 적용해보자. 우리는 training data를 근간으로 1,502 / 2,224=67.5%(약 68%)의 확률로 생존, 사망을 알 수 있다. 그러므로 내가 만든 모델의 성능은 이보다는 높은 결과를 가져와야 의미있는 것이라 할 수 있다. 이러한 방법으로 내가 만든 모델의 최악의 성능 마지노선을 설정할 수 있다.나만의 모델 만들기 (Handmade)어떻게 모델을 만들 수 있는 지 배워보는 입장에서 적어본다.Coin flip model#coin flip model with random 1/survived 0/died#iterate over dataFrame rows as (index, Series) pairs: https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.htmlfor index, row in data1.iterrows():     #random number generator: https://docs.python.org/2/library/random.html    if random.random() &gt; .5:     # Random float x, 0.0 &lt;= x &lt; 1.0            data1.set_value(index, 'Random_Predict', 1) #predict survived/1    else:         data1.set_value(index, 'Random_Predict', 0) #predict died/0    # coin flip 모델의 성능을 검증해보자. 옳게 맞추면 1, 아니면 0이다.#the mean of the column will then equal the accuracydata1['Random_Score'] = 0 #assume prediction wrong 초기화data1.loc[(data1['Survived'] == data1['Random_Predict']), 'Random_Score'] = 1 #set to 1 for correct predictionprint('Coin Flip Model Accuracy: {:.2f}%'.format(data1['Random_Score'].mean()*100)) # 평균치를 구한다.# 혹은 그냥 내장 함수를 사용하자.#http://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_scoreprint('Coin Flip Model Accuracy w/SciKit: {:.2f}%'.format(metrics.accuracy_score(data1['Survived'], data1['Random_Predict'])*100))Coin Flip Model Accuracy: 47.14%Coin Flip Model Accuracy w/SciKit: 47.14%group화 후 판단하기#group by or pivot table: https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.htmlpivot_female = data1[data1.Sex=='female'].groupby(['Sex','Pclass', 'Embarked','FareBin'])['Survived'].mean()print('Survival Decision Tree w/Female Node: \\n',pivot_female)pivot_male = data1[data1.Sex=='male'].groupby(['Sex','Title'])['Survived'].mean()print('\\n\\nSurvival Decision Tree w/Male Node: \\n',pivot_male)여자만 다양한 지표로 구분한 이유는 위의 EDA를 해보았을 때, 남자는 놀랍게도 class나, embarked에 따라 생존률이 다르지 않았다. 하지만 title이라는 변수는 유의미했다.Survival Decision Tree w/Female Node:  Sex     Pclass  Embarked  FareBin        female  1       C         (14.454, 31.0]     0.666667                          (31.0, 512.329]    1.000000                Q         (31.0, 512.329]    1.000000                S         (14.454, 31.0]     1.000000                          (31.0, 512.329]    0.955556        2       C         (7.91, 14.454]     1.000000                          (14.454, 31.0]     1.000000                          (31.0, 512.329]    1.000000                Q         (7.91, 14.454]     1.000000                S         (7.91, 14.454]     0.875000                          (14.454, 31.0]     0.916667                          (31.0, 512.329]    1.000000        3       C         (-0.001, 7.91]     1.000000                          (7.91, 14.454]     0.428571                          (14.454, 31.0]     0.666667                Q         (-0.001, 7.91]     0.750000                          (7.91, 14.454]     0.500000                          (14.454, 31.0]     0.714286                S         (-0.001, 7.91]     0.533333                          (7.91, 14.454]     0.448276                          (14.454, 31.0]     0.357143                          (31.0, 512.329]    0.125000Name: Survived, dtype: float64Survival Decision Tree w/Male Node:  Sex   Title male  Master    0.575000      Misc      0.250000      Mr        0.156673Name: Survived, dtype: float64여기서 잘 관찰해 보면, 여자이면서 class가 3이며, S 항구에서 출항한 여성들의 요금 구간에 따라 생존율이 다른 것을 볼 수 있다. 이 부분은 tree 구조로 쪼개면 정확도가 상승할 것이다.남자의 경우는 title에 따라 생존율이 극명하게 다르다.내가 만드는 tree#handmade data model using brain power (and Microsoft Excel Pivot Tables for quick calculations)def mytree(df):        #initialize table to store predictions    Model = pd.DataFrame(data = {'Predict':[]})    male_title = ['Master'] #survived titles    for index, row in df.iterrows():        #Question 1: Were you on the Titanic; majority died 타이타닉에 있으면 일단 죽었다고 가정        Model.loc[index, 'Predict'] = 0        #Question 2: Are you female; majority survived : 여자는 살았다고 가정        if (df.loc[index, 'Sex'] == 'female'):                  Model.loc[index, 'Predict'] = 1        #Question 3A Female - Class and Question 4 Embarked gain minimum information        #클래스에 따라 나누는 것은 큰 정보이득이 없다. (즉, 클래스에 따른 생존률의 차이가 없다. 정보이득이 없다. 고르게 분포되어 있어 분기를 만드는 것이 의미가 없다.)        #Question 5B Female - FareBin; set anything less than .5 in female node decision tree back to 0               # 여자이며 클래스가 3번, 출항 항구가 S 그리고 돈을 8보다 많이 낸 사람들은 생존했다. 아마 못사는 사람들이 돈을 더 많이 내지 않았을까..        if ((df.loc[index, 'Sex'] == 'female') &amp;             (df.loc[index, 'Pclass'] == 3) &amp;             (df.loc[index, 'Embarked'] == 'S')  &amp;            (df.loc[index, 'Fare'] &gt; 8)           ):                  Model.loc[index, 'Predict'] = 0        #Question 3B Male: Title; set anything greater than .5 to 1 for majority survived        # master 지위를 가진 사람만 생존했다고 가정하자.그럼 남자중 57%는 생존했다고 할 수 있다.        if ((df.loc[index, 'Sex'] == 'male') &amp;            (df.loc[index, 'Title'] in male_title)            ):            Model.loc[index, 'Predict'] = 1    return Model#model dataTree_Predict = mytree(data1)print('Decision Tree Model Accuracy/Precision Score: {:.2f}%\\n'.format(metrics.accuracy_score(data1['Survived'], Tree_Predict)*100))#Accuracy Summary Report with http://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html#sklearn.metrics.classification_report#Where recall score = (true positives)/(true positive + false negative) w/1 being best:http://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score#And F1 score = weighted average of precision and recall w/1 being best: http://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_scoreprint(metrics.classification_report(data1['Survived'], Tree_Predict))Decision Tree Model Accuracy/Precision Score: 82.04%             precision    recall  f1-score   support          0       0.82      0.91      0.86       549          1       0.82      0.68      0.75       342avg / total       0.82      0.82      0.82       891혼동 행렬(Confusion Matrix) 만들기#Plot Accuracy Summary#Credit: http://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.htmlimport itertoolsdef plot_confusion_matrix(cm, classes,                          normalize=False,                          title='Confusion matrix',                          cmap=plt.cm.Blues):    \"\"\"    This function prints and plots the confusion matrix.    Normalization can be applied by setting `normalize=True`.    \"\"\"    if normalize:        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis] # 차원을 하나 늘려 세로로 만들어주는 개념        print(\"Normalized confusion matrix\")    else:        print('Confusion matrix, without normalization')    print(cm)    plt.imshow(cm, interpolation='nearest', cmap=cmap)    plt.title(title)    plt.colorbar()    tick_marks = np.arange(len(classes))    plt.xticks(tick_marks, classes, rotation=45)    plt.yticks(tick_marks, classes)    fmt = '.2f' if normalize else 'd'    thresh = cm.max() / 2.    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):        plt.text(j, i, format(cm[i, j], fmt),                 horizontalalignment=\"center\",                 color=\"white\" if cm[i, j] &gt; thresh else \"black\")    plt.tight_layout()    plt.ylabel('True label')    plt.xlabel('Predicted label')# Compute confusion matrixcnf_matrix = metrics.confusion_matrix(data1['Survived'], Tree_Predict)np.set_printoptions(precision=2)class_names = ['Dead', 'Survived']# Plot non-normalized confusion matrixplt.figure()plot_confusion_matrix(cnf_matrix, classes=class_names,                      title='Confusion matrix, without normalization')# Plot normalized confusion matrixplt.figure()plot_confusion_matrix(cnf_matrix, classes=class_names, normalize=True,                       title='Normalized confusion matrix')Confusion matrix, without normalization[[497  52] [108 234]]Normalized confusion matrix[[ 0.91  0.09] [ 0.32  0.68]]Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-08-%EB%AA%A8%EB%8D%B8-%ED%8F%89%EA%B0%80%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-07-eb-aa-a8-eb-8d-b8-eb-a7-81-html": {
        "title": "07: 모델링",
        "tags": "DS, kaggle, ML, titanic, modeling",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 모델링을 수행한다.Modeling데이터 사이언스는 수학, CS, 산업에 대한 이해 모두가 필요한 분야이다. 그렇기 때문에 이 세 부분을 모두 주의깊게 공부할 필요가 있다. 지금 부터 할 작업은 수학적 이해가 있으면 좋지만 구현하는데에는 크게 필요가 없다. 지금은 큰 그림을 이해하는 것을 우선으로 한다.기계학습이라는 단어 자체에는 기계에게 학습을 가르친다는 착각을 일으킬 수 있는 여지가 많다. 하지만, 실제로는 그렇지 않다. 다양한 사람들이 좋은 라이브러리를 사용하여 많은 문제를 해결할 수 있게 된 것은 좋으나, 이러한 문제 때문에 오히려 제대로 된 방법을 사용못하는 사람도 많아졌다. 데이터 과학자는 데이터라는 목재를 가지고, 목표에 대한 적절한 도구를 사용하여 문제를 해결해야 한다. 개집을 짓는다면 그에 맞는 적절한 도구로 충분하지만, 큰 목조 건물을 짓는다면, 더 효율적인 도구를 통하여 문제를 해결해야 할 것이다. 결과적으로 알고리즘에 대한 정확한 이해도와 그를 사용할 수 있는 능력을 키워야 할 것이다.기계학습의 목적은, 인간의 문제를 해결하는 것이다. 이 방법으로는 크게 지도학습, 비지도 학습, 강화 학습으로 구분된다. 지도학습은 정답을 포함한 데이터 세트를 가지고 분류하는 것, 비지도 학습은 정답이 없는 데이터 세트를 가지고 모델을 학습하는 것이다. 강화학습은 두 학습의 하이브리드 방식으로 볼 수 있다.타이타닉 문제는 연속적인 값을 예측하는 것이 아닌, 이진 분류 문제이다. 따라서 지금부터 sklearn 라이브러리의 분류 알고리즘을 사용하여 분석을 시작한다.Sklearn Estimator OverviewSklearn Estimator DetailChoosing Estimator Mind MapChoosing Estimator Cheat Sheet지도 학습 중, 분류 문제에 대한 알고리즘에 대해 알아보자.Machine Learning Classification Algorithms:Ensemble MethodsGeneralized Linear Models (GLM)Naive BayesNearest NeighborsSupport Vector Machines (SVM)Decision TreesDiscriminant Analysis기계학습 알고리즘을 고르는 방법  최고의 알고리즘은 없다. NFLT (No Free Lunch Theorem)최고의 알고리즘은 존재하지 않는다. 다양한 알고리즘을 통해 검증하여 최고의 답안을 내는 것이 최선이다.머신 러닝 알고리즘 선택 및 초기화# Machine Learning AlgorithmMLA = [    #Ensemble Methods    ensemble.AdaBoostClassifier(),    ensemble.BaggingClassifier(),    ensemble.ExtraTreesClassifier(),    ensemble.GradientBoostingClassifier(),    ensemble.RandomForestClassifier(),    #Gaussian Processes    gaussian_process.GaussianProcessClassifier(),        #GLM (Generalized Linear Model)    linear_model.LogisticRegressionCV(),    linear_model.PassiveAggressiveClassifier(),    linear_model.RidgeClassifierCV(),    linear_model.SGDClassifier(),    linear_model.Perceptron(),        #Navies Bayes    naive_bayes.BernoulliNB(),    naive_bayes.GaussianNB(),        #Nearest Neighbor    neighbors.KNeighborsClassifier(),        #SVM    svm.SVC(probability=True),    svm.NuSVC(probability=True),    svm.LinearSVC(),        #Trees        tree.DecisionTreeClassifier(),    tree.ExtraTreeClassifier(),        #Discriminant Analysis (판별 분석)    discriminant_analysis.LinearDiscriminantAnalysis(),    discriminant_analysis.QuadraticDiscriminantAnalysis(),        #xgboost: http://xgboost.readthedocs.io/en/latest/model.html    XGBClassifier()        ]#split dataset in cross-validation with this splitter class: http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.ShuffleSplit.html#sklearn.model_selection.ShuffleSplit#note: this is an alternative to train_test_splitcv_split = model_selection.ShuffleSplit(n_splits = 10, test_size = .3, train_size = .6, random_state = 0 ) # 60/30 으로 나눈다. 10%는 일부러 둔다. 그 작업을 10번 만든다.# 알고리즘을 비교하기 위한 표를 만든다.MLA_columns = ['MLA Name', 'MLA Parameters','MLA Train Accuracy Mean', 'MLA Test Accuracy Mean', 'MLA Test Accuracy 3*STD' ,'MLA Time']MLA_compare = pd.DataFrame(columns = MLA_columns)# 각각의 알고리즘이 예측한 값을 보여줄 테이블을 만든다.MLA_predict = data1[Target]# row 하나에 하나의 알고리즘에 대한 결과를 적을 것이므로, row_index를 변수로 잡아준다.row_index = 0for alg in MLA:    #set name and parameters    MLA_name = alg.__class__.__name__    MLA_compare.loc[row_index, 'MLA Name'] = MLA_name    MLA_compare.loc[row_index, 'MLA Parameters'] = str(alg.get_params())        #score model with cross validation: http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.cross_validate.html#sklearn.model_selection.cross_validate    # 만들어진 10개의 split set에 대해 검증을 한다. 이 작업 이후에 결과는 10개가 나올 것이다.    cv_results = model_selection.cross_validate(alg, data1[data1_x_bin], data1[Target], cv  = cv_split)    MLA_compare.loc[row_index, 'MLA Time'] = cv_results['fit_time'].mean()    MLA_compare.loc[row_index, 'MLA Train Accuracy Mean'] = cv_results['train_score'].mean() # 10개의 결과에 대해 평균치    MLA_compare.loc[row_index, 'MLA Test Accuracy Mean'] = cv_results['test_score'].mean()       # https://ko.wikipedia.org/wiki/68-95-99.7_규칙    # 제대로 된 random으로 sampling을 했다면, cross-validation으로 나온 결과는 3시그마 규칙을 만족할 것이다.(즉, 정규 분포로 나왔을 것이다.)    # 이 값을 얻는 이유는, 최악의 훈련 결과를 알아보기 위함이다. 편차가 작을 수록 일반화된 모델이라는 생각을 할 수 있다.    MLA_compare.loc[row_index, 'MLA Test Accuracy 3*STD'] = cv_results['test_score'].std()*3   #let's know the worst that can happen!        #save MLA predictions - see section 6 for usage    alg.fit(data1[data1_x_bin], data1[Target])    MLA_predict[MLA_name] = alg.predict(data1[data1_x_bin])        row_index+=1    #print and sort table: https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.sort_values.html# test 정확도가 높은 순서대로 sorting한다.MLA_compare.sort_values(by = ['MLA Test Accuracy Mean'], ascending = False, inplace = True)MLA_compareMLA_predict.sample(10)#barplot using https://seaborn.pydata.org/generated/seaborn.barplot.htmlsns.barplot(x='MLA Test Accuracy Mean', y = 'MLA Name', data = MLA_compare, color = 'm')#prettify using pyplot: https://matplotlib.org/api/pyplot_api.htmlplt.title('Machine Learning Algorithm Accuracy Score \\n')plt.xlabel('Accuracy Score (%)')plt.ylabel('Algorithm')Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-07-%EB%AA%A8%EB%8D%B8%EB%A7%81.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-06-eda-html": {
        "title": "06: EDA (Exploratory Data Analysis)",
        "tags": "DS, kaggle, ML, titanic, 시각화, boxplot, violinplot",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 데이터를 탐험적 데이터 탐색을 통해 이해한다.EDA데이터 정제가 끝났으니, 탐험적 데이터 분석을 통해서, 데이터에 대한 이해를 시각적으로 해보자. 이 단계에서 변수를 분리하고, 종속 변수와의 상관관계를 결정해 볼 수 있다.이산적 변수와 y와의 관계for x in data1_x:    if data1[x].dtype != 'float64' :        print('Survival Correlation by:', x)        print(data1[[x, Target[0]]].groupby(x, as_index=False).mean())         # feature와 survived를 가져와서 해당 feature에 대해 group을 묶고, 그 group의 평균을 구해라        print('-'*10, '\\n')        # 빈도표 만들기print(pd.crosstab(data1['Title'], data1[Target[0]]))Survival Correlation by: Sex      Sex  Survived0  female  0.7420381    male  0.188908---------- Survival Correlation by: Pclass   Pclass  Survived0       1  0.6296301       2  0.4728262       3  0.242363---------- Survival Correlation by: Embarked  Embarked  Survived0        C  0.5535711        Q  0.3896102        S  0.339009---------- Survival Correlation by: Title    Title  Survived0  Master  0.5750001    Misc  0.4444442    Miss  0.6978023      Mr  0.1566734     Mrs  0.792000---------- Survival Correlation by: SibSp   SibSp  Survived0      0  0.3453951      1  0.5358852      2  0.4642863      3  0.2500004      4  0.1666675      5  0.0000006      8  0.000000---------- Survival Correlation by: Parch   Parch  Survived0      0  0.3436581      1  0.5508472      2  0.5000003      3  0.6000004      4  0.0000005      5  0.2000006      6  0.000000---------- Survival Correlation by: FamilySize   FamilySize  Survived0           1  0.3035381           2  0.5527952           3  0.5784313           4  0.7241384           5  0.2000005           6  0.1363646           7  0.3333337           8  0.0000008          11  0.000000---------- Survival Correlation by: IsAlone   IsAlone  Survived0        0  0.5056501        1  0.303538---------- Survived    0    1Title             Master     17   23Misc       15   12Miss       55  127Mr        436   81Mrs        26   99group by aka pivot tableusing crosstabs빈도표 만들기이산 데이터에 대한 plot이 부분에서 plot을 하는데 있어 연습을 위해 다양한 방법을 통해 구현해본다.#graph distribution of quantitative dataplt.figure(figsize=[16,12])plt.subplot(231)plt.boxplot(x=data1['Fare'], showmeans = True, meanline = True)plt.title('Fare Boxplot')plt.ylabel('Fare ($)')plt.subplot(232)plt.boxplot(data1['Age'], showmeans = True, meanline = True)plt.title('Age Boxplot')plt.ylabel('Age (Years)')plt.subplot(233)plt.boxplot(data1['FamilySize'], showmeans = True, meanline = True)plt.title('Family Size Boxplot')plt.ylabel('Family Size (#)')plt.subplot(234)plt.hist(x = [data1[data1['Survived']==1]['Fare'], data1[data1['Survived']==0]['Fare']],          stacked=True, color = ['g','r'],label = ['Survived','Dead'])plt.title('Fare Histogram by Survival')plt.xlabel('Fare ($)')plt.ylabel('# of Passengers')plt.legend()plt.subplot(235)plt.hist(x = [data1[data1['Survived']==1]['Age'], data1[data1['Survived']==0]['Age']],          stacked=True, color = ['g','r'],label = ['Survived','Dead'])plt.title('Age Histogram by Survival')plt.xlabel('Age (Years)')plt.ylabel('# of Passengers')plt.legend()plt.subplot(236)plt.hist(x = [data1[data1['Survived']==1]['FamilySize'], data1[data1['Survived']==0]['FamilySize']],          stacked=True, color = ['g','r'],label = ['Survived','Dead'])plt.title('Family Size Histogram by Survival')plt.xlabel('Family Size (#)')plt.ylabel('# of Passengers')plt.legend()범주형 데이터에 대한 plotseaborn을 사용한 plot을 해본다.#graph individual features by survivalfig, saxis = plt.subplots(2, 3,figsize=(16,12))sns.barplot(x = 'Embarked', y = 'Survived', data=data1, ax = saxis[0,0])sns.barplot(x = 'Pclass', y = 'Survived', order=[1,2,3], data=data1, ax = saxis[0,1])sns.barplot(x = 'IsAlone', y = 'Survived', order=[1,0], data=data1, ax = saxis[0,2])sns.pointplot(x = 'FareBin', y = 'Survived',  data=data1, ax = saxis[1,0])sns.pointplot(x = 'AgeBin', y = 'Survived',  data=data1, ax = saxis[1,1])sns.pointplot(x = 'FamilySize', y = 'Survived', data=data1, ax = saxis[1,2])이 단계에서 우리는 Pclass에 따른 생존률의 차이가 있다는 것을 알 수 있다. 조금더 자세하게 비교해보자.생존 여부, 클래스에 따른 추가 변수의 분포생존 여부, 클래스에 따른 지불 비용, 가족의 크기, 연령 등의 분포를 알아보자. 분포를 알아볼 때는 보통 boxplot을 사용한다. 하지만, boxplot을 사용했을 때 가독성이 떨어지는 경우가 있다. 그 이유는 점들이 찍혀 있고 그렇기 때문인데, 이럴경우 분포를 보는 것이 목적이라면 violin plot을 쓰는 것이 좋다.#graph distribution of qualitative data: Pclass#we know class mattered in survival, now let's compare class and a 2nd featurefig, (axis1,axis2,axis3) = plt.subplots(1,3,figsize=(14,12))sns.boxplot(x = 'Pclass', y = 'Fare', hue = 'Survived', data = data1, ax = axis1)axis1.set_title('Pclass vs Fare Survival Comparison')sns.violinplot(x = 'Pclass', y = 'Age', hue = 'Survived', data = data1, split = True, ax = axis2)# sns.boxplot(x = 'Pclass', y = 'Age', hue = 'Survived', data = data1, ax = axis2)axis2.set_title('Pclass vs Age Survival Comparison')sns.boxplot(x = 'Pclass', y ='FamilySize', hue = 'Survived', data = data1, ax = axis3)axis3.set_title('Pclass vs Family Size Survival Comparison')위는 boxplot을 사용했을 때이고, 아래는 violin을 사용했을 때이다. 분포만 보는 경우 아래 경우가 더 수월하다는 것을 알 수 있다. 이 때 option split를 False로 할 경우, 현재 3개의 violin이 나왔지만 이것을 6개로 나누어서 보여준다.성별과 2nd feature에 따른 생존률#graph distribution of qualitative data: Sex#we know sex mattered in survival, now let's compare sex and a 2nd featurefig, qaxis = plt.subplots(1,3,figsize=(14,12))sns.barplot(x = 'Sex', y = 'Survived', hue = 'Embarked', data=data1, ax = qaxis[0])axis1.set_title('Sex vs Embarked Survival Comparison')sns.barplot(x = 'Sex', y = 'Survived', hue = 'Pclass', data=data1, ax  = qaxis[1])axis1.set_title('Sex vs Pclass Survival Comparison')sns.barplot(x = 'Sex', y = 'Survived', hue = 'IsAlone', data=data1, ax  = qaxis[2])axis1.set_title('Sex vs IsAlone Survival Comparison')가족 구조와 성별에 따른 생존률 비교#more side-by-side comparisonsfig, (maxis1, maxis2) = plt.subplots(1, 2,figsize=(14,12))#how does family size factor with sex &amp; survival comparesns.pointplot(x=\"FamilySize\", y=\"Survived\", hue=\"Sex\", data=data1,              palette={\"male\": \"blue\", \"female\": \"pink\"},              markers=[\"*\", \"o\"], linestyles=[\"-\", \"--\"], ax = maxis1)#how does class factor with sex &amp; survival comparesns.pointplot(x=\"Pclass\", y=\"Survived\", hue=\"Sex\", data=data1,              palette={\"male\": \"blue\", \"female\": \"pink\"},              markers=[\"*\", \"o\"], linestyles=[\"-\", \"--\"], ax = maxis2)클래스, 출항 항구에 따른 생존률클래스도 여러개의 factor, 출항 항구도 factor이다. 이렇게 여러개에 대한 plot을 빠르게 하는 방법이 있다. seaborn의 facetgrid를 사용하는 것이다.e = sns.FacetGrid(data1, col = 'Embarked')e.map(sns.pointplot, 'Pclass', 'Survived', 'Sex', ci=60.0, palette = 'deep') # 순서대로 x의 구분, y의 구분, 추가 구분e.add_legend()나이에 따른 생존 확률 분포나이대에 따른 생존률의 분포를 알고 싶다. 이런 분포는 밀도 함수를 구하는 것과 같다. x가 나이, y가 생존확률이기 때문이다. 이럴 때, kernel함수를 사용하여 밀도함수를 만들어 낼 수 있다.a = sns.FacetGrid( data1, hue = 'Survived', aspect=4 )a.map(sns.kdeplot, 'Age', shade= True )a.set(xlim=(0 , data1['Age'].max()))a.add_legend()성별, 클래스에 따른 나이에 대한 사람 분포성별, 클래스에 따른 그래프를 하나씩 생성하기 위해 col, row 구분은 각각 성별, 클래스로 해준다. 그 상태에서 x는 age, y는 히스토그램에서의 개수가 될 것이다. 이 때, 각각의 그래프에서 색상 구분을 통해 survived를 구분해준다.#histogram comparison of sex, class, and age by survivalh = sns.FacetGrid(data1, row = 'Sex', col = 'Pclass', hue = 'Survived')h.map(plt.hist, 'Age', alpha = .75)h.add_legend()전체 feature들에 대한 plot#pair plots of entire datasetpp = sns.pairplot(data1, hue = 'Survived', palette = 'deep', size=1.2, diag_kind = 'kde', diag_kws=dict(shade=True), plot_kws=dict(s=10) )pp.set(xticklabels=[])feature를 2개씩 묶어 plot해준다. 이 때, kws은 keyword argument로 dictionary 자료형으로 넣어주면 된다. plot에 있어 설정들을 넘겨줄 수 있다. shade는 밀도함수의 안을 채워서 보여주는 역할을 한다. kde는 kernel density estimation을 의미하며, 커널을 씌워 밀도함수의 모양으로 plot한다.상관관계 히트맵각 변수들간의 상관관계에 대해서 plot 해본다. seaborn.diverging_palette#correlation heatmap of datasetdef correlation_heatmap(df):    _ , ax = plt.subplots(figsize =(14, 12))    colormap = sns.diverging_palette(220, 10, as_cmap = True)        _ = sns.heatmap(        df.corr(),         cmap = colormap, # 이친구가 matplot 객체를 입력으로 받는다. as_camp = True로 해줘야 한다.        square=True,         cbar_kws={'shrink':.9 },         ax=ax,        annot=True, # 박스에 값 입력해준다.        linewidths=0.1,vmax=1.0, linecolor='white',        annot_kws={'fontsize':12 }    )        plt.title('Pearson Correlation of Features', y=1.05, size=15)correlation_heatmap(data1)Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-06-EDA.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-05-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-a0-95-ec-a0-9c-html": {
        "title": "05: 데이터 정제",
        "tags": "DS, kaggle, ML, titanic",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 데이터를 정제한다.데이터 정제이 단계에서 우리는 데이터를 정제한다.방법론  잘못된 값과 이상치를 수정한다.  결측치를 채워넣는다.  분석에 필요한 새로운 feature를 생성한다.  계산을 위해 변수의 data format을 변경한다.이 방법에 대해 하나씩 자세히 알아보자.  Correcting          데이터를 다시 보면서 이상하거나 납득하기 어려운 데이터를 확인한다. 하지만 수정은 조심해야 한다. 잘못된 판단으로 원래 데이터를 수정할 경우 올바르지 않은 결과가 나올 수 있기 때문이다. 따라서 EDA를 수행한 후 어느정도의 지식을 얻은 후에 수행하기로 한다.        Completing          age, cabin, embarked field에는 결측치나 Null이 많다. Null은 상당히 위험한데, 알고리즘이 받아들일 수 없는 경우가 있기 때문이다. 예를 들어 결정 트리는 null을 받아들일 수 있지만, 다른 알고리즘은 그렇지 않다. 따라서 이 값을 변경하는 것은 매우 중요하다. 이 부분에 있어서는 두가지 접근이 사용된다.                  값을 지운다.                          추천하지는 않는 방법이다. 특히 많은 부분의 record(row)가 빈 값으로 생각되지 않는다면 수행하면 안된다.                                합리적인 값으로 대체한다.                          지우기 보다는 이것이 나은 방법이다.              좋은 방법론으로는, 결측치를 평균, 중앙값, 평균+편차, 최빈값등을 사용하는 것이다.              중급의 방법론은 특정 기준을 사용하여 채워넣는 것이다. 클래스별 나이, 요금에 따른 적재 항구와 같은 것들이 그것이다.              복잡한 방법론이 있지만, 최종 모델을 선정하기 전에, 추가한 feature로 인한 복잡도가 가치가 있는지를 확인해야 한다. 이번에는 age의 빈값은 중앙값으로, cabin은 삭제하며, embark는 최빈값으로 대체된다. 추후 모델에서 이러한 결정을 수정하며 모델을 개선할 수 있다.                                            Creating          Feature engineering은 이미 존재하는 feature를 가지고 새로운 feature를 제작하여 결과에 새로운 영향력을 주는지를 판단하는 과정이다. 예를 들어, 이번 문제에서는 title(master)이 생존에 있어 중요했는지를 판단할 수 있다.        Converting          마지막으로 데이터 포맷을 변경하는 것이다. 날짜나 통화와 같은 데이터 형식일 경우 이것을 변경해줘야 한다. 이번 문제에서는 이산, 연속, 범주형 등의 데이터 형식이 있다. 이런 부분을 계산이 가능하도록 dummy변수화 해준다.      print('Train columns with null values:\\n', data1.isnull().sum())print(\"-\"*10)print('Test/Validation columns with null values:\\n', data_val.isnull().sum())print(\"-\"*10)data_raw.describe(include = 'all') # 통계적으로 한번에 결과를 볼 수 있다.Train columns with null values: PassengerId      0Survived         0Pclass           0Name             0Sex              0Age            177SibSp            0Parch            0Ticket           0Fare             0Cabin          687Embarked         2dtype: int64----------Test/Validation columns with null values: PassengerId      0Pclass           0Name             0Sex              0Age             86SibSp            0Parch            0Ticket           0Fare             1Cabin          327Embarked         0dtype: int64----------정제 시작이제 어떻게 할 지 알았으니 실제로 시작해보자.Developer Documentation:pandas.DataFramepandas.DataFrame.infopandas.DataFrame.describeIndexing and Selecting Datapandas.isnullpandas.DataFrame.sumpandas.DataFrame.modepandas.DataFrame.copypandas.DataFrame.fillnapandas.DataFrame.droppandas.Series.value_countspandas.DataFrame.locComplete (채우기)# 결측치를 지운다.for dataset in data_cleaner:        # age를 중앙값으로 채운다.    dataset['Age'].fillna(dataset['Age'].median(), inplace = True)    # 최빈값으로 대체    dataset['Embarked'].fillna(dataset['Embarked'].mode()[0], inplace = True)    # 중앙값으로 대체    dataset['Fare'].fillna(dataset['Fare'].median(), inplace = True)    # 사용하지 않을 feature를 제거해준다.drop_column = ['PassengerId','Cabin', 'Ticket']data1.drop(drop_column, axis=1, inplace = True)print(data1.isnull().sum())print(\"-\"*10)print(data_val.isnull().sum())Survived    0Pclass      0Name        0Sex         0Age         0SibSp       0Parch       0Fare        0Embarked    0dtype: int64----------PassengerId      0Pclass           0Name             0Sex              0Age              0SibSp            0Parch            0Ticket           0Fare             0Cabin          327Embarked         0dtype: int64Create (생성하기) - feature engineeringfor dataset in data_cleaner:        # Family Size 추가    dataset['FamilySize'] = dataset ['SibSp'] + dataset['Parch'] + 1 # 나까지 추가    dataset['IsAlone'] = 1 # 혼자라고 초기화    dataset['IsAlone'].loc[dataset['FamilySize'] &gt; 1] = 0 # 가족 크기가 1보다 클 경우 혼자가 아님    dataset['Title'] = dataset['Name'].str.split(\", \", expand=True)[1].str.split(\".\", expand=True)[0] # expand가 True이면, 하나의 컬럼을 두개로 나눌 수 있다.    # df[['split_1', 'split_2']] = df['email'].str.split('@', expand=True)    # 실수 값을 범주형으로 바꾼 feature를 추가한다.    dataset['FareBin'] = pd.qcut(dataset['Fare'], 4) # 같은 갯수에 해당하는 범위로 쪼갠다. 리턴은 해당 범주    dataset['AgeBin'] = pd.cut(dataset['Age'].astype(int), 5) # 등간격 5개로 쪼갠다. 리턴은 해당 범주    # cleanup rare title namesprint(data1['Title'].value_counts()) # 만든 title의 개수를 생각해보자.stat_min = 10 # 작다는 것이 임의적이나, 만연하게 사용하는 작은 수는 10이다. http://nicholasjjackson.com/2012/03/08/sample-size-is-10-a-magic-number/title_names = (data1['Title'].value_counts() &lt; stat_min) # 10보다 count가 작은 친구들을 true로 만든다.#apply and lambda functions are quick and dirty code to find and replace with fewer lines of code: https://community.modeanalytics.com/python/tutorial/pandas-groupby-and-python-lambda-functions/data1['Title'] = data1['Title'].apply(lambda x: 'Misc' if title_names.loc[x] == True else x) # 잡다한 것들 Miscprint(data1['Title'].value_counts())print(\"-\"*10)#preview data againdata1.info()data_val.info()data1.sample(10)Mr              517Miss            182Mrs             125Master           40Dr                7Rev               6Col               2Major             2Mlle              2Lady              1Sir               1the Countess      1Jonkheer          1Don               1Capt              1Ms                1Mme               1Name: Title, dtype: int64Mr        517Miss      182Mrs       125Master     40Misc       27Name: Title, dtype: int64----------&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 891 entries, 0 to 890Data columns (total 14 columns):Survived      891 non-null int64Pclass        891 non-null int64Name          891 non-null objectSex           891 non-null objectAge           891 non-null float64SibSp         891 non-null int64Parch         891 non-null int64Fare          891 non-null float64Embarked      891 non-null objectFamilySize    891 non-null int64IsAlone       891 non-null int64Title         891 non-null objectFareBin       891 non-null categoryAgeBin        891 non-null categorydtypes: category(2), float64(2), int64(6), object(4)memory usage: 85.5+ KB&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 418 entries, 0 to 417Data columns (total 16 columns):PassengerId    418 non-null int64Pclass         418 non-null int64Name           418 non-null objectSex            418 non-null objectAge            418 non-null float64SibSp          418 non-null int64Parch          418 non-null int64Ticket         418 non-null objectFare           418 non-null float64Cabin          91 non-null objectEmbarked       418 non-null objectFamilySize     418 non-null int64IsAlone        418 non-null int64Title          418 non-null objectFareBin        418 non-null categoryAgeBin         418 non-null categorydtypes: category(2), float64(2), int64(6), object(6)memory usage: 46.8+ KBContinuous variable bins; qcut vs cutFare Bins/Buckets using qcut or frequency binsAge Bins/Buckets using cut or value binsqcut에서 사용하는 minimum sample sizepandas 문자열 다루기Convert (변환하기) - 수치화수학적 계산을 위해 범주형 데이터를 더미 변수화 한다. 범주형 데이터를 encoding하는 다양한 방법이 있다. sklearn과 pandas 함수를 사용하겠다.이 단계에서 우리는 사용한 독립 변수 x(independent/features/explanatory/predictor/etc.)와 종속 변수 y(dependent/target/outcome/response/etc.)를 정의한다.Developer DocumentationCategorical EncodingSklearn LabelEncoderSklearn OneHotEncoderPandas Categorical dtypepandas.get_dummies# code categorical datalabel = LabelEncoder()for dataset in data_cleaner:        dataset['Sex_Code'] = label.fit_transform(dataset['Sex'])    dataset['Embarked_Code'] = label.fit_transform(dataset['Embarked'])    dataset['Title_Code'] = label.fit_transform(dataset['Title'])    dataset['AgeBin_Code'] = label.fit_transform(dataset['AgeBin'])    dataset['FareBin_Code'] = label.fit_transform(dataset['FareBin'])#define y variable aka target/outcomeTarget = ['Survived']# raw 데이터에서 사용할 변수를 선택한다.data1_x = ['Sex','Pclass', 'Embarked', 'Title','SibSp', 'Parch', 'Age', 'Fare', 'FamilySize', 'IsAlone'] # pretty name/values for chartsdata1_x_calc = ['Sex_Code','Pclass', 'Embarked_Code', 'Title_Code','SibSp', 'Parch', 'Age', 'Fare'] #coded for algorithm calculationdata1_xy =  Target + data1_xprint('Original X Y: ', data1_xy, '\\n')# 숫자로 바꾼 데이터, 구간인 데이터를 숫자로 바꾼다. (양자화)data1_x_bin = ['Sex_Code','Pclass', 'Embarked_Code', 'Title_Code', 'FamilySize', 'AgeBin_Code', 'FareBin_Code']data1_xy_bin = Target + data1_x_binprint('Bin X Y: ', data1_xy_bin, '\\n')# 모델의 입력으로 사용할 dummy data를 만든다.data1_dummy = pd.get_dummies(data1[data1_x])data1_x_dummy = data1_dummy.columns.tolist()data1_xy_dummy = Target + data1_x_dummyprint('Dummy X Y: ', data1_xy_dummy, '\\n')data1_dummy.head()Original X Y:  ['Survived', 'Sex', 'Pclass', 'Embarked', 'Title', 'SibSp', 'Parch', 'Age', 'Fare', 'FamilySize', 'IsAlone'] Bin X Y:  ['Survived', 'Sex_Code', 'Pclass', 'Embarked_Code', 'Title_Code', 'FamilySize', 'AgeBin_Code', 'FareBin_Code'] Dummy X Y:  ['Survived', 'Pclass', 'SibSp', 'Parch', 'Age', 'Fare', 'FamilySize', 'IsAlone', 'Sex_female', 'Sex_male', 'Embarked_C', 'Embarked_Q', 'Embarked_S', 'Title_Master', 'Title_Misc', 'Title_Miss', 'Title_Mr', 'Title_Mrs'] Double Checkprint('Train columns with null values: \\n', data1.isnull().sum())print(\"-\"*10)print (data1.info())print(\"-\"*10)print('Test/Validation columns with null values: \\n', data_val.isnull().sum())print(\"-\"*10)print (data_val.info())print(\"-\"*10)data_raw.describe(include = 'all')Train columns with null values:  Survived         0Pclass           0Name             0Sex              0Age              0SibSp            0Parch            0Fare             0Embarked         0FamilySize       0IsAlone          0Title            0FareBin          0AgeBin           0Sex_Code         0Embarked_Code    0Title_Code       0AgeBin_Code      0FareBin_Code     0dtype: int64----------&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 891 entries, 0 to 890Data columns (total 19 columns):Survived         891 non-null int64Pclass           891 non-null int64Name             891 non-null objectSex              891 non-null objectAge              891 non-null float64SibSp            891 non-null int64Parch            891 non-null int64Fare             891 non-null float64Embarked         891 non-null objectFamilySize       891 non-null int64IsAlone          891 non-null int64Title            891 non-null objectFareBin          891 non-null categoryAgeBin           891 non-null categorySex_Code         891 non-null int64Embarked_Code    891 non-null int64Title_Code       891 non-null int64AgeBin_Code      891 non-null int64FareBin_Code     891 non-null int64dtypes: category(2), float64(2), int64(11), object(4)memory usage: 120.3+ KBNone----------Test/Validation columns with null values:  PassengerId        0Pclass             0Name               0Sex                0Age                0SibSp              0Parch              0Ticket             0Fare               0Cabin            327Embarked           0FamilySize         0IsAlone            0Title              0FareBin            0AgeBin             0Sex_Code           0Embarked_Code      0Title_Code         0AgeBin_Code        0FareBin_Code       0dtype: int64----------&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 418 entries, 0 to 417Data columns (total 21 columns):PassengerId      418 non-null int64Pclass           418 non-null int64Name             418 non-null objectSex              418 non-null objectAge              418 non-null float64SibSp            418 non-null int64Parch            418 non-null int64Ticket           418 non-null objectFare             418 non-null float64Cabin            91 non-null objectEmbarked         418 non-null objectFamilySize       418 non-null int64IsAlone          418 non-null int64Title            418 non-null objectFareBin          418 non-null categoryAgeBin           418 non-null categorySex_Code         418 non-null int64Embarked_Code    418 non-null int64Title_Code       418 non-null int64AgeBin_Code      418 non-null int64FareBin_Code     418 non-null int64dtypes: category(2), float64(2), int64(11), object(6)memory usage: 63.1+ KBNone----------data1과 data_val 모두에 구간 변수가 잘 추가되었다.Training data와 Testing data를 나누자.3.25 Split Training and Testing Data우리가 가진 train데이터를 잘 나누어, 훈련한 모델의 성능을 확인해야 한다. 여기서 우리는 sklearn 함수를 통해 데이터를 75/25로 나눌 것이다. 이 부분은 overfit our model을 방지하기 위해 중요하다. sklearn’s train_test_split function을 사용하여 데이터를 나눌 것이다. 이 단계 이후에는 sklearn’s cross validation functions을 사용하여 훈련된 모델을 비교할 것이다.#split train and test data with function defaults#random_state -&gt; seed or control random number generator: https://www.quora.com/What-is-seed-in-random-number-generation 랜덤 넘버를 주어서 원하는 랜덤을 정의할 수 있다.train1_x, test1_x, train1_y, test1_y = model_selection.train_test_split(data1[data1_x_calc], data1[Target], random_state = 0)train1_x_bin, test1_x_bin, train1_y_bin, test1_y_bin = model_selection.train_test_split(data1[data1_x_bin], data1[Target] , random_state = 0)train1_x_dummy, test1_x_dummy, train1_y_dummy, test1_y_dummy = model_selection.train_test_split(data1_dummy[data1_x_dummy], data1[Target], random_state = 0)print(\"Data1 Shape: {}\".format(data1.shape))print(\"Train1 Shape: {}\".format(train1_x.shape))print(\"Test1 Shape: {}\".format(test1_x.shape))train1_x_bin.head()# train1_x.head()# train1_x_dummy.head()Data1 Shape: (891, 19)Train1 Shape: (668, 8)Test1 Shape: (223, 8)이 부분을 통해서, data1에서 구간으로 나눈 feature에 대해 split하고, dummy화 된 data에 대해서도 이를 수행했다.Referencekaggle Notebookpandas 문자열 다루기",
        
        "url": "/ds/ml/2020/05/05/titanic-05-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%EC%A0%9C.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-04-eb-8d-b0-ec-9d-b4-ed-84-b0-eb-af-b8-eb-a6-ac-eb-b3-b4-ea-b8-b0-html": {
        "title": "04: 데이터 미리보기",
        "tags": "DS, kaggle, ML, titanic",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 데이터를 알아본다.데이터 불러오기, 미리보기# 우리는 데이터를 3단계로 나눠야 한다.# 1. train data# 2. test data(만든 모델을 test)# 3. validation(최종 예측 용)data_raw = pd.read_csv('../input/train.csv')data_val  = pd.read_csv('../input/test.csv')# 기본 데이터는 냅두고, 이걸 복사해서 쓰는 것이 효율적이다.# 여기서 python이 기본적으로 reference로 shellow copy를 한다는 점을 인지하고 deep copy를 해야한다.data1 = data_raw.copy(deep = True)# copy by reference를 한다는 점을 이용하여, 빈번하게 수정할 데이터를 한번에 list로 갖고 있자.data_cleaner = [data1, data_val]#preview dataprint (data_raw.info())#data_raw.head()#data_raw.tail()data_raw.sample(10) # random으로 10개를 뽑아준다.&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 891 entries, 0 to 890Data columns (total 12 columns):PassengerId    891 non-null int64Survived       891 non-null int64Pclass         891 non-null int64Name           891 non-null objectSex            891 non-null objectAge            714 non-null float64SibSp          891 non-null int64Parch          891 non-null int64Ticket         891 non-null objectFare           891 non-null float64Cabin          204 non-null objectEmbarked       889 non-null objectdtypes: float64(2), int64(5), object(5)memory usage: 83.6+ KBNone  Survived 변수는 종속 변수이다. 이진 데이터 타입이다. 다른 변수들은 종속 변수이다. 종속 변수들을 모두 사용한다고 좋은 결과가 나오는 것이 아니다. 올바른 변수를 사용해야 한다.  PassengerID 와 Ticket 변수는 random한 식별자이다. 따라서 사용하더라도 유용하지 않으므로 배제한다.  Pclass는 사회적 지위를 알 수 있는 지표이다. 1 = upper class, 2 = middle class, and 3 = lower class.  Name은 string 데이터이다. 이 변수는 성별, 지위 등을 알 수 있을 수 있다. 하지만 이미 지위 변수가 있기 때문에, Master와 같은 title이 붙었을 때, 유의미한 차이가 있는 지 확인하기 위해서 사용한다.  Sex 와 Embarked 변수는 string 데이터 이다. 이 부분을 사용하기 위해 dummy화를 진행한다.  Age 와 Fare 실수형 데이터이다.  SibSp 는 관련된 형제나 배우자의 수를 나타낸다.(siblings/spouse abroad) Parch 는 관련된 부모와 아이들의 수를 나타낸다. (parents/children aboard) 두 변수는 이산 데이터 타입이다. 이 변수를 가지고 가족의 크기나, 혼자인지를 판명하는 변수를 만들 수 있다.  Cabin string 데이터 이다. 이 변수를 가지고 사고가 일어났을 때, 해당 사람의 배 안에서의 대략적인 위치를 알 수 있다. 하지만 결측치가 많기 때문에 분석에서는 제외한다.            Variable      Definition      Key                  survival      Survival      0 = No, 1 = Yes              pclass      Ticket class      1 = 1st, 2 = 2nd, 3 = 3rd              sex      Sex                     Age      Age in years                     sibsp      # of siblings / spouses aboard the Titanic                     parch      # of parents / children aboard the Titanic                     ticket      Ticket number                     fare      Passenger fare                     cabin      Cabin number                     embarked      Port of Embarkation      C = Cherbourg, Q = Queenstown, S = Southampton      Referencekaggle Notebooksubprocess 모듈에 관하여seaborn 시각화",
        
        "url": "/ds/ml/2020/05/05/titanic-04-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-03-eb-9d-bc-ec-9d-b4-eb-b8-8c-eb-9f-ac-eb-a6-ac-eb-a1-9c-eb-93-9c-html": {
        "title": "03: 라이브러리 로드",
        "tags": "DS, kaggle, ML, titanic",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 라이브러리를 로드한다.데이터 정제제공된 데이터 셋을 사용하기 편하게 정제한다.라이브러리 사용사용하는 라이브러리를 확인한다.기본 라이브러리# It is defined by the kaggle/python docker image: https://github.com/kaggle/docker-python#load packagesimport sys # 시스템 파라미터에 접근할 수 있게 도와준다.print(\"Python version: {}\". format(sys.version))import pandas as pd # 데이터 정제에 도움을 주는 라이브러리print(\"pandas version: {}\". format(pd.__version__))import matplotlib # 매트랩에서 사용하는 시각화 도구를 사용할 수 있게 도와주는 시각화 도구print(\"matplotlib version: {}\". format(matplotlib.__version__))import numpy as np # 행렬 계산을 위해 필요한 라이브러리print(\"NumPy version: {}\". format(np.__version__))import scipy as sp # 수학 관련 함수가 내장된 라이브러리print(\"SciPy version: {}\". format(sp.__version__)) import IPythonfrom IPython import display # 주피터 노트북에서 예쁘게 시각화 해주는 도구print(\"IPython version: {}\". format(IPython.__version__)) import sklearn # 각종 통계 도구와 머신 러닝 알고리즘이 내장되어 있는 라이브러리print(\"scikit-learn version: {}\". format(sklearn.__version__))# 파이썬 내장 라이브러리import randomimport time# Jupyter Notebook 이나 ipython 을 사용하다보면 향후 버전이 올라갈 때 변경될 사항 등을 알려주는 경고 메시지(warning message)를 뜨지 않게 해준다.import warningswarnings.filterwarnings('ignore')print('-'*25)# input data 파일은 \"../input\"에 있다.# 아래 코드를 수행하게 되면, \"../input/\"에서 리눅스 명령어 \"ls\"를 수행한 결과를 보여주게 된다. 이 때 나온 binary code를 \"utf8\"로 디코딩해서 보여준다.from subprocess import check_outputprint(check_output([\"ls\", \"../input\"]).decode(\"utf8\"))# Any results you write to the current directory are saved as output.subprocess 모듈에 대해 궁금하다면 다음의 글을 읽어보자.subprocess 모듈에 관하여데이터 모델링 라이브러리# 일반적인 모델링 라이브러리from sklearn import svm, tree, linear_model, neighbors, naive_bayes, ensemble, discriminant_analysis, gaussian_processfrom xgboost import XGBClassifier# 모델링 시 헬퍼 함수들from sklearn.preprocessing import OneHotEncoder, LabelEncoderfrom sklearn import feature_selectionfrom sklearn import model_selectionfrom sklearn import metrics# 시각화 도구import matplotlib as mplimport matplotlib.pyplot as pltimport matplotlib.pylab as pylabimport seaborn as snsfrom pandas.tools.plotting import scatter_matrix# 시각화 도구 default 세팅%matplotlib inline # 주피터 노트북에서 plot 결과를 볼 수 있게 해준다.mpl.style.use('ggplot') # matplotlib에서 plot되는 결과를 선택할 수 있다.sns.set_style('white') # seaborn에서 사용할 style을 설정할 수 있다.pylab.rcParams['figure.figsize'] = 12,8 # plot의 크기와 선 등의 기본 값을 설정할 수 있다.matplotlib에서 style 바꾸는 법이 부분을 바꾸면 전체적인 그래프의 색등이 바뀐다.print(plt.style.available)['bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-bright', 'seaborn-colorblind', 'seaborn-dark-palette', 'seaborn-dark', 'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook', 'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk', 'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'seaborn', 'Solarize_Light2', 'tableau-colorblind10', '_classic_test']  사용법    plt.style.use(['fivethirtyeight'])      seaborn에서 스타일 바꾸는 법이 부분을 바꾸면 뒤의 배경과 같은 부분을 바꿀 수 있다.darkgrid, whitegrid, dark, white, 그리고 ticks 스타일을 제공한다.  사용법sns.set_style('darkgrid')seaborn 시각화Referencekaggle Notebooksubprocess 모듈에 관하여seaborn 시각화",
        
        "url": "/ds/ml/2020/05/05/titanic-03-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%A1%9C%EB%93%9C.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-02-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-88-98-ec-a7-91-html": {
        "title": "02: 데이터 수집",
        "tags": "DS, kaggle, ML, titanic",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 데이터를 수집한다.데이터 수집Titanic: Machine Learning from Disaster이 부분은 kaggle에 있는 데이터 셋을 사용할 것이므로 생략 한다.Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-02-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-01-eb-ac-b8-ec-a0-9c-ec-a0-95-ec-9d-98-html": {
        "title": "01: 문제 정의",
        "tags": "DS, kaggle, ML, titanic",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제를 정의한다.문제 정의  타이타닉에 승선한 객원들 중 생존/사망 여부를 예측한다.프로젝트 요약타이타닉 침몰은 역사상 가장 악명 높은 난파선 중 하나이다. 1912 년 4 월 15 일, 첫 여행 중에 타이타닉은 빙산과 충돌하여 침몰하여 2224 명의 승객과 승무원 중 1502 명이 사망했다.인명 손실이 발생한 이유 중 하나는 승객과 승무원을 위한 구명 보트가 충분하지 않았기 때문이다. 일부 그룹의 사람들은 여성, 어린이 및 상류층과 같은 다른 그룹보다 생존 할 가능성이 더 컸다.어떤 종류의 사람들이 살아남을 가능성에 대한 분석을 수행한다. 특히 기계 학습 도구를 적용하여 어떤 승객이 비극에서 살아남 았는지 예측하는 것이 목표이다.Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-01-%EB%AC%B8%EC%A0%9C%EC%A0%95%EC%9D%98.html"
      }
      ,
    
      "ds-visualization-2020-05-04-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-04-bubble-plot-html": {
        "title": "04: Circling을 통한 버블 플롯",
        "tags": "DS, python, matplotlib, scatter plot, bubble plot",
        "date": "May 4, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "산점도 그래프의 응용인 버블 플롯을 그려보자.연습 kaggle notebook  산점도에서 추가적으로 내가 원하는 그룹에 대해 원으로 그룹을 지어, 크기를 알 수 있다.원래 bubble plot은 특정 집단의 boundary를 측정하는데 용이하다. 여기서는 산점도에서 추가적으로 circling을 통하여 그 boundary를 측정하는 방법을 사용해본다. 알고리즘으로는 컨벡스 헐을 사용한다.기본적인 bubble plot# Useful for:# Visualize the relationship between data.# More info: # https://en.wikipedia.org/wiki/Scatter_plot# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/midwest_filter.csv' df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (12, 6))ax = fig.add_subplot(1,1,1,)# ----------------------------------------------------------------------------------------------------# 각 그룹마다 다르게 묶은 뒤, 연속해서 plot한다. 이럴 경우 각 포인트가 그룹마다 다른 색으로 칠해진다.for cat in sorted(list(df[\"category\"].unique())):    # filter x and the y for each category    ar = df[df[\"category\"] == cat][\"area\"]    pop = df[df[\"category\"] == cat][\"poptotal\"]        # plot the data    ax.scatter(ar, pop, label = cat, s = 10)    # ----------------------------------------------------------------------------------------------------# prettify the plot# 맨 위 줄과 오른쪽 줄을 없애서 보기 편하게ax.spines[\"top\"].set_color(\"None\") ax.spines[\"right\"].set_color(\"None\")# set a specific label for each axisax.set_xlabel(\"Area\") ax.set_ylabel(\"Population\")# change the lower limit of the plot, this will allow us to see the legend on the leftax.set_xlim(-0.01) ax.set_title(\"Scatter plot of population vs area.\")ax.legend(loc = \"upper left\", fontsize = 10)추가적인 bubble plot# Useful for:# Visualize the relationship between data but also helps us encircle a specific group we might want to draw the attention to.# More info: # https://en.wikipedia.org/wiki/Scatter_plot# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/midwest_filter.csv' df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (12, 6))ax = fig.add_subplot(1,1,1,)# ----------------------------------------------------------------------------------------------------# prepare the data for plottingsize_total = df[\"poptotal\"].sum()# we want every group to have a different markermarkers = [\".\", \",\", \"o\", \"v\", \"^\", \"&lt;\", \"&gt;\", \"1\", \"2\", \"3\", \"4\", \"8\", \"s\", \"p\", \"P\", \"*\", \"h\", \"H\", \"+\", \"x\", \"X\", \"D\", \"d\"] # ----------------------------------------------------------------------------------------------------# create an encircle# based on this solution# https://stackoverflow.com/questions/44575681/how-do-i-encircle-different-data-sets-in-scatter-plotdef encircle(x,y, ax = None, **kw):    '''    Takes an axes and the x and y and draws a polygon on the axes.    This code separates the differents clusters    '''    # get the axis if not passed    if not ax: ax=plt.gca()        # concatenate the x and y arrays    p = np.c_[x,y]        # to calculate the limits of the polygon    hull = ConvexHull(p)        # create a polygon from the hull vertices    poly = plt.Polygon(p[hull.vertices,:], **kw)        # add the patch to the axes    ax.add_patch(poly) # 내가 그린 그림을 위에 덧칠하게 해줌# ----------------------------------------------------------------------------------------------------# iterate over each category and plot the data. This way, every group has it's own color and marker.# on the iteration we will calculate our hull/polygon for each group and connect specific groupsfor cat, marker in zip(sorted(list(df[\"category\"].unique())), markers):  # 이런 스킬이 굉장히 중요해 보임    # filter x and the y for each category    ar = df[df[\"category\"] == cat][\"area\"]    pop = df[df[\"category\"] == cat][\"poptotal\"]        # this will allow us to set a specific size for each group.    # 해당 population 값에 따라 marker의 크기를 다르게 해주기 위함    size = pop/size_total        # plot the data    ax.scatter(ar, pop, label = cat, s = size*10000, marker = marker)        try:        # try to add a patch        encircle(ar, pop, ec = \"k\", alpha=0.1)    except:        # if we don't have enough poins to encircle just pass        pass# ----------------------------------------------------------------------------------------------------# prettify the plot# eliminate 2/4 spines (lines that make the box/axes) to make it more pleasantax.spines[\"top\"].set_color(\"None\")ax.spines[\"right\"].set_color(\"None\")# set a specific label for each axisax.set_xlabel(\"Area\")ax.set_ylabel(\"Population\")# change the lower limit of the plot, this will allow us to see the legend on the leftax.set_xlim(-0.01) ax.set_title(\"Bubble plot with encircling\")ax.legend(loc = \"upper left\", fontsize = 10);ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/04/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-04-bubble-plot.html"
      }
      ,
    
      "ds-visualization-2020-05-04-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-03-ec-82-b0-ec-a0-90-eb-8f-84-html": {
        "title": "03: 산점도",
        "tags": "DS, python, matplotlib",
        "date": "May 4, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "산점도 그래프를 그려보자.연습 kaggle notebook  두 데이터의 관계를 알아볼 때 용이!산점도는 실제 데이터를 2차원 평면에 plot함으로써 대략적인 분포를 파악할 수 있다.# Useful for:# Visualize the relationship between data.# More info: # https://en.wikipedia.org/wiki/Scatter_plot# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/midwest_filter.csv' df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (12, 6))ax = fig.add_subplot(1,1,1,)# ----------------------------------------------------------------------------------------------------# 각 그룹마다 다르게 묶은 뒤, 연속해서 plot한다. 이럴 경우 각 포인트가 그룹마다 다른 색으로 칠해진다.for cat in sorted(list(df[\"category\"].unique())):    # filter x and the y for each category    ar = df[df[\"category\"] == cat][\"area\"]    pop = df[df[\"category\"] == cat][\"poptotal\"]        # plot the data    ax.scatter(ar, pop, label = cat, s = 10)    # ----------------------------------------------------------------------------------------------------# prettify the plot# 맨 위 줄과 오른쪽 줄을 없애서 보기 편하게ax.spines[\"top\"].set_color(\"None\") ax.spines[\"right\"].set_color(\"None\")# set a specific label for each axisax.set_xlabel(\"Area\") ax.set_ylabel(\"Population\")# change the lower limit of the plot, this will allow us to see the legend on the leftax.set_xlim(-0.01) ax.set_title(\"Scatter plot of population vs area.\")ax.legend(loc = \"upper left\", fontsize = 10)ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/04/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-03-%EC%82%B0%EC%A0%90%EB%8F%84.html"
      }
      ,
    
      "ds-visualization-2020-05-04-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-02-matplotlib-ec-95-8c-ec-95-84-eb-b3-b4-ea-b8-b0-html": {
        "title": "02: matplotlib 알아보기",
        "tags": "DS, python, matplotlib",
        "date": "May 4, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "matplotlib의 기본적인 기능을 알아본다.Figure, axes, subplots  기본 플롯은 Figure와 axes로 시작한다.사실 그리는 방법은 여러가지가 있으나, 한가지 방법을 고수하는 것이 좋다. 이 글 에서는 OOP접근 방법에 기반하여 설명하도록 한다.Basic Way# figure 객체 생성fig = plt.figure()# subplot을 등록해준다. 1개만 그릴 경우 필요없지만,# 명백하게 적어주는 습관을 들이는 것이 좋다.ax1 = fig.add_subplot(1, 1, 1)# some datax = [1, 2, 3, 4, 5]y = [3, 2, 1, 4, 5]# plot basic thingsax1.plot(x, y);아래의 방법도 위와 같은 결과를 가져온다.# the same plot can be achieved doing this wayfig = plt.figure()ax1 = fig.subplots()ax1.plot(x, y);# you can even simplify it more by just doing thisplt.plot(x, y);간단하게 수행할 수 있지만, 명백한 방법을 일관되게 사용하는 것이 더 좋다. 이 방법 외에도 같은 결과를 만들 수 있는 다양한 코드가 존재한다. 이 부분에 대한 의문이 들었다면, matplotlib의 구조에 대해서 이해할 필요가 있다.matplotlib의 구조  Backend Layer          가장 낮은 단계      %matplotlib inline 을 사용하면, plt.show()를 호출 할 필요없이 모든 것을 렌더링하도록 백엔드에 지시한다.        Artist Layer          이 레이어는 스파인, 축, 색상 등을 변경할 수 있는 가능성을 제공한다.      ax1.plot()을 호출 할 때 이 계층에 액세스한다. 앞으로 이 단계에서 많은 기능을 수행할 것이다.        Script Layer          빠른 플롯에 매우 편리하다.      plt.plot()과 같이 사용할 때 사용합니다. 여전히 강력하지만 2 레이어만큼 강력하지 않다.      Script Layer에서 call 했을 떄 실제 동작            script Layer      actual calling Code      Details                  plt.subplot()      fig = plt.figure()  fig.add_subplot()      figure를 생성하고 1개의 subplot을 fig에 추가한다.              plt.subplots()      fig = plt.figure() fig.subplots(n, m)      fig.subplots(n,m) 의 반환값은 (n,m)크기의 axes객체가 들어간 튜플이다. 따라서 plt.subplots()를 수행하면 fig와 axes 튜플 객체가 반환된다.        fig, ax1 = plt.subplots() 이런식으로 받아주어야 한다.      Multiple plotsfig.subplots() 사용fig = plt.figure()# create a 4 plots and use tuple unpacking to name everyplot# subplots() 라는 함수로 한번에 axes를 설정할 수 있다.(ax1, ax2), (ax3, ax4) = fig.subplots(2,2)ax1.plot([1,2,3], color = \"red\")ax2.plot([3,2,1], color = \"blue\")ax3.plot([4,4,4], color = \"orange\")ax4.plot([5,4,5], color = \"black\")plt.tight_layout()plt.subplots() 사용# you can do the same using a for loopnrows = 2ncolumns = 2fig, axes = plt.subplots(nrows, ncolumns)    # return값이 2개이다.# axes is just a tuple as we saw before# since se specified for row in range(nrows):    for column in range(ncolumns):        ax = axes[row, column]        ax.plot(np.arange(10))axis 안에 plot하기fig = plt.figure(figsize = (20, 10))# create a 4 plots and use tuple unpacking to name everyplot(ax1, ax2), (ax3, ax4) = fig.subplots(2,2)ax1.plot([1,2,3], color = \"red\")ax2.plot([3,2,1], color = \"blue\")ax3.plot([4,4,4], color = \"orange\")ax3_bis = fig.add_axes([0.15, 0.15, 0.15, 0.15])ax3_bis.plot([1,2,1], color = \"pink\") # you add it to the figure!ax3_bis.annotate(\"Small annotation inside a small added axes\",                xy = (0.5, 0.5),                xycoords = \"axes fraction\",                va = \"center\",                ha = \"center\")ax4.plot([5,4,5], color = \"black\")ax4.annotate(\"Just to demonstrate the power of matplotlib\",              xy = (0.5, 0.5), # fraction of the ax4. In the center.             xycoords = \"axes fraction\", # you can also specify data and pass the values of the x and y axis.             va = \"center\",             ha = \"center\")plt.tight_layout()grid를 사용하여 예쁜 plot하기gs를 사용하면, 행렬 처럼 슬라이싱을 하여 내가 원하는 곳에 그래프를 넣을 수 있다.fig = plt.figure(figsize = (10, 5))gs = fig.add_gridspec(3, 3)ax1 = fig.add_subplot(gs[0, :])ax1.plot([1,2,1,2])ax1.set_title(\"Random text\")ax2 = fig.add_subplot(gs[1,0])ax2.plot(1,3,1)ax3 = fig.add_subplot(gs[1,1])ax3.plot(3,1,3)ax4 = fig.add_subplot(gs[2,:-1])ax4.scatter([1,2,3], [1,2,3])ax5 = fig.add_subplot(gs[1:, -1])ax5.bar([1,2,3], [1,2,3])ax5_bis = fig.add_axes([0.75, 0.5, 0.1, 0.1])ax5_bis.plot([3,1,2])plt.tight_layout()referencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/04/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-02-matplotlib-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0.html"
      }
      ,
    
      "ds-visualization-2020-05-04-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-01-eb-9d-bc-ec-9d-b4-eb-b8-8c-eb-9f-ac-eb-a6-ac-html": {
        "title": "01: 라이브러리",
        "tags": "DS, python, library",
        "date": "May 4, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "시각화를 하는데 필요한 다양한 라이브러리에 대해서 알아본다.joypy  feature에 대한 특징을 밀도 기반으로 깔끔하게 볼 수 있다.Documentationpywaffle  분포에 대한 것을 네모 박스로 처리하여 깔끔하게 볼 수 있다.calmap  히트맵으로 표현해 준다.Documentationpandas  데이터 조작 및 분석을 위해 Python 프로그래밍 언어로 작성된 소프트웨어 라이브러리Documentationmatplotlib  파이썬에서 매트랩과 유사한 그래프를 그릴 수 있게 도와주는 라이브러리Documentationimport joypyfrom pywaffle import Waffleimport calmapimport pandas as pdimport matplotlib.pyplot as pltimport osimport numpy as npfrom scipy.spatial import ConvexHull # 볼록 다각형을 시각화해야할 때가 있다.",
        
        "url": "/ds/visualization/2020/05/04/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-01-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC.html"
      }
      ,
    
      "cs-database-2020-04-25-where-having-ec-b0-a8-ec-9d-b4-html": {
        "title": "where와 having의 차이",
        "tags": "database, SQL, having, where",
        "date": "April 25, 2020",
        "author": "",
        "category": "CS/Database",
        "content": "sql에서 조건문을 담당하는 쿼리인 having과 where의 차이를 알아본다.Where  select * from 테이블명 where 조건절위와 같은 방법으로 where 조건절을 사용한다. 항상 from뒤에 위치하고 조건에는 다양한 비교연산자들이 사용되어 구체적인 조건을 줄 수 있다.having  select * from 테이블명 group by 필드명 having 조건절  위와 같은 방법으로 having 조건절을 사용한다. 항상 group by뒤에 위치하고 where 조건절과 마찬가지로 조건에는 다양한 비교연산자들이 사용되어 구체적인 조건을 줄 수 있다.차이점where은 기본적인 조건절로서 우선적으로 모든 필드를 조건에 둘 수 있다.하지만 having은 group by 된 이후 특정한 필드로 그룹화 되어진 새로운 테이블에 조건을 줄 수 있다.즉, 전체 테이블 자체에서 쿼리를 수행하고 싶다면 where를, 전체 테이블을 그룹화 한뒤, 그 해당 그룹에서 어떠한 조건을 걸어 가져오고 싶다면 having을 사용한다.예제group by - having 문제위의 문제에서 답은 다음과 같이 나올 수 있다.SELECT NAME, COUNT(NAME) AS \"Count\" FROM ANIMAL_INS    GROUP BY NAME    HAVING COUNT(NAME) &gt; 1;현재 문제는, 내가 갖고 있는 table을 name이라는 키워드로 분리한 다음, 그 분리한 각각의 set의 크기가 1보다 클 경우에 대해 쿼리를 수행해야 한다. 코드를 잘 읽어보면 이해할 수 있다.",
        
        "url": "/cs/database/2020/04/25/where-having-%EC%B0%A8%EC%9D%B4.html"
      }
      ,
    
      "cs-algorithm-2020-04-25-eb-b0-b1-ec-a4-80-ed-86-b1-eb-8b-88-eb-b0-94-ed-80-b4-html": {
        "title": "백준(14891번): 톱니바퀴",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현",
        "date": "April 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 구현 문제이다.백준(14891번) - 톱니바퀴생각단순 구현 문제이다. 비트마스크 연습을 위해 비트마스크로 풀었다. 해당 과정을 하는 동안에 인접행렬 같은 matrix를 만들어 무언가를 해보려 했지만 좋지 못했다. 구현 문제는 노가다로 적어주는게 정신 건강에 이롭다.Sudo-algorithm  입력을 받는다.  어떤 톱니바퀴를 돌리는 지 판단한다.  그 톱니바퀴를 돌렸을 때, 따라서 돌아가는 톱니바퀴의 방향을 정한다.  그 구한 톱니 바퀴의 방향대로 돌린다.  마지막에 답을 구한다.특정 톱니바퀴를 돌렸을 때, 따라서 돌아가는 것의 숫자를 0이면 돌아가지 않는다. 1이면 시계방향, -1이면 반시계방향으로 정하여 구해주었다.vector&lt;int&gt; getAction(int gear, int dir){    vector&lt;int&gt; action(5);    if (gear == 1) {        action[1] = dir;        if (isRevolve(1, 2)) action[2] = -action[1];        if (isRevolve(2, 3)) action[3] = -action[2];        if (isRevolve(3, 4)) action[4] = -action[3];    } else if (gear == 2) {        action[2] = dir;        if (isRevolve(1, 2)) action[1] = -action[2];        if (isRevolve(2, 3)) action[3] = -action[2];        if (isRevolve(3, 4)) action[4] = -action[3];    } else if (gear == 3) {        action[3] = dir;        if (isRevolve(2, 3)) action[2] = -action[3];        if (isRevolve(3, 4)) action[4] = -action[3];        if (isRevolve(1, 2)) action[1] = -action[2];    } else {        action[4] = dir;        if (isRevolve(3, 4)) action[3] = -action[4];        if (isRevolve(2, 3)) action[2] = -action[3];        if (isRevolve(1, 2)) action[1] = -action[2];    }    return action;}특정 톱니 바퀴가 돌아갈 때, 이전 상태가 돌아갈 수 있는 상태라면, 인접한 톱니바퀴의 방향은 무조건 반대 방향인 것을 사용했다. 또한 이전 상태의 양극이 반대라 특정 톱니 바퀴가 돌아가게 되면 인접한 톱니바퀴 역시 돌아갈 수 있음에도 불구하고 특정 톱니가 돌아가지 않으면 0을 리턴하므로 인접 톱니도 돌아가지 않는다.참, 비트가 켜져있는지 아닌지 구분할 때에는 꼭 괄호를 써서 생각하자.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;int state[5];int N, ans = 0;bool isRevolve(int i, int j){    if ((state[i] &amp; 32 &amp;&amp; state[j] &amp; 2) || ((state[i] &amp; 32) == 0 &amp;&amp; (state[j] &amp; 2) == 0)) {        return false;    }    else return true;}void rotate(int gearNum, int way){    if (way == 0) return;    else if (way == 1) {        int flag = state[gearNum] &amp; 1;        state[gearNum] = state[gearNum] &gt;&gt; 1;        if (flag) state[gearNum] |= 128;    } else {        int flag = state[gearNum] &amp; 128;        state[gearNum] = state[gearNum] &lt;&lt; 1;        state[gearNum] &amp;= ~256;        if (flag) state[gearNum] |= 1;    }}void getScore(){    for (int i = 1; i &lt;= 4; i++) {        if (state[i] &amp; 128) ans += int(pow(2, i-1));    }}vector&lt;int&gt; getAction(int gear, int dir){    vector&lt;int&gt; action(5);    if (gear == 1) {        action[1] = dir;        if (isRevolve(1, 2)) action[2] = -action[1];        if (isRevolve(2, 3)) action[3] = -action[2];        if (isRevolve(3, 4)) action[4] = -action[3];    } else if (gear == 2) {        action[2] = dir;        if (isRevolve(1, 2)) action[1] = -action[2];        if (isRevolve(2, 3)) action[3] = -action[2];        if (isRevolve(3, 4)) action[4] = -action[3];    } else if (gear == 3) {        action[3] = dir;        if (isRevolve(2, 3)) action[2] = -action[3];        if (isRevolve(3, 4)) action[4] = -action[3];        if (isRevolve(1, 2)) action[1] = -action[2];    } else {        action[4] = dir;        if (isRevolve(3, 4)) action[3] = -action[4];        if (isRevolve(2, 3)) action[2] = -action[3];        if (isRevolve(1, 2)) action[1] = -action[2];    }    return action;}void solve(int gear, int dir){    vector&lt;int&gt; action = getAction(gear, dir);    for (int i = 1; i &lt;= 4; i++) rotate(i, action[i]);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    for (int i = 1; i &lt;= 4; i++) {        string s;        cin &gt;&gt; s;        for (int j = 7; j &gt;= 0; j--) {            int mul = int(pow(2, 7-j));            int num = s[j]-'0';            state[i] += num*mul;        }    }    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        int gear, dir;        cin &gt;&gt; gear &gt;&gt; dir;        solve(gear, dir);    }    getScore();    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/25/%EB%B0%B1%EC%A4%80-%ED%86%B1%EB%8B%88%EB%B0%94%ED%80%B4.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-a4-91-ec-84-b1-ed-99-94-ec-97-ac-eb-b6-80-ed-8c-90-eb-8b-a8-ed-95-98-ea-b8-b0-html": {
        "title": "프로그래머스: 중성화 여부 판단하기",
        "tags": "프로그래머스, sql, 검색, case when",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : case when을 사용하는 문제이다.프로그래머스 - 중성화 여부 판단하기생각쿼리로 가져온 table에 대해서 추출을 진행할 때, 사용할 수 있는 테크닉이다. 이건 예제로 보는 것이 정확하다.CodeSELECT ANIMAL_ID, NAME,        CASE WHEN            (SEX_UPON_INTAKE LIKE \"Neutered%\" OR SEX_UPON_INTAKE LIKE \"Spayed%\") THEN \"O\"            ELSE \"X\"        END AS \"중성화\"    FROM ANIMAL_INS    ORDER BY ANIMAL_ID;",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A4%91%EC%84%B1%ED%99%94-%EC%97%AC%EB%B6%80-%ED%8C%90%EB%8B%A8%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-9e-85-ec-96-91-ec-8b-9c-ea-b0-81-ea-b5-ac-ed-95-98-ea-b8-b0-2-html": {
        "title": "프로그래머스: 입양 시각 구하기 2",
        "tags": "프로그래머스, sql",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level4 : 변수를 사용하는 문제이다.프로그래머스 - 입양 시각 구하기 2생각이 문제는 group by를 사용할 수 없다는 것이 핵심이다. group by 는 있는 값을 DISTINCT하게 판단하여 집합을 구성해주는 쿼리이다. 그런데 이 문제는 0~23의 범위에서의 count를 구하기 때문에 사용할 수가 없다.해결이 문제를 해결하기 위해서는 임의로 0에서 23까지의 범위를 만들고, 그 숫자에 따르는 개수를 파악하여 넣는 것이 효율적으로 보인다. 이런 방법을 sub Query라 부른다. 변수 선언 방법은 SET으로 한다.CodeSET @hour = -1;SELECT @hour := @hour + 1 AS \"HOUR\", (        SELECT COUNT(ANIMAL_ID) FROM ANIMAL_OUTS        WHERE @hour = HOUR(DATETIME)    ) AS \"COUNT\"    FROM ANIMAL_OUTS    WHERE @hour &lt; 23",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9E%85%EC%96%91%EC%8B%9C%EA%B0%81-%EA%B5%AC%ED%95%98%EA%B8%B0-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-9a-b0-ec-9c-a0-ec-99-80-ec-9a-94-ea-b1-b0-ed-8a-b8-ea-b0-80-eb-8b-b4-ea-b8-b4-ec-9e-a5-eb-b0-94-ea-b5-ac-eb-8b-88-html": {
        "title": "프로그래머스: 우유와 요거트가 담긴 장바구니",
        "tags": "프로그래머스, sql, table 분리",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level4 : table을 분리하는 방법을 사용해보자.프로그래머스 - 우유와 요거트가 담긴 장바구니생각문제가 잘 안풀리면, 제공해주는 table을 분리하고, 그 분리한 table로 부터 원하는 결과를 도출해보자. 즉 sub query를 사용해서 임의로 table을 만드는 것.CodeSELECT A.CART_ID FROM    (SELECT CART_ID FROM CART_PRODUCTS WHERE NAME = \"우유\") A    INNER JOIN # 둘다 있는것만 가져옴    (SELECT CART_ID FROM CART_PRODUCTS WHERE NAME = \"요거트\") B    ON A.CART_ID = B.CART_ID",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9A%B0%EC%9C%A0%EC%99%80-%EC%9A%94%EA%B1%B0%ED%8A%B8%EA%B0%80-%EB%8B%B4%EA%B8%B4-%EC%9E%A5%EB%B0%94%EA%B5%AC%EB%8B%88.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-98-a4-eb-9e-9c-ec-8b-9c-ea-b0-84-eb-b3-b4-ed-98-b8-ed-95-9c-eb-8f-99-eb-ac-bc-html": {
        "title": "프로그래머스: 오랜 기간 보호한 동물",
        "tags": "프로그래머스, sql, join",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level3 : join을 사용하는 문제이다.프로그래머스 - 오랜 기간 보호한 동물생각이 문제를 풀기 위해서는, join이라는 쿼리가 어떻게 돌아가는 지 알아야 한다. right join, left join등 다양한 join의 방법이 있지만, 일단 기본적으로 join을 하면 그냥 합쳐진다. 그것이 핵심이다.Join두 table을 합친다고 하면 어떻게 합칠 수 있을까? A의 table의 column과 B table의 column은 서로 다른 것으로 보아야 한다. 아니 애초에 왜 합칠까? 이것은 당연히 두 table의 어떠한 관계가 있기 때문이다. 엮을 수 있기 때문이다. 그렇다면 당연히 합친다는 행위에는 무엇을 기준으로 두 행을 합칠 것인가? 라는 질문이 들어야 한다. 이 값을 key라 한다.집합과 같은 개념으로 보면 오히려 조금 헷갈릴 수 있다. 차라리 join은 두 table을 말 그래도 합치는 것이고 column도 늘어난다. 다만 어떤 행을 서로 엮어줄 지에 대한 정보가 필요할 뿐.그렇게 생각하면 이 문제는 상당히 쉽다.풀이  보호소에 있는 테이블(in)을 A, 입양을 간 테이블(out)을 B라 하자.  현재 보호소에 있고 입양을 가진 않은 행을 골라야 한다.  그러기 위해서는 합치는 데 있어서 A를 기준으로 합쳐야 골라낼 수 있다.  그 다음 만들어지는 table에 있어서 B에는 없는 A행을 고른 후,  그 행에서 시간을 기준으로 오름차순으로 정렬한다.  그 중 3개를 뺀다.CodeSELECT A.NAME, A.DATETIME    FROM (ANIMAL_INS A LEFT JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID)    WHERE B.ANIMAL_ID is NULL    ORDER BY A.DATETIME ASC  # 가장 초기에 있던 녀석이 가장 오래있었음    LIMIT 3",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%A4%EB%9E%9C%EC%8B%9C%EA%B0%84-%EB%B3%B4%ED%98%B8%ED%95%9C-%EB%8F%99%EB%AC%BC.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-98-a4-eb-9e-9c-ea-b8-b0-ea-b0-84-eb-b3-b4-ed-98-b8-ed-95-9c-eb-8f-99-eb-ac-bc-2-html": {
        "title": "프로그래머스: 오랜 기간 보호한 동물 2",
        "tags": "프로그래머스, sql, limit",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : limit을 사용하는 문제이다.프로그래머스 - 오랜 기간 보호한 동물 2생각가져온 table에 대해 제한을 걸어, 그 만큼의 행만 가져오게 하는 문제이다.CodeSELECT A.ANIMAL_ID, A.NAME    FROM (ANIMAL_INS A RIGHT JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID)        WHERE B.ANIMAL_ID is NOT NULL # 전처리 : 입양만 보낸 동물은 있을 수 없다.    ORDER BY (B.DATETIME - A.DATETIME) DESC    LIMIT 2;",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%A4%EB%9E%9C-%EA%B8%B0%EA%B0%84-%EB%B3%B4%ED%98%B8%ED%95%9C-%EB%8F%99%EB%AC%BC-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-97-86-ec-96-b4-ec-a7-84-ea-b8-b0-eb-a1-9d-ec-b0-be-ea-b8-b0-html": {
        "title": "프로그래머스: 없어진 기록 찾기",
        "tags": "프로그래머스, sql, join",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level3 : join을 사용하는 문제이다.프로그래머스 - 없어진 기록 찾기생각이 문제를 풀기 위해서는, join이라는 쿼리가 어떻게 돌아가는 지 알아야 한다. right join, left join등 다양한 join의 방법이 있지만, 일단 기본적으로 join을 하면 그냥 합쳐진다. 그것이 핵심이다.Join두 table을 합친다고 하면 어떻게 합칠 수 있을까? A의 table의 column과 B table의 column은 서로 다른 것으로 보아야 한다. 아니 애초에 왜 합칠까? 이것은 당연히 두 table의 어떠한 관계가 있기 때문이다. 엮을 수 있기 때문이다. 그렇다면 당연히 합친다는 행위에는 무엇을 기준으로 두 행을 합칠 것인가? 라는 질문이 들어야 한다. 이 값을 key라 한다.집합과 같은 개념으로 보면 오히려 조금 헷갈릴 수 있다. 차라리 join은 두 table을 말 그래도 합치는 것이고 column도 늘어난다. 다만 어떤 행을 서로 엮어줄 지에 대한 정보가 필요할 뿐.그렇게 생각하면 이 문제는 상당히 쉽다.풀이  입양을 보낸 테이블(out)을 B, 입양이 온 테이블(in)을 A라 하자.  만약 입양을 보낸 행위가 발생하면, ANIMAL_ID은 두 테이블에 항상이 있어야 한다.  하지만 현재 B의 ANIMAL_ID만 존재하고 A는 공란이 발생한 상황이다.  따라서 ANIMAL_ID만 생각해보면 B가 더 큰 집합이다.  그렇다면 A를 B와 합쳐버리면, 우리가 얻을 수 있는 것은 보낸 것과 온 것을 하나의 Table로 조사할 수 있다.  그 중에서 B에는 ANIMAL_ID가 있지만 A에는 없다면 그 것이 문제가 발생한 행이다.  즉, 합쳤을 때, ANIMAL_ID가 B에는 존재하지만 A에는 존재하지 않는 B의 ANIMAL_ID가 답이다.CodeSELECT B.ANIMAL_ID, B.NAME    FROM (ANIMAL_INS A RIGHT JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID)    WHERE A.ANIMAL_ID IS NULL    ORDER BY B.ANIMAL_ID",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%97%86%EC%96%B4%EC%A7%84-%EA%B8%B0%EB%A1%9D-%EC%B0%BE%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-eb-b3-b4-ed-98-b8-ec-86-8c-ec-97-90-ec-84-9c-ec-a4-91-ec-84-b1-ed-99-94-ed-95-9c-eb-8f-99-eb-ac-bc-html": {
        "title": "프로그래머스: 보호소에서 중성화한 동물",
        "tags": "프로그래머스, sql, join, 검색",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level3 : join을 사용하는 문제이다.프로그래머스 - 보호소에서 중성화한 동물생각이 문제를 풀기 위해서는, join이라는 쿼리가 어떻게 돌아가는 지 알아야 한다. right join, left join등 다양한 join의 방법이 있지만, 일단 기본적으로 join을 하면 그냥 합쳐진다. 그것이 핵심이다.Join두 table을 합친다고 하면 어떻게 합칠 수 있을까? A의 table의 column과 B table의 column은 서로 다른 것으로 보아야 한다. 아니 애초에 왜 합칠까? 이것은 당연히 두 table의 어떠한 관계가 있기 때문이다. 엮을 수 있기 때문이다. 그렇다면 당연히 합친다는 행위에는 무엇을 기준으로 두 행을 합칠 것인가? 라는 질문이 들어야 한다. 이 값을 key라 한다.집합과 같은 개념으로 보면 오히려 조금 헷갈릴 수 있다. 차라리 join은 두 table을 말 그래도 합치는 것이고 column도 늘어난다. 다만 어떤 행을 서로 엮어줄 지에 대한 정보가 필요할 뿐.그렇게 생각하면 이 문제는 상당히 쉽다.검색  SELECT id,name FROM member WHERE name LIKE ‘김%’  김으로 시작하는 사람을 모두 조회  SELECT id,name FROM member WHERE name LIKE ‘%김’  김으로 끝나는 사람을 모두 조회  SELECT id,p_name FROM member WHERE p_name LIKE ‘%프린터%’  ‘프린터’ 가 들어가는 제품을 모두 조회  SELECT id,name FROM member WHERE name LIKE ‘김?’  ‘김’ + 외자인 사람을 모두 조회CodeSELECT A.ANIMAL_ID, A.ANIMAL_TYPE, A.NAME    FROM ANIMAL_INS A INNER JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID    WHERE A.SEX_UPON_INTAKE LIKE \"Intact%\"        AND (B.SEX_UPON_OUTCOME LIKE \"Spayed%\" OR B.SEX_UPON_OUTCOME LIKE \"Neutered%\")    ORDER BY A.ANIMAL_ID ASC;",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%B3%B4%ED%98%B8%EC%86%8C%EC%97%90%EC%84%9C-%EC%A4%91%EC%84%B1%ED%99%94%ED%95%9C-%EB%8F%99%EB%AC%BC.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-datetime-ec-97-90-ec-84-9c-date-eb-a1-9c-ed-98-95-eb-b3-80-ed-99-98-html": {
        "title": "프로그래머스: DATETIME에서 DATE로 형 변환",
        "tags": "프로그래머스, sql, date-format",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : 제곧내 이다.프로그래머스 - DATETIME에서 DATE로 형 변환생각간단하다. 예시를 보고 외우던가 나중에 찾아보자.CodeSELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, \"%Y-%m-%d\") AS \"날짜\"    FROM ANIMAL_INS;",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-DATETIME%EC%97%90%EC%84%9C-DATE%EB%A1%9C-%ED%98%95-%EB%B3%80%ED%99%98.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-eb-b0-b1-ec-a4-80-ec-88-ab-ec-9e-90-ec-b9-b4-eb-93-9c-2-html": {
        "title": "백준(10816번): 숫자카드 2",
        "tags": "백준, 알고리즘, 이분 탐색, lowerBound, upperbound",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버4 : 이분 탐색 문제이다.백준(10816번) - 숫자카드 2생각특정 숫자가 등장하는 lowerBound와 UpperBound를 잡아내면 끝나는 문제이다.LowerBound  원하는 숫자가 처음으로 등장하는 곳의 번째기본적인 이분 탐색은, 내가 탐색한 index를 포함하지 않은 상태로 다음 index를 탐색한다. 그리고 찾으면 return한다. 하지만, 이번에 우리가 할 것은, 해당 숫자의 범위를 탐색하는 것이기 때문에, 찾았다고 해서 탐색을 끝낼 수 없다. 다만, 내가 원하는 값과 같은 값이 있다면, 그 index는 답의 후보가 될 수 있다. 최종적인 답은 끝까지 탐색한 후에 도출되도록 만들어야 한다. 예시를 보자.0   1   2   3   4   5   6   7   8   9   10-10 -10 2   3   3   6   7   10  10  10  13정렬이 된 상태에서 10의 lowerBound를 찾아보자.#1start :  0 end : 11 mid :  5 a[5] :  6이 상황에서 답은 무조건 5보다 큰 index에서 나올 수 밖에 없다. 따라서 start = mid + 1 해준다.#2start :  6 end : 11 mid :  8 a[8] : 108의 index에서 찾는 값이 나왔다. 해당 index는 답의 후보이다. 그렇기 때문에 이것을 포함한 상태로 다음 값으로 넘어가야 한다. end = mid#3start :  6 end :  8 mid :  7 a[7] : 10또 후보값이 나왔다. 이 때 index가 더 작으면서 10을 만족하기 때문에 end = mid해준다.#4start :  6 end :  7 mid :  6 a[6] :  77보다 큰곳에서 10은 나온다. 따라서 start = mid + 1 해준다.#5start :  7 end :  7 mid :  7 a[7] :  10start와 end가 같아졌다. 원래 이분탐색과 다르게 이러한 조건 때문에 start = end인 상황에서 탐색을 계속할 수 없다. 같아지는 순간 종료한다.기본적인 이 알고리즘의 핵심은,  원하는 수를 찾는다.  원하는 수를 찾았으면 그 수를 end에 박아두고 계속 탐색한다.이렇게 압축할 수 있다. 만약 원하는 수가 없다면 어떻게 될까? 기본적으로 제시한 숫자의 value가 원하는 값보다 크거나 같을 경우, end = mid하기 때문에 없다면 원하는 값보다 큰 수중에서 가장 작은 수의 위치를 return할 것이다. 즉, 1 3 5 7에서 4를 찾는다면, 없기 때문에 lowerBound는 3(index = 2)를 리턴한다.Codeint lowerBound(int num){    int start = 0, end = N, mid = 0;    while (start &lt; end) {        mid = (start+end)/2;        if (a[mid] &lt; num) {            start = mid + 1;        } else {            end = mid;        }    }    return end + 1;}UpperBound  원하는 숫자보다 처음으로 크게되는 위치lowerBound와 다르게, 10을 찾는다면, 10보다 처음으로 크게되는 위치를 리턴하게 된다.이분 탐색으로부터 생각해보자. 원래 같으면 같을 때, 탈출하여 답을 제시한다. 하지만, 내가 원하는 것은 찾은 뒤에 어떠한 조치가 필요하다. 찾은 값은, lowerBound에서와 다르게, 답의 후보가 될 수 없다. 예를 들어, 내가 10이라는 값을 찾았다. 하지만 위에 정한 정의는 10을 찾은 것이 중요한 것이 아니고, 10보다 언제 처음으로 커지냐가 궁금하다. 따라서 찾았다면, 해당 제시한 위치는 답이 될 수 없다. 따라서 이 값을 포함하지 않고 탐색해야 한다. 예시를 보자.#1start :  0 end : 11 mid :  5 a[5] :  66은 10보다 작으므로 이 곳에서 답이 나올 수는 없다. start = mid + 1#2start :  6 end : 11 mid :  8 a[8] : 108위치에서 10이 나왔지만, 이 10은 내가 원하는 답이 아니다. start = mid + 1#3start :  9 end : 11 mid : 10 a[10] : 1310의 위치에서 13이 나왔고, 10의 upperBound는 이 값을 포함한 아래 영역에서 나온다. 따라서 해당 10 index는 포함한 상태로 탐색을 진행한다. end = mid#4start :  9 end : 10 mid :  9 a[9] : 109위치에서 10이 나왔지만, 이 10은 내가 원하는 답이 아니다. start = mid + 1#5start :  10 end : 10 mid :  10 a[10] : 13start = end가 되어 종료한다. upperBound는 10이다.결국, 어느 범위에서 답이 나타날 수 있는지를 명확하게 규명하는 것이 중요하다. upperBound도 lowerBound와 마찬가지로 탐색하는 값이 없다면 이 값보다 큰 수들 중 가장 작은 수의 위치를 리턴한다. 아, 잘 생각해야 하는 부분이 있는데, 탐색 범위를 0~N-1로 하면 안된다. 그렇게 될 경우, 맨 끝에 내가 찾고싶은 값이 있을 때, 원하는 index를 반환할 수 없다.1 10 10 10이런 경우에 10의 upperBound를 찾는다고 해보자. 정의에 의하면 답은 당연히 5이다. 하지만 내가 탐색을 진행할 때, start = 0, end = 3이라고 놓고 생각하면, 최종 탐색 결과는 3을 넘지 못하고 return 값은 1을 더한 4이다. 즉 절대로 4를 넘은 값이 나올 수가 없다. 위에 정의한 upperBound 정의의 일관성을 잃지 않기 위해서는 end의 index를 하나 늘려서 정해놓는 것이 바람직하다.Codeint upperBound(int num){    int start = 0, end = N, mid = 0;    while (start &lt; end) {        mid = (start+end)/2;        if (a[mid] &lt;= num) { // 등호만 다르다.            start = mid + 1;        } else {            end = mid;        }    }    return end + 1;}이 문제 해설이 문제는 해설할 것이 없다. 저 위에 설명한 것이 곧 답이다..Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;int N, M;int a[500001];int lowerBound(int num){    int start = 0, end = N, mid = 0;    while (start &lt; end) {        mid = (start+end)/2;        if (a[mid] &lt; num) {            start = mid + 1;        } else {            end = mid;        }    }    return end + 1;}int upperBound(int num){    int start = 0, end = N, mid = 0;    while (start &lt; end) {        mid = (start+end)/2;        if (a[mid] &lt;= num) {            start = mid + 1;        } else {            end = mid;        }    }    return end + 1;}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    sort(a, a+N);    cin &gt;&gt; M;    for (int i = 0; i &lt; M; i++) {        int num, ans = 0;        cin &gt;&gt; num;        int low = lowerBound(num);        int high = upperBound(num);        if (low != high) ans = high-low;        cout &lt;&lt; ans &lt;&lt; \" \";    }    return 0;}STL upperBound, lowerBound를 이용한 풀이#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;int N, M;int a[500001];int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    sort(a, a+N);    cin &gt;&gt; M;    for (int i = 0; i &lt; M; i++) {        ll num, ans = 0;        cin &gt;&gt; num;        ll low = lower_bound(a, a+N, num)-a;        ll high = upper_bound(a, a+N, num)-a;        if (low != high) ans = high-low;        cout &lt;&lt; ans &lt;&lt; \" \";    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/24/%EB%B0%B1%EC%A4%80-%EC%88%AB%EC%9E%90%EC%B9%B4%EB%93%9C-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-eb-b0-b1-ec-a4-80-eb-9e-9c-ec-84-a0-ec-9e-90-eb-a5-b4-ea-b8-b0-html": {
        "title": "백준(1654번): 랜선 자르기",
        "tags": "백준, 알고리즘, 이분 탐색, 파라메트릭 서치",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 이분 탐색 문제이다.백준(1654번) - 랜선 자르기생각이분 탐색 문제이다. 이전의 문제들과 마찬가지로, 값을 제시하고 그에 대한 분기를 만드는 것이 중요하다. 이 때, 어느 영역에서 답이 나오는지를 잘 체크하고, 답의 후보를 기록해두는 행위가 중요하다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;ll K, N;ll a[10001];ll f(ll sug){    ll count = 0;    for (int i = 0; i &lt; K; i++) {        count += (a[i]/sug);    }    return count;}int main(){    cin &gt;&gt; K &gt;&gt; N;    for (int i = 0; i &lt; K; i++) {        cin &gt;&gt; a[i];    }    sort(a, a+K);    ll start = 1, end = (1LL &lt;&lt; 31)-1, mid = 0, ans = -1;    while (start &lt;= end) {        mid = (start+end)/2;        ll count = f(mid);        if (count &lt; N) {            end = mid - 1;        } else {            ans = max(ans, mid);            start = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}",
        
        "url": "/cs/algorithm/2020/04/24/%EB%B0%B1%EC%A4%80-%EB%9E%9C%EC%84%A0-%EC%9E%90%EB%A5%B4%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-eb-b0-b1-ec-a4-80-ea-b3-b5-ec-9c-a0-ea-b8-b0-ec-84-a4-ec-b9-98-html": {
        "title": "백준(2110번): 공유기 설치",
        "tags": "백준, 알고리즘, 이분 탐색, 파라메트릭 서치",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 파라메트릭 서치 문제이다.백준(2110번) - 공유기 설치생각파라메트릭 서치 문제이다. 일단 완전 탐색이 불가하고, 답을 제시했을 때 분기를 만들 수 있다는 점에서 바로 접근했다.  인접한 집간의 최대 거리를 제시한다.  제시한 거리를 보다 크거나 같은 곳에 공유기를 설치했을 때 몇개를 설치할 수 있는지를 반환한다.  그 반환한 값(즉 내가 제시한 거리로 공유기를 설치했을 때 대수)이 C와 어떤지 비교한다.  C보다 작다면 거리를 너무 크게 잡았으므로 거리를 줄여서 제시한다.  C보다 같거나 크다면 이 값은 후보가 될 수 있는 값이다. 후보인 이유는 지금 제시한 거리보다 큰 값에서 C와 같은 값이 나올 수 있기 때문에 더 탐색한다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;int N, C;int a[200000];int f(int num){    int count = 1;    int before = 0;    for (int i = 1; i &lt; N; i++) {        if (a[i]-a[before] &gt;= num) {            count++;            before = i;        }    }    return count;}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; C;    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    sort(a, a+N);    int start = 1, end = 1e9, ans = 0;    while (start &lt;= end) {        int mid = (start+end)/2;        int count = f(mid);        if (count &lt; C) {            end = mid - 1;        } else {            ans = max(ans, mid);            start = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/24/%EB%B0%B1%EC%A4%80-%EA%B3%B5%EC%9C%A0%EA%B8%B0-%EC%84%A4%EC%B9%98.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-eb-b0-b1-ec-a4-80-ea-b0-80-ec-9e-a5-ea-b8-b4-ec-a6-9d-ea-b0-80-ed-95-98-eb-8a-94-eb-b6-80-eb-b6-84-ec-88-98-ec-97-b4-2-html": {
        "title": "백준(12015번): 가장 긴 증가하는 부분 수열(LIS) 2",
        "tags": "백준, 알고리즘, 이분 탐색",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드2 : 이분 탐색 문제이다.백준(12015번) - 공유기 설치생각기존에 dp로 풀었던 문제가 데이터의 개수만 달라져 새로운 문제가 되었다. 이번 문제는 풀이를 좀 참고하였으며 새로운 공부를 할 수 있었다.이 문제는 먼저, 일반적인 dp문제로 풀수가 없다. dp로 풀기 위해서는, $O(n^2)$알고리즘인데, 그렇게 될 경우 n=1000000이라, 터진다. 따라서 시간 복잡도를 줄여야 한다. 그래서 방법을 달리한다.  현재 index까지 왔을 때, 가장 긴 증가하는 수열의 길이는 얼마인가?이것이 기존 dp로 풀었을 때 정의였다. 그런데 조금 색다르게, 배열을 하나 두고 이걸 만들어보자.a[] : 1 2 4 3#1    1#2    1 2#3    1 2 4$4    1 2 ?이 다음에 우리는 4번째 index에 있는 3을 추가해야 한다. 3까지 포함해 보았을 때, 가장 증가하는 수열의 길이는 1 2 4 혹은 1 2 3 으로 3이다. 여전히 값은 3이지만 지금 하는 과정은 증가하는 수열을 나타내는 배열을 만들어보는 중이다. 어떤 것을 선택하는 것이 바람직 할까?조금 생각해보면 1 2 3을 가지고 있는 것이 보다 현명하다. 결국 3을 1 2 4에서 추가하지 못하는 이유는 3이 4보다 작기 때문이다. 그리고 이 마지막 값은, 다음 요소에 대한 LIS를 구하는 데 있어 가장 핵심적인 숫자이다. 이 숫자가 가장 작은 숫자를 유지하면서 같은 LIS값을 갖는 것이 이후에 배열을 업데이트하는데 있어서 LIS를 구하는 것에 핵심적이다. 그래서 기본적으로는 내 요소를 포함하는 LIS를 만드는 것이 좋다. 따라서 이 상황에서 우리는 3보다 큰 요소 중 가장 첫번째에 나오는 요소와 3을 바꿔야 한다.그렇다면 여기서 만약 이렇게 주어졌다고 생각해보자.a[] : 1 2 3 2#1    1#2    1 2#3    1 2 3$4    1 2 ?여전히 같은 상황이다. 4번째 index인 2는 3보다 작기 때문에 추가할 수 없다. 그렇다면, 위의 논리대로라면 2는 3과 바꿔야 한다. 하지만 그럴 경우 1 2 2로 LIS에 합당하는 배열을 만들지 못한다. 실질적으로 4번째 index에서 LIS는 1 2 3 이다. 즉, 유지되어야 한다. 따라서, 우리는 2를 LIS에서 찾아 자기 자신과 바꾸는 작업을 해야 한다.(위의 작업과의 일관성을 위해 이렇게 설명. 사실은 바꾸지 않는다라는 표현이 맞을지 모름)lowerBound위의 두 문제를 다 만족하는 것이 있다. 바로 lowerBound이다. lowerBound는, 내가 원하는 값의 가장 하한선의 위치를 찾아주고(같은 것을 고를 수 있음), 내가 원하는 값이 없을 경우, 내 값보다 큰 원소 중 가장 첫번째로 나오는 요소의 위치를 반환한다. 이 두 기능은, 위에서 설명한 문제의 해결책과 동일하다. 따라서 우리는 이 함수를 사용할 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;const int MAX = 1000000;int N, ans = 0;int a[MAX+1];vector&lt;int&gt; v;void push(int num){    if (v.back() &lt; num) v.push_back(num);    else {        auto p = lower_bound(v.begin(), v.end(), num);        *p = num;    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    v.push_back(MAX);    for (int i = 0; i &lt; N; i++) push(a[i]);    cout &lt;&lt; v.size() &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/24/%EB%B0%B1%EC%A4%80-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-23-eb-b0-b1-ec-a4-80-ec-97-ac-ed-96-89-ea-b0-80-ec-9e-90-html": {
        "title": "백준(1976번): 여행가자",
        "tags": "백준, 알고리즘, 유니온파인드",
        "date": "April 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 유니온 파인드 문제이다.백준(1976번) - 여행가자생각이 문제의 핵심은 갈 수 있는지 없는지를 판단하는 것이다. 처음에 그래프라고 생각하고 접근하니, dfs를 수행할 때 depth가 너무 깊어져 터질 것 같아 다른 방법으로 진행했다.갈 수 있는 지 없는 지를 판단하기 위해서 해당 문제에서 가장 중요한 조건은, 그래프의 방향성이 없다는 것이다. 방향성이 없기 때문에 일단 연결된 모든 노드들은 어떻게든 서로의 노드에 방문할 수 있다. 이 점이 핵심이다. 그렇기 때문에 우리는 특정 노드가 어디에 속해있는 지, 어느 그래프 묶음에 속해있는 지를 파악하는 것이 중요하다.유니온 파인드그렇다면 결국 어떠한 집합에 속해있는지를 판단해야 하는 문제로 바뀐다. 그 결과 이 문제는 유니온 파인드로 해결하는 것이 가장 간단해 보인다.(1, 2)이런식으로 연결되어 있다고 가정할 경우, 2의 노드의 조상을 1의 노드의 조상으로 업데이트 하는 방식을 사용했다.Code#include&lt;iostream&gt;using namespace std;int a[201];int find(int x) {   if (x == a[x]) return x;   return a[x] = find(a[x]);}void Union(int x, int y) {   x = find(x);   y = find(y);   a[x] = y;}int main(void) {   int n, m;   cin &gt;&gt; n &gt;&gt; m;   for (int i = 1; i &lt;= n; i++) {      a[i] = i;   }   for (int i = 1; i &lt;= n; i++) {      for (int j = 1; j &lt;= n; j++) {         int input;         cin &gt;&gt; input;         if (input) {            Union(i, j);         }      }   }   int route[1000], par;   for (int i = 0; i &lt; m; i++) {      cin &gt;&gt; route[i];      if (i == 0) {         par = find(route[i]);      }      else {         if (par != find(route[i])) {            cout &lt;&lt; \"NO\";            return 0;         }      }   }   cout &lt;&lt; \"YES\";}",
        
        "url": "/cs/algorithm/2020/04/23/%EB%B0%B1%EC%A4%80-%EC%97%AC%ED%96%89%EA%B0%80%EC%9E%90.html"
      }
      ,
    
      "cs-algorithm-2020-04-23-eb-b0-b1-ec-a4-80-k-eb-b2-88-ec-a7-b8-ec-88-98-html": {
        "title": "백준(1300번): K번째 수",
        "tags": "백준, 알고리즘, 파라메트릭 서치",
        "date": "April 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 유니온 파인드 문제이다.백준(1300번) - 여행가자생각어려웠다. 여러가지 배열이 섞이고, 계산하는 방법을 생각하지 못했다. 이 문제를 풀면서 배운 것은, 정말 컴퓨터처럼(센다..) 생각해야 된다는 것.. 그리고 예시를 놓고, 이것을 실제로 써보면서 이상적으로 풀 생각을 하지말고 try &amp; modify 하는 것이다. 너무 뼈저리게 느꼈다..그래서, 지금부터 써보겠다. 이 문제에서 고려해야 하는 점은 크게 2가지 이다.센다.이분 탐색으로 풀린다는 것은 알았으나, K번째 수가 N이라고 제안한 이후에, 어떻게 K번째 수인지를 도출할 것인지에 대한 고민이 많았다. 즉, 제안한 숫자에 대해 이 숫자가 몇번째 수인지를 output으로 내놓을 함수를 짜야한다. 처음에 이것은, 제안한 숫자에 대한 제곱수를 찾아 필요없는 수를 제끼고..이런 방법으로 하려고 했는데, 컴퓨터는 정말 단순하게 생각하는 것이 핵심인 것 같다.   1   2   3   4   5   6   7   8   9  10   2   4   6   8  10  12  14  16  18  20   3   6   9  12  15  18  21  24  27  30   4   8  12  16  20  24  28  32  36  40   5  10  15  20  25  30  35  40  45  50   6  12  18  24  30  36  42  48  54  60   7  14  21  28  35  42  49  56  63  70   8  16  24  32  40  48  56  64  72  80   9  18  27  36  45  54  63  72  81  90  10  20  30  40  50  60  70  80  90 100내가 만약, 25라는 숫자를 제안했다고 하자. 그렇다면, 1번째 행에서 부터, 이 숫자보다 작은 것이 몇개있는 지를 센다. 그렇다면 10이다. 3번째 열에서는 8이다. 이 숫자들은, i번째 행의 숫자로 제시한 숫자를 나눈 몫으로 가능하다. 이 문제가 쉬운 이유이다. 그렇기 때문에 내가 제안한 숫자의 번째 수를 계산하는 것은 $O(N)$에 가능하다.ll f(ll num){    ll count = 0, numbering, current = 0;    for (int i = 1; i &lt;= N; i++) {        if (num/i &gt; N) {            numbering = N;            current = i * N;        } else {            numbering = num/i;            current = num/i * i;        }        count += numbering;    }    return count;}이 과정을 N이 3일 때 정리해보면 다음과 같다. 1 2 3 2 4 6 3 6 9 제시하는 숫자 : 1 2 3 4 5 6 7 8 9 count      : 1 3 5 6 6 8 8 8 9어떤 것이 답인가? 1 2 3 2 4 6 3 6 9 제시하는 숫자 : 1 2 3 4 5 6 7 8 9 count 함수  : 1 3 5 6 6 8 8 8 9 B[]        : 1 2 2 3 3 4 6 6 9 번째 수      : 1 2 3 4 5 6 7 8 9하지만 이렇게 되면 조금 문제가 발생한다. 원하는 K가 8, 즉 8번째 수라면 7을 제안해도 8, 6을 제안해도 8, 8을 제안해도 8이다. 그런데, 7을 제안하면 A배열에 없기 때문에 답이 아니다. 또한, K가 7일 경우, count함수를 통과시켜 나온 리턴 값에는 7이 없다. 하지만 7번째 수는 분명히 존재한다.이 문제는 숫자가 연속적으로 나열된 문제가 아니기 때문에, 특정 숫자에 대한 번째만이 존재한다. 다시 말하면 6이라는 숫자는 실제 B배열에서 7번째, 8번째 숫자이지만, 7이라는 숫자는 A배열에 없기 때문에 N번째 숫자라는 개념 자체가 불가능 하다. 즉, 7이라는 숫자를 제안했을 때, A배열에서 있다고 가정하고 숫자를 세면, 6을 세었을 때와 같은 count가 나오나, 7이라는 숫자가 없기 때문에 답이 아니다.숫자의 범위 때문에, 답을 제시하는 방법을 사용하긴 해야한다. 그렇다면 어떻게 A배열에 있으면서, 원하는 K번째가 있는 수를 제시할 수 있을까?K보다 count가 큰 녀석은 답의 후보이다.이것을 알기 위해서, 일단 이분 탐색이 맞다하고 생각을 해보자.1 2 32 4 63 6 9K = 7제시하는 숫자 : 1 2 3 4 5 6 7 8 9count 함수  : 1 3 5 6 6 8 8 8 9B[]        : 1 2 2 3 3 4 6 6 9번째 수      : 1 2 3 4 5 6 7 8 9start : 1  end : 9  제시 : 5start : 6  end : 9  제시 : 7start : 6  end : 6  제시 : 6K = 7인 상황에서 생각해보자. 먼저 (1+9)/2 = 5를 제안한다. 이 때의 함수 통과 값은 6이므로, K보다 작다. 따라서 값을 올려 제안한다.이번엔 (6+9)/2 = 7을 제안한다. 이 경우 함수 통과 값은 8이다. K보다 작다. 따라서 제시하는 값을 낮춘다.마지막으로 (6+6)/2 = 6를 탐색한다. 이 경우 count는 8이다. 그리고 나서 L, R가 역전되므로 끝난다. 하지만 답은 찾았다. 6이다.즉, count가 굳이 K와 같지 않더라도 답을 구할 수 있다.이 부분을 잘 생각해보자.7을 세었을 때와 6을 세었을 때, 같은 번째 수(8)라는 결론이 나오나, 우리는 8이라는 숫자가 처음 등장하는 숫자를 답으로 제안해야 한다. 7을 제안했을 때, 8이 나오는 이유는, 7이라는 숫자가 A배열에 없기 때문이다. 실제로 있는 수는, count함수를 돌렸을 때, 처음으로 8이라는 숫자가 나오는 경우, 해당 숫자를 A배열에 있는 수라고 생각할 수 있다. (잘 생각해보자.) 그렇기 때문에, 우리는 이분 탐색의 분기를 다음과 같이 정해야 한다.  count가 K보다 작다.          이 구간에는 답이 존재할 수 없으므로 더 큰 값을 탐색한다.        count가 K보다 크다.          이 구간에는 답이 존재할 수 있다. 그렇기 때문에 이 때 제시한 값은 답의 후보로 채택한다.      그리고, count가 K와 같은 구간을 찾기 위해 더 작은 값을 탐색한다.      이 과정을 거치게 되면서 우리가 하는 과정은, 최대한 K와 같은 값을 찾는다 이다.이러한 방법은 곧, 같은 count값이 나오더라도, 그 같은 count값이 처음으로 등장하는 수를 답으로 채택한다. 라는 의미와 일치한다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;ll MAX_NUM = 10000000000;ll N, K;ll f(ll num){    ll count = 0, numbering, current = 0;    for (int i = 1; i &lt;= N; i++) {        if (num/i &gt; N) {            numbering = N;            current = i * N;        } else {            numbering = num/i;            current = num/i * i;        }        count += numbering;    }    return count;}int main(){    cin &gt;&gt; N &gt;&gt; K;    ll ans = 0;    ll start = 1, end = min(MAX_NUM, N*N);    while (start &lt;= end) {        ll mid = (start+end)/2;        ll count = f(mid);        if (count &lt; K) {            start = mid+1;        } else {            ans = mid;            end = mid-1;        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/23/%EB%B0%B1%EC%A4%80-K%EB%B2%88%EC%A7%B8-%EC%88%98.html"
      }
      ,
    
      "dv-c-2020-04-20-testcase-ec-97-90-ec-a2-85-eb-a3-8c-ec-a1-b0-ea-b1-b4-ec-9d-b4-ec-97-86-eb-8a-94-ea-b2-bd-ec-9a-b0-html": {
        "title": "testcase에 종료 조건이 없는 경우",
        "tags": "c++, iostream, 입출력",
        "date": "April 20, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "종료 조건이 없는 입력에 대해 해결하는 방법을 알아본다.Codeint main(){    while(cin &gt;&gt; a &gt;&gt; b){        // 동작    }    return 0;}cin역시 함수이기 때문에, 입력이 제대로 들어오면 1을 return한다. 그리고 입력이 들어오지 않았을 때는 0을 return한다.",
        
        "url": "/dv/c++/2020/04/20/testcase%EC%97%90-%EC%A2%85%EB%A3%8C%EC%A1%B0%EA%B1%B4%EC%9D%B4-%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-20-eb-b0-b1-ec-a4-80-eb-a1-9c-eb-b4-87-ec-b2-ad-ec-86-8c-ea-b8-b0-html": {
        "title": "백준(4991번): 로봇 청소기",
        "tags": "백준, 알고리즘, 그래프",
        "date": "April 20, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 그래프 문제이다.백준(4991번) - 로봇 청소기생각현재 시작 위치에서 다음 쓰레기를 치우고, 그 위치에서 다시 다음 경로를 탐색하는 과정으로 문제를 풀려 했다. 하지만 코드를 짜면서도 탐색과정이 계속하여 중복되서 어떻게 풀어야 할지 고민을 많이했다.시간 초과 Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;#define INF 999999999using namespace std;typedef pair&lt;int, int&gt; PI;int W, H;char map[21][21];int check[21][21];int dy[4] = {0, -1, 0, 1}, dx[4] = {1, 0, -1, 0};int ans;vector&lt;PI&gt; trash;PI start;void printMap(){    cout &lt;&lt; \"Map\" &lt;&lt; '\\n';    for (int i = 0; i &lt; H; i++) {        for (int j = 0; j &lt; W; j++) {            cout &lt;&lt; map[i][j];        }cout &lt;&lt; '\\n' &lt;&lt; '\\n';    }}void printCheck(){    cout &lt;&lt; \"Check\" &lt;&lt; '\\n';    for (int i = 0; i &lt; H; i++) {        for (int j = 0; j &lt; W; j++) {            cout &lt;&lt; setw(3) &lt;&lt;check[i][j];        }cout &lt;&lt; '\\n' &lt;&lt; '\\n';    }}void bfs(PI start){    memset(check, -1, sizeof(check));    queue&lt;pair&lt;PI, int&gt;&gt; q;    q.push(make_pair(start, 0));    check[start.first][start.second] = 0;    while (!q.empty()) {        int now_y = q.front().first.first, now_x = q.front().first.second;        int count = q.front().second;        q.pop();        count++;        for (int i = 0; i &lt; 4; i++) {            int next_y = now_y + dy[i], next_x = now_x + dx[i];            if (0 &lt;= next_y &amp;&amp; next_y &lt; H &amp;&amp; 0 &lt;= next_x &amp;&amp; next_x &lt; W &amp;&amp; map[next_y][next_x] != 'x') {                if (check[next_y][next_x] == -1) {                    q.push(make_pair(make_pair(next_y, next_x), count));                    check[next_y][next_x] = count;                }            }        }    }//    printCheck();}void go(int depth, PI start, int count){//    printMap();    if (depth == trash.size()) {        ans = min(ans, count);        return;    }//    memset(check, 0, sizeof(check));    for (int i = 0; i &lt; trash.size(); i++) {        int now_y = trash[i].first, now_x = trash[i].second;        if (map[now_y][now_x] == '*'){            bfs(start);            if (check[now_y][now_x] != 0) {                map[start.first][start.second] = '.';                map[now_y][now_x] = 'o';                go(depth+1, trash[i], count+check[now_y][now_x]);                map[now_y][now_x] = '*';                map[start.first][start.second] = 'o';            }        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    while (true) {        cin &gt;&gt; W &gt;&gt; H;        ans = INF;        trash.clear();        if (W == 0 &amp;&amp; H == 0) {            return 0;        }        for (int i = 0; i &lt; H; i++) {            for (int j = 0; j &lt; W; j++) {                cin &gt;&gt; map[i][j];                if (map[i][j] == 'o') {                    start = make_pair(i, j);                }                if (map[i][j] == '*') {                    trash.push_back(make_pair(i, j));                }            }        }        go(0, start, 0);        if (ans == INF) {            cout &lt;&lt; -1 &lt;&lt; '\\n';        } else {            cout &lt;&lt; ans &lt;&lt; '\\n';        }    }}그 결과 시간초과가 났다. 그래서 다른 방법을 고민했다.그래프o 역시 쓰레기로 본다면 다음과 같은 그림으로 볼 수 있다.결국, 0번 위치에서 시작하여 나머지 노드들을 전부 순회했을 때, 최소이동 거리를 구하는 문제이다. 이렇게 문제를 모델링할 경우 노드간의 거리를 구하는 과정을 1번만 수행하면 되기 때문에 위에 있는 코드보다 연산이 줄어든다.7 5........o...*.........*...*........  0  4  2  6  4  0  6  2  2  6  0  4  6  2  4  0해당 입력에 대해 노드와 간선을 구하면 다음과 같이 구해진다. 이제 부터 해야할 일은 0번 부터 출발하여 어떤 순서로 이를 순회할지에 대한 문제이다.  0  1  2  3  0  1  3  2  0  2  1  3  0  2  3  1  0  3  1  2  0  3  2  1순회하는 방법은 다음과 같이 순열로 구성된다. 0-&gt;1-&gt;2-&gt;3과 같은 방향으로 갔을 때, 이동거리의 최솟값을 구하면 된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;#define INF 999999999using namespace std;typedef pair&lt;int, int&gt; PI;int N, M;char map[21][21];int check[21][21];int node[11][11];int dy[4] = {0, -1, 0, 1}, dx[4] = {1, 0, -1, 0};vector&lt;PI&gt; trash;int ans;void printCheck(){    cout &lt;&lt; \"Check\" &lt;&lt; '\\n';    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt; M; j++) {            cout &lt;&lt; setw(3) &lt;&lt; check[i][j];        }cout &lt;&lt; '\\n' &lt;&lt; '\\n';    }}void printNode(){    for (int i = 0; i &lt; trash.size(); i++) {        for (int j = 0; j &lt; trash.size(); j++) {            cout &lt;&lt; setw(3) &lt;&lt; node[i][j];        }cout &lt;&lt; '\\n';    }}void bfs(PI start){    queue&lt;PI&gt; q;    q.push(start);    check[q.front().first][q.front().second] = 0;    while (!q.empty()) {        int now_y = q.front().first, now_x = q.front().second;        q.pop();        int count = check[now_y][now_x];        for (int i = 0; i &lt; 4; i++) {            int next_y = now_y + dy[i], next_x = now_x + dx[i];            if (0 &lt;= next_y &amp;&amp; next_y &lt; N &amp;&amp; 0 &lt;= next_x &amp;&amp; next_x &lt; M &amp;&amp; map[next_y][next_x] != 'x') {                if (check[next_y][next_x] == -1) {                    check[next_y][next_x] = count+1;                    q.push(make_pair(next_y, next_x));//                    printCheck();                }            }        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    while (true) {        cin &gt;&gt; M &gt;&gt; N;        // 사용하는 배열 초기화        trash.clear();        ans = INF;        memset(node, 0, sizeof(node));        if (M == 0 &amp;&amp; N == 0) return 0; // 종료 조건        for (int i = 0; i &lt; N; i++) {            for (int j = 0; j &lt; M; j++) {                cin &gt;&gt; map[i][j];                if (map[i][j] == 'o') trash.insert(trash.begin(), make_pair(i, j)); // 시작 위치는 0에 고정                if (map[i][j] == '*') trash.push_back(make_pair(i, j));            }        }        for (int i = 0; i &lt; trash.size(); i++) {            memset(check, -1, sizeof(check));            bfs(trash[i]);            for (int j = i; j &lt; trash.size(); j++) {                node[i][j] = check[trash[j].first][trash[j].second];                node[j][i] = check[trash[j].first][trash[j].second];            }        }//        printNode();        vector&lt;int&gt; p; // 순열을 위한 배열 생성        for (int i = 1; i &lt; trash.size(); i++) p.push_back(i);        do{            p.insert(p.begin(), 0); // 시작 위치 추가            int localAns = 0;            for (int i = 0; i &lt; p.size()-1; i++) {                localAns += node[p[i]][p[i+1]];                if (node[p[i]][p[i+1]] == -1) {                    ans = -1;                    break;                }            }            ans = min(ans, localAns);            p.erase(p.begin()); // 시작 위치 삭제        }while(next_permutation(p.begin(), p.end()));        cout &lt;&lt; ans &lt;&lt; '\\n';    }    return 0;}Traveling Salesman problem (TSP)이런 문제는 결국 모든 지점을 지나는데 걸리는 최소 거리를 묻는 문제이다. 이러한 문제는 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 비슷한 문제로는 백준(2098번) - 외판원 순회가 있다.",
        
        "url": "/cs/algorithm/2020/04/20/%EB%B0%B1%EC%A4%80-%EB%A1%9C%EB%B4%87-%EC%B2%AD%EC%86%8C%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-19-eb-b0-b1-ec-a4-80-ec-b5-9c-ec-86-9f-ea-b0-92-ec-b0-be-ea-b8-b0-html": {
        "title": "백준(11003번): 최솟값 찾기",
        "tags": "백준, 알고리즘, 슬라이딩 윈도우",
        "date": "April 19, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플래티넘5 : 슬라이딩 윈도우 문제이다.백준(11003번) - 최솟값 찾기생각N이 500만이라 세그먼트 트리로 풀면 터진다.  세그먼트 트리를 만드는데 드는 시간          nlogn = 대략 22 * 5000000 = 110000000        쿼리를 보는데 드는 시간          nlogn        2nlogn그런데 재귀이기 때문에 간당간당하다. 실제로 재귀로 풀면 터지고 비재귀로 풀면 들어온다고 한다. 해당 문제는 세그먼트 트리보다 간단한 구현을 원하는 듯하다.문제는 간단하다. N개의 수가 들어왔을 때, L의 윈도우에서 최솟값을 차례대로 구하면 된다.이 때 문제는, 10개의 원소가 있을 때 L이 3이라 가정하면, 순서대로 이 윈도우에 해당하는 최솟값을 구하면 되는데, 계속해서 다음 윈도우와 겹치는 부분이 발생한다는 것이다. 결국 중복이 발생하고, 이부분에서 오래 걸린다.문제를 해결하는 방법은 그리디이다. 즉, 윈도우 내에서 최솟값을 구하는 데에는 어떠한 정답이 존재한다.Sliding Windowinput 배열, deque, result 세개의 구조가 필요하다.위 동영상은 sliding window를 통해 max 값을 찾는 방법을 소개하고 있다. 이 방법의 핵심은 sliding window에서 감소하는 부분 수열을 찾는 것이다. 답은 감소하는 부분 수열에서 나올 수 밖에 없다. 내가 이 수열을 만들 수 있다면, 그 수열에서 가장 첫번째 값이 무조건 답이다.그렇다면 고민해야 하는 부분은, window가 이동할 때, 어떤식으로 업데이트가 이루어져야 하냐는 점이다. 감소하는 부분 수열을 만들기 위해서 우리가 고려해야 하는 부분은 감소하는 부분 수열의 양단이다.입력이 8, 6, 2가 들어왔을 때를 생각해보자. 첫번째 window에서 최대 감소 수열을 구하면 위와 같다.이 상황에서 다음 window로 넘어가는 과정에, 2보다 작은 수가 들어왔다고 생각해보자. 그러면 맨 앞에 있는 8을 빼고, 1을 그냥 뒤에 추가하면 된다. 그리고 이 윈도우에서 최댓값은 여전히 맨 앞에 있는 요소이다.그런데 같은 상황에서 이번에는 5가 들어왔다고 생각해보자. 그렇다면 이 window에서 최대 감소 수열은 변경된다. 맨 앞에 있는 요소는 여전히 빠지지만, window 내의 감소 수열은 위와 같이 변경되야 한다. 여전히 최댓값은 맨 앞의 요소이다.Pop을 하는 과정에서 중요한 것이 있다. 무조건적으로 맨 앞에 있는 요소를 빼면 안된다. deq에 들어가 있는 것은 최대 감소수열을 가리키는 index이다. window가 이동하면서 제거되는 index가 deq에 들어가있는 첫번째 요소의 index와 같을 때 deq안의 원소를 지워줘야 한다. 그렇지 않을 경우 해당 요소는 여전히 넘어가는 window안에 있기 때문에 지워지면 안되는 값이다.결론  window내에서 최대 감소 수열을 만들었을 때 최댓값은 맨 앞 요소이다.  window가 이동 할 때, 업데이트 방식이 존재한다.  이런 방법을 사용했을 때, 시간 복잡도는 N이다.이런 방법을 사용하면 결국 한번의 탐색과정과 동시에 모든 윈도우에서 최댓값을 구할 수 있다. 그렇다면 최솟값 찾기에 이 방법을 도입해보자.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;int N, L;vector&lt;int&gt; v;list&lt;int&gt; deq;void pop_front(int index){    // 증가하는 수열의 맨 첫번째가 지금 윈도우의 시작점과 같다면 이동하면서 빼준다.    // 만약 아니라면 그 값을 빼주면 안된다!    if (!deq.empty() &amp;&amp; deq.front() == index) {        deq.pop_front();    }}void push_back(int index){    // 현재 새로들어온 index보다 작은 이전의 녀석들은 증가하는 수열에서 제거해준다.    while (!deq.empty() &amp;&amp; v[deq.back()] &gt; v[index]) {        deq.pop_back();    }    deq.push_back(index);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; L;    v.resize(N+1);    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; v[i];    for (int i = 1; i &lt;= N; i++) {        push_back(i);        cout &lt;&lt; v[deq.front()] &lt;&lt; ' ';        // 시작할 때 window size보다 작은 index는 pop을 하지않고 넣어준다.        if (i - L &gt;= 0) {            pop_front(i - L + 1);        }    }}",
        
        "url": "/cs/algorithm/2020/04/19/%EB%B0%B1%EC%A4%80-%EC%B5%9C%EC%86%9F%EA%B0%92-%EC%B0%BE%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-19-eb-b0-b1-ec-a4-80-eb-b3-bc-eb-a1-9d-ea-bb-8d-ec-a7-88-html": {
        "title": "백준(1708번): 볼록 껍질",
        "tags": "백준, 알고리즘, 기하",
        "date": "April 19, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드1 : 기하 문제이다.백준(1708번) - 볼록 껍질생각볼록 껍질, Convex Hull이라 한다. 이 알고리즘에서 유명한 것을 그라함 스캔 알고리즘인데, 해당 동영상을 봐보자.이것과 같은 알고리즘을 구현하기 위해서는 다음과 같은 절차를 거쳐야 한다.  가장 y가 작은 점을 구한다.  그 점을 기준으로 직선의 각을 기준으로 정렬한다.  각이 가장 작은 점부터 조사하면서 볼록 껍질인지 아닌지 확인하고 추가한다.이 때, 각을 기준으로 정렬을 수행해야 하는데, 각은 double 형이라 이를 정렬하는데 좋지 않다. 일단 구하기도 어렵고 같은 선상에 있을 때 골치가 아프다..그래서 이 때 각을 대변해 줄 수 있는 다른 지표로 외적의 부호를 사용한다. 이 부분이 달달한 부분인데, 외적의 값은 x, y축을 기저로 보았을 때, 시계 방향, 반시계 방향을 대변해 준다. 이 때, 특정 두 점과의 외적을 수행하면 서로의 상대적 위치를 알 수 있다.이 연산을 점들을 각 순서로 정렬하는 비교 연산으로 사용하자.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;struct Point{    ll x, y;};vector&lt;Point&gt; p;int N;ll ccw(Point p1, Point p2, Point p3){    return p1.x*p2.y + p2.x*p3.y + p3.x*p1.y - (p2.x*p1.y + p3.x*p2.y + p1.x*p3.y);}bool compareMinelement(Point p1, Point p2){    if (p1.y == p2.y) return p1.x &lt; p2.x;    else return p1.y &lt; p2.y;}bool compareCCW(Point p1, Point p2){    ll cp = ccw(p[0], p1, p2);    if (cp == 0) return (p1.x + p1.y) &lt; (p2.x + p2.y);    return cp &gt; 0;}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    p.resize(N);    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;    }    sort(p.begin(), p.end(), compareMinelement);    sort(p.begin()+1, p.end(), compareCCW);    vector&lt;Point&gt; v;    v.push_back(p[0]);    v.push_back(p[1]);    // 이 for문은 세점 중 가장 바깥쪽 점을 의미    for (int i = 2; i &lt; N; i++) {        // 볼록을 찾을 때까지 계속 진행        while (v.size() &gt;= 2) {            // 두개를 본다.            Point p2 = v.back();            v.pop_back();            Point p1 = v.back();            // ccw이면 중간에 있는 점(p2)를 확인된 점으로 판단하고 스택에 넣는다.            if (ccw(p1, p2, p[i]) &gt; 0) {                v.push_back(p2);                break;            }            // ccw가 아니면 p2를 추가하지 말고 p2이전의 2점과 현재 p[i]와 ccw인지 비교한다. (처음으로 돌아간다)        }        // while문을 통과했다면 점이 추가가 된 것이므로 현재 탐색하는 가장 바깥쪽 점도 넣어준다.        v.push_back(p[i]);    }    cout &lt;&lt; v.size() &lt;&lt;  '\\n';}보다 깔끔한 Convex Hull Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;struct Point {   ll x, y;   Point(ll a, ll b) :x(a), y(b) {};   Point() {};   bool operator&lt;(const Point &amp;rhs) const {      if (x != rhs.x) return x &lt; rhs.x;      return y &lt; rhs.y;   }};vector&lt;Point&gt; point;ll ccw(Point pt1, Point pt2, Point pt3) {   ll ret = pt1.x*pt2.y + pt2.x*pt3.y + pt3.x*pt1.y;   ret -= (pt2.x*pt1.y + pt3.x*pt2.y + pt1.x*pt3.y);   return ret;}ll dist(Point pt1, Point pt2) {   ll dx = pt2.x - pt1.x;   ll dy = pt2.y - pt1.y;   return dx * dx + dy * dy;}int main(){    int N;    cin &gt;&gt; N;    point.resize(N);    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; point[i].x &gt;&gt; point[i].y;    }    vector&lt;Point&gt; hull;    swap(point[0], *min_element(point.begin(), point.end()));    sort(point.begin() + 1, point.end(), [](Point x, Point y) {       ll cw = ccw(point[0], x, y);       if (cw == 0) return dist(point[0], x) &lt; dist(point[0], y);       return cw &gt; 0;    });    for (auto i : point) {        // hull의 뒤에서 2번째 값, 1번째 값, 그리고 point의 3번째 값을 비교하여        // 반시계가 아니면 hull의 맨 뒤의 점을 뺀다.        // 반시계이면 해당 점을 포함한 상태로 다음점을 비교한다.       while (hull.size() &gt;= 2 &amp;&amp; ccw(hull[hull.size() - 2], hull.back(), i) &lt;= 0) {          hull.pop_back();       }       hull.push_back(i);    }    cout &lt;&lt; hull.size() &lt;&lt; endl;}",
        
        "url": "/cs/algorithm/2020/04/19/%EB%B0%B1%EC%A4%80-%EB%B3%BC%EB%A1%9D-%EA%BB%8D%EC%A7%88.html"
      }
      ,
    
      "cs-algorithm-2020-04-19-eb-b0-b1-ec-a4-80-ea-b0-80-ec-9e-a5-ea-b8-b4-ec-a6-9d-ea-b0-80-ed-95-98-eb-8a-94-eb-b6-80-eb-b6-84-ec-88-98-ec-97-b4-4-html": {
        "title": "백준(14002번): 가장 긴 증가하는 부분 수열 4",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 19, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 동적 계획법 문제이다.백준(14002번) - 가장 긴 증가하는 부분 수열 4생각전형적인 dp 문제이다. 다만 이 문제는, 경로를 추적해야 한다는 점에서 조금 다르다. 경로를 추적하는 방법으로는 dp를 미리 구해놓고, 이것을 역으로 추적하여 구하는 방법이 가장 간단하다.정의  dp[i] = i번째 수까지 포함했을 때 가장 긴 증가하는 부분 수열의 길이점화식  dp[i] = max(dp[i], dp[j] + 1) 단, a[i] &gt; a[j]일 때Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;cmath&gt;#include&lt;functional&gt;using namespace std;int N;int a[1001];int dp[1001];vector&lt;int&gt; trace;void tracing(int index){    trace.push_back(a[index]);    if (dp[index] == 1) return;    for (int i = index-1; i &gt; 0; i--) {        if (dp[index] == dp[i] + 1 &amp;&amp; a[index] &gt; a[i]){            tracing(i);            break;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; a[i];    }    fill(dp, dp+N+1, 1);    for (int i = 1; i &lt;= N; i++) {        for (int j = i; j &gt; 0; j--) {            if (a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + 1);        }    }    int max = dp[N], maxIdx = N;    for (int i = N; i &gt; 0; i--) {        if (max &lt; dp[i]) {            max = dp[i];            maxIdx = i;        }    }    tracing(maxIdx);    cout &lt;&lt; max &lt;&lt; endl;    for (int i = int(trace.size())-1; i &gt;= 0; i--) {        cout &lt;&lt; trace[i] &lt;&lt; ' ';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/19/%EB%B0%B1%EC%A4%80-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-4.html"
      }
      ,
    
      "cs-algorithm-2020-04-19-eb-b0-b1-ec-a4-80-1-eb-a1-9c-eb-a7-8c-eb-93-a4-ea-b8-b0-2-html": {
        "title": "백준(12852번): 1로 만들기 2",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 19, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획법 문제이다.백준(12852번) - 1로 만들기 2생각전형적인 dp 문제이다. 다만 이 문제는, 경로를 추적해야 한다는 점에서 조금 다르다. 경로를 추적하는 방법으로는 dp를 미리 구해놓고, 이것을 역으로 추적하여 구하는 방법이 가장 간단하다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;cmath&gt;#include&lt;functional&gt;using namespace std;int N;int dp[1000001];vector&lt;int&gt; trace;void tracing(int num){    trace.push_back(num);    if (num == 1) return;    int before = num-1;    if (num%3 == 0) {        if (dp[before] &gt; dp[num/3]) before = num/3;    }    if(num%2 == 0) {        if (dp[before] &gt; dp[num/2]) before = num/2;    }    tracing(before);}int main(){    cin &gt;&gt; N;    dp[0] = 987654321;    for (int i = 2; i &lt;= N; i++) {        dp[i] = dp[i-1] + 1;        if (i%3 == 0) {            dp[i] = min(dp[i], dp[i/3]+1);        }        if (i%2 == 0){            dp[i] = min(dp[i], dp[i/2]+1);        }    }    tracing(N);    cout &lt;&lt; dp[N] &lt;&lt; endl;    for (int i = 0; i &lt; trace.size(); i++) {        cout &lt;&lt; trace[i] &lt;&lt; ' ';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/19/%EB%B0%B1%EC%A4%80-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-17-eb-b0-b1-ec-a4-80-ed-8f-89-eb-b2-94-ed-95-9c-eb-b0-b0-eb-82-ad-html": {
        "title": "백준(12865번): 평범한 배낭",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 17, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드5 : 동적 계획법 문제이다.백준(12865번) - 평범한 배낭생각결국 무게 제약이 있는 문제이다. 나는 이 문제를 풀 때 감을 잡기 참어려웠는데, 무게에 제약이 있다는 점을 갖고 완전 탐색을 한다는 아이디어를 가지고 생각했다. 완전 탐색을 곧이곧대로 하려면 $O(n!)$ 의 시간 복잡도가 생겨 풀기 어렵다. 그렇기 때문에 이 문제는 다이나믹으로 접근한다.다이나믹으로 접근하면, 작은 문제를 정의하고 이것이 큰 문제에 어떠한 영향을 주는 지를 확인해야 한다.정의  dp[i][j] = i번째 물건까지 포함했을 때 j의 무게를 포함하는 가치의 최댓값말이 좀 어렵다. 예시를 보자4 76 134 83 65 12현재 무게 : 6 현재 가치 : 13  1   2   3   4   5   6   7  0   0   0   0   0  13  13현재 무게 : 4 현재 가치 : 8  1   2   3   4   5   6   7  0   0   0   8   8  13  13현재 무게 : 3 현재 가치 : 6  1   2   3   4   5   6   7  0   0   6   8   8  13  14현재 무게 : 5 현재 가치 : 12  1   2   3   4   5   6   7  0   0   6   8  12  13  1414새로운 아이템이 추가됨에 따라, 그 상태에서 가질 수 있는 가치의 최댓값을 가지고 있으면 문제는 해결된다.점화식  dp[i][j] = max(dp[i][j], dp[i-1]j-a[i][0]]] + a[i][1];위의 예시를 잘 보면, dp[4][7]을 업데이트 하기 위해서는 dp[3번째 무게까지 포함][4의 무게] + 6(3의 가치) 와 dp[3번째 무게까지 포함][7의 무게] 두개를 비교해야 한다. 즉, 8+6, 과 13을 비교한다.잘 생각해보면, 이전 무게까지 포함했을 때 최댓값과, 새로 들어온 무게를 만들었을 때의 가치를 비교하면 되는 문제이다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int N, K;int a[101][2];int dp[101][100001];void print(int i){    cout &lt;&lt; \"현재 무게 : \" &lt;&lt; a[i][0] &lt;&lt; \" 현재 가치 : \" &lt;&lt; a[i][1] &lt;&lt; '\\n';    for (int j = 1; j &lt;= K; j++) {        cout &lt;&lt; setw(3) &lt;&lt; j &lt;&lt; \" \";    }cout &lt;&lt; '\\n';    for (int j = 1; j &lt;= K; j++) {        cout &lt;&lt; setw(3) &lt;&lt; dp[i][j] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; K;    for (int i = 1; i &lt;= N; i++) {        int w, v;        cin &gt;&gt; w &gt;&gt; v;        a[i][0] = w;        a[i][1] = v;    }    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= K; j++) {            // 만들고 싶은 무게에 지금 넣고 싶은 무게를 넣지 못하는 경우            if (j - a[i][0] &lt; 0) {                // 이전 아이템까지 넣었던 최대 가치로 갖고 있는다                dp[i][j] = max(dp[i][j], dp[i-1][j]);                continue;            }            // 현재 만들고 싶은 무게에 지금 넣고 싶은 무게를 넣을 수 있다면            // 이전 아이템까지 넣었을 때 최대 가치를 가졌던 것과, 지금 넣고 싶은 무게를 넣었을 때            // 가치를 비교하여 최대 가치로 업데이트 해준다.            dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i][0]] + a[i][1]);        }        print(i);    }    // 최종적으로 N개의 짐까지 다 넣어보았을 때, 최대 가치가 얼마인지 찾는다.    cout &lt;&lt; *max_element(dp[N], &amp;dp[N][K+1]) &lt;&lt; '\\n';    //dp[i][j] = i번째 물건까지 포함했을 때 j의 무게를 만들었을 때 무게의 최댓값    // dp[i][j] = max(dp[i][j], dp[i-1][j-a[i].first] + a[i].second;    return 0;}공간 복잡도 감소그런데, 지금 dp의 크기를 보면 100*100000 = 10000000이라 많은 메모리를 낭비하고 있다. dp[i]~dp[i+1] 과의 관계에서 값이 도출이 되기 때문에 이전 depth의 dp는 필요가 없다. 따라서 temp라는 배열에 이를 저장하고 그 저장한 배열에서 값을 따오면 공간 복잡도를 줄일 수 있다.#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int N, K;int a[101][2];int dp[100001];int temp[100001];void print(int i){    cout &lt;&lt; \"현재 무게 : \" &lt;&lt; a[i][0] &lt;&lt; \" 현재 가치 : \" &lt;&lt; a[i][1] &lt;&lt; '\\n';    for (int j = 1; j &lt;= K; j++) {        cout &lt;&lt; setw(3) &lt;&lt; j &lt;&lt; \" \";    }cout &lt;&lt; '\\n';    for (int j = 1; j &lt;= K; j++) {        cout &lt;&lt; setw(3) &lt;&lt; dp[j] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; K;    for (int i = 1; i &lt;= N; i++) {        int w, v;        cin &gt;&gt; w &gt;&gt; v;        a[i][0] = w;        a[i][1] = v;    }    for (int i = 1; i &lt;= N; i++) {        memcpy(temp, dp, sizeof(dp));        for (int j = 1; j &lt;= K; j++) {            if (j - a[i][0] &lt; 0) dp[j] = max(dp[j], dp[j]);            else dp[j] = max(temp[j], temp[j-a[i][0]] + a[i][1]);        }    }    cout &lt;&lt; *max_element(dp, dp+K+1) &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/17/%EB%B0%B1%EC%A4%80-%ED%8F%89%EB%B2%94%ED%95%9C-%EB%B0%B0%EB%82%AD.html"
      }
      ,
    
      "cs-algorithm-2020-04-17-eb-b0-b1-ec-a4-80-ed-8c-8c-ec-8a-a4-ec-b9-bc-html": {
        "title": "백준(2986번): 파스칼",
        "tags": "백준, 알고리즘, 소수, 수학",
        "date": "April 17, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 수학 문제이다.백준(2986번) - 파스칼생각일단 코드가 처음보는 거라 유심히 보았다. 결국 이런 것을 묻는 문제였다.  가장 큰 약수가 뒤에서 부터 몇번째에 나오니?그렇다면 가장 큰 약수를 구해야 하는데, 가장 큰 약수는 사실 $\\sqrt{n}$ 까지만 조사해도 풀 수 있다. 모든 수는 약수로 1을 가지므로 1을 초기값으로 두고, $\\sqrt{n}$까지 루프를 돌며 가장 큰 약수를 구한 뒤, 그 값까지 오는 count 개수를 출력하면 된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int main(){    int n, divisor = 1;    cin &gt;&gt; n;    for (int i = 2; i*i &lt;= n; i++) {        if (n%i == 0) {            divisor = n/i;            break;        }    }    cout &lt;&lt; n-divisor &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/17/%EB%B0%B1%EC%A4%80-%ED%8C%8C%EC%8A%A4%EC%B9%BC.html"
      }
      ,
    
      "cs-algorithm-2020-04-17-eb-b0-b1-ec-a4-80-ec-9d-b4-eb-b6-84-ea-b7-b8-eb-9e-98-ed-94-84-html": {
        "title": "백준(1707번): 이분 그래프(Bipartite Graph)",
        "tags": "백준, 알고리즘, dfs, 그래프",
        "date": "April 17, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 그래프 문제이다.백준(1707번) - 이분 그래프생각이분 그래프란 무엇인가? 문제를 읽고는 파악하는 게 힘들었다. 차라리 그림으로 보는 것이 좋다.왼쪽과 같은 그래프가 있을 이걸 오른쪽 그림처럼 바꿀 수 있느냐의 문제이다. 즉 저는 두 개의 집합으로 나눴을 때, 그 집합 내에 소속되는 정점과 인접하지 않는 (서로소 관계를 유지하는) 그래프 라 할 수 있다. 여기서 핵심은 나와 인접한 노드들의 색이 반대라는 것이다.풀이풀이 방법은 생각 보다 간단하다. 물론 처음에는 좀 삽질을 했지만.. 여전히 그래프 문제이기 때문에 탐색 방법론 부터 생각하는 것이 합리적이다.가장 생각하기 어려운 모양 부터 생각해 보겠다. 아래의 예는 그래프가 발생했을 때, 닫힌 그래프로 구성이 되어 정확하게 3개로 쪼개지는 경우에 대해 생각해 본 것이다.  닫힌 그래프는 여러개 존재할 수 있다. (그래프 입력 : a, b, c의 닫힌 그래프로 나뉜다고 가정해보자.)  각각의 닫힌 그래프에서 이분 그래프가 되기 위해서는 나와 인접한 노드의 색이 반대여야 한다. (a 그래프에서 이분 그래프인지 확인한다.)  이렇게 모든 닫힌 그래프에서 이분 그래프인지 확인했을 때 하나라도 이분 그래프가 아니라면 “No”를 출력한다.  모든 닫힌 그래프에서 이분 그래프라면, 이 세 닫힌 그래프를 합쳐도 이분 그래프이기 때문에 “YES”를 출력한다.이번에는 4개의 node에서 2개의 노드만 연결되었을 경우를 생각해 보자. 연결이 되지 않은 노드는 색을 어떻게 칠해주냐에 따라 다르므로, 결국 연결된 그래프에 대해서는 이분 그래프인지를 확인해 주면 된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define MAX 20000#define RED 1#define BLUE 2using namespace std;vector&lt;int&gt; graph[MAX+1];int isVisited[MAX+1];int V, E;// 내 노드에서 부터 시작해서 연결된 친구들을 다른 색으로 바꾼다.// 이미 색이 칠해져 있으면 탐색하지 않는다.void dfs(int voltex, int color){    isVisited[voltex] = color;    for (int i = 0; i &lt; graph[voltex].size(); i++) {        int nextVoltex = graph[voltex][i];        if (!isVisited[nextVoltex]) dfs(nextVoltex, 3-color);    }}// 나랑 연결된 친구들은 다른 색이어야 한다.bool isBipartiteGraph(){    for (int i = 1; i &lt;= V; i++) {        for (int j = 0; j &lt; graph[i].size(); j++) {            int nextVoltex = graph[i][j];            if (isVisited[i] == isVisited[nextVoltex]) return false;        }    }    return true;}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    int T;    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; V &gt;&gt; E;        for (int i = 0; i &lt;= V; i++) graph[i].clear();        memset(isVisited, 0, sizeof(isVisited));        for (int i = 0; i &lt; E; i++) {            int v1, v2;            cin &gt;&gt; v1 &gt;&gt; v2;            graph[v1].push_back(v2);            graph[v2].push_back(v1);        }        for (int i = 1; i &lt;= V; i++) {            if (!isVisited[i]) dfs(i, RED); // 색을 배정 받지 않은 친구들 탐색        }        if (isBipartiteGraph()) cout &lt;&lt; \"YES\" &lt;&lt; '\\n';        else cout &lt;&lt; \"NO\" &lt;&lt; '\\n';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/17/%EB%B0%B1%EC%A4%80-%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84.html"
      }
      ,
    
      "cs-algorithm-2020-04-17-eb-b0-b1-ec-a4-80-ec-95-b1-html": {
        "title": "백준(7579번): 앱",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 17, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 동적 계획법 문제이다.백준(7579번) - 평범한 배낭생각이 문제는, 백준(12865번): 평범한 배낭과 매우 비슷하다. 한번 푸는 것이 좋다.이 문제는 memory의 범위가 매우 크기 때문에, 이 것을 기준으로 로직을 짜면 메모리가 터진다. 그래서 반대로 cost를 어떤 기준으로 만들 수 있는 지를 고민하여 코드를 짰다.정의  dp[i][j] = i번째 앱까지 비활성화했을 때 j의 비용까지 만들 수 있을 때 메모리의 최댓값메모리의 최댓값이라 잡은 이유는, 최소 Cost로 최대 메모리를 지우는 것이 합리적이기 때문이다.5 6030 10 20 35 403 0 3 5 4현재 비용 : 3 현재 메모리 : 30  0   0   0  30  30  30  30  30  30  30  30  30  30  30  30  30현재 비용 : 0 현재 메모리 : 10 10  10  10  40  40  40  40  40  40  40  40  40  40  40  40  40현재 비용 : 3 현재 메모리 : 20 10  10  10  40  40  40  60  60  60  60  60  60  60  60  60  60현재 비용 : 5 현재 메모리 : 35 10  10  10  40  40  45  60  60  75  75  75  95  95  95  95  95현재 비용 : 4 현재 메모리 : 40 10  10  10  40  50  50  60  80  80  85 100 100 115 115 115 1356새로운 앱이 추가됨에 따라, 그 Cost에서 가질 수 있는 메모리의 최댓값을 가지고 있으면 문제는 해결된다.점화식  dp[j] = max(temp[j], temp[j-nowCost] + nowMem)temp는 i-1개의 앱을 사용했을 때의 정보를 갖고 있는 dp이다. 이전 평범한 배낭 문제에서도 이전 depth의 정보만을 가져다가 사용하기 때문에 메모리가 낭비된다.이 문제는, 새로운 앱이 추가되었을 때, 현재 Cost에서 최대 메모리를 지우는 것을 목표로 코드를 짜면 된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define COSTMAX 10000#define APPMAX 100using namespace std;typedef long long ll;int costLimit = 0;int N, M;ll dp[COSTMAX+1];ll temp[COSTMAX+1];int mem[APPMAX+1];int cost[APPMAX+1];ll ans;void print(int i){    cout &lt;&lt; \"현재 비용 : \" &lt;&lt; cost[i] &lt;&lt; \" 현재 메모리 : \" &lt;&lt; mem[i] &lt;&lt; '\\n';    for (int i = 0; i &lt;= costLimit; i++) {        cout &lt;&lt; setw(3) &lt;&lt; dp[i] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    cin &gt;&gt; N &gt;&gt; M;    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; mem[i];    }    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; cost[i];        costLimit += cost[i];    }    for (int i = 1; i &lt;= N; i++) {        memcpy(temp, dp, sizeof(dp));        int nowCost = cost[i];        int nowMem = mem[i];        for (int j = nowCost; j &lt;= costLimit; j++) {            dp[j] = max(temp[j], temp[j-nowCost] + nowMem);        }        print(i);    }    for (int i = 0; i &lt;= costLimit; i++) {        if (dp[i] &gt;= M) {            ans = i;            break;        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/17/%EB%B0%B1%EC%A4%80-%EC%95%B1.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-ec-86-8c-ec-88-98-html": {
        "title": "백준(2581번): 소수",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버4 : 수학 문제이다.백준(2581번) - 소수생각소수 구하는 알고리즘인 에라토스테네스의 체를 사용하면 간단히 풀 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define MAX 10000using namespace std;int N, M;bool isPrime[MAX+1];void SeiveofEratosThenes(){    fill(isPrime+2, isPrime+MAX+1, true);    for (int i = 2; i*i &lt;= M; i++) {        if (isPrime[i] == false) continue;        for (int j = i*i; j &lt;= M; j+=i) {            isPrime[j] = false;        }    }}int main(){    cin &gt;&gt; N &gt;&gt; M;    SeiveofEratosThenes();    vector&lt;int&gt; primeArr; int sum = 0;    for (int i = N; i &lt;= M; i++) {        if (isPrime[i]) {            primeArr.push_back(i);            sum += i;        }    }    if (primeArr.size() == 0) {        cout &lt;&lt; -1 &lt;&lt; '\\n';    } else cout &lt;&lt; sum &lt;&lt; '\\n' &lt;&lt; primeArr[0] &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-ec-86-8c-ec-88-98-ea-b5-ac-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1929번): 소수 구하기",
        "tags": "백준, 알고리즘, 에라토스테네스의 체, 수학",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 수학 문제이다.백준(1929번) - 소수 구하기생각소수 구하는 알고리즘인 에라토스테네스의 체를 사용하면 간단히 풀 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define MAX 1000000using namespace std;bool isPrime[MAX+1];int N, M;void SeiveofEratosThenes(){    fill(isPrime+2, isPrime+N+1, true);    for (int i = 2; i*i &lt;= N; i++) {        if (isPrime[i] == false) continue;        for (int j = i*i; j &lt;= N; j+=i) {            isPrime[j] = false;        }    }}int main(){    cin &gt;&gt; M &gt;&gt; N;    SeiveofEratosThenes();    for (int i = M; i &lt;= N; i++) {        if (isPrime[i] == true) cout &lt;&lt; i &lt;&lt; '\\n';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-eb-b2-a0-eb-a5-b4-ed-8a-b8-eb-9e-91-ea-b3-b5-ec-a4-80-html": {
        "title": "백준(4948번): 베르트랑 공준",
        "tags": "백준, 알고리즘, 에라토스테네스의 체, 수학",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 수학 문제이다.백준(4948번) - 베르트랑 공준생각소수 구하는 알고리즘인 에라토스테네스의 체를 사용하면 간단히 풀 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define MAX 123456*2using namespace std;int N;bool isPrime[MAX+1];void SeiveofEratosThenes(){    fill(isPrime+2, isPrime+MAX+1, true);    for (int i = 2; i*i &lt;= MAX; i++) {        if (isPrime[i] == false) continue;        for (int j = i*i; j &lt;= MAX; j+=i) {            isPrime[j] = false;        }    }}int main(){    SeiveofEratosThenes();    while (1) {        int count = 0;        cin &gt;&gt; N;        if (N == 0) {            break;        }        for (int i = N+1; i &lt;= 2*N; i++) {            if (isPrime[i]) count++;        }        cout &lt;&lt; count &lt;&lt; '\\n';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EB%B2%A0%EB%A5%B4%ED%8A%B8%EB%9E%91-%EA%B3%B5%EC%A4%80.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-eb-8f-99-ec-a0-842-html": {
        "title": "백준(2294번): 동전 2",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획법 문제이다.백준(2294번) - 동전 2생각다이나믹의 유형 중 중요한 유형이다. 대부분의 동전 문제의 방식과 비슷하다. 1차원 다이나믹이지만 2개의 반복문을 통해 2차원 처럼 생각하는 것이 필요하다.정의  dp[i] = n의 가치를 만들기 위해 필요한 최소 숫자의 개수정의는 매우 간단하다. 하지만 이 것을 구현할 때는 2차원 처럼 생각해야 편하다.점화식  dp[j] = min(dp[j],dp[j-a[i]]+1)위의 점화식이 나오는 과정을 생각해보자.3 152510========동전의 값 : 2========0 - 1 - 2 - 3 - 4 - 5 - 6 - 7========동전의 값 : 5========0 - 1 - 2 1 3 2 4 3 2 4 3 5 4========동전의 값 : 10========0 - 1 - 2 1 3 2 4 3 1 4 2 5 3  2로써 만들 수 있는 것을 업데이트 한다.  5로써 만들 수 있는 것을 업데이트 한다.  10로써 만들 수 있는 것을 업데이트 한다.이 때, 해당 가치가 업데이트 되는 방향은 결정되어 있다. 5의 가치는 3의 가치에서 2의 동전을 더해서 만들 수 있다. 이런 관계를 잘 엮는다면 문제를 해결할 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N, M;int a[101];int dp[10001];const int INF = 987654321;void print(int coin){    cout &lt;&lt; \"========\" &lt;&lt; \"동전의 값 : \"&lt;&lt; coin &lt;&lt; \"========\" &lt;&lt; '\\n';    for (int i = 0; i &lt; M; i++) {        if (dp[i] == INF) {            cout &lt;&lt; '-' &lt;&lt; \" \";        } else cout &lt;&lt; dp[i] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    cin &gt;&gt; N &gt;&gt; M;    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; a[i];    }    fill(dp+1, dp+M+1, INF);    for (int i = 1; i &lt;= N; i++) {        for (int j = a[i]; j &lt;= M; j++) {            dp[j] = min(dp[j],dp[j-a[i]]+1);        }        print(a[i]);    }    if (dp[M] == INF) cout &lt;&lt; -1;    else cout &lt;&lt; dp[M];    cout &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EB%8F%99%EC%A0%842.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-eb-8f-99-ec-a0-841-html": {
        "title": "백준(2293번): 동전 1",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획법 문제이다.백준(2293번) - 동전 2생각다이나믹의 유형 중 중요한 유형이다. 대부분의 동전 문제의 방식과 비슷하다. 1차원 다이나믹이지만 2개의 반복문을 통해 2차원 처럼 생각하는 것이 필요하다.정의  dp[i] = n의 가치를 만들기 위해 필요한 경우의 수정의는 매우 간단하다. 하지만 이 것을 구현할 때는 2차원 처럼 생각해야 편하다.점화식  dp[j] += dp[j-a[i]];위의 점화식이 나오는 과정을 생각해보자.3 152510========동전의 값 : 2========1 0 1 0 1 0 1 0 1 0 1 0 1 0 1========동전의 값 : 5========1 0 1 0 1 1 1 1 1 1 2 1 2 1 2========동전의 값 : 10========1 0 1 0 1 1 1 1 1 1 3 1 3 1 3  2로써 만들 수 있는 것을 업데이트 한다.  5로써 만들 수 있는 것을 업데이트 한다.  10로써 만들 수 있는 것을 업데이트 한다.이 때, 해당 가치가 업데이트 되는 방향은 결정되어 있다. 5의 가치는 3의 가치에서 2의 동전을 더해서 만들 수 있다. 이런 관계를 잘 엮는다면 문제를 해결할 수 있다. 이 문제는 동전 2의 문제와 같다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N, M;int a[101];int dp[10001];void print(int coin){    cout &lt;&lt; \"========\" &lt;&lt; \"동전의 값 : \"&lt;&lt; coin &lt;&lt; \"========\" &lt;&lt; '\\n';    for (int i = 0; i &lt; M; i++) {        cout &lt;&lt; dp[i] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    cin &gt;&gt; N &gt;&gt; M;    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; a[i];    }    dp[0] = 1;    for (int i = 1; i &lt;= N; i++) {        for (int j = a[i]; j &lt;= M; j++) {            dp[j] += dp[j-a[i]];        }        print(a[i]);    }    cout &lt;&lt; dp[M] &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EB%8F%99%EC%A0%841.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-eb-8b-a4-eb-a6-ac-eb-86-93-ea-b8-b0-html": {
        "title": "백준(1010번): 다리놓기",
        "tags": "백준, 알고리즘, 메모이제이션, 재귀",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버4 : 메모이제이션 문제이다.백준(1010번) - 소수생각고등학교 때 많이 풀어본 함수의 개수 구하는 문제와 같다. 결국은 공역단에서 N개의 site를 고르게 되면 자동으로 순서가 결정되기 때문이다. M개의 원소 중에 N개의 원소를 고르면 되는 문제이기 때문에 이것은 결국 조합을 구현하는 문제와 같다. 그 과정에서 중복되는 조합 값이 존재하기 때문에 이것을 따로 저장하게 되면 시간이 매우 많이 단축된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;ll memo[31][31];ll combination(int M, int N){    if (M == N || N == 0) return 1;    if (memo[M-1][N-1] == 0) memo[M-1][N-1] = combination(M-1, N-1);    if (memo[M-1][N] == 0) memo[M-1][N] = combination(M-1, N);    return memo[M-1][N-1] + memo[M-1][N];}int main(){    int T;    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        int N, M;        cin &gt;&gt; N &gt;&gt; M;        cout &lt;&lt; combination(M, N) &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EB%8B%A4%EB%A6%AC%EB%86%93%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-ea-b3-a8-eb-93-9c-eb-b0-94-ed-9d-90-ec-9d-98-ec-b6-94-ec-b8-a1-html": {
        "title": "백준(9020번): 골드바흐의 추측",
        "tags": "백준, 알고리즘, 에라토스테네스의 체, 수학",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 수학 문제이다.백준(9020번) - 골드바흐의 추측생각소수 구하는 알고리즘인 에라토스테네스의 체를 사용하면 간단히 풀 수 있다. 이 때, 시간제한 때문에 구한 소수를 담아두는 것이 좋다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define MAX 10000using namespace std;bool isPrime[MAX+1];void SeiveofEratosThenes(){    fill(isPrime+2, isPrime+MAX+1, true);    for (int i = 2; i*i &lt;= MAX; i++) {        if (isPrime[i] == false) continue;        for (int j = i*i; j &lt;= MAX; j+=i) {            isPrime[j] = false;        }    }}void solve(int N){    vector&lt;int&gt; prime;    for (int i = 2; i &lt;= N; i++) {        if (isPrime[i]) prime.push_back(i);    }    int size = int(prime.size());    int a = -100000, b = 100000;    for (int i = 0; i &lt;= size; i++) {        for (int j = i; j &lt;= size; j++) {            if (prime[i]+prime[j] == N) {                if (prime[j]-prime[i] &lt; b-a) {                    a = prime[i]; b = prime[j];                }            }        }    }    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; '\\n';}int main(){    SeiveofEratosThenes();    int T;    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        int N;        cin &gt;&gt; N;        solve(N);    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EA%B3%A8%EB%93%9C%EB%B0%94%ED%9D%90%EC%9D%98-%EC%B6%94%EC%B8%A1.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ec-a0-90-ed-94-84-html": {
        "title": "백준(1890번): 점프",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 동적 계획법 문제이다.백준(1890번) - 점프생각앞으로 보내는 dp문제이다.정의이 문제는 위치에 따라 개수가 결정되므로 dp의 인자를 좌표의 위치로 잡는 것이 수월하다.  dp[y][x] = (y,x) 위치까지 도착하는 경로의 개수점화식해당 위치까지 도착하는 개수는 이전 위치에서 올 수 있느냐를 판단해야 한다. 이 경우 과거로 부터 현재를 갖고오는 것이 무리가 있으니 오히려 현재 위치에서 다음 위치로 갈 수 있는 경로를 업데이트 하는 것이 옳다.  dp[y+d][x] += dp[y][x]  dp[y][x+d] += dp[y][x]d는 (y,x)위치에서 점프할 수 있는 크기이다. 이 때 dp[y][x]로 업데이트 해주는 이유는, 해당 (y, x) 위치에 도착할 수 있는 경로가 2개라면, 이 지점까지 도달한 경로 모두는 다음 위치로 이동할 수 있기 때문에 그 숫자로 업데이트하는 것이 맞다.42 3 2 11 2 1 32 2 1 13 1 1 0=========(1,1 )==================y 방향=========1 0 0 00 0 0 01 0 0 00 0 0 0=========(1,1 )==================x 방향=========1 0 1 00 0 0 01 0 0 00 0 0 0=========(1,3 )==================y 방향=========1 0 1 00 0 0 01 0 1 00 0 0 0=========(1,3 )==================x 방향=========1 0 1 00 0 0 01 0 1 00 0 0 0=========(3,1 )==================y 방향=========1 0 1 00 0 0 01 0 1 00 0 0 0=========(3,1 )==================x 방향=========1 0 1 00 0 0 01 0 2 00 0 0 0=========(3,3 )==================y 방향=========1 0 1 00 0 0 01 0 2 00 0 2 0=========(3,3 )==================x 방향=========1 0 1 00 0 0 01 0 2 20 0 2 0=========(3,4 )==================y 방향=========1 0 1 00 0 0 01 0 2 20 0 2 2=========(3,4 )==================x 방향=========1 0 1 00 0 0 01 0 2 20 0 2 2=========(4,3 )==================y 방향=========1 0 1 00 0 0 01 0 2 20 0 2 2=========(4,3 )==================x 방향=========1 0 1 00 0 0 01 0 2 20 0 2 44Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int N;int map[101][101];ll dp[101][101];int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= N; j++) {            cin &gt;&gt; map[i][j];        }    }    memset(dp, 0, sizeof(dp));    dp[1][1] = 1;    dp[N][N] = 0;    for (int y = 1; y &lt;= N; y++) {        for (int x = 1; x &lt;= N; x++) {            if (dp[y][x] == 0 || (y == N &amp;&amp; x == N)) continue;            int d = map[y][x];            if (y+d &lt;= N) dp[y+d][x] += dp[y][x];            if (x+d &lt;= N) dp[y][x+d] += dp[y][x];        }    }    cout &lt;&lt; dp[N][N] &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EC%A0%90%ED%94%84.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ec-9d-b4-eb-8f-99-ed-95-98-ea-b8-b0-html": {
        "title": "백준(11048번): 이동하기",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획법 문제이다.백준(11048번) - 이동하기생각DFS나 BFS로는 depth가 깊어져 시간초과가 난다. 이 문제는 동적계획법으로 풀어야 한다. 그저 최대 사탕의 개수만 출력하면 되기 때문이다.정의이 문제는 위치에 따라 개수가 결정되므로 dp의 인자를 좌표의 위치로 잡는 것이 수월하다.  dp[y][x] = (y,x)위치에서 가질 수 있는 사탕 개수의 최댓값점화식이 정의에 부합하는 점화식은 어떤식으로 짤 수 있을까? 점화식은 임의의 좌표 위치에서 이 좌표가 만들어지기 위해 어떤 좌표와의 연관성이 있는지를 확인하면 된다. 문제에서 특정 위치에서 갈 수 있는 방향은 우, 좌, 대각이다. 그렇다면 특정 위치에서의 사탕의 최댓값은 좌, 우, 10시방향 대각선 세 방향의 값으로 부터 도출될 수 있다.  dp[y][x] = max(dp[y-1][x], dp[y][x-1], dp[y-1][x-1]) + input[y][x]주의할 점(1, 1)에서 시작하므로 (1, 1), (1행, 1), (1, 1열)의 위치에서는 3방향에서 업데이트를 할 수 없다. 이 점을 고려하여 분기를 만들어 코드를 짜는 것이 좋다.#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N, M;int map[1001][1001];int dp[1001][1001];int main(){   cin &gt;&gt; N &gt;&gt; M;   for (int i = 1; i &lt;= N; i++) {       for (int j = 1; j &lt;= M; j++) {           cin &gt;&gt; map[i][j];           if (i == 1 &amp;&amp; j == 1) dp[i][j] = map[i][j];       }   }   for (int y = 1; y &lt;= N; y++) {       for (int x = 1; x &lt;= M; x++) {           if (y == 1 &amp;&amp; x == 1) {               continue;           } else if (y == 1){               dp[y][x] = max(dp[y][x], dp[y][x-1]);           } else if (x == 1){               dp[y][x] = max(dp[y][x], dp[y-1][x]);           } else {               dp[y][x] = max(dp[y][x], dp[y-1][x]);               dp[y][x] = max(dp[y][x], dp[y][x-1]);               dp[y][x] = max(dp[y][x], dp[y-1][x-1]);           }           dp[y][x] += map[y][x];       }   }   cout &lt;&lt; dp[N][M] &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ec-8a-a4-ed-83-80-ed-8a-b8-ec-99-80-eb-a7-81-ed-81-ac-html": {
        "title": "백준(14889번): 스타트와 링크",
        "tags": "백준, 알고리즘, dfs, 재귀",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : dfs 문제이다.백준(14889번) - 스타트와 링크생각기본적인 dfs 문제이다. 반으로 나눈 팀에 대한 점수를 더하는 것이므로, true false를 통해 구현할 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N;int map[21][21];bool check[21];int ans = 987654321;void go(int count, int start){    if (count == N/2) {        int start, link;        start = link = 0;        for (int i = 1; i &lt;= N; i++) {            for (int j = 1; j &lt;= N; j++) {                if (check[i] &amp;&amp; check[j]) start += map[i][j];                if (!check[i] &amp;&amp; !check[j]) link += map[i][j];            }        }        ans = min(ans, abs(start-link));        return;    }    for (int i = start; i &lt;= N-(N/2)+count+1; i++) {        check[i] = true;        go(count+1, i+1);        check[i] = false;    }}int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= N; j++) {            cin &gt;&gt; map[i][j];        }    }    go(0, 1);    cout &lt;&lt; ans &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%99%80-%EB%A7%81%ED%81%AC.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-eb-b0-9c-ec-a0-84-ec-86-8c-html": {
        "title": "백준(1102번): 발전소",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드1 : 동적 계획법 문제이다.백준(1102번) - 발전소생각dp의 정의는 간단하게 생각할 수 있다. 특정한 상태의 발전소로 오는 방법은 몇가지로 정해지기 때문이다. 그래서 정의를 잡으면 다음과 같다.정의  dp[상태] = 발전소의 상태에서의 발전소를 고치는데 발생하는 비용의 최솟값그렇다면 상태는 어떻게 정의할 수 있을까?비트마스크YNN은 100으로 생각할 수 있다. 그렇다면 이 상태에서 다음상태로는 어떻게 갈 수 있을까?  켜져있는 발전소를 확인한다.  해당 발전소에서 꺼져있는 발전소를 확인한다.  꺼져있는 발전소를 킨다.  다른 상태에서 또 같은 상태로 올 때, 최소값으로 업데이트 한다.주의할 점초기값을 모두 -1로 만든 상태에서 값을 출력하는 것이 좋다. 만들지 못하는 경우를 출력하기 위함이다. 또한 0개의 발전소를 키라는 조건에서 -1을 리턴하면 안되고 0을 리턴해야 한다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N;int a[17][17];string str;int dp[1&lt;&lt;16];int p;int main(){    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt; N; j++) {            cin &gt;&gt; a[i][j];        }    }    int start = 0;    for (int i = 0; i &lt; N; i++) {        char temp;        cin &gt;&gt; temp;        if (temp == 'Y') start += (1&lt;&lt;i); // YNN -&gt; 001로 저장한다. 이진수의 shift연산 중에는 이게 편하다.    }    cin &gt;&gt; p;    // 기본 dp의 값을 -1로 해둔다.    // 일단 다 못 만든다고 가정하는 것    memset(dp, -1, sizeof(dp));    dp[start] = 0;    //  start에서 dp값은 0이다. 최소값이 0    for (int i = 0; i &lt; (1&lt;&lt;N); i++) {        if (dp[i] == -1) continue; // 상태에 대한 최소값이 없다면 진행할 수 없다.        for (int j = 0; j &lt; N; j++) {   // 발전소를 순차적으로 체크하며 다음 상태를 만든다.            if (i&amp;(1&lt;&lt;j)){    // 현재 발전소의 상태중 j번째 발전소가 있다면                for (int k = 0; k &lt; N; k++) {                    if ((i&amp;(1&lt;&lt;k)) == 0){   // 현재 발전소의 상태에서 j번째 발전소를 가지고 k위치의 발전소를 키려고 할때 k위치 발전소가 꺼져있다면                        if (dp[i|(1&lt;&lt;k)] == -1 || dp[i|(1&lt;&lt;k)] &gt; dp[i] + a[j][k]) {                            dp[i|(1&lt;&lt;k)] = dp[i]+a[j][k];                        }                    }                }            }        }    }    int ans = -1;    for (int i = 0; i &lt; (1&lt;&lt;N); i++) {        if (dp[i] == -1) continue;        int count = 0;        for (int j = 0; j &lt; N; j++) {            if (i&amp;(1&lt;&lt;j)) count++;        }        if (count &gt;= p) {            if (ans == -1 || ans &gt; dp[i]) ans = dp[i]; // ans를 -1로 했기 때문에 처음에 scope들어오기 위해 조건 추가        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EB%B0%9C%EC%A0%84%EC%86%8C.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ea-b0-80-ec-9e-a5-ea-b8-b4-eb-b0-94-ec-9d-b4-ed-86-a0-eb-8b-89-eb-b6-80-eb-b6-84-ec-88-98-ec-97-b4-html": {
        "title": "백준(11054번): 가장 긴 바이토닉 부분 수열",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 동적 계획법 문제이다.백준(11054번) - 가장 긴 바이토닉 부분 수열생각dp의 정의는 간단하게 생각할 수 있다. 이 문제는 가장 긴 감소하는 부분 수열, 가장 긴 증가하는 부분 수열을 합한 문제이다.정의  dp1[i] = i번째 원소를 포함했을 때 발생하는 가장 감소하는 부분 수열의 길이  dp2[i] = i번째 원소를 포함했을 때 발생하는 가장 증가하는 부분 수열의 길이점화식  dp1[i] = dp1[j]+1 단, a[i] &lt; a[j]  dp2[i] = dp2[j]+1 단, a[i] &gt; a[j]  ans = max(ans, dp1[i]+dp2[i]-1)Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N;int a[1001];int dp1[1001];int dp2[1001];int ans = 0;int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; a[i];    fill(dp1+1, dp1+N+1, 1);    fill(dp2+1, dp2+N+1, 1);    for (int i = N; i &gt;= 1; i--) {        for (int j = N; j &gt;= i; j--) {            if (a[i] &gt; a[j]) dp1[i] = max(dp1[i], dp1[j] + 1);        }    }    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= i; j++) {            if (a[i] &gt; a[j]) dp2[i] = max(dp2[i], dp2[j] + 1);        }    }    for (int i = 1; i &lt;= N; i++) {        ans = max(ans, dp1[i]+dp2[i]-1);    }    cout &lt;&lt; ans &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EB%B0%94%EC%9D%B4%ED%86%A0%EB%8B%89-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ea-b0-80-ec-9e-a5-ea-b0-90-ec-86-8c-ed-95-98-eb-8a-94-eb-b6-80-eb-b6-84-ec-88-98-ec-97-b4-html": {
        "title": "백준(11722번): 가장 감소하는 부분 수열",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 동적 계획법 문제이다.백준(11722번) - 가장 감소하는 부분 수열생각dp의 정의는 간단하게 생각할 수 있다.정의  dp[i] = i번째 원소를 포함했을 때 발생하는 가장 감소하는 부분 수열의 길이점화식현재 상태의 가장 감소하는 부분 수열의 길이는, 이전의 원소들이 가지고 있는 가장 감소하는 부분 수열의 길이에 종속적이다. 이 때, 업데이트하는 규칙이 필요한데, 내가 현재 가지고 있는 원소가 이전 원소의 크기보다 작다면 업데이트 하면 된다.  dp[i] = dp[j]+1 단, a[i] &lt; a[j]Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N;int a[1001];int dp[1001];int ans = 0;int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; a[i];    fill(dp+1, dp+N+1, 1);    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= i; j++) {            if (a[i] &lt; a[j]) dp[i] = max(dp[i], dp[j] + 1);            ans = max(ans, dp[i]);        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EA%B0%80%EC%9E%A5-%EA%B0%90%EC%86%8C%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4.html"
      }
      ,
    
      "cs-algorithm-2020-04-14-eb-b0-b1-ec-a4-80-four-squares-html": {
        "title": "백준(17626번): Four Squares",
        "tags": "백준, 알고리즘, 동적 계획법",
        "date": "April 14, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버5 : 동적 계획법 문제이다.백준(17626번) - Four Squares생각생각 보다 힘들게 푼 문제이다. n이 50000이고, 시간 제한이 0.5초이기 때문에 완전탐색으로 풀면 힘들 것이라 생각했다. 그래서 동적 계획법 방법으로 풀이를 채택했다.이 문제는 동전 문제와 비슷하게 생각해야 한다. 결국 몇개의 제곱수가 최소로 필요하냐는 문제인데, 사실 1로 모든 수를 만들 수 있기 때문에 더해지는 숫자의 개수가 늘어남에 따라 최소 개수로 업데이트를 해주는 것이 맞다.정의  dp[i] = i을 만드는데 있어 필요한 최소 숫자의 갯수정의는 1차원 다이나믹이지만, 계속 업데이트를 해주어야 한다. 업데이트를 하게 되면 최종적으로 4번하면 i을 만드는데 있어 필요한 최소 제곱수의 갯수 로 정리될 수 있다. (문제에 이미 증명되었다고 한다)점화식  dp[i] = min(dp[i], dp[j*j]+dp[i-j*j])잘 생각해보자. n이라는 숫자를 만들기 위해 필요한 개수는 dp[n-i*i]로 부터 올 수 밖에 없다. 제곱수를 더하여 해당 수가 만들어지기 때문이다.n = n-1*1 + 1*1  = n-2*2 + 2*2  = n-3*3 + 3*3  ...  = n-sqrt(n)*sqrt(n) + sqrt(n)*sqrt(n)그렇다면, dp역시 이 관계가 적용되나 생각해보자. 9에서 발생하는 최소 개수를 만들기 위해서는 (8에서 발생하는 최소 개수 + 1에서 발생하는 최소 개수) 그리고 (5에서 발생하는 최소 개수 + 4에서 발생하는 최소 개수), (3에서 발생하는 최소 개수 + 0에서 발생하는 최소 개수)를 비교하면 된다. 이 때 뒤에서 발생하는 최소 개수(1, 4, 0)은 모두 제곱수 이다. 하지만 앞은 제곱수가 아니기 때문에 1보다 큰 숫자를 가지고 있을 것이다. 하지만 업데이트 하는 과정에서 계속해서 숫자가 작아지고, 이것은 문제에서 증명된 사실과 같이 4를 초과할 수 없다. 설명이 너무 어렵다                   0      1      2      3      4      5      6      7      8      9                  1      0      1      2      3      1      5      6      7      8      1              2      0      1      2      3      1      2      3      4      2      1              3      0      1      2      3      1      2      3      0      0      1              4      0      1      2      3      1      2      3      0      0      1      1은 한번의 제곱수까지 사용했을 때 표현할 수 있는지를 나타낸 것이다. 5는 제곱수가 아니므로 초기값을 INF로 잡는다. 그 다음으로 2개의 숫자까지 사용했을 때 필요한 개수를 생각해보자. (1, 4), (2, 3)에서 올 수 있는데, dp값을 더했을 때 최솟값이 2이므로 5는 2개의 제곱수를 사용했을 때 2개를 더하면 만들어진다. 이렇게 모두를 업데이트 하면, 2개의 숫자를 사용했을 때 필요한 제곱수의 최소개수를 업데이트 할 수 있다. 3개의 숫자까지 사용한다면, 여전히 방법을 똑같다. 하지만 이미 dp에 있는 값은 그 숫자를 표현하기 위해 필요한 최소 숫자의 개수를 대변하고 있다. 따라서 업데이트를 하면 자동적으로 최소 개수로 업데이트 된다. 여기서 핵심은 m개의 숫자까지를 사용했을 때 최소숫자의 개수라는 것이다. 즉 열 방향으로도 dp의 정의가 적용되고 있다. 마찬가지로 4번째 숫자까지 사용했을때 업데이트를 진행하면 답이다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;int N;int dp[50001];int main(){    cin &gt;&gt; N;    fill(dp, dp+N+1, INF);    for (int i = 1; i &lt;= N; i++) {        if (int(sqrt(i))*int(sqrt(i)) == i) dp[i] = 1;        else dp[i] = i;    }    for (int k = 0; k &lt; 3; k++) {        for (int i = 1; i &lt;= N; i++) {            for (int j = 1; j &lt;= int(sqrt(i)); j++) {                dp[i] = min(dp[i], dp[j*j]+dp[i-j*j]);            }        }    }    cout &lt;&lt; dp[N] &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/14/%EB%B0%B1%EC%A4%80-Four-Squares.html"
      }
      ,
    
      "cs-algorithm-2020-04-13-eb-b0-b1-ec-a4-80-eb-95-85-eb-94-b0-eb-a8-b9-ea-b8-b0-html": {
        "title": "백준(6171번): 땅따먹기",
        "tags": "백준, 알고리즘, 동적 계획법, Convex Hull",
        "date": "April 13, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플레티넘1 : 동적 계획법, Convex Hull 문제이다.백준(6171번) - 땅따먹기생각일단 완전 탐색을 생각해 본다. 음.. 말도 안된다. 몇개를 겹쳐서 만드는지 완전탐색을 한다면 시간 복잡도가 $O(n!)$ 이다. 이 문제는 그냥 직관적으로 동적 계획법 냄새가 난다. 어떠한 조건에서 특정 위치까지의 땅의 최소값이 다음을 구하는데 영향을 줄 것 같기 때문이다.정의  dp[n] = n번째 땅까지 구매했을 때 비용의 최솟값이렇게 정의했다면, 이제는 점화식을 어떻게 세울지 고민해야 한다. n번째 땅까지 구매했을 때 비교해봐야 하는 값들을 나열해 보자.  n번째 땅을 그냥 산다. 그리고 n-1까지의 최소값과 더한다.  n-1번째 땅과 묶어서 계산해본다. 그리고 n-2까지의 최솟값과 더한다.  n-2번째 땅과 묶어서 계산해본다. 그리고 n-3까지의 최솟값과 더한다.…호오. 가능할 것 같은 냄새가 난다. 이렇게 할 경우 $O(n^2)$ 까지 줄일 수 있을 것 같다.dp[i] = min(dp[j-1] + j부터 i까지의 땅을 합쳐 산 금액)이 것을 수식으로 정리해보면, 위와 같다. 그렇다면 j부터 i가지의 땅을 합쳐 산 금액은 어떻게 구할까?j부터 i가지의 땅을 합쳐 산 금액실제로 땅을 사본다고 생각한다. 가장 빨리 직관을 얻는 것은 그림을 그려보는 것이다. 결국 이 문제는, 땅을 구입하는데 있어서 이걸 통짜로 한번에 사버린다는 얘기와 같다.입력이 100 1, 20 20이 들어왔다고 생각하자. 이 부분에 해당하는 땅을 그리면 위와 같다. 그런데, 내가 이 두 땅을 합친다고 생각하면 결국 중요한 것을 최대 너비와 최대 높이이다. 아까 위에서 본 것처럼 결국 dp[i]을 구하기 위해서는 맨 아래 땅부터 포함해서 위쪽 땅을 1개, 2개 3개 … 를 선택하여 합쳐야 한다. 그렇다면, 땅을 합치는 데 있어서 3개를 합친다면, 3개의 땅의 너비와 높이를 다 비교해서 얻어내야 하는데.. 굳이 그래야 할까?정렬하기굳이 그럴 필요 없다. dp[i]을 구하는데 있어서 무조건 포함해야 하는 땅은 i번째 땅이다. 그렇다면 내가 합치고 싶은 범위의 땅은 j번째 땅이다. 이 두땅을 각각 ground[i], ground[j] 라 하겠다.땅을 구하는데 있어서 위의 문제처럼 일일히 최댓값을 구하지말고, 이렇게 하면 좋겠다.  ground[i] = 합칠 땅의 최대 height  ground[j] = 합칠 땅의 최대 width이러면, 시간 복잡도 $O(1)$에 가능하다..!필요없는 땅 제거그런데 정렬을 하다보니 이런 땅도 있다.음.. 이런 땅은 어쩌지? 잘 생각해보면, 이 땅은 필요없다. 이미 땅을 살 때, 포함되는 땅이기 때문이다. 예를 들어 20 20을 구매한다면, 15 15는 합쳐살 경우 자연스레 구매하게 되는 땅이다. 합쳐사지 않는 다면 오히려 비용만 늘기 때문에 결국 이 땅은 최소값을 구하는데 도움이 되지 않는 땅이다. 또한 이 땅을 배열에 갖고 있게 된다면, 우리가 위에서 만들고 싶은 정렬 규칙에 위배되므로써 상수시간 안에 구하는 것이 어려워진다. 따라서 이런 조건에 해당하는 땅은 제거한다.  정렬한 땅에서, 지금 땅의 높이보다 다음 땅의 높이가 크면 추가한다.점화식  dp[i] = min(dp[j-1] + (ground[j].w * ground[i].h)) &gt; (단, i &gt;= j &gt;= 1)Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Square {    ll w, h;};int N;vector&lt;Square&gt; temp;vector&lt;Square&gt; ground;vector&lt;ll&gt; dp;bool compare(Square a, Square b){    if (a.w == b.w) return a.h &lt; b.h;    return a.w &gt; b.w;}int main(){    cin &gt;&gt; N;    temp.resize(N);    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; temp[i].w &gt;&gt; temp[i].h;    }    sort(temp.begin(), temp.end(), compare);    ground.push_back(temp[0]);    ground.push_back(temp[0]);    for (int i = 1; i &lt; N; i++) {        Square next = temp[i];        Square now = ground.back();        if (next.h &gt; now.h) ground.push_back(next);    }    int size = int(ground.size());    dp.resize(size);    for (int i = 1; i &lt; size; i++) {        dp[i] = dp[i-1] + ground[i].w * ground[i].h;        for (int j = i; j &gt; 0; j--) {            dp[i] = min(dp[i], dp[j-1] + (ground[j].w * ground[i].h));        }    }    cout &lt;&lt; dp[size-1] &lt;&lt; '\\n';    return 0;}Convex Hull하지만.. 플레티넘의 위엄이 있다. 이렇게 풀면 시간초과가 난다. 당연히 입력이 1000000이기 때문에 최악의 경우 $O(n^2)$ 이다. 그래서 여기서는 추가적인 최적화가 필요하다.",
        
        "url": "/cs/algorithm/2020/04/13/%EB%B0%B1%EC%A4%80-%EB%95%85%EB%94%B0%EB%A8%B9%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-12-eb-b0-b1-ec-a4-80-ed-81-90-eb-b9-99-html": {
        "title": "백준(5373번): 큐빙",
        "tags": "백준, 알고리즘, 규현, 시뮬레이션",
        "date": "April 12, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드1 : 구현, 시뮬레이션 문제이다.백준(5373번) - 큐빙Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int T, n;void clockwise(vector&lt;vector&lt;char&gt;&gt;&amp;a){    char temp = a[0][0];    a[0][0] = a[2][0];    a[2][0] = a[2][2];    a[2][2] = a[0][2];    a[0][2] = temp;    temp = a[0][1];    a[0][1] = a[1][0];    a[1][0] = a[2][1];    a[2][1] = a[1][2];    a[1][2] = temp;    return;}void U(vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt;&amp;a){    vector&lt;vector&lt;char&gt;&gt; temp = a[5];    a[5] = a[0];    a[0] = a[4];    a[4] = a[1];    a[1] = temp;    clockwise(a[1]); clockwise(a[1]);    clockwise(a[4]); clockwise(a[4]);    clockwise(a[2]);    clockwise(a[3]); clockwise(a[3]); clockwise(a[3]);    return;}void F(vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt;&amp;a){    vector&lt;vector&lt;char&gt;&gt; temp = a[2];    a[2] = a[5];    a[5] = a[3];    a[3] = a[4];    a[4] = temp;    clockwise(a[2]);    clockwise(a[4]);    clockwise(a[3]);    clockwise(a[5]);    clockwise(a[1]); clockwise(a[1]); clockwise(a[1]);    clockwise(a[0]);    return;}void L(vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt;&amp;a){    // 0 -&gt; 2 -&gt; 1 -&gt; 3    vector&lt;vector&lt;char&gt;&gt; temp = a[0];    for (int i = 0; i &lt; 3; i++)    {        a[0][i][0] = a[3][i][0];        a[3][i][0] = a[1][i][0];        a[1][i][0] = a[2][i][0];        a[2][i][0] = temp[i][0];    }    clockwise(a[4]);    return;}void R(vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt;&amp;a){    // 0 -&gt; 3 -&gt; 1 -&gt; 2    vector&lt;vector&lt;char&gt;&gt; temp = a[0];    for (int i = 0; i &lt; 3; i++)    {        a[0][i][2] = a[2][i][2];        a[2][i][2] = a[1][i][2];        a[1][i][2] = a[3][i][2];        a[3][i][2] = temp[i][2];    }    clockwise(a[5]);    return;}int main(void){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; T;    char command, clock;    for (int tc = 0; tc &lt; T; tc++) {        vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt; cube;        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'w')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'y')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'r')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'o')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'g')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'b')));        cin &gt;&gt; n;        for (int i = 0; i &lt; n; i++)        {            cin &gt;&gt; command &gt;&gt; clock;            int k = 1;            if (clock == '-') k = 3;            if (command == 'U')            {                U(cube);                for (int j = 0; j &lt; k; j++) R(cube);                for (int j = 0; j &lt; 3; j++) U(cube);            }            else if (command == 'D')            {                U(cube);                for (int j = 0; j &lt; k; j++) L(cube);                for (int j = 0; j &lt; 3; j++) U(cube);            }            else if (command == 'F')            {                F(cube);                for (int j = 0; j &lt; k; j++) L(cube);                for (int j = 0; j &lt; 3; j++) F(cube);            }            else if (command == 'B')            {                F(cube);                for (int j = 0; j &lt; k; j++) R(cube);                for (int j = 0; j &lt; 3; j++) F(cube);            }            else if (command == 'L')            {                for(int j = 0; j &lt; k; j++) L(cube);            }            else if (command == 'R')            {                for (int j = 0; j &lt; k; j++) R(cube);            }        }        for (int i = 0; i &lt; 3; i++)        {            for (int j = 0; j &lt; 3; j++)                cout &lt;&lt; cube[0][i][j];            cout &lt;&lt; '\\n';        }    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/12/%EB%B0%B1%EC%A4%80-%ED%81%90%EB%B9%99.html"
      }
      ,
    
      "cs-algorithm-2020-04-12-eb-b0-b1-ec-a4-80-ec-88-98-ed-95-99-ec-9d-80-eb-84-88-eb-ac-b4-ec-89-ac-ec-9b-8c-html": {
        "title": "백준(2904번): 수학은 너무 쉬워",
        "tags": "백준, 알고리즘, 소수, 소인수 분해, 에라토스테네스의 체, 수학",
        "date": "April 12, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 수학 문제이다.백준(2904번) - 수학은 너무 쉬워생각문제 이름 부터 뭔가 마음에 들지 않았다. 풀이 방법은 바로 떠올랐는데 왜 요즘 이런게 구현이 안되는지… score가 최대공약수를 구하는 것이기 때문에 소인수 분해를 떠올릴 수 있고, 그러기 위해서는 소수를 구해야 한다. 그러니 소수를 구하는 가장 빠른 알고리즘인 에라토스 테네스의 체를 떠올릴 수 있다.규칙의 이해            8      24      9                  $2^3$      $2^3\\cdot 3$      $3^2$      문제의 입력은 다음과 같다. 이 때 A,B를 정해서 문제에서 원하는 규칙에 따라 진행하는 것은, 각각의 수를 이루는 소수들 중 하나를 떼서 준다로 압축할 수 있다.            A : 8-&gt;4      24      B : 9-&gt;18                  $2^2$      $2^3\\cdot3$      $2\\cdot 3^2$      이런 규칙을 가지고 문제에서 원하는 것을 구하기 위해서는 어떠한 상황이여야 하는지 생각해 보자.최대 숫자  내가 가진 소인수의 개수를 서로에게 나눠주는 과정 속에서 최대한 잘 나눠가졌을 때, 공통된 숫자가 무엇이냐?상당히 공리주의적 관점이다. 위의 조건을 만족하려면 각각이 가진 개수를 모두 파악한 후, 인원수로 나눈것이 모두가 고루고루 나누는 최종 숫자이다.            8      24      9      1728      12                  $2^3$      $2^3\\cdot 3$      $3^2$      $2^6\\cdot3^3$      $2^2\\cdot 3$      이 문제에서는 12라는 숫자가 답이 될 수 있겠다.최소 이동 횟수이제 답이 되는 후보를 알았다. 각각의 숫자를 그 숫자를 위해 움직여야 하는 횟수가 있을 것이다.            8      24      9                  $2^3$      $2^3\\cdot 3$      $3^2$              2      1      3        8의 경우 12가 되기 위해서 2를 버리고 3을 얻어야 한다.  24의 경우 2를 버려야 한다.  9의 경우 2를 2개 얻고, 3을 버려야 한다.총 6번의 움직임이 필요하지만, 이것은 하나의 행동이 2번씩 중복되어 나타났다. 이 것을 해소하기 위해서는 최종적으로 답을 내기 위해 2로 나누거나, 하나의 행동만을 제약해서 counting을 하면 된다. (답이 요구하는 개수보다 작을 경우만 센다)구현구현하기 위해 필요한 것을 생각해본다.에라토스테네스의 체에라토스테네스의 체는, 소수를 구하는 방법 중 가장 빠른 방법이다.에라토스테네스의 체  n까지의 소수는 $\\sqrt{n}$ 범위 안에있는 소수를 가지고 구할 수 있다.          소인수 분해를 하면, 해당 수의 제곱근 보다 작은 소인수를 가지고 모든 약수를 구할 수 있다.        소수의 배수는 소수가 아니다.120까지의 소수를 구하기 위해서는 $\\sqrt{120} = 10.9…$즉, 11보다 작은 수, 10까지의 수를 가지고 120까지의 소수를 구할 수 있다.알고리즘void SieveOfEratosthenes(){    for (int i = 2; i &lt;= MAX; i++)        isPrime[i] = true;    for (int i = 2; i*i &lt;= MAX; i++) {        if (!isPrime[i]) continue;        for (int j = i*i; j &lt;= MAX; j+=i)            isPrime[j] = false;    }}이 때, j를 $i^2$ 부터 탐색하는 것에 주목하자. i 이전의 배수들은 그 전의 소수가 이미 걸렀기 때문이다. 해당 알고리즘의 시간 복잡도는 $n\\cdot \\sqrt{n}$ 이다.나머지 필요한 것들  에라토스테네스의 체를 통해 얻은 소수를 저장할 변수가 필요하다.          vector&lt;int&gt; primelist        각각의 입력되는 숫자에 대해 소인수 분해를 하여 담아둘 변수가 필요하다.          vector&lt;vector&lt;int&gt;&gt; input (n, vector&lt;int&gt; (primeNumberSize, 0))      n개의 숫자에 대해 1000000까지 발생하는 소수의 개수 만큼의 배열이 필요하다.      j는 발생하는 소수를 오름차순으로 정렬했을 때의 index이다.        전체 소인수들의 개수를 저장할 변수가 필요하다.          vector&lt;int&gt; whole (primelist.size(), 0)      이제 해야 할 일은 순서도를 작성하는 것이다.알고리즘  에라토스테네스의 체로 1000000까지의 소수를 구한다.  이 소수를 primelist에 저장한다.  primelist의 개수만큼 whole, input 의 크기를 공간을 만든다.  각각의 input이 어떻게 소인수 분해되는지 구한다.  구하는 도중에 전체 배열에 추가한다.  다 구했다면 최종적으로 위에서 구한 방법으로 답을 구한다.Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long ll;#define MAX 1000000bool isPrime[MAX + 1];int whole[MAX + 1];//vector&lt;int&gt; primelist;int N;void SieveOfEratosthenes(){    for (int i = 2; i &lt;= MAX; i++)  isPrime[i] = true;    for (int i = 2; i*i &lt;= MAX; i++) {        if (!isPrime[i]) continue;//        primelist.push_back(i); // 여기다 추가하면 1000 범위내의 소수만 들어간다..        for (int j = i*i; j &lt;= MAX; j+=i) isPrime[j] = false;    }}int main(){    SieveOfEratosthenes();    cin &gt;&gt; N;    vector&lt;int&gt; primelist;    for (int i = 1; i &lt;= MAX; i++) if (isPrime[i]) primelist.push_back(i);    vector&lt;vector&lt;int&gt;&gt; input(N, vector&lt;int&gt;(primelist.size(), 0));    for (int i = 0; i &lt; N; i++) {        int num;        cin &gt;&gt; num;        for (int j = 0; j &lt; primelist.size(); j++) {            if (num == 1) break;            while (num % primelist[j] == 0) {                num /= primelist[j];                whole[primelist[j]]++;                input[i][j]++;            }        }    }    int ans = 1, count = 0;    for (int i = 0; i &lt; primelist.size(); i++) {        int currentWholePrimeCount = whole[primelist[i]]/N;        for (int j = 0; j &lt; N; j++) {            if (currentWholePrimeCount &gt; input[j][i])                count += (currentWholePrimeCount-input[j][i]);        }        ans *= pow(primelist[i], currentWholePrimeCount);    }    cout &lt;&lt; ans &lt;&lt; \" \" &lt;&lt; count &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/12/%EB%B0%B1%EC%A4%80-%EC%88%98%ED%95%99%EC%9D%80-%EB%84%88%EB%AC%B4-%EC%89%AC%EC%9B%8C.html"
      }
      ,
    
      "dv-c-2020-04-11-eb-b0-b0-ec-97-b4-ea-b3-bc-ed-8f-ac-ec-9d-b8-ed-84-b0-html": {
        "title": "2차원 배열과 더블 포인터",
        "tags": "c++, pointer, array",
        "date": "April 11, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "c++에서 2차원 배열과 더블 포인터의 관계에 대해 알아본다.2차원 배열과 더블 포인터",
        
        "url": "/dv/c++/2020/04/11/%EB%B0%B0%EC%97%B4%EA%B3%BC-%ED%8F%AC%EC%9D%B8%ED%84%B0.html"
      }
      ,
    
      "dv-c-2020-04-11-file-ec-9e-85-ec-b6-9c-eb-a0-a5-html": {
        "title": "파일을 사용한 입출력",
        "tags": "c++, iostream, 입출력",
        "date": "April 11, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "알고리즘 문제를 풀 때, 임의의 입출력을 만들기 위해 파일을 사용하는 경우를 알아본다.필요성알고리즘 문제를 푸는데, 예제 입출력이 너무 적다. 어떠한 랜덤 값을 만들어서 넣고싶다. 그런데 이 값이 매우 많아서 일일히 치는 것이나 어디다가 저장해놓고 콘솔에 복붙하는 건 너무 간지가 안난다. 그래서 이 과정을 파일 입출력으로 바꿔서 해본다. 이럴 경우 랜덤으로 값을 뽑기도 쉽고 뭔가더 간지가 난다.입력 (input.txt)510 40 30 50 1010 200출력 (output.txt)600Code#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;int main(){    freopen(\"input.txt\", \"r\", stdin);    freopen(\"output.txt\", \"w\", stdout);    int a, b;    cin &gt;&gt; a &gt;&gt; b;    ...    cout &lt;&lt; ans;}#define _CRT_SECURE_NO_WARNINGSscanf 대신 scanf_s를 사용하는 것은 어떠한 보안상의 문제 때문에 사용한다. 엄밀히 말하면 버퍼 때문인데, 이것은 다른 글을 참고하자. 이럴 때, 컴파일러는 오류를 내는데, 이런 오류를 무시하라는 명령이다.freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);  파일 이름  쓰기, 읽기 모드  어떤 것으로 처리할 것인지위와 같이 쓰면, 파일을 읽은 뒤에, 이것을 cin, cout으로 처리하여 읽도록 만들어 준다.",
        
        "url": "/dv/c++/2020/04/11/file-%EC%9E%85%EC%B6%9C%EB%A0%A5.html"
      }
      ,
    
      "cs-algorithm-2020-04-11-eb-b0-b1-ec-a4-80-ed-8a-b8-eb-a6-ac-ec-9d-98-eb-86-92-ec-9d-b4-ec-99-80-eb-84-88-eb-b9-84-html": {
        "title": "백준(2250번): 트리의 높이와 너비",
        "tags": "백준, 알고리즘, 트리, 유니온파인드, 재귀",
        "date": "April 11, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드2 : 트리, 유니온파인드 문제이다.백준(2250번) - 트리의 높이와 너비Root 찾기흠.. 입력으로 들어오는 node들이 순차적이지 않다는 점을 알아야 한다.이거 때매 시간 엄청 날렸다 즉, 랜덤으로 들어오는 그래프 정보를 가지고, 어떤 녀석이 tree의 root가 될 것인지 알아내야 한다. 이 과정에서 unionfind 방법을 사용한다. 트리의 자식은 부모를 따른다. 이 점을 사용하여 모든 자식이 따르는 부모을 적어둔 뒤, 최종적으로 갖는 부모가 무엇인지를 찾는다면, 해당 그래프의 root를 찾을 수 있다.트리 그리기그냥 보기에는 해당 문제는 헷갈린다.. 하지만 트리의 기본을 생각한다면 어렵지 않다. 트리는 전위탐색, 후위탐색, 중위(?)탐색이 있다. 용어보다는 의미가 중요하다.위와 같은 트리가 있다고 할 때, 전위 탐색은 좌-중-우, 후위 탐색은 우-중-좌, 중위 탐색은 중-좌-우 와 같은 방식으로 탐색하는 방법이다.이 점을 기억하고 있다면, 세가지 탐색 방법중 전위탐색을 위 문제에 적용해보자. 무조건 왼쪽 먼저 탐색한다면 오른쪽으로 가는 numbering을 하는데 있어 순차적이다.물론 나는 처음에 각 node의 좌우 node 개수를 가지고 부모 노드의 위치를 결정하려 했으나, 이 방법이 보다 효과적이었다.예외문제는 10000개의 정보가 들어올 때 발생하는 트리의 크기를 잘 정해주어야 한다는 것이다. 나는 이 부분을 생각 못하고, 그냥 세그먼트 트리의 level을 구하는 것처럼 level = ceil(log2(N))+1 과 같이 두고 문제를 풀었는데, 당연히 컴파일 에러였다.멍청이최악의 경우를 항상 생각해야 한다. 최악의 경우 10000개의 level을 가질 수 있으므로 이부분을 잘 고려해야 한다. 또한 이 정보를 저장하는 짓은 미친짓이다. 두번째 멍청이짓 10000*10000 배열이 너무 sparse 하다. 그러니, 문제에서 원하는 정보만 뽑아서 제출하는 것이 가장 좋다.Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;vector&gt;using namespace std;struct node {    int left;    int right;};int N;int a[10010] = {0};node b[10010] = {0};vector&lt;vector&lt;int&gt;&gt; map;int col = 1;vector&lt;pair&lt;int, int&gt;&gt; width;// Root 찾기int find(int num){    if (num == a[num]) return num;    return a[num] = find(a[num]);}// Tree 채우며 정보 넣기void fillTree(int num, int level){    if (num == -1) return;    fillTree(b[num].left, level+1);    map[level].push_back(col);    col++;    fillTree(b[num].right, level+1);}// 마지막 정답 찾는 과정에서 정렬 규칙bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b){    if (a.second == b.second) return a.first &lt; b.first;    return a.second &gt; b.second;}int main(){    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    vector&lt;int&gt; temp;    for (int i = 0; i &lt;= N; i++) map.push_back(temp);    // unionfind를 위해 초기 부모를 자신으로 업데이트한다.    for (int i = 1; i &lt;= N; i++) a[i] = i;    for (int i = 0; i &lt; N; i++) {        int value, left, right;        cin &gt;&gt; value &gt;&gt; left &gt;&gt; right;        if (left != -1) a[left] = value;        if (right != -1) a[right] = value;        b[value].left = left;        b[value].right = right;    }    int root = find(1);    fillTree(root, 1);    pair&lt;int, int&gt; ans = {0,0};    for (int i = 1; i &lt;= N; i++) {        int size = int(map[i].size());        if (size == 0) break;        sort(map[i].begin(), map[i].end());        int width = map[i][size-1]-map[i][0]+1;        if (ans.second &lt; width) {            ans.first = i;            ans.second = width;        }    }    cout &lt;&lt; ans.first &lt;&lt; \" \" &lt;&lt; ans.second &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/11/%EB%B0%B1%EC%A4%80-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EB%86%92%EC%9D%B4%EC%99%80-%EB%84%88%EB%B9%84.html"
      }
      ,
    
      "cs-algorithm-2020-04-11-eb-b0-b1-ec-a4-80-ec-a2-8c-ed-91-9c-ec-95-95-ec-b6-95-html": {
        "title": "백준(18870번): 좌표 압축",
        "tags": "백준, 알고리즘, 정렬, 집합, 파라메트릭 서치, 이진 탐색",
        "date": "April 11, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 파라메트릭 서치 문제이다.백준(18870번) - 좌표 압축Root 찾기처음에 또다시 해시로 풀려고 하다가, 중간에 입력값의 범위가 후덜덜한 것을 보고 풀이 방법을 바꾸었다. 이 문제를 그냥 linear하게 풀려고 하면 100000번을 linear하게 탐색해야 하기 때문에 터져버린다.그래서! 이 문제는 파라메트릭 서치로 풀이한다. 하나의 질문에 대해 몇번이 필요한지 사실 결정되어 있다. 입력되는 것들을 집합화 하고, 이것들을 정렬하면, index가 곧 해당 입력의 압축된 좌표이다.  입력52 4 -10 4 -9            집합화      2      4      -10      -9                  정렬      -10      -9      2      4              index      0      1      2      3      잘 보면, 집합화 한 원소를 정렬한 뒤, 이것들을 배열에 넣었을 때, index가 곧 해당 원소의 압축된 좌표이다.따라서, 이제는 입력된 순서대로 이 index를 찾아주기만 하면 된다. 이 때, 찾는 방법으로 이진 탐색을 사용하면 된다.Code#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int N;set&lt;int&gt; s;int arr[1000001];int net[1000001];int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; arr[i];        s.insert(arr[i]);    }    int idx = -1;    for (auto iter = s.begin(); iter != s.end(); iter++) {        idx++;        net[idx] = *iter;    }    for (int i = 0; i &lt; N; i++) {        int start = 0, end = idx;        int now = arr[i];        while (start &lt;= end) {            int mid = (start+end)/2;            if (net[mid] &gt; now) {                end = mid-1;            } else if (net[mid] &lt; now){                start = mid+1;            } else {                cout &lt;&lt; mid &lt;&lt; \" \";                break;            }        }    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/11/%EB%B0%B1%EC%A4%80-%EC%A2%8C%ED%91%9C%EC%95%95%EC%B6%95.html"
      }
      ,
    
      "cs-algorithm-2020-04-11-eb-b0-b1-ec-a4-80-eb-b0-b0-html": {
        "title": "백준(1092번): 배",
        "tags": "백준, 알고리즘, 그리디, 정렬",
        "date": "April 11, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드2 : 그리디, 정렬 문제이다.백준(1092번) - 배생각실제로 운송물을 움직인다고 생각해보자. 그렇다면 가장 무거운 하중을 움직일 수 있는 크레인이 가장 많이 움직여야 최단 시간에 짐을 움직일 수 있다. 이부분이 핵심이다. 그리고 짐을 움직일 수 없는 경우는, 가장 무거운 하중을 움직일 수 있는 크레인이 가장 무거운 하중을 못옮길 때이다.알고리즘  가장 무거운 하중을 옮길 수 있는 순서로 정렬한다.  하중도 무거운 하중부터 정렬한다.  가장 무거운 하중을 옮길 수 있는 크레인이 가장 무거운 하중을 옮길 수 있는지 확인한다.  옮길 수 없다면 -1을 출력한다.  옮길 수 있다면 가장 무거운 하중을 옮기는 크레인 부터 무거운 하중 부터 옮긴다.  이 과정을 모든 하중을 옮길 때까지 반복하고 그 때까지 걸리는 시간을 출력한다.Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;using namespace std;int N, M;int crane[51];vector&lt;int&gt; box;int main(){    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; crane[i];    }    cin &gt;&gt; M;    for (int i = 0; i &lt; M; i++) {        int temp;        cin &gt;&gt; temp;        box.push_back(temp);    }    sort(crane, crane+N, greater&lt;&gt;());    sort(box.begin(), box.end(), greater&lt;&gt;());    if (box[0] &gt; crane[0]) {        cout &lt;&lt; -1 &lt;&lt; '\\n';        return 0;    }    int loaded = 0, index = 0, count = 0;    while (loaded != int(box.size())) {        for (int i = 0; i &lt; M; i++) {            if (crane[index] &gt;= box[i] &amp;&amp; box[i] != 0) {                box[i] = 0;                loaded++;                index++;            }            if (index == N) break;        }        count++;        index = 0;    }    cout  &lt;&lt;  count &lt;&lt; '\\n';    return 0;;}",
        
        "url": "/cs/algorithm/2020/04/11/%EB%B0%B1%EC%A4%80-%EB%B0%B0.html"
      }
      ,
    
      "cs-network-2020-04-09-ec-bb-b4-ed-93-a8-ed-84-b0-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-03-http-html": {
        "title": "03: HTTP",
        "tags": "Network, HTTP",
        "date": "April 9, 2020",
        "author": "",
        "category": "CS/Network",
        "content": "HTTP Protocol 특징 (간략)  HyperText Transport Protocol  Message 종류 두 가지          Request &amp; Response        TCP 사용          Transport Layer 위에 Application Layer 존재        stateless protocol          상대방 상태정보를 저장하지 않음      그냥 request, response후 아무것도 저장 안한다.      Non-Persistent HTTPRequest Message 를 서버로 보내기 위해선 우선 TCP Connection이 선행되어야 한다. 그리고 request msg 에 대해서 response msg 를 받게되면 TCP Connection 은 끊기며 다시 웹사이트의 리소스를 들고오기 위해선 TCP Connection 을 재차 맺어야한다. Connection 이 지속적인 상태가 아니다.  HTTP client가 IP/PORT에 TCP 연결을 시작한다.  HTTP server의 host는 80번 포트에서 TCP 연결을 기다리다가 문제가 없으면 “accept” 라고 client에게 알린다.  HTTP client는 HTTP request 메시지를 TCP 연결 Socket에 보낸다.  HTTP server는 요청을 받고 response를 socket에 넣는다.  HTTP sever는 TCP 연결을 끊는 준비를 한다.  HTTP client는 응답을 받고 화면에 보여준다.  HTTP client가 다 받았다면 다 받았다는 메시지를 보낸다.  함께 Connection을 끊는다.Persistent HTTP웹클라이언트 (브라우저) 는 보통 같은 사이트에 여러 개의 TCP 커넥션을 맺는다. 예를 들어 웹 페이지에 첨부된 이미지들 대부분은 같은 웹사이트에 있으며, 여러 하이퍼링크도 같은 사이트를 가리키는 경우가 있다. 여기서 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹 페이지의 다른 이미지 등을 가져오기 위해서 그 서버에 또 다시 요청하는 경우가 생기는데, 이 속성을 사이트 지역성(Site Locality)이라고 부른다. 하지만 이러한 TCP 커넥션을 계속 유지하여 앞으로도 있을 HTTP 요청에 재사용할 수 있도록 하는 것이다. 처리가 완료된 이후에도 계속 연결된 상태로 있는 TCP 커넥션을 Persistent Connection 이라고 한다.ReferenceKOCW 이석복 교수님 - 컴퓨터네트워크",
        
        "url": "/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-03-HTTP.html"
      }
      ,
    
      "cs-network-2020-04-09-ec-bb-b4-ed-93-a8-ed-84-b0-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-02-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-eb-84-93-ea-b2-8c-eb-b3-b4-ea-b8-b0-2-html": {
        "title": "02: 네트워크 넓게 보기 Part 2",
        "tags": "Network, TCP, Socket, overview",
        "date": "April 9, 2020",
        "author": "",
        "category": "CS/Network",
        "content": "기본 용어 정리네트워크  프로그램을 동작시키는 프로세스의 일종, 메시지 교환, 송수신Net + Work 의 합성어이다. 메세지를 교환하며 송수신을 한다. 좀 더 추가하자면 두 대 이상의 디바이스가 논리적 혹은 물리적으로 연결되어 통신이 가능한 상태임을 말한다.IPC(Inter Process Communication)프로세스는 완전히 독립된 실행객체이다. 서로 독립되어 있다는 것은 다른 프로세스의 영향을 받지 않는다는 장점이 있다. 그러나 독립되어 있기 때문에 별도의 설비가 없이는 서로 간에 통신이 어렵다는 문제가 있으며, 이를 위해 커널 영역에서는 IPC라는 내부 프로세스간 통신(Inter Process Communication)을 제공한다. 이 기능을 사용하여 프로세스는 프로세스간 통신이 가능케 한다.Socket  프로세스간 통신 interfaceIPC를 가능케하는 interface이다. 서로 다른 process에서 접속을 하려 할 때, 이 socket을 사용하여 접근하게 되고, 해당 socket은 접속하는 process가 제대로 왔는 지와 같은 검사를 수행하게 된다. 은행에서 창구를 생각하면 된다.사용자 입장에서 소켓을 통해 메시지를 내려받을 때, 원하는 요구사항  timing          빠른 시간내에 데이터가 도착했으면 좋겠다. (음성)        security          안전하게 나한테만 왔으면 좋겠다.        data integrity          모든 데이터가 순서에 맞게 제대로 왔으면 좋겠다.        Throughput          특정 시간안에 도착하는 데이터의 양이 많았으면 좋겠다. (영화 다운로드)      등이 있지만, 실질적으로 TCP를 사용한다고 가정했을 때 제공받을 수 있는 것은 3번 뿐이다. UDP를 사용할 경우 3번도 지켜지지 않는다. 결과적으로 내가 위의 3가지에 해당하는 기능을 원한다면, 애플리케이션 계층에서 구현하여야 한다.IP  인터넷 공간 상에서 해당 단말기의 고유 주소Socket을 통해 통신한다는 것은 알았다. 근데 우리가 전화를 걸더라도, 어디에 전화를 걸것인지 알아야 한다. 그걸 대표하는 것이 전화번호이다. 마찬가지로 통신을 하려면, 어디에 통신할 것인지 알려주는 과정이 필요하다. 그 어디에 해당하는 것이 IP 주소 이다.Port  IP 주소를 갖고 있는 컴퓨터에서 Process에 접근하기 위한 번호해당 컴퓨터에 들어가더라도, 어떤 process에 접근하는지를 알아야 한다. 그걸 대표하는 것이 포트 번호이다. 특정 프로토콜은 특정한 포트번호로 설정되어 있다.예를 들어 웹 서버의 포트 번호는 기본적으로 80번 포트로 약속되어 있다.DNS  도메인이름을 치면 IP주소로 바꿔주는 서비스naver.com -&gt; 192.168.03.2 OR 192.168.03.2:80TCP 특징 (간략)  Transmission Control Protocol  Reliable Transport          신뢰성 있는 전송 (패킷 유실없이 감 : 패킷이 유실되지 않는다는 것이 아니다.)        Flow Control          수신 호스트의 데이터 처리속도를 고려하여 속도를 조절        Congestion Control          네트워크 상황에 맞게 속도 조절      UDP 특징 (간략)  User Datagram ProtocolTCP와 완전 반대이다. 어떠한 규약없이 server가 그냥 보낸다.ReferenceKOCW 이석복 교수님 - 컴퓨터네트워크",
        
        "url": "/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-02-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%93%EA%B2%8C-%EB%B3%B4%EA%B8%B0-2.html"
      }
      ,
    
      "cs-network-2020-04-09-ec-bb-b4-ed-93-a8-ed-84-b0-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-01-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-eb-84-93-ea-b2-8c-eb-b3-b4-ea-b8-b0-1-html": {
        "title": "01: 네트워크 넓게 보기 Part 1",
        "tags": "Network, Router, Protocol, Bandwidth, Traffic, Delay, overview",
        "date": "April 9, 2020",
        "author": "",
        "category": "CS/Network",
        "content": "기본 용어 정리프로토콜  서로 다른 개체들이 서로 간의 의사소통을 하기 위해 만들어놓은 규약사람이 대화를 하는 과정에도 일정한 흐름과 규약이 존재한다. 어떠한 객체가 소통하기 위해서는 서로의 방식을 맞추어야 한다.패킷  한번에 전송할 데이터의 크기편지를 내가 썼다. 그 편지를 누군가한테 보내는데, 글자하나하나를 보내지 않는다. 이 때 편지는 우체부 아저씨가 누군가한테 배달하는 단위가 된다. 이와 같은 개념이 패킷이다. 패킷은 데이터를 보내는 데 있어 발생하는 단위이다. 이 패킷의 구조에 대해서는 나중에 알아보자.대역폭  수도관의 크기결국 데이터는 흐름이다. 그렇기 때문에 어떤 관을 따라간다고 생각할 수 있다. 이 때 관의 지름이 대역폭이다. 한번에 보낼 수 있는 데이터의 양이라 생각하면 된다. 이 크기가 클수록 많은 데이터를 초 당 전송할 수 있는 양이 늘어난다. 인터넷 속도와 직결된다.트래픽  어떤 통신장치나 시스템에 걸리는 부하(전송량)요청에 대해 전송해주는 시간 대비 데이터의 총량을 말한다.네트워크 구조네트워크 엣지(Network Edge)  말단 device, 우리가 사용하는 대부분의 기기에 해당한다.네트워크 코어(Network Core)  엔드 시스템을 연결하기 위한 중간의 매개들을 말한다.물리적 링크  코어와 엣지 사이에 존재하는 데이터 전송 선과 같은 것들을 의미한다.네트워크의 내부라우터네트워크 내부에 존재하는 장치(네트워크 코어)들로써, 라우터는 사용자들이 보낸 메세지를 목적지까지 전달하는 역할을 가지고 있다. 결국 라우터는 데이터를 전달하는 장치이다.라우터의 데이터 전달방식      Circuit Switching          출발지부터 목적지까지의 대역폭을 예약해놓은 상태로써, 한번에 데이터를 전달하는 것이다. 하나의 회선을 할당받아 (회선을 독점하여) 데이터를 전달하기 때문에 아무런 방해없이 한번에 전달할 수 있다. 예시로 전화망이 있다. 전화를 걸게되면 전화를 건 송신자로부터 수신자의 전화기에 이르기까지의 경로를 찾아내고, 한번 설정된 송신자와 수신자의 경로는 데이터(음성) 이 전송되는 동안 계속 유지되는 것이다. 이 예로 부터 Circuit Switching은 언제든지 계속 사용하는 시스템에 적합하다는 것을 알 수 있다.                  장점      단점                  대역폭이 결정되므로, delay가 발생할 수 없다.      일정 사용자에게 할당해주므로 낭비가 발생한다.            Packet Switching          사용자가 보내는 데이터가 패킷단위로 잘게 나뉘어서 전달되는 것이다. 패킷은 출발지에서 다음 라우터로 전송하기 이전에 저장하고 어느 경로로 갈지 결정하는 Store and Forward 방식을 취한다. 패킷의 헤더에는 출발지(source) 와 목적지(destination) 에 대한 정보가 들어있다. 대부분의 경우는 이 사용법을 택한다. 인터넷을 사용하는 패턴이 Packet Switching 에 적합하기 때문이다. 연속된 요청이 필요없기 때문에 대역폭을 할당할 필요가 없다.                  장점      단점                  짧게 사용하는 다수의 사용자도 커버가 가능하다.      짧은 시간에 많은 요청이 들어올 경우 delay가 발생한다.      Packet Delay패킷스위칭을 시 라우터는 패킷단위의 데이터를 전달받고 목적지로 전달하는 역할을 수행한다. 이 과정에서 라우터가 보낼 수 있는 대역폭보다 더 많은 유저가 더 빠른 속도로 데이터를 보낸다면 딜레이가 생길 수 밖에 없다. 톨게이트에 사람이 마구 몰리는 상황을 상상해보자.Delay의 구분Processing Delay  패킷 자체를 평가한다.필연적인 딜레이 중 하나로써, 목적지에 따른 어느 라우터로 전송할 지 결정하는 것에 대한 지연이다. 이 과정에서는 패킷의 형식을 검사하고, 목적지를 판단하는 과정을 수행한다.Queueing Delay  들어온 패킷들을 줄세운다.데이터를 전달하는 라우터의 큐에 들어가서 앞서서 도착해 큐에 대기중인 패킷들이 모두 나갈때까지 걸리는 지연이다. (큐에 얼마나 많이 들어가있는지에 따라서 큐잉 딜레이는 가변적)Transmission Delay  패킷하나가 모두 전송되기 까지 걸리는 시간라우터의 큐 제일 앞에 배치되어서 패킷 하나가 온전하게 마지막 비트까지 최종 목적지로 가는데까지의 지연이다. 패킷은 전송의 한 단위이기 때문에, 하나의 패킷이 모두 전송이 되어야 sender는 전송이 되었다고 판단한다. 예를 들면 패킷의 bit가 100bits이고 대역폭이 1bps 이면 1초당 1bit만 전송할 수 있기 때문에 100초 후에 이 패킷은 전송되었다고 판단할 수 있다.Propagation Delay  실제로 비트가 선을 따라 전송되는데 걸리는 시간마지막 비트까지 대역폭에 올라오고, 이후에 마지막 비트가 최종 목적지까지 도달하는 물리적 시간이다. 이 속도는 전자기파의 속도라 사실 많은 영향을 주지는 않는다. ( 가까우면 빨리, 거리가 멀면 오래 걸림)결과적으로 라우터에서 패킷을 받을 때 걸리는 nodal delay 는 위 4가지의 지연의 합으로 표현된다.Delay 줄이기Processing Delay라우터에 좋은 처리장치를 달아서 패킷에 대해 판단하는 속도를 향상시킨다.Queueing Delay사용자의 패턴에 의존하기 때문에 불가능하다. 통계적 기법을 사용해야 한다.Transmission Delay패킷하나가 빠져나가는 시간을 줄인다. 초당 선송할 수 있는 양을 늘리면 된다. 마치 톨게이트에서 5차선이었던 것을 10차선으로 바꾸면 한번에 빠져나갈 수 있는 차량의 수가 증가한다. 이 때, 이 차선에 대응되는 개념이 대역폭이다.Propagation Delay빛의 속도는 세상에서 가장 빠르다.. 불가능하다.Packet Loss  큐에 패킷이 가득차있는 경우 버려진다.라우터의 큐에 삽입되기 이전에 큐에 패킷이 가득차있는 경우 큐의 저장공간이 없기 때문에 Packet Loss 가 발생하며, 패킷은 버려진다.TCP 작동이런 경우 안전한 전송을 담당하는 Client 쪽의 TransportLayer 계층의 TCP 프로토콜이 해당 패킷을 재전송한다. 잘 몰라도 된다. 나중에 배운다.ReferenceKOCW 이석복 교수님 - 컴퓨터네트워크",
        
        "url": "/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-01-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%93%EA%B2%8C-%EB%B3%B4%EA%B8%B0-1.html"
      }
      ,
    
      "cs-algorithm-2020-04-08-eb-b0-b1-ec-a4-80-ea-b8-b0-ed-83-80-eb-a0-88-ec-8a-a8-html": {
        "title": "백준(2343번): 기타 레슨",
        "tags": "백준, 알고리즘, 파라메트릭 서치, 이분 탐색",
        "date": "April 8, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 이분 탐색, Parametric Search 문제이다.백준(2343번) - 기타 레슨생각처음에 이 문제를 풀 때, 세그먼트 트리로 풀려고 했다. 그런데, 문제가 생겼다. 그렇게 구현하려면, 100000개 를 50000개의 블루레이에 담으려고 한다면 계속해서 재귀 함수를 타고 들어가며 구해야 한다. 시간 제한이 2초이고, 또한 재귀함수의 depth가 너무 깊어져 이 방향으로 문제를 해결하면 안된다고 판단했다.고민을 하던 중, 답을 먼저 제안하고, 이 답을 기반으로 역으로 추적하면 어떨까하는 생각이 들었다. 이 방법을 파라메트릭 서치(parametric Search)라 한다.Parametric Search  최적화 문제를 결정 문제로 바꾸어 해결한다.이진 탐색과 비슷한 방법이다. 그런데 어떤 상황에서 사용하는지 알아야 한다. 위의 문제는 결국, N개의 입력이 들어왔을 때, 이걸 M개로 나누고, M개로 나눈 각각의 뭉텅이들 사이에서 최댓값들을 뽑아 그것의 최솟값을 구하는 문제이다. (응?)  입력 N을 M개의 집합으로 자른다. 다양한 가지수로 자를 수 있다. 이 가지수를 K라 하자.  그 집합들의 합을 갖고 있는다.  그 요소들을 가지는 집합 L를 만든다. (K의 요소 개수는 M개, 발생하는 집합 L의 개수는 K개)  발생한 모든 L 집합에 대해 요소들의 최댓값을 구한다. 그 최댓값을 모은 집합을 P라 하자. (P의 요소 개수는 K개)  P집합의 요소들 중 최소값을 구한다.완전 탐색을 한다면 위와 같이 할 수 있을 것이다. 그런데, 결국 이 문제는 최적의 디스크 크기를 구하는 문제이다. 이런 문제에서 새로운 발상을 할 수 있는데, 답은 제안하는 것이다.방법이 문제에서 내가 원하는 것은 disk 크기를 구하는 것이다. 이 disk 크기가 될 수 있는 최솟값과 최댓값을 계산해보자. N = 100000 이고, 각각의 동영상 용량은 10000이 최대이므로, 이 동영상 모두를 한 disk에 넣는다면 1000000000크기가 최대이다. 일단 이해를 하는 과정이기에 최댓값을 100이라 가정하겠다.과정은 이분 탐색과 비슷하다. 답이 될 수 있는 최소, 최대에서 반이 답이 되는지 되지 않는지 판단한다.너무 디스크 크기가 작다면 오른쪽을 탐색한다.너무 디스크 크기가 크다면 왼쪽을 탐색한다.위의 과정을 반복하여 답을 도출한다.결국 위 방법의 핵심은, 원하는 답의 범위를 설정하고 이 값이 되는지 안되는지를 파악한다. 이다. 이러한 방법을 사용하기로 마음 먹었다면, 어떠한 조건에서 탐색의 방향을 바꿀 수 있는지, 해당 문제의 특징은 무엇인지 확인해야 한다.문제의 특징  M개의 disk를 사용했을 때, disk 크기가 가장 줄어들 수 있다.  만약 10개의 disk를 사용할 수 있다고 하자. 그렇다면 답은 N을 10개로 나누었을 때 가장 작게 나눌 수 있다.  물론 10개보다 적은 수의 disk를 사용해서 나누었을 때 10개를 사용했을 때의 답과 같게 나올 수는 있다.  따라서 10개보다 적은 수의 disk를 사용할 경우에도 답을 업데이트 해주는 대상이 된다.  또한 M개의 disk를 사용할 수 있는 모든 경우의 수를 비교해야 한다. 처음에 M개로만 나뉘면 답이라 해서 틀렸다. ㅠ탐색 조건  제시한 블루레이 Size를 가지고 만들었을 때 나온 값이 M보다 크면 Size를 키운다.제시한 Size를 가지고 N를 최대한 나눈 결과 가지고 있는 블루레이 갯수(M)보다 disk가 더 필요하다는 결론이 나오면, 현재 disk 사이즈가 너무 작아 더 필요로 한다는 결론이다. 따라서 disk 크기를 키워야 한다.  제시한 블루레이 Size를 가지고 만들었을 때 나온 값이 M보다 작으면 지금 제시한 값을 업데이트 한다.나온 값과 이전에 탐색한 답 중 최솟값으로 업데이트 한다.  제시하는 답은 video의 값보다는 항상 같거나 커야한다.1 2 3 4 5 라는 video가 들어온다고 가정하자. 이 때, 내가 제시하는 답은 5보다 항상 같거나 커야 한다. 만약 3이라는 답을 제시한다면 4와 5는 disk에 들어갈 수도 없으므로 논리에서 벗어난다.Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int video[100000];int N, M, ans = 1e9;bool isOk(int value){    int sum = 0, count = 1;    for (int i = 0; i &lt; N; i++) {        if (value &lt; video[i]) return false;        if (sum + video[i] &gt; value) {            sum = video[i];            count++;        }        else sum += video[i];        if (count &gt; M) return false;    }    return true;}int main(){    cin &gt;&gt; N &gt;&gt; M;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; video[i];    }    int left = 0, right = 1e9;    while (left &lt;= right) {        int mid = (left+right)/2;        if (isOk(mid)) {            ans = min(ans, mid);            right = mid - 1;        } else {            left = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/04/08/%EB%B0%B1%EC%A4%80-%EA%B8%B0%ED%83%80-%EB%A0%88%EC%8A%A8.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-20-eb-94-94-ec-8a-a4-ed-81-ac-ec-8a-a4-ec-bc-80-ec-a4-84-eb-a7-81-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "20: 디스크 스케쥴링 알고리즘",
        "tags": "OS, Disk, Disk Scheduling",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "하드 디스크의 구조를 바탕으로 스케쥴링을 하는 방법에 대해 알아본다.1. 디스크 스케줄링보조기억장치는 현재 여러 가지 존재하지만 아직까지는 하드 디스크가 주로 사용된다.하드 디스크의 구조는 앞서 살펴봤듯이 위 그림과 같다. 디스크에 접근하는 시간은 Seek time(탐색 시간) + rotational delay + transfer time 으로 계산할 수 있는데, 이 중에서 seek time(head를 움직이는 시간)이 가장 크다.현재 컴퓨터 환경은 대부분 다중 프로그래밍 환경이다. 그러므로 여러 프로세스가 메인 메모리에서 실행 중에 있는데, 이러한 여러 프로세스가 동시에 디스크를 읽으려는 요청이 올 수 있다. 이와 같은 요청이 오면 디스크 역시 CPU와 같이 디스크 큐(dist queue)에서 요청을 저장해두고 이를 처리해야 한다.여기서 컴퓨터의 성능을 위해 여러 요청들을 효율적으로 처리해야 한다. 디스크를 읽는 시간은 매우 오래 걸리는 작업이고 특히 탐색 시간이 오래걸리므로 최대한 이 시간을 줄이는 것이 중요하다. 이러한 방법들을 디스크 스케줄링 알고리즘이라 한다.1.1 FCFS(First-Come First-Served)이 방법은 어느 스케줄링 알고리즘에서도 존재하는 가장 간단하고 가장 공평한 방법이다. 바로 예제를 살펴보자.1.1.1 예제200 cylinder dist: 0, 1, 2, ..., 199Disk queue: 98, 183, 37, 122, 14, 124, 65, 67현재 헤드가 가리키는 실린더(cylinder) 위치: 53예제를 그림으로 나타내면 위 그림과 같다. 가로축은 0번부터 199번까지 실린더의 위치를 나타낸다. 여기서 파란색 선이 dist queue를 FCFS 방법으로 처리한 결과이다.  헤드가 움직인 총 거리          = (98 - 53) + (183 - 98) + (183 - 37) + (122 - 37) + (122 - 14) + (124 - 14) + (124 - 65) + (67 - 65) = 640 cylinders      위 그림의 결과를 본 것처럼 큐에 들어온 순서가 큰 값, 작은 값이 반복한다면 헤드가 움직이는 거리가 매우 커짐을 알 수 있다.1.2 SSTF(Shortest-Seek-Time-First)SSTF 스케줄링 알고리즘은 가장 짧은 탐색 시간을 먼저 선택하는 것이다. 다시 말하면 현재 헤드가 다음 요청을 처리하기 위해 움직여야 하는 거리가 가장 짧은 것을 선택하는 것이다.1.2.1 예제200 cylinder dist: 0, 1, 2, ..., 199Disk queue: 98, 183, 37, 122, 14, 124, 65, 67현재 헤드가 가리키는 실린더(cylinder) 위치: 53위 예제는 FCFS 스케줄링에서 본 예제와 같은 것이다. 처음 헤드 위치 53을 시작으로 dist queue에 있는 실린더 번호 중 53과 가장 가까운 65번 실린더를 선택한다. 65번에서는 가장 가까운 67번을 선택하고 같은 과정을 반복한다.  헤드가 움직인 총 거리          = (65 - 53) + (67 - 65) + (67 - 37) + (37 - 14) + (98 - 14) + (122 - 98) + (124 - 122) + (183 - 124) = 236 cylinders      SSTF 스케줄링 알고리즘의 결과는 위 예제에서 FCFS 스케줄링보다 훨씬 적은 수의 실린더를 움직이는 것을 볼 수 있다. 하지만 SSTF 스케줄링의 큰 단점은 기아(starvation)가 발생할 수 있다. dist queue에는 지속적으로 새로운 프로세스의 요청이 들어오기 때문에 헤드와 멀리 떨어져 있는 실린더는 끝내 수행하지 못하는 현상이 발생하는데, 이를 starvation이라고 한다.그리고 SSTF 스케줄링이 현재와 가장 가까운 실린더를 선택한다고 해서 최적의 알고리즘은 아니다. 위 예제에서도 가장 처음 위치인 53번 실린더에서 65번이 아닌 37번으로 이동한 후에 SSTF 알고리즘을 수행하면 208 cylinders 가 나온다.그리디가 아니다1.3 ScanScan 스케줄링은 말그대로 헤드가 지속적으로 디스크를 앞뒤로 검사하는 것이다. 그래서 헤드가 앞으로 스캔할 때(번호가 작은 실린더 방향)와 뒤로 스캔할 때(번호가 큰 실린더 방향) 선택하는 실린더가 서로 다르다. 즉 관성을 고려하여 한방향으로 쭉 가다가 끝이면 반대 방향으로 돈다.1.3.1 예제200 cylinder dist: 0, 1, 2, ..., 199Disk queue: 98, 183, 37, 122, 14, 124, 65, 67현재 헤드가 가리키는 실린더(cylinder) 위치: 53스캔 방향: 0번 방향으로 움직임(번호가 작은 실린더 방향)위 결과에서 볼 수 있듯이 스캔 방향이 0번 실린더 방향이므로 53번에서 작은 번호의 실린더로 향한 후에 큰 번호 실린더로 움직인 것을 볼 수 있다.  헤드가 움직인 총 거리          = (53 - 37) + (37 - 14) + (14 - 0) + (65 - 0) + (67 - 65) + (98 - 67) + (122 - 98) + (124 - 122) + (183 - 124) = 236 cylinders      여기서 한 가지 생각해 볼 점은 일반적으로 프로세스들이 디스크에 요청할 때 그 위치를 종합해보면 실린더에 골고루 퍼져있다. 그러므로 Scan 스케줄링 알고리즘처럼 앞뒤로 움직이는 것이아니라 처음부터 한 방향으로 끝까지 움직이고 다시 처음으로 되돌아가서 같은 방향으로 끝까지 움직이는 것이 더욱 효과적이다.이러한 아이디어에서 나온 것이 Circular Scan 스케줄링 알고리즘이다.1.4 C-Scan이 방식은 위에서 말한 Circular Scan 스케줄링 알고리즘이다. 즉 한 방향으로 계속 움직이는 것이다. Scan 방식은 끝에 다다랐을 때 반대방향으로 가는데, 굳이 그럴 필요가 없다. 물론 오른쪽에서 왼쪽 끝으로 갈 때 한바퀴를 돌기 때문에 움직이는 거리는 더 길어질 수 있지만 다시 처음 위치로 되돌아갈 때는 데이터를 읽지 않으므로 더 빠른 속도로 움직일 수 있다. (그냥 모터로 슝 긁으면 된다.)1.5 Look이 알고리즘은 위 Scan 스케줄링 예제에서 0번 실린더가 존재하지 않지만 0번까지 가는 모습을 보았다. (찍턴하기 위해서) 이러한 비효율적인 움직임을 없애기 위해 존재하는 실린더의 최소와 최대 범위만 움직이는 알고리즘을 Look 스케줄링 알고리즘이라고 한다. 하지만 이 범위를 알기 위해서 미리 큐를 검사해야한다. (어디가 가장 근접한 끝인지 알아야 하기 때문)1.6 C-LookC-Look은 Circular Look 을 말한다. Look은 위에서 Scan 스케줄링이 0번 부터 끝 실린더까지 움직이지 않고 존재하는 실린더의 최소에서 최대 범위를 움직인다고 하였는데, C-Look은 이 범위에서 C-Scan과 같이 한 방향으로만 움직이는 것을 말한다. 즉, 최대 실린더에서 최소 실린더 방향으로 움직인다고 할 때 최소 범위에 도달하면 다시 최대 범위로 되돌아가서 같은 방향으로 움직인다.1.7 Elevator AlgorithmElevator Algorithm은 Scan과 파생되어 나온 알고리즘(C-scan, Look, C-Look)을 부르는 다른 용어이다. 위 Scan 스케줄링 알고리즘 예제 그림을 90도로 회전하면 엘리베이터의 모습과 유사하여 붙여진 이름이다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-20-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-19-ed-8c-8c-ec-9d-bc-ed-95-a0-eb-8b-b9-html": {
        "title": "19: 파일 할당 (Allocation of file)",
        "tags": "OS, Memory, frame allocation",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "보조 기억 장치에 저장되는 파일의 할당에 대해 알아본다.컴퓨터 시스템 자원 중 가장 중요한 것은 CPU이다. CPU 자원 관리에 대해서는 맨 처음 부분에서 다루었으며 CPU 스케줄링, 프로세스 동기화 등에 대해서 배웠다. CPU 다음으로 중요한 자원은 메인 메모리와 같은 주기억장치이다. 메인 메모리 관리에 대한 주요 이슈는 페이징, 가상 메모리(요구 페이징) 등이 있었다.CPU, 주기억장치 다음 중요한 컴퓨터 시스템 자원은 하드디스크와 같은 보조기억장치이다. 하드디스크가 데이터를 관리하는 방식은 파일 시스템이다. 파일은 컴퓨터에서 운영체제를 사용해본 사용자라면 매우 익숙한 단어일 것이다. 대표적인 windows 운영체제를 보면 폴더(디렉토리) 내부에 또 다른 폴더 또는 어떠한 파일이 존재한다. 이러한 폴더 및 파일은 트리 구조로 관리할 수 있다.이번 장에서는 보조기억장치 중 컴퓨터에서 주로 사용하는 하드디스크의 파일이 할당되는 방법에 대해서 살펴볼 것이다.1. HDD 구조위 그림은 하드디스크의 구조이다.  platter          실제 데이터를 기록하는 자성을 가진 원판이다. platter는 그림과 같이 여러 개가 존재하고 앞뒤로 사용할 수 있다. 한 platter는 여러 개의 track으로 이루어져 있다.        track          platter의 동심원을 이루는 하나의 영역이다.        sector          하나의 track을 여러 개로 나눈 영역을 sector라 한다. sector size는 일반적으로 512 bytes이며 주로 여러 개를 묶어서 사용한다.        cylinder          한 cylinder는 모든 platter에서 같은 track 위치의 집합을 말한다.      앞서 sector는 여러 개로 묶어서 사용한다고 했는데, 이를 블록(block)이라 한다. 하드디스크는 블록 단위로 읽고 쓰기 때문에 block device 라고 불리기도 한다.하드디스크가 블록 단위로 읽고 쓰는 것을 확인할 수 있는 간단한 방법은 메모장 프로그램에서 알파벳 a만을 적고 저장해보자. a는 character로 1byte 크기를 갖는데, 실제 저장된 텍스트 파일의 속성을 확인하면 디스크에 4KB(하나의 block size) 가 할당되는 것을 확인할 수 있다.(실제 디스크 할당 크기는 운영체제마다 다르다.)따라서 디스크는 비어있는 블록들의 집합이라고 볼 수 있다.(pool of free blocks) 그렇다면 운영체제는 각각의 파일에 대해 free block을 어떻게 할당할까?2. 파일 할당위 그림은 pool of free blocks를 논리적인 그림으로 나타낸 모습이고 블록마다 인덱스 번호를 설정하였다. 블록들이 위와 같이 있을 때 파일을 할당하는 방법은 크게 연속 할당, 연결 할당, 색인 할당 세 가지가 존재한다.2.1 연속 할당 (Contiguous Allocation)연속 할당은 말그대로 연속된 블록에 파일을 할당 하는 것이다. 예를 들어, 블록 크기가 1KB이고, 할당할 파일은 f1, f2, f3 3개가 있고 각각의 크기는 5KB, 3KB, 4KB이다.앞선 예제로 연속 할당을 수행하면 위의 그림과 같은 모습이 나온다.2.1.1 연속할당의 장점연속 할당에는 세 가지 특징이 있다.  연속 할당의 장점은 디스크 헤더의 이동을 최소화 할 수 있다.          I/O 성능을 높일 수 있다. 이 방식은 예전의 IBM에서 사용하던 방법이며 주로 동영상, 음악, VOD 등에 적합하다.        순차 접근(Sequential Access)이 가능하다.          이는 말그대로 순서대로 파일을 읽을 수 있다는 의미이다.        직접 접근(Direct Access)이 가능하다.          운영체제는 파일의 정보를 디렉토리(directory) 라는 테이블에 저장한다. 디렉토리에서 사용자가 접근가능한 정보는 파일의 이름, 크기, 날짜 등이 있고, 운영체제 내부에서 접근하는 정보는 해당 파일의 시작 블록 번호와 같은 것이 있다. 예를 들어, 위 예제의 f1 파일의 디렉토리 정보는 아래와 같다.      file name: f1file size: 5 bytes...-----------------block number: 0연속 할당은 순차적으로 저장되어 있으므로 운영체제는 디렉토리에서 얻은 시작 블록 번호로 원하는 블록에 바로 접근할 수 있다. 예를 들어, 위 예제에서 f1 파일의 3번째 블록에 접근하고 싶다고 가정하자. 운영체제는 f1의 시작 블록 번호가 0번인 것을 알고 있기 때문에 2번 블록에 접근하면 f1의 3번째 블록이라는 것을 알 수 있다.2.1.2 연속할당의 단점연속 할당은 현재에는 거의 사용하지 않는 방식인데, 이 방법에는 큰 단점이 존재하기 때문이다.  외부 단편화 문제가 발생한다.          파일을 할당하고 지우고를 반복하다보면 중간 중간에 빈 공간(hole)이 생기는데 연속 할당은 연속된 공간을 찾아야 하기 때문에 이전 메인 메모리 할당에서 살펴본 것과 같이 외부 단편화 문제가 발생한다.      외부 단편화로 인해 디스크 공간의 낭비가 매우 심해진다. 이전 메모리 할당에서 외부 단편화로 인해 메모리의 약 1/3을 낭비한다고 하였는데, 디스크의 연속 할당도 같은 낭비가 발생한다.        파일을 저장할 때 실제 크기를 알 수 없다.          특히, 계속해서 사용하는 파일의 경우 크기가 계속 증가 할 수 있기 때문에 이를 지속해서 연속적으로 할당하기에는 매우 부적절하다.      2.2 연결 할당 (Linked Allocation)연결 할당은 연속 할당의 문제점을 해결하기 위해 나온 방법으로, 연속적으로 할당하는 것이 아니라 링크드 리스트(linked list) 와 같은 방식으로 파일을 할당한다위 그림은 block 크기가 1 byte, 파일 f1의 크기가 5 bytes 일 때 연결 할당을 수행한 모습이다. 각 블록의 마지막에 주소를 저장하는 포인터 공간(4bytes)이 존재하며, 여기서 다음 블록을 가리키고 있다. 마지막 블록의 포인터 공간에는 끝임을 나타내는 값이 저장되어 있다.이러한 파일을 linked list of data blocks 라고 하며, f1의 파일 디렉토리 정보는 아래와 같다.file name: f1file size: 5 bytes...-----------------block number: 62.2.1 연결할당의 장점  위치와 상관없이 할당이 가능하므로 외부 단편화 문제가 없다. (= 디스크 낭비가 없다.)          연결 할당을 사용해서 새로운 파일을 할당할 때는 비어있는 임의의 블록을 첫 블록으로 선택하며, 만약 파일이 커지는 경우 다른 블록을 할당해서 기존의 블록과 연결만 해주면 된다.      2.2.2 연결할당의 단점하지만, 연결 할당 역시 여러 문제점을 가지고 있다.  순차 접근은 가능하지만 직접 접근은 불가능하다.          파일의 블록들은 모두 흩어져 있으므로 시작 블록 번호를 가지고는 원하는 위치의 블록에 바로 접근할 수는 없다.        포인터를 저장하는 4 bytes 이상의 손해가 발생한다.  낮은 신뢰성          중간 블록의 포인터가 끊어지면 그 이후의 모든 블록에 접근하지 못한다.        느린 속도          블록이 모두 흩어져 있으므로 디스크 헤더의 움직임이 그 만큼 많이 발생한다.      2.2.3 FAT(File Allocation Table) 시스템위 문제점을 개선하기 위해 나온 것이 같은 연결 할당 방식인 FAT(File Allocation Table) 시스템이다. FAT 시스템은 다음 블록으르 가리키는 포인터들만 모아서 하나의 테이블(FAT)을 만들어 한 블록에 저장한다.위 그림은 앞선 예제의 f1 파일을 FAT 파일 시스템 방식으로 저장한 모습이다. 0번 블록에 저장된 FAT를 보면 테이블의 인덱스는 전체 디스크의 블록 번호이며, 각 인덱스마다 다음 블록 번호를 저장하고 있다.FAT 시스템을 사용하면 기존의 연결 할당의 문제점 대부분을 해결할 수 있다. FAT를 한 번만 읽으면 직접 접근이 가능하고, FAT만 문제가 없다면 중간 블록에 문제가 생겨도 FAT를 통해 그 다음 블록은 여전히 읽을 수 있다. 그리고 FAT는 일반적으로 메모리 캐싱을 사용하여 블록 위치를 찾는데는 빠르지만 실제 디스크 헤더가 움직는 것은 블록이 흩어져 있으므로 여전히 느리다고 볼 수 있다. 마지막으로 FAT는 매우 중요한 정보이므로 손실 시 복구를 위해 이중 저장을 한다.FAT의 각 인덱스 크기는 전체 블록의 개수를 저장할 만큼의 크기를 가지고 있어야 하는데, 현재는 일반적으로 32bit 크기를 사용($2^{32}$)한다. 이를 FAT32라고 부른다.(이전에는 FAT16, FAT12 등이 있었다.)2.3 색인 할당 (Indexed Allocation)색인 할당 역시 연결 할당과 같이 데이터를 랜덤한 블록 번호에 할당하지만 할당된 블록 번호(포인터)를 하나의 블록에 따로 저장한다. 이러한 블록을 인덱스 블록이라고 부르며, 파일 당 하나의 인덱스 블록이 존재한다. 색인 할당은 디렉토리 정보가 다른 할당과 다른데, 시작 블록 번호를 저장하는 것이 아니라 인덱스 블록 번호를 저장한다.2.3.1 예제            block size      f1      f2                  1byte      5byte      2byte      file name: f1file size: 5 bytes...-----------------index block number: 11file name: f2file size: 2 bytes...-----------------index block number: 27그림을 보면, 블록 하나를 지정하여, 파일의 인덱스를 저장하는 인덱스 블록으로 사용한다.색인 할당은 인덱스 블록에 할당된 블록을 순서대로 저장하기 때문에 직접 접근이 가능하다. 그리고 연속적으로 할당할 필요가 없으므로 외부 단편화 문제 또한 발생하지 않는다. 색인 할당은 Unix/Linux에서 주로 사용한다.색인 할당의 단점은 작은 크기의 파일인 경우에도 하나의 블록을 인덱스 블록으로 사용하기 때문에 저장 공간이 손실된다. 그리고 하나의 인덱스 블록을 가지고는 크기가 큰 파일을 저장할 수 없다.예를 들어, 하나의 블록 크기가 512 bytes인 블록은 최대 저장할 수 있는 블록의 인덱스 개수가 512 / 4 bytes(포인터 크기) = 128개이다. 즉 파일의 최대 크기는,128(인덱스 블록에서 저장할 수 있는 블록의 포인터 개수의 최대값) x 512bytes(블록 하나의 크기) = 64KB로 아주 작은 크기이다. 블록 크기가 1KB이라 하더라도 최대 인덱스 개수는 256개(1000/4)이고 최대 파일의 크기는 256KB이다.2.3.2 해결 방법이를 해결하기 위한 여러 가지 방법이 있다.2.3.2.1 Linked이 방식은 인덱스 블록을 여러 개 만들어 연결 할당을 하는 것과 같다. 즉, 각 인덱스 블록의 마지막은 다음 인덱스 블록을 가리키는 포인터가 저장되어 있다.2.3.2.2 Multilevel index이 방식은 계층을 두는 방법으로 하나의 인덱스 블록의 모든 포인터가 다른 인덱스 블록을 가리킨다. 만약 이것으로 부족하면 계층을 더 만들어 간다.2.3.2.3 Combined이 방식은 Linked와 Multilevel index를 합친 방법으로 한 인덱스 블록의 포인터들은 데이터 블록과 또 다른 인덱스 블록 둘 다 가리킬 수 있다.(리눅스는 combined 방식을 사용한다.)ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-19-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-18-ed-94-84-eb-a0-88-ec-9e-84-ed-95-a0-eb-8b-b9-html": {
        "title": "18: 프레임 할당 (Allocation of frame)",
        "tags": "OS, Memory, frame allocation",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "page를 메모리에 할당하는 프레임 할당에 대해 알아본다.1. Global VS Local Replacement  Global Replacement          메모리 상의 모든 프로세스 페이지에 대한 교체 작업을 수행한다.      앞에서 배운 FIFO, OPT, LRU 등은 Victim을 정할 때, 모든 메모리에 올려져 있는 frame을 다 확인 후에 교체를 수행했다.        Local Replacement          메모리 상의 자기 자신의 프로세스 페이지에 대해서만 교체 작업을 수행한다.      지금 요청이 들어온 page가 p1이라면, 메모리상에 올라가 있는 frame 중 p1 frame만 교체의 대상으로 간주한다.      메모리 사용 효율은 일반적으로 Global Replacement가 좋다.2. 프레임 할당(Allocation of Frames)어떻게 할당하는 것이 좋은지에 대한 고민을 해본다.2.1. 쓰레싱(Thrashing)일반적으로 메모리에 올라가는 프로세스 개수가 증가할수록 CPU의 이용률은 올라갈 것이라 예상한다. 왜냐하면 프로세스가 많을 수록 CPU의 할 일 역시 증가하기때문이다. 이는 일정 범위까지는 맞는 예상이지만, 그 범위를 넘어서면 오히려 CPU 이용률이 감소하는 현상이 나타난다.위 그림은 이러한 현상을 그래프로 나타낸 것이다. 이와 같은 현상이 발생하는 이유는 프로세스가 증가할수록 메인 메모리의 비어있는 프레임 개수는 줄어들게 되고 결국 모든 프레임이 가득 차게 된다. 그 후에도 계속 프로세스가 증가한다면 메모리와 backing store 사이에 page in/out 작업이 발생하는데, 프로세스가 많아질수록 이 작업 역시 증가한다. page in/out은 디스크 I/O 작업으로 CPU를 사용하지 않는 작업이다. 그러므로 이 작업이 많아질수록 CPU는 그동안 아무것도 하지 않게 된다.위 그래프에서도 나와있듯이, I/O 작업이 증가하여 CPU 이용률이 떨어지는 현상을 Thrashing 이라 한다.2.1.1 해결 방법쓰레싱을 해결하는 방법은 크게 두 가지가 있다.  Global Replacement보다 Local Replacement를 사용하는 것이다.          하지만 이 경우에는 메모리 사용 효율이 떨어지는 단점이 있다.        프로세스당 충분한/적절한 수의 프레임(메모리)을 할당한다.그렇다면, 적절한 프레임의 수는 어떻게 정하는 것일까?2.2 프레임 할당의 방법프레임 할당은 크게 정적 할당과 동적 할당으로 나뉜다.2.2.1 정적 할당(Static Allocation)  동일 할당(Equal Allocation)          모든 프로세스에게 똑같은 수의 프레임을 할당한다. 이 방식은 프로세스의 크기에 따라 매우 비효율적이다.        비례 할당(Proportional Allocation)          프로세스의 크기에 따라 프레임을 할당한다. 이 방식 역시 단점이 있다. 프로세스 크기가 크더라도 모든 기능을 사용하지 않기 때문에 이 방식 또한 비효율적이다.      이처럼 정적 할당은 한계가 뚜렷하다. 따라서 동적 할당의 방법을 사용하는 것이 좋다.2.2.2 동적 할당(Dynamic Allocation)2.2.2.1 Working Set Model프로세스가 실행 중일 때 어느 페이지를 사용하는지 실험한 결과에서 Locality 성질이 성립한다는 것을 발견할 수 있었다. 즉, 특정 시간 대에 참고하는 부분은 일부분이다.위 그래프는 프로세스가 실행 중에 어떤 프로세스를 사용하는지 표시한 것으로, 특정 시간에는 일정 범위의 페이지를 주로 참조하는 것을 알 수 있다. 이러한 성질은 캐시에서도 볼 수 있다. 이를 통해 특정 시간에 따라 사용하는 페이지의 개수만큼 프레임을 할당해줄 수 있다.그런데 어떻게 locality를 조사할 수 있을까? 여기서 치명적인 단점이 있다. 바로 프로세스를 미리 수행해봐야 할 수 있다는 것이다. 그리고 프로세스를 수행할 때마다 사용하는 기능이 달라질 수 있으므로, Locality를 이용하는 방법은 비현실적이다.이를 해결하기 위해 나온 것이 working set 이다. working set은 위의 locality의 방식과 유사한데, 미래가 아닌 과거를 보는 것이다.위 그림은 working set을 사용하는 모습이다. working set은 현재 시간에서 일정 시간($\\Delta$) 이전동안 사용되었던 페이지의 집합이다. $\\Delta$(델타)는 운영체제 내부에서 정하는 기준에 따라 다르며, 이를 working set window 라 한다. 마지막으로 working set의 개수만큼 프레임을 할당한다.만약 현재 시간이 t1이라면 working set = {1, 2, 5, 6, 7}이다. 이 때 working set의 개수는 총 5개이므로 프레임 역시 5개를 할당해주면 된다.2.2.2.2 Page-Fault Frequency(PFF)페이지 부재의 비율은 프로세스에 할당된 프레임의 수에 반비례한다. 즉, 할당된 프레임의 수가 적을수록 페이지 부재 비율은 늘어난다.위 그림은 이와 같은 현상을 그래프로 나타낸 것이다. 세로축은 페이지 부재 비율이고, 가로축은 할당된 프레임의 수이다. 여기서 운영체제 내부에서 해당 프로세스의 페이지 부재 횟수를 계속 검사한다. 그러면 위와 같은 그래프처럼 나오는데, 여기서 상한선(upper bound)과 하한선(lower bound)를 설정한다.만약 상한선보다 많은 페이지 부재가 발생하면 프레임을 더 많이 할당해주고, 하한선보다 적게 페이지 부재가 발생하면 할당된 프레임 개수를 줄여준다.3. 페이지 크기(Page Size)현재 페이지의 일반적인 크기는 4KB ~ 4MB 이다. 이는 과거에서부터 점점 커져왔고, 현재에도 메모리 크기가 증가하면서 커지고 있다.페이지 크기에 따라 성능에는 어떤 영향을 미치는지 알아보자.3.1 페이지 크기에 따른 성능  내부단편화          내부단편화를 줄이려면 페이지 크기는 작은 것이 좋다.        Page-in, page-out 시간          페이지의 in/out 시간을 결정하는 가장 큰 요인은 하드디스크 기준으로 하드디스크의 헤더가 움직이는 시간이다.(seek time) 페이지 크기가 크면 클수록 한 번의 seek time마다 큰 페이지를 읽을 수 있으므로, 페이지 부재 빈도가 줄어든다.(데이터를 읽는 시간은 크기에 따라 차이가 매우 적다.)        페이지 테이블 크기          페이지 크기가 클수록 페이지 개수가 줄어들기 때문에 그만큼 페이지 테이블 크기도 줄일 수 있다.        Memory resolution(해상도)          Memory resolution은 해당 메모리에 필요한 데이터가 있는 확률이다. 이는 페이지 크기가 작을수록 resolution을 높일 수 있다. 만약 페이지 크기가 크면 다른 필요없는 부분이 있을 확률이 크기 때문이다.        Page fault 발생 확률          Page fault 발생 확률을 줄이려면 페이지 크기가 큰 것이 좋다. 이는 locality 성질과도 관련이 있는데, 대부분 프로세스는 필요한 부분이 일정 범위 이내인 경우가 많으므로 페이지 크기가 클수록 필요한 부분이 있을 확률이 크다.                  big      small                  Page fault 발생 확률 ▼      내부 단편화 ▼              페이지 테이블 크기 ▼      Page-in, page-out 시간 ▼                     Memory resolution(해상도) ▲      3.2 페이지 테이블반도체 기술의 발달로 TLB 역시 CPU의 내장 칩 형태로 만들어져있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-18-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-17-ed-8e-98-ec-9d-b4-ec-a7-80-ea-b5-90-ec-b2-b4-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "17: 페이지 교체 알고리즘",
        "tags": "OS, Memory, FIFO, paging",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "페이지 교체 알고리즘에 대해 알아본다.1. Page reference string페이지 교체 알고리즘을 살펴보기 전에 Page reference string 이라는 용어를 알아야 한다. CPU가 내는 주소는 이진수 단위이지만, 페이지 교체 알고리즘을 계산하기 위해서는 이진수 주소 단위가 아닌 페이지 단위로 계산해야한다.            CPU 논리 주소      요청할 페이지 번호                  100      1              101      1              432      4              612      6              103      1              104      1              611      6              612      6      예를 들어, CPU가 내는 주소를 위와 같이 표현해보자. 편의를 위해 주소는 십진수로 표현했다. 만약 페이지 크기를 100이라 하면, 우측과 같이 된다. 주소 100번지는 1번 페이지에서 offset이 0인 위치이고, 101은 1번 페이지의 offset 1인 위치라고 볼 수 있다.마지막으로 페이지 번호로 나타낸 것을 page reference string으로 나타내면 {1, 4, 6, 1, 6}이다. 이는 간단히 말하면 연속된 페이지는 생략하고 하나의 페이지 번호만 나타낸 것으로 볼 수 있다. 이 이유는 연속된 페이지를 참조할 때는 한 번 page fault가 발생하면 같은 페이지를 사용하는 동안에는 절대 page fault가 발생할 수 없기 때문이다. 즉, CPU가 가리키는 page의 번호가 연속적으로 동일하다면, disk로 가서 page를 가져올 필요가 없으므로, 위의 번호들만 가지고 판단하는 것이 바람직하다.2. First-In First-Out(FIFO)FIFO은 가장 간단한 알고리즘이다. 가장 먼저 page-in 한 페이지를 먼저 page-out 시킨다. 이를 사용한 이유는 초기화 코드가 더 이상 사용되지 않을 것이라는 아이디어에서 시작되었다.2.1 예제  페이지 참조열(page reference string)          {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}        사용가능한 프레임 개수(number of frame): 3  최초의 메모리는 비어있는 상태이다.            1      2      3      4      5      6      7      8      9      10      11      12      13      14      15      16      17      18      19                  7      0      1      2      0      3      0      4      2      3      0      3      2      1      2      0      7      0      1                  order      page-in      frame states      Page fault count      page-out      first page                  1      7      {7}      1             7              2      0      {7, 0}      2             7              3      1      {7, 0, 1}      3             7              4      2      {2, 0, 1}      4      7      0              5      0      {2, 0, 1}      4             0              6      3      {2, 3, 1}      5      0      1              7      0      {2, 3, 0}      6      1      2              8      4      {4, 3, 0}      7      2      3              9      2      {4, 2, 1}      8      3      1              10      3      {4, 2, 3}      9      1      4              11      0      {0, 2, 3}      10      4      2              12      3      {0, 2, 3}      10             2              13      2      {0, 2, 3}      10             2              14      1      {0, 1, 3}      11      2      3              15      2      {0, 1, 2}      12      3      0              16      0      {0, 1, 2}      12             0              17      7      {7, 1, 2}      13      0      1              18      0      {7, 0, 2}      14      1      2              19      1      {7, 0, 1}      15      2      7      결과는 최종 page fault 수는 15이다. 예제를 수행하면서, 이전에 page-out한 페이지를 그 다음 바로 page-in을 하려한다면 다시 page fault가 발생하기 때문에 비효율적인 모습을 볼 수 있다.2.2 Belady’s Anomaly프레임 수가 증가하면(= 메모리 용량이 증가하면) page fault 수가 줄어드는 것이 정상적이다.하지만 위의 FIFO를 사용했을 때, 그래프를 그려보면 다음과 같은 결과가 나온다.이와 같이 특정한 페이지 참조열에 대해서는 프레임 수가 증가해도 page fault 수가 오히려 증가하는 이상 현상이 발생한다. 이를 Belady’s Anomaly라 한다.3. Optimal(OPT)OPT는 말그대로 가장 효율적인 페이지 교체 알고리즘이다. 이 알고리즘은 가장 오랫동안 사용되지 않을 페이지를 희생양 페이지로 선택한다.3.1 예제  페이지 참조열(page reference string)          {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}        사용가능한 프레임 개수(number of frame): 3  최초의 메모리는 비어있는 상태이다.여기서 가장 오랫동안 사용되지 않을 페이지를 계산하기 위해 현재 시점 에서 그 이후에 최초로 나타나는 시점의 거리 를 dist로 둔다. 이 값이 가장 큰 페이지가 가장 오랫동안 사용되지 않은 페이지로 정한다.(해당 페이지가 이후에 나오지 않는 경우는 INF로 가장 큰 값으로 한다.)            1      2      3      4      5      6      7      8      9      10      11      12      13      14      15      16      17      18      19                  7      0      1      2      0      3      0      4      2      3      0      3      2      1      2      0      7      0      1                  order      page-in      frame states      Page fault count      page-out      dist                  1      7      {7}      1             {15}              2      0      {7, 0}      2             {14, 3}              3      1      {7, 0, 1}      3             {13, 2, 11}              4      2      {2, 0, 1}      4      7      {5, 1, 10}              5      0      {2, 0, 1}      4             {4, 2, 9}              6      3      {2, 0, 3}      5      1      {3, 1, 4}              7      0      {2, 0, 3}      5             {2, 4, 3}              8      4      {2, 4, 3}      6      0      {1, INF, 2}              9      2      {2, 4, 3}      6             {4, INF, 1}              10      3      {2, 4, 3}      6             {3, INF, 2}              11      0      {2, 0, 3}      7      4      {2, 5, 1}              12      3      {2, 0, 3}      7             {1, 4, INF}              13      2      {2, 0, 3}      7             {2, 3, INF}              14      1      {2, 0, 1}      8      3      {1, 2, 5}              15      2      {2, 0, 1}      8             {INF, 1, 4}              16      0      {2, 0, 1}      8             {INF, 2, 3}              17      7      {7, 0, 1}      9      2      {INF, 1, 2}              18      0      {7, 0, 1}      9      1      {INF, INF, 1}              19      1      {7, 0, 1}      9      2      {INF, INF, INF}      OPT의 결과는 총 9번의 page fault가 발생했다. 이는 FIFO의 15번보다 크게 줄어든 모습을 볼 수 있다. 하지만 OPT의 방법은 현실적으로 불가능하다. 실제 컴퓨터에서는 미래에 어떤 프로세스가 사용되는지 알 수 없다. 그러므로 어느 프로세스가 가장 오래 사용안되는 지를 계산할 수 없다.4. Least-Recently-Used(LRU)OPT는 최적해를 구할 수 있지만 미래를 알 수 없으므로 현실적으로 불가능한 방법이었는데, 최적의 해는 아니더라도 근사의 해를 구하기 위해서 LRU가 나왔다. LRU는 최근에 사용되지 않으면 나중에도 사용되지 않을 것이라는 개념으로 과거의 페이지 기록을 통해 희생양 페이지를 선택한다.4.1 예제LRU는 근사 해를 구하므로 OPT보다는 page fault가 많이 발생하지만, FIFO보다는 일반적으로 적게 일어난다. 그러므로 현재 대부분 환경에서는 LRU를 사용하고 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-17-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-16-ea-b0-80-ec-83-81-eb-a9-94-eb-aa-a8-eb-a6-ac-html": {
        "title": "16: 가상 메모리 (Virtual Memory)",
        "tags": "OS, Memory, Virtual Memory",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "가상 메모리(Virtual Memory)에 대해 알아본다.가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 즉, 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다. 예를 들어, 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행할 수 있도록 하는 것이다.1. Demanding Paging이러한 방식이 어떻게 가능할까? 앞서 메모리 낭비 방지의 동적 할당에서도 봤듯이, 필요한 부분만 메모리에 적재하는 것이다. 프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올리는 것이다. 이러한 프로세스의 일부분은 페이지 단위일 수도 있고, 세그먼트 단위일 수도 있지만 현재 대부분은 페이지 단위를 사용한다.이처럼 현재 필요한(요구되어지는) 페이지만 메모리에 올리는 것을 Demanding Paging(요구 페이징) 이라고 한다.1.1 동작  CPU가 page table에 가서 해당 page에 접근한다.  이 때, Memory에 올라온 상태가 아니면(invaild), Interupt를 발생한다.  OS 내부의 ISR에서 이 인터럽트를 처리하러 Disk에서 page를 찾는다.  찾은 Page를 Memory에 올려 Frame화 한다.  page table을 업데이트 한다.  CPU에게 다시 수행하라고 명령한다.가상 메모리를 만드는 방법은 대표적으로 두 가지가 존재하지만, 대부분 요구 페이징을 사용하므로 가상 메모리와 요구 페이징을 같은 용어로 사용하는 경우가 많다.1.2 Page Fault(페이지 부재)페이지 부재는 위에서 살펴본 CPU가 접근하려는 페이지가 메모리에 없는 경우이다. 즉, 페이지 테이블의 valid bit값이 0인 경우이다.위에서 이러한 경우를 처리하는 방법을 알아보았다. 실질적으로 이 부분이 가상 메모리의 핵심적인 기능이라 할 수 있다.1.2.1 Pure Demanding PagingPure Demanding Paging은 프로세스가 최초로 실행될 때는 어떤 페이지가 필요한지 알 수 없으므로, 아무 페이지도 올리지 않는다. 그러므로 프로그램을 실행하자마자 page fault가 발생한다. 즉, 순수하게 필요한 페이지만 올리는 것을 말한다. Pure Demanding Paging의 장점은 메모리를 최대한 효율적으로 사용할 수 있다. 하지만 시작부터 page fault가 발생하므로 속도면에서 느리다.1.2.2 PrepagingPrepaging은 pure demanding paging과 반대대는 개념이다. 프로그램을 실행할 때 필요할 것이라 판단되는 페이지를 미리 올리는 것이다. 이것의 장점은 page fault가 발생할 확률이 적으므로 속도면에서 빠르지만, 단점으로 미리 올라간 페이지를 사용하지 않는다면 메모리가 낭비된다.1.2.3 Swapping VS Demanding PagingSwapping와 Demanding Paging의 공통점은 둘 다 메모리와 backing store 사이를 서로 오고 가는 기능을 수행하지만, Swapping은 프로세스 단위로 이동하고 Demanding Paging은 페이지 단위로 이동하는 차이점이 있다.1.2.4 유효 접근 시간(Effective Access Time)Demending Paging은 페이지 테이블에 해당 페이지가 없으면 backing store에서 메모리로 가져오는 과정이 있다. 그렇기 때문에 페이지 테이블에 해당 페이지가 있을 때와 없을 때 시간 차이가 발생한다. 이러한 시간 차이를 고려하여 평균적으로 어느정도 소요되는지 계산하는 것을 유효 접근 시간이라 한다.  p          페이지 부재 확률(probability of a page fault = page fault rate)        Tm          메모리를 읽는 시간(DRAM)        Tp          Page fault가 발생했을 때 소요되는 시간(대부분 backing store(하드디스크)를 읽는 시간이 차지한다. (seek time + rotational delay + transfer time)      p = 1/1,000            용어      정의      값                  p      페이지 부재 확률      1/1000              Tm      메모리를 읽는 시간      200nsec              Tp      Disk 탐색 시간      8msec      메모리를 읽는 시간에 비해 40배 정도 느리다.p = 1/399,990            용어      정의      값                  p      페이지 부재 확률      1/399,990              Tm      메모리를 읽는 시간      200nsec              Tp      Disk 탐색 시간      8msec      메모리를 읽는 시간에 비해 10% 느리다.지역성의 원리(Locality of reference)위의 예제를 보았을 때, page fault는 매우 적은 확률로 발생해야 효율적이다. 그러면 현실적으로 페이지 부재는 어느정도로 발생할까? 이는 지역성의 원리(Locality of reference)로 인해 페이지 부재 확률은 매우 낮다. 지역성의 원리는 ‘메모리 접근은 시간적 지역성과 공간적 지역성을 가진다‘는 의미이다.  시간적 지역성          CPU는 어느 메모리 공간을 읽은 후, 시간이 지나도 그 공간을 다시 읽을 확률이 매우 높다는 것을 말한다.      대표적인 예로 반복문이 있다. 반복문은 하나의 코드 공간을 여러 번 읽는다.        공간적 지역성          CPU가 메모리 공간을 읽을 때는 인접한 범위 내에서 읽는다는 의미이다.      프로그램은 대부분 절차적인 순서로 구현되어 있어 순서대로 읽는 경우가 빈번하다.      이와 같이 페이지 부재가 현실적으로 발생할 확률은 매우 낮으므로 예제와 같이 40배로 느려지는 일을 거의 없다. 여기서 더 효율적으로 사용하기 위해서는 페이지 부재일 때 소요되는 시간을 줄일 수 있는데, backing store로 HDD를 사용하기 보다는 더욱 빠르게 동작하는 SSD나 저가 DRAM과 같은 것을 사용하는 방법이 있다.1.3 페이지 교체(Page Replacement)Demanding Paging은 요구되어지는 페이지만 backing store에서 가져온다. 하지만 프로그램들이 계속 실행함에 따라 요구 페이지도 계속 늘어나고, 언젠가는 메모리가 가득 차게 될 것이다.(memory full) 여기서 다른 프로그램이 새로 실행되거나 실행중인 프로세스가 다른 페이지를 요구한다면 이미 메모리에 있는 페이지 중 하나를 다시 backing store에 보내고(page-out), 새로운 페이지를 메모리에 올려야한다.(page-in) 이를 페이지 교체라고 한다. 여기서 backing store로 page-out이 된 페이지를 victim page 라고 한다.1.2.1 Victim Page(희생양 페이지)희생양 페이지는 어떤 페이지로 하는 것이 좋을까? 먼저 생각할 수 있는 것은 메모리에 올라가 있는 페이지 중 CPU에 수정(modify)되지 않는 페이지를 고르는 것이 효율적으로 보인다. 즉, 읽기만 수행하는 페이지를 고르는 것이 이상적이다. 수정되지 않은 페이지는 page-out이 될 때 backing store에 쓰기(write) 연산을 할 필요가 없기 때문이다. backing store는 읽는 시간도 느리지만, 거기에 더해 쓰기 작업까지 한다면 더욱 비효율적일 것이다.그러면 해당 페이지가 수정되었는지 안되었는지를 판단할 수 있어야 하는데, 이를 위해 페이지 테이블에 modified bit(=dirty bit)를 추가하여 이를 검사한다. 해당 페이지가 수정되었다면 이 비트를 1로 두고, 수정되지 않으면 0으로 둔다. 이를 이용해서 victim page는 최대한 수정되지 않은 페이지를 선택한다.위 그림은 modified bit를 추가한 페이지 테이블의 모습이다. 여기서 수정되지 않은 페이지는 0, 2, 3번 3개의 페이지가 존재하는데 이 중에서는 어떤 페이지를 선택해야 할까?제일 간단한 방법은 랜덤하게 선택하는 것이지만, 이는 성능을 보장할 수 없다. 그 다음은 가장 먼저 메모리에 올라온 페이지를 희생양 페이지로 선택하는 것이다. 이는 아주 유명한 FIFO(First-In First-Out) 방식이다. 이 외에도 여러가지 방법이 존재한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-16-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-15-ec-84-b8-ea-b7-b8-eb-a9-98-ed-85-8c-ec-9d-b4-ec-85-98-html": {
        "title": "15: 세그멘테이션 (Segmentation)",
        "tags": "OS, Memory, Segmentation",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프르세스를 논리적 내용을 기반으로 나누는 세그멘테이션(Segmentation)에 대해 알아본다.Segmentation지금까지 살펴본 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하였다. 여기서 물리적이라 함은 말 그래도 프로세스를 일정한 크기로 자른 것이다. 반면에 세그먼테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치하는 것을 말한다. 논리적 내용은, 어떤 의미론적 단위를 의미한다. 돼지고기를 그냥 1cm 간격으로 나누는 것이 Paging, 목살, 삼겹살, 갈비와 같이 나누는 것이 Segmentation이다. 따라서 각 세그먼트의 크기는 일반적으로 같지 않다.세그먼테이션은 프로세스를 세그먼트(segment)의 집합으로 생각한다. 앞에서도 말했듯, Process는 Code, Data, Stack 과 같은 구조로 나뉜다. 물론 code, data, stack 각각 내부에서 더 작은 세그먼트로 나눌 수도 있다.1. Segment Table이번에는 page size가 동일하지 않기 때문에, frame 번호로 논리 주소와 물리 주소를 연결할 수 없다. 이번에는 table이 bound를 가지고 있어야 한다. 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limit)를 엔트리로 갖는다. 페이징과 마찬가지로 논리 주소의 규약을 가지며, 이번에는 p가 아니고 s로 표기한다.한 가지 주의할 점은 세그먼트의 크기는 일정하지 않기 때문에, 테이블에 limit 정보가 주어진다. 그리고 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다.위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습이다. 페이징 주소변환과 동일하게 d는 논리주소와 물리주소가 동일하다. 물리주소 a는 base[s] + d 로 계산된다.  논리주소 (2, 100)          2(4300) + 100 = 4400 &lt; 4700(base+limit)        논리주소 (1, 500)          1(6300) + 500 = 6800 &gt; 6700(base+limit)                  =&gt; 인터럽트로 인해 프로세스 강제 종료(범위를 벗어남)                    2. 세그먼테이션에서 보호와 공유먼저, 결론부터 말하면 페이징보다 세그먼테이션에서의 보호와 공유는 더 효율적이다.보호에서는 세그먼테이션 역시 r, w, x 비트를 테이블에 추가하는데, 세그먼테이션은 논리적으로 나누기 때문에 해당 비트를 설정하기 매우 간단하고 안전하다. 페이징은 code + data + stack 영역이 있을 때 이를 일정한 크기로 나누므로 두 가지 영역이 섞일 수가 있다. 그러면 비트를 설정하기가 매우 까다롭다.공유에서도 마찬가지다. 페이징에서는 code 영역을 나눈다해도 다른 영역이 포함될 확률이 매우 높다. 하지만 세그먼테이션은 정확히 code 영역만 나누기 때문에 더 효율적으로 공유를 수행할 수 있다.3. 세그먼테이션과 페이징세그먼테이션은 페이징과 유사하고 보호와 공유에서는 더 나은 성능을 보여주었지만, 현재 대부분은 페이징 기법을 사용한다. 그 이유는 세그먼테이션에는 치명적인 단점이 있기 때문이다.3.1 외부 단편화메모리 할당을 처음 시작할 때 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다. 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 했었다.세그먼테이션도 똑같은 문제점이 발생한다. 왜냐하면 세그먼테이션은 논리적인 단위로 나누기 때문에 세그먼트의 크기가 다양하다. 이로 인해 다양한 크기의 hole이 발생하므로 외부 단편화의 문제가 발생한다.3.2 Paged segmentation결론적으로 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다. 그러므로 두 가지를 합쳐서 사용하는 방법이 나왔다. 두 장점을 합치기 위해서는 세그먼트를 페이징 기법으로 나누는 것이다.(Paged segmentation)하지만 이 역시 단점이 존재한다. 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두 번해야한다. 즉 CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-15-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-14-ed-8e-98-ec-9d-b4-ec-a7-95-html": {
        "title": "14: 페이징 (Paging)",
        "tags": "OS, Memory, Paging",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "외부 단편화를 해결하는 방법인 페이징(Paging)에 대해 알아본다.1. 페이징(Paging)외부 단편화로 인한 메모리 낭비는 매우 심하다는 것을 살펴보았다. Compaction을 사용하면 외부 단편화는 해결할 수 있지만, 그로 인해 발생하는 오버헤드와 비효율적인 성능으로 사용하기는 어렵다. 그 이후에 연구를 통해 나온 것이 페이징이다. 페이징은 hole을 가지고 해결하려 한 것이 아니라 프로세스를 작은 크기로 나눠서 외부 단편화를 해결하려고 하였다.페이징은 프로세스를 일정한 작은 크기로 나누는데, 프로세스뿐아니라 hole도 같은 크기로 나눈다. 이러한 작은 조각들의 크기를 맞춰서 메모리에 할당한다. 하지만, 하나의 프로세스는 연속적인 동작을 수행하는데 이를 작은 조각으로 나누어서 여기저기 흩어진다면 프로세스가 정상적으로 동작할까?메모리상에 여러 곳에 흩어진 프로세스를 수행하기 위해 CPU를 속여야한다. 이전 다중프로그래밍을 살펴봤을 때 MMU를 통해 논리 주소와 물리 주소를 나눠서 사용한다고 했었다. 이 역시 CPU를 속이는 행동이다. 실제 메모리는 전혀 연속적이지 않는데, CPU는 연속적으로 사용하고 있다는 것을 보장받으며 정상적으로 수행한다.페이징으로 작은 크기로 나눈 것도 위와 같은 방법으로 할 수 있다. 만약 50byte 크기의 프로세스가 있다고 하자. 페이징의 크기는 각 10byte로 나눈다.위 그림과 같이 프로세스 P1은 5개의 페이지로 나눌 수 있다. 이를 메인 메모리 5곳에 나눠서 할당하였다. CPU는 논리 주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기전에 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경되어야 한다.프로세스를 나눈 조각을 page 라 하고, 메모리를 나눈 조각을 frame 이라 한다. 프로세스는 페이지의 집합이고, 메모리는 프레임의 집합이다. 프로세스를 정상적으로 사용하기 위해 MMU의 재배치 레지스터를 여러개 사용해서 위의 그림과 같이 각 페이지의 실제 주소로 변경해준다. 이러한 여러 개의 재배치 레지스터를 페이지 테이블(Page Table) 이라 한다.1.1. 주소 변환(Address Translation)페이징 기법을 사용하기 위해서는 여러 개로 흩어진 페이지에 CPU가 접근하기 위해서 페이지 테이블을 통해 주소를 변환해야 한다.1.1.1 논리 주소(Logical address)CPU가 내는 주소는 2진수로 표현된다. 이 주소가 m비트로 표현된다고 가정하자. 여기서 하위 n비트는 오프셋(offset) 또는 변위(displacement)라고 한다. 그리고 상위 m-n 비트는 페이지의 번호에 해당한다.(n = d, m-n = p)논리주소를 물리주소(physical address)로 변환하기 위해서 페이지 번호(p)는 페이지 테이블의 인덱스 값이고, p에 해당되는 테이블 내용은 메모리의 프레임 번호이다. 변위(d)는 변하지 않는 값이다. d는 페이지 크기에 따라 달라진다. 만약 현재 페이지 크기를 16byte이라고 한다면, 이는 2^4이므로 d = 4 이다.만약 논리주소가 50번째로 주어진다면, 50=110010 이고, page size가 16byte라 주어졌을 때, 4자리를 제외한 p=11이고 d=0010 이다.1.1.2 동작 예시위 그림을 보면, 어떻게 동작하는 지 한눈에 확인 할 수 있다. 우리가 해야할 일은, 논리 주고가 들어왔을 때, 이것을 page, displacement로 나누고, page 변수를 frame 변수로 바꿔주는 page table을 통과하여 나온 값을 가지고 물리 주소를 찾으면 된다.위 그림으로 부터 따라해 볼 수 있다. p와 d만 잘 생각하면 쉬운 아이디어임을 알 수 있다. 이 페이징으로부터 연속 메모리 할당을 하면서 외부 단편화가 발생하는 문제는 해결했다. 하지만..1.2 내부단편화(Internal Fragment)페이징은 외부 단편화가 아닌 내부 단편화가 발생한다. 내부단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채울 수 없다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다.예를 들어, 15bytes 크기의 프로세스 P가 있다. 페이지 크기(프레임 크기)를 4bytes라 하면, P를 페이지로 나눈 결과인 4, 4, 4, 3 의 크기로 총 4개의 페이지가 만들어진다. 여기서 마지막 3bytes 페이지는 프레임 크기보다 1byte작으므로, 이 만큼 메모리 공간이 비게 된다. 이렇게 비어진 공간은 프로세스 P에서도 쓰지 않고, 다른 프로세스에서도 쓰지 못하는 낭비되는 공간이 된다.내부단편화는 해결할 방법이 없다. 하지만 내부단편화는 외부단편화에 비해 낭비되는 메모리 공간은 매우 적다. 내부단편화의 최대 낭비되는 크기는 page size - 1 이 된다.(외부 단편화는 최대 전체 메모리의 1/3이 낭비된다고 이전에 살펴봤다.) 이는 무시할 정도로 작은 크기이다.1.3 페이지 테이블 만들기페이지 테이블을 만드는 방법은 여러 가지가 있다. 먼저, CPU 내부에 페이지 테이블을 만들 수 있다. CPU 내부의 기억장치는 레지스터로, 여러 개의 레지스터로 페이지 테이블을 만드는 것이다. CPU 내부에 페이지 테이블을 만들면, 장점은 주소 변환 속도가 빠르다. 하지만 단점은 CPU 내부에 사용할 수 있는 레지스터는 한정되어 있으므로 페이지 테이블의 크기가 매우 제한된다.  CPU          장점 : 주소 변환 속도가 빠르다.      단점 : CPU 내부에 사용할 수 있는 레지스터는 한정되어 테이블의 크기가 제한된다.      반대로, 페이지 테이블을 메모리 내부에서 만들 수도 있다. 메모리 내부에 만드는 것의 장단점은 CPU와 정 반대이다. 즉, 장점은 페이지 테이블의 크기에 제한이 없는 것이고, 단점은 주소 변환 속도가 느리다는 것이다. CPU는 프로세스의 주소에 접근하기 위해서 메모리에 위치한 페이지 테이블에 한 번, 실제 주소로 접근하는데 한 번해서 메모리에 총 2번 접근해야하므로 속도 역시 2배로 느려진다.  Memory          장점 : 페이지 테이블의 크기에 제한이 없다.      단점 : 주소 변환 속도가 느리다.      1.3.1 TLB(Translation Look-aside Buffer)페이지 테이블을 CPU에 만들 때나 메모리에 만들 때 둘 다 장단점이 확실하기 때문에, 이를 해결하기 위해 페이지 테이블도 캐시로 만들어 해결하였다. 페이지 테이블을 별도의 칩(SRAM)으로 만들어서 CPU와 메모리 사이에 위치시키는 것이다. 이러한 테이블을 TLB(Translation Look-aside Buffer) 라고 부른다. 이는 CPU보다 변환 속도는 느리고 메모리보다 테이블 크기는 작지만, CPU보다 테이블 크기가 크고 메모리보다 변환 속도가 빠르다.TLB는 캐시와 역할이 동일하므로, 실제 전체 페이지 테이블은 메모리에 위치해 있고 테이블의 일부를 TLB에 가져와서 사용한다. 그러므로 TLB에 유효한 페이지가 있을 때와 없을 때의 속도 차이가 발생한다.1.3.2 TLB의 효율그렇다면, TLB의 효율을 알아보기 위해 Effective Memory Access Time을 계산해보자.            용어      정의      값                  Tm      메모리를 읽는 시간      100ns              Tb      TLB를 읽는 시간      20ns              hit ratio      TLB에 유효한 페이지 엔트리가 있을 확률      80%      먼저, EMAT의 정형화된 식을 보자. 가중 평균의 식이다. h는 hit ratio이다.실제 유효한 메모리에 접근하는 시간은 위와 같다. 없을 경우 2번 읽어야 하여 Tm을 두번 더해주었다. TLB에 유효한 페이지가 있다면 TLB를 읽는 시간과 실제 메모리를 읽는 시간만 있으면 된다. 하지만, TLB에 유효한 페이지가 없다면 이를 다시 메모리에서 가져와야 하므로 메모리를 총 2번 읽어야 한다.예제를 계산해보면, 0.8 * (20 + 100) + 0.2 * (20 + 100 + 100) = 140ns 이다. hit ratio는 실제로 평균 95%이상이므로 충분히 효율적으로 동작한다고 볼 수 있다.1.4 보호(Protection)모든 주소는 페이지 테이블을 경유하므로, 테이블을 이용해서 보호 기능을 수행할 수 있다. 접근이 유효한지 그렇지 않은지를 구분하는 bit를 추가하여 켜져있을 때 수행하도록 한다. 대표적으로 페이지 테이블마다 r(read), w(write), x(execute) 비트를 두어, 해당 비트가 켜져있을 때 그 수행이 가능하도록한다.위 그림은 페이지 테이블에 r,w,x 비트를 추가한 모습이다. 만약, 1번 페이지 엔트리처럼 쓰기 비트가 꺼져있는 페이지에 쓰기 작업을 시도하면 CPU에 인터럽트가 발생하여 ISR에서 강제로 해당 프로세스를 종료시킨다.1.5 공유(Sharing)공유는 메모리 낭비를 방지하기 위함이다. 같은 프로그램을 쓰는 복수 개의 프로세스가 있다면, 프로세스의 메모리는 code + data + stack 영역으로 나뉘는데 프로그램이 같다면 code 영역은 같을 것이다. 그러므로 하나의 code 영역을 복수 개의 프로세스가 공유하여 메모리 낭비를 줄이는 것이다. 단, code가 공유되려면 code가 변하지 않는 프로그램이어야 한다. 이를 non-self-modifying code = reentrant code(재진입가능 코드) = pure code 라고 한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-14-%ED%8E%98%EC%9D%B4%EC%A7%95.html"
      }
      ,
    
      "dv-c-2020-04-05-ec-a0-95-ec-a0-81-eb-b3-80-ec-88-98-html": {
        "title": "정적 변수 (static)",
        "tags": "c++, static",
        "date": "April 5, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "c++에서 static 키워드를 갖는 정적 변수에 대해서 알아본다.필요성  지역이 사라져도 변수는 유지되어야 해!지역 변수, 전역 변수 말고 c++에는 이상한 녀석이 하나 더 있다. 정적 변수라는 것이 그것인데, 아니 이게 왜 필요하지..?함수를 호출했는데, 이 함수를 몇 번 호출했는지 알고 싶다. 그러면, 사실 가능한 방법은 전역변수로 이 함수가 호출되었을 때 값을 증가시키면 된다.int count = 0;void call(){    count++;    cout &lt;&lt; conut &lt;&lt; '\\n';}int main(){    call();    call();    call();    call();    call();    return 0;}하지만, 이렇게 되면 프로그램의 안정성이 너무 떨어진다. 이름이 겹치는 문제도 생기고, 해당 변수의 역할은 함수의 호출 횟수만을 체크하는 것인데, 너무 범위가 크게 잡혀있기 때문이다. 결국 Scope를 줄이고 싶은 것이다.이런 경우 static을 적어주면, 전역변수처럼 행동하되, 이 녀석의 Scope는 해당 함수를 호출했을 때로 줄어들게 된다.void call(){    static int count = 0;    count++;    cout &lt;&lt; conut &lt;&lt; '\\n';}int main(){    call();    call();    call();    call();    call();    return 0;}특징 정리  메모리 공간에서 정적 변수는 전역 변수가 저장되는 Data 영역에 저장된다.          프로세스 구조        초기값을 주지 않을 경우 항상 0으로 초기화 되며 프로그램을 실행시킬 때 한번만 초기화 된다.          이 부분은 매우 중요한데, 실제로 함수가 실행될 때, 값이 변하는 것 같지만, 영향을 주지 않는다. 그렇기 때문에 원하는 결과인 1, 2, 3, 4 ,5가 출력된다.      ",
        
        "url": "/dv/c++/2020/04/05/%EC%A0%95%EC%A0%81%EB%B3%80%EC%88%98.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-13-ec-a3-bc-ea-b8-b0-ec-96-b5-ec-9e-a5-ec-b9-98-ea-b4-80-eb-a6-ac-html": {
        "title": "13: 주기억 장치 관리",
        "tags": "OS, Memory, MMU",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제에서 중요한 부분인 메모리 관리 기능에 대해 알아보자.메모리는 CPU 자원만큼 컴퓨터를 사용하는데 매우 중요한 자원 중 하나이다. 이전에는 운영체제에서 CPU 자원을 관리하는 프로세스 관리에 대해 살펴보았고, 지금부터는 메인 메모리를 관리하는 기능에 대해 살펴볼 것이다. 특히, 과거에는 메모리가 매우 비싼 자원이었고 크기 또한 작았기 때문에, 운영체제에서 메모리에 대한 관리가 지금보다 더 중요하였다.현재에는 과거보다 훨씬 큰 메모리를 저렴하게 사용하지만, 지금도 메모리는 부족하다. 메모리가 커져온 만큼 프로그램의 크기와 처리하는 데이터의 크기는 그보다 더욱 빠른 속도로 커져왔다. 그러므로 현재에도 여전히 메모리를 최대한 효율적으로 사용하기 위해 여러 방법들이 연구되고 있고, 운영체제 기능에서도 매우 중요한 위치를 차지하고 있다.1. 메모리에 프로그램 할당하기메모리는 기본적으로 주소(Address)와 데이터(Data)로 구성되어 있다.CPU와 메모리는 양방향으로 위 그림과 같이 주고 받는다. CPU는 주소를 가지고 메인 메모리에 요청을하거나 해당 주소에 계산 결과를 저장하고, 메모리는 요구하는 주소에 저장되어 있는 데이터를 CPU에게 전달한다.1.1 프로그램을 빌드하는 과정프로그램을 빌드하는 과정은 소스파일, 목적파일, 실행파일 순서로 생성된다.  소스파일(Source file)          고수준언어 또는 어셈블리어        목적파일(Object file)          컴파일 또는 어셈블 결과        실행파일(Executable file)          링크 결과      위 그림은 프로그램이 만들어지는 과정을 그림으로 표현한 것이다.  소스파일은 컴파일러(compiler)에 의해 컴파일 수행 결과로 목적 파일을 생성한다.          어셈블리어는 어셈블러가 어셈블을 수행하여 기계어로 변환한다. 프로그래밍을 하면서 외부의 라이브러리를 사용할 때가 빈번한데, 컴파일 단계에서는 이를 추가하지 않기 때문에 목적파일에는 이에 대한 정보가 없다.        링크 단계에서 하드디스크에서 프로그래머가 추가한 라이브러리를 찾아 정보를 추가하여, 실행 파일을 만든다.          링크 단계는 링커(linker)가 수행한다. 이 프로그램을 실행하면 로더(loader)에 의해 메인 메모리에 할당된다.      그리고 생성된 프로그램은 code, data, stack 영역으로 나뉘어져 있다. 단순히 생성된 프로그램에는 code와 data영역만 존재한다. 실제로 실행을 하는 과정에서는 함수를 실행하기 때문에, 돌아올 return address 등을 저장하는 stack도 필요하다.1.2 MMU(Memory Management Unit)  메모리 관리를 효율적으로 해주는 OS 서비스그렇다면, 프로그램을 실제로 메모리에 올리기 위해서는 좀 더 복잡한 과정이 필요하다. 먼저, 이 프로그램은 메모리에 몇 번지에 할당될까? 만약 운영체제가 없다면, 프로그래머가 직접 이를 처리해주어야 할 것이다. 하지만 운영체제가 존재하므로 실제 프로그래머는 이를 신경쓸 필요가 없다. 그러므로 프로그래밍을 할 때 주소를 사용하는 경우가 있는데, 프로그램이 메모리에 올라가는 주소를 고려하지 않고 프로그래밍이 가능한 것이다.(고수준언어에서는 직접 주소를 다루지 않는 경우가 많다.)또한, 다중 프로그래밍 환경에서는 여러 프로그램이 메모리에 올라가고 내려가고를 반복하기 때문에, 한 프로그램은 고정적인 공간을 사용할 수 없다. 이러한 여러 고려 사항을 해결해주는 것이 전에도 살펴봤던 MMU(Memory Management Unit)이다. 그리고 MMU에는 프로그램이 메모리에 할당될 때마다 다른 주소공간을 사용하기 때문에 재배치 레지스터(Relocation register)가 별도로 존재한다.위 그림은 MMU의 모습이다. 프로그램은 메인 메모리에 해당 주소를 사용할 수 있는지 여부를 생각하지 않고 주소를 사용한다. 만약 해당 프로그램이 사용하는 시작주소가 0번지라고 할 때, 실제 메인 메모리에서는 할당되는 주소가 유동적이기 때문에 0번지이라는 주소를 실제 할당된 주소로 변경해주어야 한다. 이때 재배치 레지스터를 이용한다.만약, 프로그램이 메인 메모리 500번지에 할당되어 재배치 레지스터값이 500으로 설정되었다면, CPU에서 프로그램의 0번지를 사용할 때 MMU를 통과하면 재배치 레지스터에 의해 500번지로 변경된다. 그 결과 CPU는 0번지를 사용하는 것으로 알고 있지만, 실제 메모리에서는 MMU에 의해 500번지를 사용하고 있는 것이다. CPU를 속인다.MMU(Memory Management Unit)의 기능을 살펴보면, 이전에 메모리 보호를 위해 base와 limit 레지스터가 있었다. 이는 CPU에서 주소를 사용하는데 이 주소가 해당 프로그램의 base나 limit 범위를 벗어나면 인터럽트가 발생하여 그 프로그램을 강제로 종료시킨다.MMU는 이 기능 이외에도 재배치 레지스터를 사용해서 프로그램이 어느 주소를 사용하더라도 실제 메인 메모리에 할당된 주소를 찾아갈 수 있도록 address translation 동작을 수행한다. 즉, CPU는 프로그램에 설정된 주소를 계속 사용하고 메모리에 명령을 보내지만, MMU에 의해 실제로 프로그램이 할당된 메모리 주소로 변환해서 사용할 수 있는 것이다. 그 결과, 프로그램의 실제 메모리 주소 공간의 위치는 CPU에 전혀 영향을 미치지 않고 정상적으로 사용할 수 있는 것이다.MMU에 의해 위 그림과 같이 주소는 두 가지로 구분된다. CPU에서 사용하는 주소는 논리 주소(logical address)라고 하고, 메모리가 사용하는 주소는 물리 주소(physical address)라고 한다.2. 메모리 낭비 방지운영체제는 메모리를 효율적으로 사용하기 위해 메모리 공간을 낭비하지 않는 것이 중요하다.2.1. 동적 적재(Dynamic Loading)  프로그램이 실행하는데 반드시 필요한 루틴/데이터만 적재(load)하는 것프로그램의 전체 코드에서 모든 루틴이 다 사용되는 것은 아니다. 대표적으로 오류 처리 구문이다. 오류 처리 구문은 if문과 같이 오류가 발생할 때만 해당 내부 코드가 실행되는 것을 말한다. 그러므로 동적 적재를 수행하면 프로그램의 실제 메모리에는 이러한 오류 구문을 제외하고 적재한다. 이러한 상태에서 실행하다가 오류가 발생하면 그 때 해당 오류 구문을 찾아 메모리에 올린다.데이터도 마찬가지다. 모든 데이터가 반드시 사용되는 것이 아니기 때문에, 특히 배열과 클래스의 경우는 필요한 부분만 메모리에 올려두고, 실행 도중 필요할 때마다 해당 부분을 찾아 메모리에 올려준다.반대로, 모든 루틴과 데이터를 적재하는 것을 정적 적재(static loading)이라고 한다. 현대 운영체제는 대부분 동적 적재를 사용한다.2.2. 동적 연결(Dynamic Linking)  공통으로 사용하는 라이브러리는 하나만 올리자.동적 연결은 여러 프로그램에 공통으로 사용되는 라이브러리를 중복으로 메모리에 올리는 것이 아니라 하나만 올리도록 하는 것이다.예를 들어, 아래와 같은 코드의 P1, P2 프로세스가 있다고 하자.// P1int a = 1;int b = 2;printf(\"%d\\n\", a + b);// P2int a = 1;int b = 2;printf(\"%d\\n\", a * b);이 두 소스파일을 컴파일하면 목적파일이 생성되고, 여기서 사용된 라이브러리를 링크하여 실행파일을 만든 다음 메모리에 적재한다. 두 프로세스가 적재되었을 때, printf() 를 사용하는 라이브러리는 메모리에 중복되어서 적재되어있다.이와 같이, 똑같은 라이브러리를 사용하는 프로그램은 흔히 볼 수 있다. 이러한 같은 라이브러리를 하나만 메모리에 올린 후, 이를 사용하는 프로그램이 하나의 메모리에 접근하도록 하면 메모리 낭비를 줄일 수 있다.동적 연결은 같은 라이브러리가 중복으로 메모리에 올라가는 것을 방지하기 위해 프로그램이 메모리에 적재된 후에 링크(link) 작업을 수행한다. 기존에는 실행 파일이 만들어지기 전에 링크 과정을 수행하였는데, 이를 정적 연결이라고 한다.위 그림은 예제에서 살펴 본 P1, P2 프로세스가 동적 연결을 통해 공통 라이브러리(printf() 라이브러리)를 연결한 모습을 볼 수 있다. 이러한 라이브러리를 Linux에서는 공유 라이브러리(Shared Library), Windows에서는 동적 연결 라이브러리(Dynamic Linking Library, DLL)라고 부른다.2.3 SwappingSwapping은 메모리에 적재되어 있는 프로세스 중에서 오랫동안 사용하지 않은 프로세스를 프로세스 이미지 형태로 만든 후 하드디스크(Backing store)에 내려보낸다. 메모리에서 Backing store로 가는 것을 swap-out, 다시 Backing store에서 메모리로 가는 것을 swap-in이라고 한다.여기서, 프로세스 이미지는 해당 프로그램이 메모리에 적재된 후 실행되면서 데이터를 추가하거나 변경하는 등의 과정을 거치는데, 현재 데이터의 상태를 프로세스 이미지라고 부른다. 그러므로 이는 단순히, 하드디스크에 존재하는 프로그램(exe파일)과는 전혀 다른 데이터이므로, 따로 저장해야한다. 이와 같은 swapping 과정으로 인한 프로세스 이미지를 저장하기 위해 하드디스크의 일부분을 분리하여 사용하는데, 이를 backing store 또는 swap device라고 부른다.Backing store의 크기는 대략 메인 메모리 크기 정도로 예상할 수 있다. 메모리의 모든 프로세스가 쫓겨난다고 해도 메인 메모리 크기를 넘지 않기 때문이다. 메인 메모리 크기가 크지 않는 PC나 스마트폰은 하드디스크의 일부를 backing store로 사용하지만, 메모리 크기가 크다면 따로 하드디스크 자체를 backing store로 사용하는 경우도 있다.Swap-out된 프로세스는 다시 swap-in을 할 때, 이전의 메모리 주소 공간이 아닌 새로운 주소 공간으로 갈 수도 있다. 이는 해당 프로세스가 backing store에 있는 동안 다른 프로세스가 해당 주소 공간을 사용할 수 있기 때문에다. 하지만 이는 MMU의 재배치 레지스터로 인해 어디에 적재되는지 상관없이 정상적으로 수행할 수 있다.현재는 프로세스의 크기가 커지고, 하드디스크는 메인 메모리보다 속도면에서 매우 느리므로 swapping 동작의 오버헤드는 크다고 볼 수 있다. 하지만 이로 인해 얻는 이득이 더 많으므로 대부분 운영체제는 이를 사용하고 있고, 속도가 중요한 서버 컴퓨터나 슈퍼 컴퓨터는 backing store를 하드디스크가 아닌 좀 더 빠른 저장 장치를 사용하기도 한다.3. 연속 메모리 할당(Contiguous Memory Allocation)과거에는 메모리에 프로세스가 하나만 올라가는 형태였다. 하지만 현재에는 메모리에 여러 프로세스가 할당되는 다중 프로그래밍 환경이 되었다.부팅 직후에 메모리 상태를 살펴보면, 운영체제만 할당되어 있고 비어있는 상태일 것이다. 이러한 비어있는 공간을 hole 이라 부른다. 즉, 부팅 직후에는 운영체제와 big single hole이 있는 상태이다. 시간이 지나면서 프로세스가 생성되고 종료하고를 반복하면, 여러 곳에 서로 다른 크기의 홀(hole)이 존재할 것이다. 이러한 상태를 scattered holes라고 한다.{}:.center}위 그림은 부팅 직후 상태에서 시간이 경과하면서 프로세스들이 생성, 종료를 반복한 후의 상태이다. 이와 같이 hole들이 불연속하게 흩어져 있는 상태를 메모리 단편화(Memory fragmentation) 라고 한다.메모리 단편화로 인해서 여러 곳에 hole이 흩어져 있는 상태에서 하나의 프로세스가 메모리에 할당되려하면 문제가 발생할 수 있다. 예를 들어, hole이 3개가 있고 각 크기는 50byte, 50byte, 80byte이다. 그런데 할당하려는 프로세스의 크기는 150byte이다. 각 hole들을 하나로 합치면 230byte로 이 프로세스를 할당할 수 있는데 실재로는 나누어져 있으므로 할당되지 못한다. 이러한 현상을 외부 단편화(External fragmentation) 라고 한다. 외부 단편화를 줄이기 위해서는 어떤 해결 방법이 있을까?3.1. 연속 메모리 할당 방식외부 단편화의 해결방법을 살펴보기 전에 연속 메모리 할당 방식을 먼저 살펴보자. 연속 메모리 할당 방식에는 3가지가 있다. First-fit, Best-fit, Worst-fit 이 있다.  First-fit(최초 적합)          최초 적합은 할당할 프로세스 크기보다 크거나 같은 hole을 탐색하는 순서 중에서 가장 먼저 찾은 hole에 프로세스를 할당하는 것이다.        Best-fit(최적 적합)          최적 적합은 할당할 프로세스 크기와 hole 크기의 차이가 가장 작은 hole에 프로세스를 할당하는 것이다.(hole크기는 프로세스 크기보다 반드시 커야 한다.)        Worst-fit(최악 적합)          최적 적합과 반대로, 할당할 프로세스 크기와 hole 크기의 차이가 가장 큰 hole에 프로세스를 할당하는 것이다.      예제            Hole id      HoleSize      Process Name      Size                  1      100kb      P1      212kb              2      500kb      P2      417kb              3      600kb      P3      112kb              4      300kb      P4      426kb              5      200kb                    First-fitBest-fitWorst-fit각 3가지 방식대로 프로세스를 할당한 모습을 볼 수 있다. 예제의 결과를 보면 Best-fit은 4개의 프로세스를 모두 할당할 수 있었고, 나머지 2개는 마지막 P4를 할당하지 못했다. 모든 hole을 합치면 P4를 할당할 수 있지만, hole들은 각각 나눠져 있기 때문에 할당할 수 없다.(외부 단편화)각 할당 방식의 일반적인 성능을 비교해보면, 속도면에서는 first-fit이 가장 빠르다. 메모리 이용률면에서는 first-fit, best-fit이 비슷한 성능을 낸다고 알려져있다. 하지만 여러 실험을 통해 best-fit을 사용하더라도 외부 단편화로 인해 전체 메모리의 1/3 정도를 낭비한다고 한다. 이는 거의 사용이 불가능한 수준이다.이를 해결하는 방법 중 하나는 Compaction 이다. compaction은 여러 곳에 흩어져있는 hole들을 강제로 하나로 합치는 것이다. 하지만 hole을 옮기는 오버헤드가 너무 크고, hole과 process 두개를 하기 때문에 어떻게 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않는 큰 단점이 존재한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-13-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-12-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-5-html": {
        "title": "12: 프로세스 동기화 Part 5",
        "tags": "OS, Synchronization, monitor",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "현재 사용하는 동기화 도구인 모니터(Monitor)에 대해서 알아본다.세마포는 실제로 매우 오래된 동기화 도구이다. 현재에는 모니터(monitor)라는 동기화 도구를 주로 사용하며, 이는 좀 더 고수준의 동기화 기능을 제공한다.1. 모니터 구조Semaphore의 구조는 위와 같았다. 그렇다면 monitor는 무엇이 다를까?위는 모니터의 구조를 간단히 나타낸 그림이다. 모니터는 공유 자원 + 공유 자원 접근함수로 이루어져 있고, 2개의 큐를 가지고 있다. 각각 mutual exclusion(상호배타) queue, conditional synchronization(조건동기) queue이다.  상호배타 큐는 말그대로 공유 자원에 하나의 프로세스만 진입하도록 하기 위한 큐이다.  조건동기 큐는 이미 공유자원을 사용하고 있는 프로세스가 특정한 호출 wait()을 통해 조건동기 큐로 들어갈 수 있다.조건동기 큐에 들어가 있는 프로세스는 공유자원을 사용하고 있는 다른 프로세스에 의해 깨워줄 수 있다. 이 역시 깨워주는 프로세스에서 특정한 호출 notify()을 해주며, 깨워주더라도 이미 공유자원을 사용하고 있는 프로세스가 해당 구역을 나가야 비로소 큐에 있던 프로세스가 실행된다.2. monitor in java자바는 모니터를 제공하는 대표적인 언어이며, 자바의 모든 개체는 모니터가 될 수 있다. 그렇다면 자바를 통해 모니터에 대한 예제를 살펴보자.class C {  private int value, ...;     // 공유 변수  synchronized void Foo() {   // 배타동기    // ...  }  synchronized void Goo() {    // ...  }  void H() {    // ...  }}위 코드는 모니터를 사용하고 있는 클래스이다. value와 같은 변수들은 여러 쓰레드가 공유하고 있는 변수로 볼 수 있고, synchronized 키워드는 배타동기를 수행하는 함수를 말한다. 즉, 해당 함수에는 단 하나의 쓰레드만 접근할 수 있다.Foo() 함수와 Goo() 함수는 synchronized 키워드를 통해 상호배타 함수로 선언하였는데, 이는 “둘 다 같은 임계구역을 갖는다”는 의미이다. 다시 말해서, Foo() 함수에 한 쓰레드가 수행 중이라면, Foo() 함수뿐 아니라 Goo() 함수에도 다른 쓰레드는 접근할 수 없다. 반면에 H() 함수는 일반 함수인데, 이 함수에서는 공통 변수에 대한 업데이트를 하지 않는다는 것을 예상할 수 있다. (여러 쓰레드가 동시에 접근가능하다.)조건동기는 특정한 메서드 호출로 사용할 수 있다.wait(): 호출한 쓰레드를 조건동기 큐에 삽입한다.notify(): 조건동기 큐에 있는 하나의 쓰레드를 깨워준다.notifyAll(): 조건동기 큐에 있는 모든 쓰레드를 깨워준다.모니터 역시, 세마포에서 할 수 있는 기능인 Mutual exclusion, Ordering을 모두 할 수 있다. 예제를 통해 이를 살펴보자.3. Problem Solving by Monitormonitor를 사용하여 지금까지 배운 문제들을 해결하는 방법에 대해 알아보자.3.1 BankAccount Problem이전에 세마포에서 살펴본 은행계좌 문제를 통해 세마포 대신 모니터를 사용해서 Mutual exclusion, Ordering을 구현해보자.3.1.1 Mutual Exclusionclass Test {\tpublic static void main(String[] args)\tthrows InterruptedException {\t\tBankAccount b = new\t\tBankAccount();\t\tParent p = new Parent(b);\t\tChild c = new Child(b);\t\tp.start();\t\tc.start();\t\tp.join();\t\tc.join();\t\tSystem.out.println( \"\\nbalance = \" + b.getBalance());\t}}class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tsynchronized void withdraw(int amt) {\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}class Parent extends Thread {\tBankAccount b;\tParent(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;100; i++)\t\t\tb.deposit(1000);\t}}class Child extends Thread {\tBankAccount b;\tChild(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;100; i++)\t\t\tb.withdraw(1000);\t}}코드가 매우 간단해졌다..!{:.center-text}위 코드에서 볼 수 있듯이, 세마포를 사용할 때보다 모니터를 사용하면 매우 간결하게 코드를 구현할 수 있다. 세마포를 선언하고 number of permit 값을 설정하는 대신, synchronized 키워드 하나로 이를 대체한 것을 볼 수 있다.+++++++++++++++++++++++------------------------------------------+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------balance = 0실행 결과는 위와 같고, balance값이 정상적으로 0을 출력한다.3.1.2 Mutual Ordeing은행계좌 문제를 살펴보기전에, ordering을 하기 위해 모니터를 어떻게 사용하는지 보자.            P1      P2                         wait()              section 1      section 2              notify()             위 구조는 프로세스 순서를 P1, P2 순서로 실행하기 원하는 경우이며, 이는 세마포와 매우 유사한 것을 알 수 있다. 그러면 은행계좌 문제를 모니터로 구현하는데, 입금 먼저 수행, 출금 먼저 수행, 입금 출금 반복 수행 3가지를 각각 구현해보자. 그리고 위 코드에서 수정하는 부분은 순서를 정하는 입금, 출금함수이므로 이 부분을 대변하는 BankAccount만 수정하자.입금 먼저 수행하기먼저 입금시작하면 기다리라고 하면된다.class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tnotify();\t}\tsynchronized void withdraw(int amt) {\t\twhile (balance &lt;= 0)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------------------------------------------------balance = 0출금 먼저 수행하기먼저 출금시작하면 기다리라고 하면된다.class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\twhile (balance == 0)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tsynchronized void withdraw(int amt) {\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tnotify();\t}\tint getBalance() {\t\treturn balance;\t}}----------------------------------------------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++balance = 0입금 출금 반복 수행하기입금 넣고 기다리고 출금 넣고 기다리고를 반복하면 된다!class BankAccount {\tint balance;\tboolean p_turn = true;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tnotify();\t\tp_turn = false;\t\ttry {\t\t\twait();\t\t} catch (InterruptedException e) {}\t}\tsynchronized void withdraw(int amt) {\t\twhile (p_turn)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tnotify();\t\tp_turn = true;\t}\tint getBalance() {\t\treturn balance;\t}}+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-balance = 03.2 전통적 동기화 문제10: 전통적인 동기화 문제들을 수정해본다!2.1 Producer-Consumer ProblemSemaphore를 사용하면 상호 배제 sem, 가득 차있을 때 block하는 sem, 비어있을 때 block하는 sem 총 3개를 사용했어야 했다. 하지만 이번에는 코드가 간단해진다!class Buffer {    int[] buf;    int size, count, in, out;    Buffer(int size) {        buf = new int[size];        this.size = size;        count = in = out = 0;    }    synchronized void insert(int item) {        while (count == size)            try {                wait();            } catch (InterruptedException e) {}        buf[in] = item;        in = (in+1)%size;        notify();        count++;    }    synchronized int remove() {        while (count == 0)            try {                wait();            } catch (InterruptedException e) {}        int item = buf[out];        out = (out+1)%size;        count--;        notify();        return item;    }}class Producer extends Thread {    Buffer b;    int N;    Producer(Buffer b, int N) {        this.b = b; this.N = N;    }    public void run() {        for (int i=0; i&lt;N; i++)            b.insert(i);    }}class Consumer extends Thread {    Buffer b;    int N;    Consumer(Buffer b, int N) {        this.b = b; this.N = N;    }    public void run() {        int item;        for (int i=0; i&lt;N; i++)            item = b.remove();    }}class Test {    public static void main(String[] arg) {        Buffer b = new Buffer(100);        Producer p = new Producer(b, 10000);        Consumer c = new Consumer(b, 10000);        p.start();        c.start();        try {            p.join();            c.join();        } catch (InterruptedException e) {}        System.out.println(\"Number of items in the buf is \" + b.count);    }}Number of items in the buf is 02.2 The Dining Philosopher Problemclass Philosopher extends Thread {    int id; // philosopher id\tChopstick lstick, rstick;    Philosopher(int id, Chopstick lstick, Chopstick rstick) {        this.id = id;        this.lstick = lstick;        this.rstick = rstick;    }    public void run() {        try {            while (true) {                lstick.acquire();                rstick.acquire();                eating();                lstick.release();                rstick.release();                thinking();            }        }catch (InterruptedException e) { }    }    void eating() {        System.out.println(\"[\" + id + \"] eating\");    }    void thinking() {        System.out.println(\"[\" + id + \"] thinking\");    }}class Chopstick {    private boolean inUse = false;    synchronized void acquire() throws InterruptedException {        while (inUse)            wait();        inUse = true;    }    synchronized void release() {        inUse = false;        notify();    }}class Test {    static final int num = 5; // number of philosphers &amp; chopsticks    public static void main(String[] args) {        int i;        /* chopsticks */        Chopstick[] stick = new Chopstick[num];        for (i=0; i&lt;num; i++)            stick[i] = new Chopstick();        /* philosophers */        Philosopher[] phil = new Philosopher[num];        for (i=0; i&lt;num; i++)            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);        /* let philosophers eat and think */        for (i=0; i&lt;num; i++)            phil[i].start();    }}이 코드는 교착상태를 해결하지 않은 상태이다. 해결 하기 위해서는 circular wait 조건을 불만족하도록 만들면 된다. 이 부분에서는 쉽게 동기화 문제를 해결할 수 있음을 보고가면 된다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-12-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-5.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-11-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-4-html": {
        "title": "11: 프로세스 동기화 Part 4",
        "tags": "OS, Synchronization, Deadlock",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스 동기화에서 발생하는 논리적 오류인 교착 상태(Deadlock)에 대해 알아본다.Deadlock (교착 상태)교착 상태는 어떠한 자원을 갖고 있는 상황에서 문제가 발생한다. 자동차 교차로를 생각해보자. A자동차도 신호를 받았고, B 자동차도 신호를 받았다. 그래서 두 자동차가 움직이는 것에 논리적 오류가 없지만, 두 자동차가 갈 수 없는 상황이 발생한다. 바로 출근 시간 길 막힘이다. 길이 막혀 아무런 동작도 수행할 수 없다. 이런 상황을 교착상태라 한다.프로세스는 실행을 위해 CPU, 메모리, 파일 등 여러 하드웨어 자원이 필요하다. 이를 운영체제에서 프로세스가 요구하는 자원을 적절히 분배해준다. 예를 들어, 한 프로세스가 A 자원을 가지고 있는 상태에서 B 자원을 요구하고 있다. 하지만 B 자원은 다른 프로세스 역시 요구하고 있는 자원인데, 이러한 상황에서 자원을 분배하는 순서가 잘못되면 교착상태에 빠지게 된다.1. 교착상태 필요 조건(Necessary Conditions)교착상태가 일어나기 위한 필요 조건이 네 가지가 존재한다. 이는 필요 조건이므로, 네 가지가 모두 해당된다고 해서 반드시 교착상태가 일어나는 것은 아니다. 단지 일어날 가능성이 발생한다.하지만 네가지 조건 중 하나라도 해당되지 않으면 교착 상태는 일어나지 않는다. 즉, 4가지 조건에 모두 해당되면 Deadlock의 가능성이 있으나, 그렇지 않다면 Deadlock은 일어나지 않는다.  Mutual exclusion (상호배타)          한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다.                  젓가락은 한 철학자가 사용하고 있으면 이 젓가락은 사용할 수 없으므로 상호배타적이다.                      No Preemption (비선점)          한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.                  한 철학자가 젓가락을 집은 상태에서 다른 철학자가 이 젓가락을 뺏을 수 없다.                      Hold and wait (보유 및 대기)          한 프로세스가 자원을 가지고 있는 상태에서 대기한다.                  철학자는 왼쪽 젓가락을 가지고 있는 상태에서 오른쪽 젓가락을 집기 위해 대기한다.                      Circular wait (환형대기)          프로세스가 요구하는 자원의 방향이 원형을 이룬다.                  모든 철학자는 왼쪽 젓가락부터 집을 수 있다.                    교착상태는 위 네 가지 조건을 모두 만족하더라도 매우 드물게 일어나는 현상이지만, 한 번 교착상태에 빠지면 프로세스가 무한 루프에 빠져 수행하지 못하고 해당 프로세스가 가지고 있는 자원은 아무도 사용하지 못한다. 이는 전체 컴퓨터 환경에 매우 치명적이다. 그리고 교착상태에 의한 오류를 해결하기는 매우 힘들다.2. 자원(Resources)교착 상태가 발생하는 가장 큰 원인은 결국 자원의 문제이다. 따라서 이 자원을 어떻게 이용하고 있는 지 파악하는 것이 중요하다.하드웨어 자원은 여러 개가 존재하고 동일한 형식(type)의 자원이 존재할 수 있다. 예를 들어, 같은 CPU가 2개있는 환경이 있다. 이러한 자원 하나하나를 instance라고 한다.자원은 프로세스가 직접적으로 사용할 수 없고, 운영체제에 요청(request)하면 운영체제가 제공해준다. 그 후 프로세스는 이 자원을 사용(use)하고 모든 사용이 끝나면 이를 반납(release)한다.요청(request) -&gt; 사용(use) -&gt; 반납(release)2.1 자원 할당도(Resource Allocation Graph)자원 할당도는 어떤 자원이 어떤 프로세스에 할당되었는지 또는 어느 프로세스가 어느 자원을 할당 받으려고 기다리는지를 그림으로 나타낸 것이다.            용어      모양                  Resource(자원)      사각형              Instance(인스턴스)      점              Process(프로세스)      원              할당      화살표      R1은 P1에 할당되어 있는 상태이고, P2는 R1을 요청하고 있는 상태이다.자원 할당도를 사용하는 이유는 교착상태의 필요조건을 한 눈에 볼 수 있기 때문이다. 자원 할당도를 분석할 때 mutual exclusion(한번에 하나)과 no-preemption(강제로 못 뺏는다.)은 기본으로 적용된다.Hold and wait는 화살표를 통해 한 프로세스가 인스턴스를 할당받았고 다른 자원을 가리키고 있다면, 이 상황은 Hold and wait인 상태이다.Circular wait 역시 화살표 방향이 원형을 이루고 있다면 이는 환형대기인 상태이다.이런 그림을 보면 Circular wait 조건을 가지고 있어 교착 상태의 가능성을 가지고 있다.위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.4. 교착상태 처리4.1 교착상태 방지 (Deadlock Prevention)교착상태 방지는 교착상태 필요조건 네 가지 중 최소 한 가지를 만족시키지 않도록 만드는 것이다.  상호배타(Mutual exclusion)          상호배타를 없애기 위해서는 자원을 공유 가능하게 만들어야 한다. 하지만 현실적으로 이러한 방법이 불가능한 경우가 많다.        비선점(No preemption)          비선점을 없애러면 반대로 선점이 가능하도록 만들어야 한다. 이 역시 대부분의 자원에게는 불가능한 방법이다. CPU는 강제로 스위칭하는 것이 가능한 경우가 있지만, 대부분의 경우에는 불가능하다. 가령 프린터를 수행하는 중간에 다른 프로세스가 이를 선점하는 것은 불가능하다고 볼 수 있다.        보유 및 대기(Hold &amp; Wait)          이 조건을 없애려면 자원을 가지고 있는 상태에서 다른 자원을 기다리지 않도록 만든다. 만약 여러 개의 자원이 필요하다면 필요한 모든 자원을 얻을 수 있는 경우에만 해당 자원을 요청한다. 또는 필요한 자원 중 일부만 가지는 경우 할당받은 자원을 모두 운영체제에 반납한다. 하지만 이와 같은 방법은 자원의 활용률을 저하시키고, starvation 현상이 발생하는 단점이 있다.      왼쪽 젓가락을 가진 상태에서 오른쪽 젓가락을 요청했는데, 이미 할당되어 있다면, 왼쪽 젓가락도 할당해제 한다.        환형대기(Circular wait)          이 조건을 없애는 것은 위 세 가지 조건보다는 할 수 있는 확률이 높다. 대표적인 예는 모든 자원에 번호를 부여하여 이 번호에 대한 오름차순으로 자원을 요청하는 것이다. 이 역시 자원의 활용률을 저하시키는 단점이 있다.      네 가지 방법을 살펴본 결과 가장 현실적인 방법은 hold &amp; wait나 circular wait 조건을 없애는 것이다. 하지만 둘 다 자원을 비효율적으로 사용하게 되는 단점을 가지고 있다. 그래서 이와 같이 교착상태 방지 방법은 군사, 우주, 의료와 같은 크리티컬한 곳에서 사용하는 것이 좋다.철학자 문제에 적용위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.Circular wait 조건을 없애기 위해 짝수 번호 철학자는 왼쪽 젓가락, 오른쪽 젓가락 순서로, 홀수 번호 철학자는 반대 순서인 오른쪽 젓가락, 왼쪽 젓가락 순서로 집는다고 하자.위 그림은 circular wait 조건을 없앤 식사하는 철학자 문제의 자원 할당도이다. 화살표가 원형을 만들지 않는 것을 볼 수 있다.// Philosopher Thread run functionpublic void run() {    try {        while (true) {            if (id % 2 == 0) {                lstick.acquire();                rstick.acquire();            }            else {                rstick.acquire();                lstick.acquire();            }            eating();            lstick.release();            rstick.release();            thinking();        }    }catch (InterruptedException e) { }}이전 글에서 있던 철학자가 젓가락을 집는 코드를 수정했다. 위와 같이 코드를 변경하고 실제로 수행하면 무한 반복문이 끝나지않고 정상적으로 계속되는 것을 확인할 수 있다.4.2 교착상태 회피 (Deadlock Avoidance)교착상태 회피와 방지의 차이점은 교착상태를 다르게 접근하는 것이다. 교착상태 회피에서는 교착상태를 자원 요청에 대한 잘못된 승인으로 판단한다. OS단에서 요청에 대해 잘 관리를 해주었다면 해결할 수 있다고 생각하는 것이다.이러한 접근은 은행과 비슷하다. 은행이 투자를 할 때, 안전한 곳과 안전하지 않은 곳을 잘 분리하여 투자해야, 위기 상황에서 부도가 나지 않을 것이다. 마찬가지로, OS에서 deadlock이 나지 않는 방법으로 할당해주는 방법이 교착 상태 회피이다.따라서, 교착상태 회피에서는 안전한 할당(Safe allocation)과 불안정한 할당(Unsafe allocation) 두 가지로 나뉜다.안전한 할당현재 운영체제에는 magnetic tape 자원이 총 12개가 있고, 이를 요청하는 3개의 프로세스가 있다.            process      Max needs      Current needs                  P0      10      5              P1      4      2              P2      9      2        Current needs          한 프로세스가 한 번 요청을 할 때 요구하는 개수        Max needs          프로세스를 정상적으로 끝내기 위해 필요한 총 개수      운영체제 입장에서 3개의 프로세스가 모두 수행될 때까지 자원을 분배해보자.  order : 순서  process : 프로세스 이름  needs : 프로세스가 필요로 하는 tape의 개수  possible : 할당이 가능한지 판단하는 변수  state : 해당 프로세스의 진행 상태  dealloc : 할당 해제 되었는지 확인하는 변수  tapeSize : 현재까지 할당되어 사용할 수 있는 tape의 개수  wait : 할당 받지 못해 대기하는 지 유무            order      process      needs      possible      state      dealloc      tapeSize      wait                  1      P0      5      O      5/10      X      12-&gt;7      X              2      P1      2      O      2/4      X      7-&gt;5      X              3      P2      2      O      2/9      X      5-&gt;3      X              4      P0      5      X      5/10      X      3      O              5      P1      2      O      4/4      O      3-&gt;1-&gt;5      X              6      P0      5      O      10/10      O      5-&gt;0-&gt;10      X              7      P2      2      O      4/9      O      10-&gt;8-&gt;12      X              8      P2      2      O      6/9      O      12-&gt;10-&gt;12      X              9      P2      2      O      8/9      O      12-&gt;10-&gt;12      X              10      P2      2      O      9/9      O      12-&gt;11-&gt;12      X        P0에게 5개를 할당한다.(5/10) =&gt; 현재 magnetic tape 개수: 7  P1에게 2개를 할당한다.(2/4) =&gt; 현재 magnetic tape 개수: 5  P2에게 2개를 할당한다.(2/9) =&gt; 현재 magnetic tape 개수: 3  다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 3개이므로 할당해줄 수 없다.  P1에게 2개를 할당한다.(4/4) =&gt; 현재 magnetic tape 개수: 1          P1은 필요한 4개의 magnetic tape을 받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 5        대기하고 있던 P0에게 5개를 할당한다.(10/10) =&gt; 현재 magnetic tape 개수: 0          P0 역시 필요한 자원을 모두 할당받았으므로, 종료 후 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 10        P2는 현재 필요한 magnetic tape 개수가 7개이고, 현재 남아있는 magnetic tape 개수 10개이므로 정상적으로 수행가능하다. (7~10)이 예제에서는 3개의 프로세스가 모두 정상적으로 자원을 할당받고 종료할 수 있었다. 이를 안전한 할당이라 한다. 다음 예제를 보자.불안전한 할당            process      Max needs      Current needs                  P0      10      5              P1      4      2              P2      9      3      이 예제 역시 운영체제가 보유하고 있는 총 magnetic tape 개수는 12개이고, 3개의 프로세스가 존재한다. 자원을 분배해보자.            order      process      needs      possible      state      dealloc      tapeSize      wait                  1      P0      5      O      5/10      X      12-&gt;7      X              2      P1      2      O      2/4      X      7-&gt;5      X              3      P2      3      O      3/9      X      5-&gt;2      X              4      P0      5      X      5/10      X      2      O              5      P1      2      O      4/4      O      2-&gt;0-&gt;4      X              6      P0      5      X      5/10      X      4      O              7      P2      3      O      6/9      X      4-&gt;1      X              8      P0      5      X      5/10      X      1      O              9      P2      3      X      6/9      X      1      O              10      P0      5      X      5/10      X      1      O              11      P2      3      X      6/9      X      1      O              $\\vdots$                                                         P0에게 5개를 할당한다.(5/10) =&gt; 현재 magnetic tape 개수: 7  P1에게 2개를 할당한다.(2/4) =&gt; 현재 magnetic tape 개수: 5  P2에게 3개를 할당한다.(3/9) =&gt; 현재 magnetic tape 개수: 2  다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 2개이므로 할당해줄 수 없다.  P1에게 2개를 할당한다.(4/4) =&gt; 현재 magnetic tape 개수: 0          P1은 필요한 자원을 모두 할당받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 4        대기하고 있던 P0는 아직 할당받으르 수 없다.  P2에게 3개를 할당한다.(6/9) =&gt; 현재 magnetic tape 개수: 1  현재 남아있는 magnetic tape 개수는 1개이고, P0가 요구하는 개수는 5개, P2는 3개이므로 두 프로세스 모두 할당받을 수 없다. (8~)이 예제에서 남은 magnetic tape 개수가 요구하는 개수보다 적으므로 자원을 할당해줄 수 없다. 그러므로 P0, P2 프로세스는 자원을 하염없이 기다리게 된다. 이를 불안전한 할당이라 하고, 그 결과 교착상태에 빠지게 된다.교착상태 회피는 마치 대출전문 은행과 유사하게 동작하므로, 해결 방법을 Banker’s Algorithm이라 한다. 돈이 있어야 값지4.3 교착상태 검출 및 복구 (Deadlock Detection &amp; Recovery)교착상태 검출 및 복구는 교착상태 자체가 매우 드문 현상이므로 자유롭게 자원을 분배하다가 교착상태가 발생하면 이를 정상적인 상태로 복구하는 것이다.1번과 2번 방법은 사전에 교착상태를 일어나지 않도록 하는 방법이지만, 교착상태 검출 및 복구 방법은 교착상태가 일어나는 것을 허용한다. 그 대신, 교착상태가 일어났을 때 이를 인지하고 복구를 해야 한다.교착상태가 일어나는 것을 감지하기 위해 운영체제 내부에서 주기적으로 교착상태가 발생하였는지 검사해야한다. 그 주기의 길이가 짧으면 그 만큼 오버헤드가 크고, 주기가 길면 오버헤드는 줄일 수 있지만 복구 가능성이 낮아진다.복구하는 방법은 교착상태가 발생하는지 주기적으로 검사하듯이 메모리의 상태를 주기적으로 메모리에 저장해놓고 만약 교착상태가 발생하면 그 이전 상태로 되돌리는 방법이 있다. 그 외에도 일부 프로세스를 강제로 종료하거나 자원을 강제로 선점하여 프로세스에게 할당해주는 방법 등이 있다.정상적인 상태로 복구한다는 장점이 있지만, 복구를 제대로 하지 못할 수도 있고, 검출을 위해 추가적인 오버헤드가 발생한다는 단점이 있다.3.4 교착상태 무시교착상태의 필요조건 네 가지를 모두 만족하더라도 교착상태가 반드시 일어나는 것이 아니라고 했듯이, 교착상태는 매우 드문 상황이다. 그러므로 이를 위해 오버헤드를 감수하는 것이 비효율적인 환경도 존재한다. 그러한 환경은 교착상태에 대한 아무런 조치를 하지 않는 방법도 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-11-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-4.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-10-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-3-html": {
        "title": "10: 프로세스 동기화 Part 3",
        "tags": "OS, Synchronization, Deadlock",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "전통적인 동기화 문제에 대해서 알아본다.현실적으로 찾아보았을 때, 동기화가 잘 되지 않으면 발생하는 문제들이 많다. 은행 계좌 문제와 같은 전통적으로 알려진 동기화 문제들에 대해서 알아본다.1. Producer-Consumer Problem생산자-소비자 문제는 생산자가 데이터를 생산하면 소비자는 그 데이터를 소비하는 형태의 문제이다. 컴퓨터 환경에서 예를 보면, 컴파일러 -&gt; 어셈블러, 웹 서버 -&gt; 웹 클라이언트 등이 있다. 컴파일러에서 생성한 어셈블리어는 어셈블러에서 이를 소비하여 기계어를 만든다.생산자-소비자 관계를 간단히 그림으로 나타내면 위와 같다. 이 관계의 대부분은 생산자에서 생산한 데이터 양을 소비자가 한 번에 소비하는 경우는 드물다. 생산한 데이터는 중간의 buffer 라는 저장 공간(메모리 공간)에 저장해두고 소비자는 여기서 필요한 만큼 가져간다. 창고와 같다.버퍼의 크기는 현실적으로 유한하다. 그러므로 생산자는 버퍼 공간이 가득 차면 더 이상 저장할 수 없다. 소비자는 버퍼가 비어 있으면 가져올 수 없다. 이러한 유한한 버퍼 크기를 bounded buffer 라고 한다.정리  생산자 소비자 문제          생산자 : 데이터 생산, 소비자 : 데이터 소비      컴파일러 -&gt; 어셈블러, 파일 서버 -&gt; 클라이언트, 웹서버 -&gt; 웹 클라이언트        Bounded Buffer          Buffer란 생산자와 소비자 사이에 존재하는 창고와 같음      생산자와 소비자 사이의 속도 차이를 보완하기 위해 필요함      버퍼 크기는 유한하다.                  생산자는 가득 차면 넣을 수 없다.          소비자는 버퍼가 비면 뺄 수 없다.                    1.1 CodeMainclass Test {\tpublic static void main(String[] arg) {\t\tBuffer b = new Buffer(100);\t\tProducer p = new Producer(b, 10000);\t\tConsumer c = new Consumer(b, 10000);\t\tp.start();\t\tc.start();\t\ttry {\t\t\tp.join();\t\t\tc.join();\t\t} catch (InterruptedException e) {}\t\tSystem.out.println(\"Number of items in the buf is \" + b.count);\t}}Buffer Class이 부분을 주목해서 봐야 한다.class Buffer {\tint[] buf; // buf: Bounded buffer\tint size;\t// size: 버퍼 크기\tint count; // count: 버퍼에 저장된 데이터 개수\tint in; // in: 생산한 데이터를 담을 버퍼 인덱스\tint out; // out: 소비할 데이터를 가리키는 버퍼 인덱스\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t}\tvoid insert(int item) {\t\t/* check if buf is full */\t\twhile (count == size)\t\t\t;\t\t/* buf is not full */\t\tbuf[in] = item;\t\tin = (in+1)%size; //  Circular Queue\t\tcount++;\t}\tint remove() {\t\t/* check if buf is empty */\t\twhile (count == 0)\t\t\t;\t\t/* buf is not empty */\t\tint item = buf[out];\t\tout = (out+1)%size; //  Circular Queue\t\tcount--;\t\treturn item;\t}}Buffer 클래스의 멤버 변수를 보면  buf: Bounded buffer  size: 버퍼 크기  count: 버퍼에 저장된 데이터 개수  in: 생산한 데이터를 담을 버퍼 인덱스  out: 소비할 데이터를 가리키는 버퍼 인덱스Producer/****** 생산자 ******/class Producer extends Thread {\tBuffer b;\tint N;\tProducer(Buffer b, int N) {\t\tthis.b = b; this.N = N;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;N; i++)\t\t\tb.insert(i);\t}}Consumer/****** 소비자 ******/class Consumer extends Thread {\tBuffer b;\tint N;\tConsumer(Buffer b, int N) {\t\tthis.b = b; this.N = N;\t}\tpublic void run() {\t\tint item;\t\tfor (int i=0; i&lt;N; i++)\t\t\titem = b.remove();\t}}만약 생성자가 데이터를 계속 생성하여 버퍼의 마지막 인덱스로 가면 그 다음은 처음으로 되돌아간다. (circular buffer) 소비하는 것도 마찬가지이다.main을 보면 크기가 100인 버퍼를 생성하고 2개의 쓰레드가 각각 생산자와 소비자 역할을 하여 각각 10000번씩 생산하고 소비한다. 정상적인 결과는 count값이 0이 출력되야 한다.하지만 실제 코드를 수행하면 무한 루프에 빠지거나, count값에 전혀 예상하지 않은 값이 출력된다.이 문제 당연하게도 동기화 문제이다. 생산자와 소비자가 동시에 접근하는 공통 변수인 buf, count 를 두 프로세스가 동시에 업데이트하기 때문이다. 다시 말하면 임계구역에 동시에 접근한 것이다.1.2 동기화 해결해결방법은 앞서 배웠던 세마포를 사용하여 mutual exclusion을 보장하는 것이다. 임계구역을 동시에 접근하는 것을 방지하고 하나의 프로세스만 허용해야한다. sem이라고 선언하지 않고 mutex라 선언한다. 지금 만드는 semaphore는 mutual exclusion을 막는 역할을 하기 때문이다.Buffer Classclass Buffer {\tint[] buf;\tint size;\tint count;\tint in;\tint out;\tSemaphore mutex;   // 세마포 선언\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t\tmutex = new Semaphore(1);\t}\tvoid insert(int item) {\t\t/* check if buf is full */\t\twhile (count == size)\t\t\t;\t\t/* buf is not full */\t\ttry {            mutex.acquire();            buf[in] = item;            in = (in+1)%size;            count++;            mutex.release();\t\t} catch(InterruptedException e) {}\t}\tint remove() {\t\t/* check if buf is empty */\t\twhile (count == 0)\t\t\t;\t\t/* buf is not empty */\t\ttry {\t\t\tmutex.acquire();\t\t\tint item = buf[out];\t\t\tout = (out+1)%size;\t\t\tcount--;\t\t\tmutex.release();\t\t\treturn item;\t\t} catch(InterruptedException e) {}\t\treturn -1;\t}}위는 임계구역에 세마포를 추가한 코드이다. 임계구역은 위에서 말했듯이 buf, count 에 접근하는 영역이므로 insert(), remove() 함수 내부에 선언한 것을 볼 수 있다.1.3 Busy waiting여기서 한 가지 더 문제점이 있다. 바로 busy waiting 이다. 위에서 busy waiting은 생산과 소비하기 전에 버퍼가 가득 찼는지 비어 있는지 확인하는 무한 반복문을 말한다. 이는 아무 일도 하지 않으면서 무한으로 반복하여 CPU를 점유하고 있으므로 매우 비효율적이다. 이를 해결할 수 있는 것도 세마포이다.class Buffer {\tint[] buf;\tint size;\tint count;\tint in;\tint out;\tSemaphore mutex, full, empty;\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t\tmutex = new Semaphore(1);\t\tfull = new Semaphore(0);\t\tempty = new Semaphore(size);\t}\tvoid insert(int item) {\t\ttry {            empty.acquire();    // 버퍼의 비어있는 공간을 1 감소시킨다.(비어있는 공간이 없으면 block)            mutex.acquire();            buf[in] = item;            in = (in+1)%size;            count++;            mutex.release();            full.release();    // 버퍼의 찬 공간을 1 증가시킨다.          } catch(InterruptedException e) {}\t}\tint remove() {\t\ttry {            full.acquire();    // 버퍼의 찬 공간을 1 감소시킨다.(버퍼가 모두 비어있으면 block)            mutex.acquire();            int item = buf[out];            out = (out+1)%size;            count--;            mutex.release();            empty.release();   // 버퍼의 비어있는 공간을 1 증가시킨다.            return item;          } catch(InterruptedException e) {}\t\treturn -1;\t}}busy waiting을 없애기 위해 두 개의 세마포를 더 추가하였다.  empty: 버퍼에서 비어있는 공간의 개수(초기값 size)  full: 버퍼에서 차있는 공간의 개수(초기값 0)추가한 세마포 변수는 위와 같고, empty는 초기화할 때 버퍼는 모두 비어있으므로 버퍼의 크기로 초기화하고 full은 초기 버퍼에는 아무런 데이터가 없으므로 0으로 초기화한다.데이터를 생성하기 전에 비어있는 공간이 있는지 확인한다. 없다면 empty세마포의 value값이 -1이 되므로 block이 되고, 있다면 임계구역 내부로 진입하여 데이터를 생성한다. 생성이 완료되면 full세마포의 value값을 1 증가시킨다.(소비자는 반대로 동작한다고 볼 수 있다. 코드참고) 이 코드를 실행시켜보면 정상적으로 결과값이 0이 출력되는 것을 확인할 수 있다.2. Readers-Writers ProblemReaders-Writers 문제는 대표적으로 공통 데이터베이스에 접근하는 경우가 있다. 하나의 데이터베이스에 여러 프로세스(readers, writers)가 접근하므로, 데이터베이스는 임계구역으로 설정해야한다. 즉, 한 번에 한 개의 프로세스만 접근가능하도록 해야하는데 이는 매우 비효율적이다.비효율을 해결하기 위해 데이터베이스에 접근하는 프로세스 종류를 reader와 writer로 나눈다. 그리고 reader는 데이터베이스 내의 정보를 바꾸지 않고 읽기만 하는 프로세스이므로, 여러 reader 프로세스가 동시에 데이터베이스를 접근하는 것을 허용한다. writer는 데이터베이스 내용을 바꾸는 프로세스이므로 당연히 mutual exclusion 을 보장해야한다.2.1 분류Readers-Writers 문제는 우선순위에 따라 여러 경우로 나눌 수 있다.  The first R/W problem (readers-preference): 이 방법은 reader 프로세스에 우선권을 주는 것이다. 만약, 한 reader 프로세스가 데이터베이스를 읽고 있는 동안 writer 프로세스가 오면 당연히 접근하지 못하고 기다린다. 이 상황에서 다른 reader 프로세스가 들어온다면, writer 프로세스가 기다리는 것을 무시하고 데이터베이스에 접근하여 읽는다. 그 결과, 두 reader가 동시에 데이터베이스를 읽는 상황이 된다.  The second R/W problem (writers-preference): 위 방법과 반대로 writer 프로세스가 기다리는 상황에서 다른 reader 프로세스가 들어온다면, 기존의 writer 프로세스 다음 순서로 기다려야한다.  The third R/W problem: 아무에게도 우선순위를 주지 않는다.3. Dining Philosopher Problem식사하는 철학자 문제는 원형 테이블에 5명의 철학자와 5개의 젓가락이 있는 상황이 있다고 하자. 각 철학자는 생각하고 식사하고 생각하고 식사하고를 반복한다. 단, 식사를 하기 위해서는 2개의 젓가락이 필요하다.이 상황을 프로그래밍을 해보자. 젓가락은 한 철학자가 가져가면 다른 철학자는 이 젓가락을 사용할 수 없다. 즉, 한 젓가락에 동시에 접근할 수 있는 철학자는 한 명뿐이므로 젓가락은 세마포로 만들 수 있다.(number of permit = 1) 한 철학자가 식사를 하려고 하면, 왼쪽 젓가락과 오른쪽 젓가락 순서로 가져가고, 식사가 끝나면 동일하게 왼쪽 젓가락, 오른쪽 젓가락 순서로 내려놓는다.3.1 Codeimport java.util.concurrent.Semaphore;class Philosopher extends Thread {\tint id; // philosopher id\tSemaphore lstick, rstick; // left, right chopsticks\tPhilosopher(int id, Semaphore lstick, Semaphore rstick) {\t\tthis.id = id;\t\tthis.lstick = lstick;\t\tthis.rstick = rstick;\t}\tpublic void run() {\t\ttry {\t\t\twhile (true) {\t\t\t\tlstick.acquire();\t\t\t\trstick.acquire();\t\t\t\teating();\t\t\t\tlstick.release();\t\t\t\trstick.release();\t\t\t\tthinking();\t\t\t}\t\t}catch (InterruptedException e) { }\t}\tvoid eating() {\t\tSystem.out.println(\"[\" + id + \"] eating\");\t}\tvoid thinking() {\t\tSystem.out.println(\"[\" + id + \"] thinking\");\t}}class Test {\tstatic final int num = 5; // number of philosphers &amp; chopsticks\tpublic static void main(String[] args) {        int i;        /* chopsticks */        Semaphore[] stick = new Semaphore[num];        for (i=0; i&lt;num; i++)            stick[i] = new Semaphore(1);        /* philosophers */        Philosopher[] phil = new Philosopher[num];        for (i=0; i&lt;num; i++)            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);        /* let philosophers eat and think */        for (i=0; i&lt;num; i++)            phil[i].start();      }}5개의 젓가락 세마포와 5명의 철학자 쓰레드를 생성한다. 각 철학자 쓰레드에는 무한 반복문으로 왼쪽 젓가락과 오른쪽 젓가락을 순서대로 집은 후 식사를 하고(몇 번 철학자가 식사했다는 것을 화면에 출력), 다시 왼쪽 젓가락, 오른쪽 젓가락 순으로 내려놓고 생각을 한다.단순히 코드를 봐서는 문제점이 없어보인다. 하지만 이를 수행하면 중간에 멈추고 더이상 실행되지 않는다.이는 대표적인 starvation 문제중 하나이다. 모든 철학자가 식사를 하지 못하고 굶어죽는 상황이라고 할 수 있다.이는 매우 드문 상황으로 모든 철학자가 동시에 식사를 하려고 왼쪽 젓가락을 집었다고 하자. 그러면 5명의 철학자가 5개의 젓가락을 모두 집어든 상황이다. 그 결과, 남아있는 젓가락은 더 이상없고 모든 철학자가 반대편 젓가락을 들기 위해 기다리고 있다. 하지만 식사할 수 있는 철학자는 없으므로 아무도 젓가락은 내려놓지 않고 하염없이 기다리고 있다.이러한 상황을 교착상태(deadlock) 라고 한다. 오오미ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-10-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-3.html"
      }
      ,
    
      "cs-algorithm-2020-04-03-eb-b0-b1-ec-a4-80-ec-b5-9c-ec-86-8c-ea-b0-92-html": {
        "title": "백준(10868번): 최소값",
        "tags": "백준, 알고리즘, 세그먼트트리",
        "date": "April 3, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플래티넘5 : 세그먼트 트리 문제이다.백준(10868번) - 최소값생각            0      1      2      3      4      5      6                  4      1      7      5      2      9      8      입력값이 이렇게 주어진다고 생각해보자. 이 상태에서 3~6까지의 최소값을 구하는 것은, 단순한 방법으로 구해도 $O(n^2)$으로 풀 수 있다. 하지만 이러한 확인(쿼리)가 많아진다면, 급격하게 시간 복잡도가 올라간다. 따라서 이 문제에서 제시하는 m(100000) 개에 대해서 n(100000)을 모두 확인하는 방법으로 간다면 문제를 풀 수 없다.($O(n^2)$)문제의 원인그렇다면 어느 부분에서 연산이 많이 걸리는 지 생각해보자. 가장 큰 부분을 판단을 중복으로 한다는 것이다. 0~3까지의 최소값을 구하는 것과, 1~4까지의 최소값을 구하는 과정에는 1~3까지의 최소값을 비교하는 과정이 중복된다. 그렇다면, 처음에 주어진 index를 나누어, 그 나눈 구간에 대해 최소값을 구해놓으면 어떨까?어떻게 나눌까?나누겠다는 생각이 들고 난 후에는, 어떻게 하면 잘 나눌 수 있을 지에 대해 고민했다. 이 부분은 트리가 가장 용이하다. 정보를 저장하는 자료구조 중, 탐색에 있어 시간복잡도가 log이다. 나누는 방법은 생각 보다 간단하다.Tree 구조트리의 구조는 모양의 변화를 가지는 것이다. 우리가 보통 가지는 선형 리스트를 조금 바꾸어 생각하면 쉽게 트리 구조를 만들 수 있다.이렇게 2의 제곱수만큼의 개수를 아래쪽으로 옮기면서 쌓으면 트리 구조가 된다. 이 때, 중요한 것은 가장 위층으로 부터 아래로 내려오는데 그 index들의 관계를 아는 것이다. 잘 보면, 1에서 2, 3은 $2\\times 1$, $2\\times 1 + 1$ 과 같다. 왼쪽 트리, 오른쪽 트리로 가는 관계는 계속 일관성을 가진다.Segment Tree그렇다면 이번에는 이 트리 구조를 이 문제에 맞는 모양으로 바꾸어 보자. 우리는 최소값을 미리 저장하기 위해 트리구조를 사용하기로 했는데, 그 구조를 아래와 같이 만들어서 생각해보자.기본적인 트리구조는 같지만 추가된 변수가 있다. 그것은 index의 시작과 끝을 나타내는 start~end 변수이다. 이렇게 나누었다고 가정하고, 2~5까지의 최소값을 얻기위해 조사해야 하는 Node의 개수를 파악해보자.이렇게 3개의 값만 조사하면 최소값을 얻을 수 있다! 이 때 발생하는 시간 복잡도는 $log(N)$ 이다. depth가 내려갈 수록 반씩 조사를 덜 할 수 있기 때문이다.tree에 필요한 node 수위 예시에서 총 7개의 원소를 넣기 위해 필요한 node의 개수는 총 13개 이다. 이 13개를 다 넣기 위해 필요한 트리의 깊이는 총 4이다. 이 값을 얻기 위한 수식은 다음과 같다.보통의 tree는 input으로 들어오는 요소의 개수와 트리의 node번호가 일치하지만, 이 경우는 depth가 1개 추가되므로 1을 더해주어야 한다. 이것을 코드로 구현하면 다음과 같다.h = ceil(log2(n))+1;treeSize = (1 &lt;&lt; h);&lt;&lt;은 shift 연산자로, 2진 연산을 할 때, 자리수를 올려주는 역할을 한다.init (초기화)처음에 input을 받고서, 가장 먼저 해야하는 일은, input을 tree안에 넣는 것이다. 그런데 우리가 설계한 세그먼트 트리를 생각해보면, 이 친구는 아래 node가 결정된 뒤에 상위 노드가 결정될 수 있다. 재귀로 짜면 해결될 것이다.void init(vector&lt;int&gt;&amp; input, vector&lt;int&gt;&amp; tree, int node, int start, int end){    if (start == end) {        tree[node] = input[start];        return;    }    init(input, tree, 2*node, start, (start+end)/2);    init(input, tree, 2*node+1, (start+end)/2+1, end);    tree[node] = min(tree[2*node], tree[2*node+1]);    return;}init 함수의 argument로는 input 벡터, tree 벡터, 내가 기록할 node의 index, 처음 node가 커버하게 될 index의 시작과 끝이 필요하다. 그 뒤로는 아까 트리 구조에서 본 왼쪽, 오른쪽 노드로 가는 함수 관계에 따라 init함수를 계속 수행하면 된다. 종료조건은, 그림에서 보았듯이 start와 end과 같아지는 지점에서 input에 start 해당하는 index의 값을 넣어준다.find저장된 자료구조에서 찾는 과정이다. 내가 찾으려고 하는 범위을 left, right 라 하고, 내가 처음에 탐색을 시작할 노드의 번호를 node, 그 노드가 커버하는 index의 범위를 start, end라 하자. tree의 가장 위부터 탐색을 시작할 때, 범위에 걸리는 녀석들만 비교의 대상이 되어야 한다. 이런 범위를 따져보면 총 3가지로 나눌 수 있다.  left, right 사이에 현재 노드의 커버범위가 들어온다.          후보로 선정한다.        left, right 와 현재 노드의 커버범위가 전혀 겹치지 않는다.          버린다.        애매하게 걸친다.          더 깊이 들어가서 조사한다.      이 과정을 구현하면 다음과 같다.int findMin(vector&lt;int&gt;&amp; tree, int node, int start, int end, int left, int right){    if (left &gt; end || right &lt; start) {        return INF;    } else if (left &lt;= start &amp;&amp; end &lt;= right){        return tree[node];    }    int a = findMin(tree, 2*node, start, (start+end)/2, left, right);    int b = findMin(tree, 2*node+1, (start+end)/2+1, end, left, right);    return min(a, b);}Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int INF = 1111111111;void init(vector&lt;int&gt;&amp; input, vector&lt;int&gt;&amp; tree, int node, int start, int end){    if (start == end) {        tree[node] = input[start];        return;    }    init(input, tree, 2*node, start, (start+end)/2);    init(input, tree, 2*node+1, (start+end)/2+1, end);    tree[node] = min(tree[2*node], tree[2*node+1]);    return;}int findMin(vector&lt;int&gt;&amp; tree, int node, int start, int end, int left, int right){    if (left &gt; end || right &lt; start) {        return INF;    } else if (left &lt;= start &amp;&amp; end &lt;= right){        return tree[node];    }    int a = findMin(tree, 2*node, start, (start+end)/2, left, right);    int b = findMin(tree, 2*node+1, (start+end)/2+1, end, left, right);    return min(a, b);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    int n, m;    cin &gt;&gt; n &gt;&gt; m;    int h = int(ceil(log2(n)))+1;    int treeSize = (1 &lt;&lt; h);    vector&lt;int&gt; tree(treeSize, INF);    vector&lt;int&gt; a(n);    for (int i = 0; i &lt; n; i++) {       cin &gt;&gt; a[i];    }    init(a, tree, 1, 0, n-1);    for (int i = 0; i &lt; m; i++) {        int left, right;        cin &gt;&gt; left &gt;&gt; right;        cout &lt;&lt; findMin(tree, 1, 0, n-1, left-1, right-1) &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/04/03/%EB%B0%B1%EC%A4%80-%EC%B5%9C%EC%86%8C%EA%B0%92.html"
      }
      ,
    
      "cs-algorithm-2020-04-03-eb-b0-b1-ec-a4-80-ea-b5-ac-ea-b0-84-ed-95-a9-ea-b5-ac-ed-95-98-ea-b8-b0-html": {
        "title": "백준(2042번): 구간 합 구하기",
        "tags": "백준, 알고리즘, 세그먼트트리",
        "date": "April 3, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플래티넘5 : 세그먼트 트리 문제이다.백준(2042번) - 구간 합 구하기생각전형적인 세그먼트 트리 문제이다. 구간에 대한 합을 연속된 쿼리로 물어보는 경우인데, 이런 경우 단순하게 짜면 그냥 펑!이다. 이 문제 같은 경우는 추가적으로 수가 변형되는데, 이전 백준(10868번): 최소값에서 한 단계 업그레이드 되었다고 보면된다.update업데이트는 별 것 없다. 내가 바꾸고 싶은 녀석의 트리 하위 노드에 접속하여, 그 노드가 영향을 주는 노드만 쏙쏙 업데이트 해주면 된다. 만약 2번 값을 바꾸고 싶다면 2번이 영향을 주는 노드는 파란색 노드들 이다.void update(int changed_index, ll changed_value, int index, int start, int end){        if (start == end) {           nodes[index] = changed_value;           return;        }        int mid = (start+end)/2;        if (start &lt;= changed_index &amp;&amp; changed_index &lt;= mid) {            update(changed_index, changed_value, 2*index, start, mid);        } else {            update(changed_index, changed_value, 2*index+1, mid+1, end);        }        nodes[index] = nodes[2*index] + nodes[2*index+1];    }사실 이 부분을 생각할 때, 위 방법 말고, 차이를 다 더해주는 방법을 생각했는데 좋지 않아 적지 않는다.Code이번에는 클래스로 구현했다. 그런데, 클래스로 구현하면 속도가 매우 느리다고 한다. private 키워드도 느리니 쓰지 말라한다. 흥. 구조체로 구현하라고 한다.#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, m, k;ll arr[1000001];class SegmentTree{private:    ll* nodes;    ll* input;public:    SegmentTree(int size, ll* input){        int h = ceil(log2(size))+1;        int treeSize = (1 &lt;&lt; h);        nodes = new ll[treeSize];        this-&gt;input = input;        init(1, 0, size-1);    }    ~SegmentTree(){        delete[] nodes;    }    void init(int index, int start, int end){        if (start == end) {            nodes[index] = input[start];            return;        }        int mid = (start+end)/2;        init(2*index, start, mid);        init(2*index+1, mid+1, end);        nodes[index] = nodes[index*2] + nodes[index*2+1];    }    ll findSum(int index, int start, int end, int left, int right){        if (left &gt; end || right &lt; start){            return 0;        } else if (left &lt;= start &amp;&amp; end &lt;= right){            return nodes[index];        }        int mid = (start+end)/2;        return findSum(2*index, start, mid, left, right) + findSum(2*index+1, mid+1, end, left, right);    }    void update(int changed_index, ll changed_value, int index, int start, int end){        if (start == end) {           nodes[index] = changed_value;           return;        }        int mid = (start+end)/2;        if (start &lt;= changed_index &amp;&amp; changed_index &lt;= mid) {            update(changed_index, changed_value, 2*index, start, mid);        } else {            update(changed_index, changed_value, 2*index+1, mid+1, end);        }        nodes[index] = nodes[2*index] + nodes[2*index+1];    }};int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for (int i = 0; i &lt; n; i++) {        cin &gt;&gt; arr[i];    }    SegmentTree st(n, arr);    int changeCount = 0, printCount = 0;    while (!(changeCount == m &amp;&amp; printCount == k)) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        if (a == 1) {            ll c;            cin &gt;&gt; c;            changeCount++;            st.update(b-1, c, 1, 0, n-1);        } else {            int c;            cin &gt;&gt; c;            printCount++;            cout &lt;&lt; st.findSum(1, 0, n-1, b-1, c-1) &lt;&lt; '\\n';        }    }    return 0;}#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;int N, M, K;void init(vector&lt;ll&gt;&amp; input, vector&lt;ll&gt;&amp; tree, int node, int start, int end){    if (start == end) {        tree[node] = input[start];        return;    }    int mid = (start+end)/2;    init(input, tree, 2*node, start, mid);    init(input, tree, 2*node+1, mid+1, end);    tree[node] = tree[node*2] + tree[node*2+1];}ll findSum(vector&lt;ll&gt;&amp; tree, int node, int start, int end, int left, int right){    if (end &lt; left || start &gt; right) return 0;    else if (start &gt;= left &amp;&amp; end &lt;= right) return tree[node];        int mid = (start+end)/2;    ll a = findSum(tree, 2*node, start, mid, left, right);    ll b = findSum(tree, 2*node+1, mid+1, end, left, right);    return a+b;}void update(vector&lt;ll&gt;&amp; tree, int loc, ll value, int node, int start, int end) {    if (start == end) {        tree[node] = value;        return;    }        int mid = (start+end)/2;        if (start &lt;= loc &amp;&amp; loc &lt;= mid) {        update(tree, loc, value, 2*node, start, mid);    } else {        update(tree, loc, value, 2*node+1, mid+1, end);    }    tree[node] = tree[2*node] + tree[2*node+1];}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;    int h = int(ceil(log2(N)));    int treeSize = (1 &lt;&lt; (h+1));    vector&lt;ll&gt; a(N);    vector&lt;ll&gt; tree(treeSize, 0);    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; a[i];    }    init(a, tree, 1, 0, N-1);        for (int i = 0; i &lt; M+K; i++) {        int action;        cin &gt;&gt; action;        if (action == 1){            int loc;            ll value;            cin &gt;&gt; loc &gt;&gt; value;            update(tree, loc-1, value, 1, 0, N-1);                    } else {            int left, right;            cin &gt;&gt; left &gt;&gt; right;            cout &lt;&lt; findSum(tree, 1, 0, N-1, left-1, right-1) &lt;&lt; '\\n';        }    }        return 0;}",
        
        "url": "/cs/algorithm/2020/04/03/%EB%B0%B1%EC%A4%80-%EA%B5%AC%EA%B0%84-%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-03-eb-b0-b1-ec-a4-80-ea-b3-b5-ed-95-ad-html": {
        "title": "백준(10775번): 공항",
        "tags": "백준, 알고리즘, 유니온파인드",
        "date": "April 3, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드2 : 유니언 파인드 문제이다.백준(10775번) - 공항생각이런 문제는 정말 비행기가 온다고 생각하고 푸는 것이 가장 좋은 것 같다. 그러니까 모든 문제는 시뮬레이션을 제대로 하는 것이 중요.. 총 5개의 게이트가 있다고 하자. 그 때, 4번으로 비행기가 들어온다. 그럼 4번에 배정하는 것이 맞다. 그런데 또 4번으로 들어온다. 이 문제는 4번 보다 작은 게이트에만 비행기가 들어올 수 있으므로 들어갈 수 있는 게이트는 1, 2, 3이다. 그런데, 문제 특징 상 원하는 게이트보다 작은 부분에만 들어갈 수 있으므로 가장 많은 비행기를 넣기 위해서는 원하는 게이트에서 작은 숫자를 가진 게이트 중, 숫자가 가장 큰 게이트에 들어가는 것이 최선이다.(응?) 이해를 위해 표를 그려보자.            gate      1      2      3      4      5                         0      0      0      1      0      이 상황에서 3번 게이트로 들어올 경우 두가지 그림이 가능하다.            gate      1      2      3      4      5                         1      0      0      1      0                  gate      1      2      3      4      5                         0      0      1      1      0      1번 표의 경우, 만약 1번으로 들어오는 비행기가 있다고 하면, 이 비행기는 이미 게이트가 차 있으므로 들어가지 못한다. 그래서 총 숫자는 2이다. 2번 표에서는 1번 게이트가 비어있으므로 비행기를 댈 수 있다. 그 결과 정답은 3이다. 이렇게, 비행기가 들어오는 방법은 원하는 게이트보다 작거나 같은 게이트 중 비어있는 게이트에서 가장 큰 숫자를 가진 게이트 순서로 도킹해야한다.유니온 파인드위에서 생각한 것은, 대안 게이트를 찾는 방법이다. 그런데 생각해보면, 이 대안 게이트는 그래프로 볼 수 있다.gate     : 1, 2, 3, 4, 5airplain : 4, 4, 3, 1위와 같은 순서로 비행기가 들어온다고 했을 때의 그림을 보자.airplain 4airplain 4airplain 3airplain 1이 과정에서, 신경써주어야 하는 것은, 해당 게이트의 대안 게이트의 번호가 무엇인지이다! 무조건 처음에는 비행기가 왔을 때, 자신의 게이트에 넣는 것은 확정이므로, 처음 도킹 위치의 초기값은 자기 자신의 게이트 이다. 이제 비행기가 들어오면서, 어떠한 방법으로 이것을 업데이트 해줄지 고민하면 된다.대안 게이트 합치기기본적으로 대안 게이트의 위치는 나보다 하나 작은 녀석의 게이트이다. 하지만 그 위치에도 이미 도킹이 되어 있다면, 그 녀석의 대안 게이트를 또 찾아야 한다. 그러므로 대안 게이트를 찾아서 업데이트 할 때는 나보다 작은 녀석을 기반으로 하되, 그녀석의 최종적인 대안 게이트를 찾아야 한다. 유니온 파인드 알고리즘에서 이 대안 게이트는 조상에 치환되는 개념으로 볼 수 있다. 결국은 조상을 찾아서, 그 조상으로 업데이트를 진행해야 한다.종료조건은 간단하다. 문제에서 보여주듯 원하는 게이트보다 작은 게이트들이 다 도킹이 된 상태면 종료한다. 이 조건은, 알고리즘 상에서 대안 게이트의 번호가 0이 되는 것과 동치이다. 0번 게이트는 없으므로 도킹할 수 없다.알고리즘  초기 게이트의 위치를 대안 게이트의 번호를 자기자신의 게이트를 가리키도록 한다.  비행기가 들어올 때, 대안 게이트를 찾는다.  대안 게이트를 찾으면, 대안 게이트에 비행기가 도킹했다고 생각하고 도킹한 비행기의 숫자를 늘린다.  대안 게이트에 비행기가 들어왔으므로, 방금 도킹한 비행기의 대안 게이트를 찾는다.  만약, 대안 게이트의 번호가 0인 경우 현재까지 도킹한 비행기를 출력하고 종료한다.Code#include &lt;iostream&gt;using namespace std;int n, m;int parent[100001];int ans = 0;int find(int gate){    if (gate == parent[gate]){        return gate;    }    return parent[gate] = find(parent[gate]);     // 탐색하는 과정에서 있었던 대안 게이트를 최종 값으로 업데이트한다.}// 게이트의 최종 대안 게이트로 업데이트 한다.void unite(int x, int y) {    x = find(x);    y = find(y);    parent[x] = y;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        parent[i] = i;    }    for (int i = 0; i &lt; m; i++) {        int command;        cin &gt;&gt; command;        int empty_gate = find(command);        if (empty_gate == 0) {            break;        }        ans++;        unite(empty_gate, empty_gate-1); // 기본적으로 나보다 하나 작은 게이트와 합친다.    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/03/%EB%B0%B1%EC%A4%80-%EA%B3%B5%ED%95%AD.html"
      }
      ,
    
      "cs-algorithm-2020-04-02-eb-b0-b1-ec-a4-80-ec-a7-91-ed-95-a9-ec-9d-98-ed-91-9c-ed-98-84-html": {
        "title": "백준(1717번): 집합의 표현",
        "tags": "백준, 알고리즘, 유니온파인드",
        "date": "April 2, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 유니온 파인드 문제이다.백준(1717번) - 집합의 표현생각문제를 이해해보자. 먼저 처음에 아무일도 하지 않을 경우에 입력된 n에 대해서 0 ~ n까지의 바구니가 생긴다. 그 다음, m개의 명령이 들어온다. 명령은 해당 원소가 들어있는 바구니를 합치는 것, 그리고 해당 원소가 같은 바구니에 들어있는 지 확인하는 것이다.그렇다면 핵심은, 현재 어떻게 내가 들어가 있는 바구니를 찾을 것인가? 그리고 찾았다면 어떤식으로 합쳐서 가지고 있을 것인가? 이다. 결국 집합을 만들고, 서로소 인지를 확인하는 문제이다.가장 단순하게 생각해보자. 처음에 모든 바구니는 자기자신만을 원소로 갖는 바구니를 가진다. 이 상태에서 1번 바구니와 3번 바구니를 합치라는 명령이 내려올 때, 우리는 일반적으로 이것을 동등하게 생각하고 연결하려 한다. 하지만 이렇게 생각할 경우에 해당 바구니에 대한 번호를 재정의 해야 한다. 예를 들어, (1, 2)가 들어있는 바구니는 몇번 바구니라 정의해야 할까? 또 추가적으로 3이 들어온 경우 (1, 2, 3)은 몇번 바구니 일까? 바구니에 원소가 추가될 경우 계속하여 바구니의 이름을 재정의 해야 한다.그러니 위계 질서를 줘보자. 1번 바구니와 2번 바구니를 합친다는 명령이 내려왔을 때 2번 바구니는 1번을 따른다. (2-&gt;1) 그리고 3번 바구니는 2번을 따른다고 하면 (3-&gt;2-&gt;1)로 준다. 그리고 이렇게 생성된 바구니의 번호를 1이라 하면, 합치는 과정을 통한다하더라도 합쳐진 집합의 번호는 가장 먼저 합쳐진, 즉 조상 원소의 번호라 지칭할 수 있다. 즉, 위의 바구니는 1번 바구니라 할 수 있고, 다른 합쳐진 집합이 있다하더라도 이 집합의 조상은 독립적으로 유지된다.(3-&gt;2-&gt;1) = 1번 바구니(4-&gt;5) = 5번 바구니5번 바구니와 3번 바구니를 합해라.=&gt; (4-&gt;5-&gt;3-&gt;2-&gt;1) = 1번 바구니문제 발생하지만 이 경우에는 문제가 발생하는데, (2-&gt;1), (5-&gt;4) 인 경우가 있다고 하자. 이 때 5번이 2번 바구니에 속한다고 할 경우 이 논리대로라면 (5-&gt;2-&gt;1)이 된다. 그런데 사실은 4번도 1번 바구니에 속해야 한다. 논리적 오류가 발생한다.이 문제는 바구니가 속하는 기준이 한 방향이기 때문이다. 하지만 속하는 기준을 여러개로 만들지 않아도 해결이 가능하다.해결 방법아까 조상을 만들고, 추가된 집합에 대한 바구니 번호를 가장 위에 있는 조상의 번호를 따르기로 했다. 위에서 발생한 문제에 대해 해당 번호가 어떤 바구니(조상)에 있는지 확인하고 그 바구니끼리 연결한다면 해당 문제는 해결된다.(2-&gt;1) = 1번 바구니(5-&gt;4) = 4번 바구니5번 바구니와 2번 바구니를 합쳐라.5번의 조상 : 4번2번의 조상 : 1번(4-&gt;1)로 바꿔버린다.=&gt; (2-&gt;1), (5-&gt;4-&gt;1)이렇게 된 경우 1번 바구니에 해당한 번호는 2, 4, 5로 원하는 결론이다.구현이것을 구현하는 것이 어려워 보이지만, 단순하다. 위에서 결국 필요한 것은 내 원소의 번호, 그리고 그 원소가 따르는 번호이다. 그리고 그 따르는 것들의 바구니 번호는 가장 위에 기초가 되는 조상 번호가 대표한다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      3      4      5      6      7      7 80 1 31 1 70 7 61 7 10 3 70 4 20 1 11 1 1line 10 1 3 // 1번과 3번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      3      4      5      6      7      1의 조상 번호 : 13의 조상 번호 : 33번이 따르는 바구니를 1로 바꾼다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      6      7      line 21 1 7 // 1번과 7번은 같은 바구니이니?            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      6      7      7의 조상 번호 : 71의 조상 번호 : 1Noline 30 7 6 // 7번과 6번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      6      7      7의 조상 번호 : 76의 조상 번호 : 66번은 7번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      7      line 41 7 1 // 7번과 1번은 같은 바구니이니?            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      7      7의 조상 번호 : 71의 조상 번호 : 1Noline 50 3 7 // 3번과 7번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      7      3의 조상 번호 : 17의 조상 번호 : 77번은 3번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      3      line 60 4 2 // 4번과 2번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      3      4의 조상 번호 : 42의 조상 번호 : 22번은 4번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      4      1      4      5      7      3      line 70 1 1 // 1번과 1번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      3      1의 조상 번호 : 11의 조상 번호 : 11번은 1번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      4      1      4      5      7      3      line 81 1 1 // 1번과 1번은 같은 바구니이니?            바구니      0      1      2      3      4      5      6      7                  번호      0      1      4      1      4      5      7      3      1의 조상 번호 : 11의 조상 번호 : 1Yes결론이런 방식으로 업데이트 하는 과정을 거치면, 묶인 집합을 효과적으로 찾을 수 있다. 결론적으로 구현해야 하는 함수는 find, union 함수이다.findfind 함수같은 경우에는, 특정 원소에 대해 물었을 때, 그 녀석이 속한 바구니를 끝까지 찾아 어떤 바구니인지 반환한다.unionunion 함수는 명령이 들어왔을 때, 각각이 속해있는 바구니를 찾고 그 바구니를 연결한다. 이 때, 중요한 것은 해당 원소의 바구니 번호를 찾아야 한다는 것이다.#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n, m;int box[1000001];int find(int elem){    if (elem == box[elem]) {        return elem;    }    return find(box[elem]);}void merge(int elem1, int elem2){    box[find(elem2)] = find(elem1);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt;= n; i++) {        box[i] = i;    }    for (int i = 0; i &lt; m; i++) {        int command, elem1, elem2;        cin &gt;&gt; command &gt;&gt; elem1 &gt;&gt; elem2;        if (command) {            if (find(elem1) == find(elem2)) {                cout &lt;&lt; \"YES\" &lt;&lt; '\\n';            } else {                cout &lt;&lt; \"NO\" &lt;&lt; '\\n';            }        } else {            merge(elem1, elem2);        }    }    return 0;}시간 복잡도 문제하지만 위의 코드대로 한다면 문제가 발생한다. 그 이유는 원소의 개수가 많아짐에 따라 어떤 바구니에 들어있는지 탐색하는 시간이 오래걸리기 때문이다. 예제 입력에 대한 마지막 상황을 보자.            바구니번호      0      1      2      3      4      5      6      7                  따르는 번호      0      1      4      1      4      5      7      3      이 상황에서, 6은 어느 바구니에 있을까? (6-&gt;7-&gt;3-&gt;1) 로, 1번 바구니에 있다. 만약, 6번을 0번이 속한 바구니와 합치라는 명령이 들어온다면 4번의 연산을 수행해야 한다. 그렇다면, 극단적인 경우에, n개의 원소가 순차적으로 얽혀있고 (n-&gt;n-1-&gt;n-2-&gt;…) n이라는 원소를 특정 바구니에 합치라는 명령이 들어올 경우, $O(n)$ 의 시간 복잡도를 갖는다. 이 때, 수행하는 명령의 개수가 m일 경우 $O(nm)$ 의 시간 복잡도를 갖는다. 현재 문제에서 n = 100000, m = 1000000이므로 시간 초과가 난다.해결이 문제는 해결이 간단한데, find 함수에 찾는 과정에서, 최종 조상의 번호를 아예 해당 원소의 바구니라고 저장해버리는 것이다. 이 상황에서는 원소가 속해있는 바구니 번호가 중요한 것이지, 그 과정에서 발생하는 그래프가 중요한 것이 아니기 때문이다.#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n, m;int box[1000001];int find(int elem){    if (elem == box[elem]) {        return elem;    }    return box[elem] = find(box[elem]);}void merge(int elem1, int elem2){    box[find(elem2)] = find(elem1);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt;= n; i++) {        box[i] = i;    }    for (int i = 0; i &lt; m; i++) {        int command, elem1, elem2;        cin &gt;&gt; command &gt;&gt; elem1 &gt;&gt; elem2;        if (command) {            if (find(elem1) == find(elem2)) {                cout &lt;&lt; \"YES\" &lt;&lt; '\\n';            } else {                cout &lt;&lt; \"NO\" &lt;&lt; '\\n';            }        } else {            merge(elem1, elem2);        }    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/02/%EB%B0%B1%EC%A4%80-%EC%A7%91%ED%95%A9%EC%9D%98-%ED%91%9C%ED%98%84.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-09-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-2-html": {
        "title": "09: 프로세스 동기화 Part 2",
        "tags": "OS, Synchronization, Semaphore",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스 동기화 도구에 대해 알아본다.Semaphore(세마포)Semaphoresms 깃발이라는 네덜란드 단어이다. 옛날에는 기찻길에서 공유하는 길이 있을 때, 깃발 표식으로 오고감의 신호를 주고 받았다. 이러한 맥락에서, Critical section을 사용하는 쓰레드에 사용하는 방법의 이름으로 붙게 되었다.위의 그림을 보면 공유하는 기찻길이 하나이다. 이 경우 공유 자원이 1이라 볼 수 있다. 하나의 기차가 지나갈 때 1을 감소시키고, 다 지나간 뒤에 1을 증가시키는 일을 반복한다. 그리고 다른 기차가 지나가려고 할 때, Semaphore가 0인 경우에는 정지하고 1인 경우에 순차적으로 지나가게 하면 해결된다. 이렇게 Semaphore가 0, 1인 경우를 Binary Semaphore라 한다.공유 자원이 꼭 1개일 필요는 없다. 여러개의 자원인 상황도 존재한다. 가령 위의 기차 그림에서 통과해서 갈 수 있는 공유 기찻길이 5개라면, 공유자원은 5이다. 이런 경우를 counting semaphore라 한다.1. 구현위의 예시에서 보듯, 깃발은 총 두가지가 필요하다. 지나가는 경우에는 감소, 지나간 뒤에는 증가이다. 초기에는 P, V로 불렸다.(네덜란드에서 만들어져 네덜란드어의 약자이다.) 현재에는 P는 test를 의미하며 acquire() 로 사용하고, V는 increment를 의미하며 release() 로 사용한다. acquire()는 자원이 사용가능한지 확인하고, 사용가능하다면 사용하고 그렇지 않다면 대기한다. release()는 자원을 내놓고, 다음 자원을 실행시킨다.자바를 통해 세마포 구조를 간단히 살펴보면 아래와 같다.class Semaphore {  int value;      // number of permits  Semaphore(int value) {    // ...  }  void acquire() {    value--;    if (value &lt; 0) {      // add this process/thread to list      // block    }  }  void release() {    value++;    if (value &lt;= 0) {      // remove a process P from list      // wakeup P    }  }}위 코드에서 acquire() 는 value값을 감소시키고 만약 value값이 0보다 작으면(가용자원을 모두 사용함) 이미 해당 임계구역에 어느 프로세스가 존재한다는 의미이므로 현재 프로세스는 접근하지 못하도록 막아야한다. 이를 list라는 기다리는 줄에 추가한 뒤 block을 걸어준다.(list는 일반적으로 큐로 되어있다.)release() 는 value값을 증가시키고, 만약 value값이 0보다 같거나 작으면 임계구역에 진입하려고 대기하는 프로세스가 list에 남아있다는 의미이므로 그 중에서 하나를 꺼내어 임계구역을 수행할 수 있도록 해주어야 한다.세마포를 그림으로 나타내면 위와 같다. list는 실제로 큐로 볼 수 있다. acquire()에 의해 block되는 프로세스는 세마포 내부에 있는 큐에 삽입된 후, 다른 프로세스가 임계구역을 나오면서 release()를 호출하여 세마포 큐에 있는 프로세스를 깨워야 한다.(다시 ready queue로 보낸다.)위에서 살펴본 것처럼 세마포는 일반적으로 Mutual exclusion을 위해 사용된다.운영체제 정리 08: 프로세스 동기화 &lt;1. 발생 이유와 목적&gt;Bank Account Problem(은행 계좌 문제) 해결이전 글에서 보았던 은행 계좌 문제에 세마포를 적용해보자. 위에서 임계구역은 BankAccount 클래스 내부의 입출력하는 부분인 것을 보았다. 여기에 세마포를 적용해보면 아래와 같다.import java.util.concurrent.Semaphore;  // 세마포를 사용하기 위해 파일 가장 위에 추가해야 한다.class BankAccount {\tint balance;\tSemaphore sem;\tBankAccount() {   // BankAccount 클래스의 생성자가 호출되면 세마포를 만든다.\t\tsem = new Semaphore(1);  // value 값을 1로 초기화한다.\t}\tvoid deposit(int amount) {\t\ttry {\t\t\tsem.acquire();   // 임계구역에 들어가기를 요청한다.\t\t} catch (InterruptedException e) {}\t    /* 임계 구역 */\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();   // 임계구역에서 나간다.\t}\tvoid withdraw(int amount) {\t\ttry {\t\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t    /* 임계 구역 */\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tsem.release();\t}\tint getBalance() {\t\treturn balance;\t}}value 값은 임계구역에 몇 개의 프로세스를 접근할 것인지 정하는 것과 같다. 지금은 임계 구역에 하나의 프로세스만 접근가능하기 때문에 1 로 초기화 한다. (위 코드를 제외한 부분은 동일하다.) 이 코드를 수행하면 아래와 같은 결과가 나온다.// +,- 출력 생략balance = 0정상적으로 잔액이 0원이 나온 것을 확인할 수 있다. 이 코드는 임계구역의 문제를 해결하였으므로 몇 번을 수행하여도 같은 결과값이 출력된다.2. Ordering세마포는 mutual exclusion뿐 아니라 ordering을 하기 위해서도 사용한다. 즉, 프로세스의 실행 순서를 원하는 순서로 설정 할 수 있다.예를 들어, 프로세스가 P1, P2 두 개가 있다고 가정하자. 원하는 순서는 P1, P2 순으로 실행하기를 원한다. 그러면 아래와 같이 설정해줄 수 있다.// 초기 semaphore 값 = 0sem value = 0            P1      P2                         sem.acquire()              section 1      section 2              sem.release()             P1이 먼저 실행된 경우  Section 1 이전에 아무런 동작이 없으므로 바로 수행한다.  sem.release() 를 만나면 value값을 1 증가시키고, 세마포 큐에 있는 프로세스를 깨워주는데 현재에는 큐에 프로세스가 없으므로 아무 동작도 하지 않는다.  P2가 실행된다.  P2의 sem.acquire() 를 만나면 현재 value값은 1이고 이를 1감소시키면 0이 된다. value = 0이면 block을 하지 않으므로, 무사히 Section 2가 수행된다.P2가 먼저 실행된 경우  Section 2 이전에 sem.acquire() 가 있으므로 이를 수행하는데, 현재 value값은 0이고 이를 1 감소 시키면 -1 이 된다. value값이 음수면 해당 프로세스를 block시킨다.(세마포 큐에 삽입한다.)  P1이 실행되면 Section 1이 바로 수행된다.  sem.release() 를 만나면 value값을 1 증가시키고, 세마포 큐에 있는 P2 프로세스를 깨워준다.(현재 value = 0)  P2의 Section 2가 수행된다.위에서 두 가지 경우를 살펴보았듯이, P1, P2 둘 중 어느 것을 먼저 실행하여도 결과적으로 P1 -&gt; P2 순서로 수행하는 것을 알 수 있다.입금 출금 순서로 은행계좌 문제 해결하기위에서 계속 살펴봤던 은행계좌 문제에서 ordering을 적용해보자. 프로세스의 실행 순서는 반드시 입금, 출금 순서로 수행해야한다.class BankAccount {\tint balance;\tSemaphore sem, semOrder;\tBankAccount() {\t\tsem = new Semaphore(1);\t\tsemOrder = new Semaphore(0);   // Ordeing을 위한 세마포\t}\tvoid deposit(int amount) {\t\ttry {\t\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();\t\tsemOrder.release();   // block된 출금 프로세스가 있다면 깨워준다.\t}\tvoid withdraw(int amount) {\t\ttry {\t\t\tsemOrder.acquire();   // 출금을 먼저하려고 하면 block한다.\t\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tsem.release();\t}\tint getBalance() {\t\treturn balance;\t}}위처럼 코드를 수정할 수 있다. Ordering을 위한 semOrder 세마포 변수를 선언하고, 출금하는 동작 앞에 acquire(), 입금하는 동작 뒤에 release() 를 추가하였다.+++++++++++++++++++++++++------------+++++-----+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------------------------------balance = 0실행 결과는 위와 같다. +(입금)가 맨 앞에서 실행한 모습을 볼 수 있다.(입금, 출금 횟수는 100번으로 줄였다.)만약, 입금, 출금, 입금, 출금, … 교대로 출력하도록 하려면 세마포를 두 개 사용하여 아래와 같이 구현할 수 있다.void deposit(int amount) {\ttry {\t\tsem.acquire();\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();\t\tsemWithraw.release();\t\tsemDeposit.acquire();   // 입금후에는 반드시 출금을 해야 하므로 자신을 block한다.\t} catch (InterruptedException e) {}}void withdraw(int amount) {\ttry {\t\tsemWithraw.acquire();  // 입금보다 먼저 수행하는 것을 막는다.\t\tsem.acquire();\t} catch (InterruptedException e) {}\tint temp = balance - amount;\tSystem.out.print(\"-\");\tbalance = temp;\tsem.release();\tsemDeposit.release();  // 출금 수행이 완료되면 block되었던 입금 프로세스를 깨워준다.}int getBalance() {\treturn balance;}+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-balance = 0ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-09-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-2.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-08-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-1-html": {
        "title": "08: 프로세스 동기화 Part 1",
        "tags": "OS, Synchronization, Critical Section Problem",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스 동기화가 발생하는 예시와 목적, 그리고 그것을 해결하기 위한 원칙에 대해 알아본다.1. 프로세스 동기화란?  하나의 자원을 한 순간에 하나의 프로세스(쓰레드)만이 이용하도록 제어하는 것1.1 배경현대 컴퓨터의 메모리에는 여러 프로세스가 존재하는데, 이러한 프로세스들이 하나의 공유 메모리나 또 다른 프로세스에 접근할 때는 매우 신중해야 한다. 이처럼 한 프로세스가 다른 프로세스에게 영향을 받거나 주는 프로세스를 Cooperating process라고 한다. 반대로 아무런 영향을 미치지 않는 독립적인 프로세스는 Independent process이다.현대 컴퓨터 환경에는 cooperating process가 훨씬 많이 존재하고, 이들은 서로 영향을 미치기 때문에 데이터나 흐름에 대한 동기화가 매우 중요하다. 프로세스 사이에 동기화를 하는 것을 프로세스 동기화(Process Synchronization) 라고 한다.(현재에는 대부분 쓰레드 기준으로 스위칭을 하므로, Thread synchronization으로 많이 불린다.)1.2 필요성대표적인 예로 기차표 예매가 있다. 어느 시간에 한 좌석의 기차표는 반드시 하나만 존재해야한다. 그런데 이를 예매하려는 사용자(프로세스)는 여러 명이다. 이 사용자들이 동시에 하나의 좌석 기차표를 구매하려고 하면 어떠한 일이 발생할까? 실제 환경에서는 당연하게도 동기화 문제를 해결한 시스템이므로 한 사람만이 기차표를 예매할 수 있을 것이다. 만약 동기화에 문제가 발생한다면 한 기차표를 여러 사람이 예매하는 불상사가 발생할 수 있다.1.3 목표프로세스 동기화는 여러 프로세스가 공유하는 자원의 일관성을 유지하는 것이다. 가령 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때 이 프로세스들의 순서를 정하여 데이터의 일관성을 유지시켜주어야 한다. 이 부분에 대한 자세한 목적은 아래의 예를 파악하며 문제를 인지한 후에 명확하게 재정의하겠다.2. Bank Account Problem(은행 계좌 문제)동기화의 필요성을 가장 잘 느낄 수 있는 은행 계좌 문제에 대해 알아본다.2.1 문제 설명동기화 문제 중에서 대표적인 은행 계좌 문제를 살펴보자. 은행에는 하나의 계좌에 입금, 출금을 할 수 있다. 여기서 계좌는 공유하는 자원이고, 입금과 출금은 각각 프로세스라고 볼 수 있다. 부모님이 자식에게 입금을 하고, 자식은 출금을 하는 상황을 자바로 구현한 코드는 아래와 같다.// 계좌class BankAccount {\tint balance;\tvoid deposit(int amount) {\t\tbalance = balance + amount;\t}\tvoid withdraw(int amount) {\t\tbalance = balance - amount;\t}\tint getBalance() {\t\treturn balance;\t}}입금, 출금, 잔액조회 함수를 멤버함수로 갖는 클래스를 구현한다.// 입금 프로세스class Parent extends Thread {\tBankAccount b;  // 생성자는 공유하는 계좌를 초기값으로 가진다.\tParent(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {   // run(): 쓰레드가 실제로 동작하는 부분(치환)\t\tfor (int i = 0; i &lt; 100; i++)\t\t  b.deposit(1000);\t}}멤버 변수로 계좌를 가지고, 이것을 생성할 때 인자로 받는 클래스이다. 해당 클래스에서 run()은 입금을 100번 수행한다.// 출금 프로세스class Child extends Thread {\tBankAccount b;  // 생성자는 공유하는 계좌를 초기값으로 가진다.\tChild(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i = 0; i &lt; 100; i++)\t\t  b.withdraw(1000);\t}}멤버 변수로 계좌를 가지고, 이것을 생성할 때 인자로 받는 클래스이다. 해당 클래스에서 run()은 출금을 100번 수행한다.// Test.javaclass Test {\tpublic static void main(String[] args) throws InterruptedException {\t\tBankAccount b = new BankAccount();\t\tParent p = new Parent(b);\t\tChild c = new Child(b);\t\tp.start();   // start(): 쓰레드를 실행하는 메서드\t\tc.start();\t\tp.join();    // join(): 쓰레드가 끝나기를 기다리는 메서드\t\tc.join();\t\tSystem.out.println(\"balance = \" + b.getBalance());\t}}main 함수에서는 위에서 만든 클래스들을 사용하여, 계좌를 공유하는 두 개의 쓰레드를 만든다. 그리고 부모, 자식 클래스에서 각각 입금과 출금을 100번씩 수행하고, 결과적으로 남은 잔액을 조회한다. 잔액은 0이 나와야 할 것이다.// Resultbalance = 0이 결과는 정상적이다. 100번 1,000원을 입금하고, 100번 1,000원을 출금하면 잔액은 0원이 남는다. 위 코드는 2개의 쓰레드가 동작하고 있음에도 불구하고 동기화 문제가 발생할 확률은 매우 낮다. 반복이 100번 밖에 안 일어나는 매우 간단한 코드 이기 때문이다.2.2 동기화 문제 발생실제 상황에서는, 입금, 출금 명령을 내리고 이 명령이 전달되는데 까지 시간이 소요된다. 그런 상황을 만들기 위해 출금하는 과정에서 temp라는 필요없는 변수를 추가하고, +,-를 출력하고, 반복 횟수를 1000번으로 늘렸다.// 계좌class BankAccount {\tint balance;\tvoid deposit(int amount) {\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tvoid withdraw(int amount) {\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}// Result++++++++++++++++++++++++++++++++++------------------------------------------------------------------------------------------------------------------------+++++++++----------------------------------------------++++++++++++++++++++++++++++++++----+++++++-+++++----+++--------------------------------------------------------+++++++-++++-+++++++++-------++++++++++++++++++++++++++++++++++++++++++++++++++++++++---------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-++++++++++++-------------------++++++++++++++++++++-++++++++++++++++++++++++++++++++-+-------------------------------------------------------------------------+++++++++++-+++++++----------------------------------------+-------+------------+------+------------------------------------------------------------------------+-------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------+-------+----------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+--------------------------+-------------------------------------------------------------------------------++---------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++balance = 1000000+는 입금을 한 경우, -는 출금을 한 경우이고, 주목할 점은 balance값이 0이 아닌 1000000이라는 알 수 없는 값이 출력되었다. 또한 여러번 실행할 경우 100000이라는 값이 고정되어 출력되는 것도 아니다. 결과가 불일치하며, 비일관적이다. (비일관적인 이유는 운영체제에서 쓰레드를 스위칭하는 패턴이 매번 다르기 때문이다.)약간의 시간 지연을 준 것만으로도 여러 쓰레드가 하나의 공유 자원을 사용하는 프로그램은 망가지게 된다.2.3 왜 발생할까?이러한 문제가 발생하는 원인은 공통변수(common variable)에 대한 동시 업데이트(concurrent update) 때문이다.위 예제에서 공통 변수는 계좌의 잔액이다. 이에 접근하는 프로세스의 코드를 보면 다음과 같다.balance = balance + amount;   // 입금balance = balance - amount;   // 출금이는 자바 문법에서는 한 줄이라 문제가 없어 보이지만, 로우 레벨(어셈블리어)로 내려가면 여러 줄로 구현된다. 예를 들어, balance를 업데이트 하는 하이 레벨 코드 1줄이 로우 레벨에서 3줄로 구현된다고 하자.  공유 변수인 현재 잔액을 복사한다.  현재 잔액에서 명령을 수행한다.  나온 결과를 가지고 잔액을 갱신한다.그런데, parent가 수행하던 도중에 1000번을 다 수행하지 못한 상황에서 interrupt(이 경우에는 시간 지연을 걸었으므로 timer interrupt가 되겠다.)가 걸려 2번 라인에서 멈췄다고 생각해보자. parent가 1000원을 입금했지만, 업데이트가 되지 않아 여전히 현재 잔액은 0이다.이번에는 child가 부모님이 용돈을 넣은 줄 알고 신나서 돈을 뽑는 상황을 생각해보자. 잔액을 확인했더니, 아직 0이다. 그래서 child는 마이너스 통장을 통해 돈은 인출하고 현재 잔액은 -1000이 된다.따라서 이 경우, 입금과 인출이라는 행위는 프로세스 입장에서 원자성을 갖는 행위이므로 동기화가 필수적이다. 기억이 안난다면 이 글을 보자.가볍게 이해하는 컴퓨터 01: 용어 정리3. 임계구역(Critical section) 문제위의 예에서 보았던 문제를 임계구역 문제라 한다. 임계구역은 여러 개의 쓰레드가 수행되는 시스템에서 각 쓰레드들이 공유하는 데이터(변수, 테이블, 파일 등)를 변경하는 코드 영역을 말한다. 이는 동기화에서 중요한 문제 중 하나이다. 은행계좌 문제에서의 임계구역은 다음과 같다.void deposit(int amount) {  balance = balance + amount;}void withdraw(int amount) {  balance = balance - amount;}3.1 해결 방법임계구역을 해결하기 위해서는 3가지 조건이 만족해야한다.  Mutual exclusion(상호배타)          오직 한 쓰레드만이 진입 가능하다. 한 쓰레드가 임계구역에서 수행 중인 상태에서는 다른 쓰레드는 절대 이 구역에 접근할 수 없다.        Progress(진행)          한 임계구역에 접근하는 쓰레드를 결정하는 것은 유한 시간 이내에 이루어져야한다.      누가 먼저 들어갈 것인지 빠르게 결정해라        Bounded waiting(유한대기)          임계구역으로 진입하기 위해 대기하는 모든 쓰레드는 유한 시간 이내에 해당 임계구역으로 진입할 수 있어야 한다.      기다리는 모든 쓰레드가 진입가능하도록 만들어라.      4. 프로세스/쓰레드 동기화의 목적  원하는 결과값을 도출하도록 임계구역 문제를 해결한다.  프로세스의 실행 순서를 원하는대로 제어한다.  Busy wait 등과 같은 비효율성을 제거한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-08-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-07-ec-93-b0-eb-a0-88-eb-93-9c-html": {
        "title": "07: 쓰레드(Thread)",
        "tags": "OS, CPU, Thread",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "Thread에 대해서 알아본다.쓰레드(Thread)  쓰레드는 프로그램 내부의 흐름(맥)이다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void){  int n = 1;  int m = 10;  cout &lt;&lt; n * m;  while(n &lt; m)    n++;  cout &lt;&lt; \"end\" &lt;&lt; endl;}이런 코드는 하나의 흐름을 가지고 있고 이것을 쓰레드라 부른다. 일반적으로 하나의 프로그램은 하나의 쓰레드를 갖는다.다중 쓰레드(Mulitithreads)하나의 프로그램에 쓰레드가 2개 이상 존재하는 것을 다중 쓰레드라고 한다. 이렇게 한 프로그램에 여러 개의 쓰레드 즉, 흐름이 있을 수 있는 이유는 쓰레드가 빠른 시간 간격으로 스위칭되기 때문이다. 이러한 동작으로 사용자는 여러 쓰레드가 동시에 실행되는 것처럼 보인다.이 때, 동시에 수행되는 것 처럼 보이는 것을 concurrent, 실제 동시에 수행되는 것을 simultaneous라고 한다.  concurrent          CPU가 하나인 환경에서 스위칭에 의해 동시에 수행        simultaneous          여러개의 CPU 환경에서 실제로 동시에 수행되는 경우      예시다중 쓰레드를 사용하는 대표적인 예는 Web browser 이다. 화면을 출력하는 쓰레드와 데이터를 읽어오는 쓰레드가 기본적으로 따로 수행하고 있다. 그 외에도 Word processor, Media player 등 현재 대부분의 프로그램은 다중 쓰레드로 동작한다.현대 운영체제의 Switching 단위이전의 CPU 스케줄링에서 하나의 프로세스가 수행하다가 다른 프로세스로 넘어간다고 하였는데, 이는 예전의 방식이다. 현재 운영체제에서는 대부분 다중 쓰레드를 지원하기 때문에 하나의 프로세스 안에서 여러 쓰레드를 수행하다가 다른 프로세스로 넘어가서 그 프로세스의 쓰레드를 수행한다. 그러므로 현대 운영체제의 context switching 단위는 프로세스가 아닌 쓰레드 단위이다.Thread VS Precess이 부분을 제대로 이해하기 위해 process를 보고오자.가볍게 이해하는 컴퓨터 07: 운영 체제가 하는 일운영체제 정리 05: 프로세스 관리프로세스는 다른 프로세스와 완전히 독립적이다. 해당 프로세스가 가지는 구조로는 Code, Data, Heap, Stack이 있다. 이 때 쓰레드는 자기가 속한 프로세스의 일부 메모리를 공유한다. 집이라면 각 개인 구성원이 거실을 공유하는 셈이다.            공유      독립                  Code      Stack              Data      PC(program counter)              Heap      SP(stack pointer)                     Registers      Thread가 독립적 요소를 가져야 하는 이유현대 운영체제는 결국 Context Switching의 최소단위를 thread로 잡고 있기 때문이다. 결국 CPU가 처리하는 것은 thread이고, 그렇기 때문에 현재 실행 흐름을 독립적으로 기록할 필요가 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-07-%EC%93%B0%EB%A0%88%EB%93%9C.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-06-cpu-ec-8a-a4-ec-bc-80-ec-a5-b4-eb-a7-81-html": {
        "title": "06: CPU 스케쥴링",
        "tags": "OS, CPU, Scheduling",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "CPU 스케쥴링에 대해 알아본다.CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다. 이때 다음 프로세스가 어느 프로세스인지를 선택하는 알고리즘을 CPU Scheduling 알고리즘이라고 한다. 간단히 생각해보면 먼저 온 프로세스가 먼저 실행되는 것이 가장 좋을 것이라 생각할 수 있다. 하지만 여러 상황에서 사용되는 컴퓨터 환경에서 꼭 이러한 방법이 좋다고 할 수 없다. (단순한 환경에서도 이 방법이 반드시 빠른 것도 아니다.) 그러므로 CPU 스케줄링에는 여러가지 방법이 존재한다.1. 스케쥴링의 유형유형으로는 Preemptive 와 Non-preemptive가 있다.1.1 PreemptivePreemptive(선점)은 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생한 것도 아니고 모든 작업을 끝내지도 않았는데, 다른 프로세스가 해당 CPU를 강제로 점유 할 수 있다. 즉, 프로세스가 정상적으로 수행중인 가운데 다른 프로세스가 CPU를 강제로 점유하여 실행할 수 있는 것이다. 급똥 우선순위1.2 Non-preemptiveNon-preemptive(비선점)은 말 그대로 preemptive와 반대이다. 한 프로세스가 한 번 CPU를 점유했다면, I/O나 인터럽트 발생 또는 프로세스 종료가 될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다. 순서대로 들어가자2. Scheduling criteriaScheduling criteria(척도)는 스케줄링의 효율을 분석하는 기준들이다.  CPU Utilization(이용률, %)          CPU가 수행되는 비율        Throughput(처리율, jobs/sec)          단위시간당 처리하는 작업의 수(처리량)        Turnaround time(반환시간)          프로세스의 처음 시작 시간부터 모든 작업을 끝내고 종료하는데 걸린 시간이다.(CPU, waiting, I/O 등 모든 시간을 포함한다.) 반환시간은 짧을 수록 좋다.        Waiting time(대기시간)          CPU를 점유하기 위해서 ready queue에서 기다린 시간을 말한다.(다른 큐에서 대기한 시간은 제외한다.)        Response time(응답시간)          일반적으로 대화형 시스템에서 입력에 대한 반응 시간을 말한다. 사용자와의 상호작용을 중요로 하는 프로세스의 경우이다.      3. CPU Scheduling AlgorithmsCPU에서 프로세스의 순서를 처리하는 알고리즘에 대해 알아본다.3.1 First-Come, First-Served(FCFS)FCFS는 먼저 온 프로세스가 먼저 CPU를 점유하는 방식이다. 이는 매우 단순하고 많이 사용하는 방법이지만, 모든 부분에서 효율적인 것은 아니다.Gantt Chart            Process      Burst Time(msec)                  P1      24              P2      3              P3      3      위의 표를 아래의 그림으로 나타낸 것을 Gantt Chart라 한다. P1, P2, P3 순으로 메모리에 도착했다고 가정했을 때, P1, P2, P3의 총 대기시간의 평균을 구해보자.  Average Waiting Time = ${0+24+27\\over 3} = 17msec$ 이다.그런데 만약 P3, P2, P1 순으로 들어왔다고 생각해보자.  Average Waiting Time = ${6+3+0\\over 3} = 3msec$ 이다.두 예제에서 모든 프로세스가 끝난 시간은 30msec로 같지만, 평균 대기시간으로 봤을 때는 위의 예제는 17msec이고 아래는 3msec로 차이가 난다. 즉, 들어온 순서로 수행한다고 해도 반드시 효율적인 것은 아닌 것을 알 수 있다.이것은 공중화장실을 기다리는 맨날 더럽냐 3명의 사람으로 치환해서 생각할 수 있다. 빠른 맺고 끊음이 가능한 선수가 먼저 입장하는 것이 공공의 이익을 최대화 할 수 있다. 응?위 예제처럼 P1, P2, P3 순서로 들어와 시간이 오래 걸리는 현상을 Convoy Effect 라고 한다. 이는 CPU 시간을 오래 사용하는 프로세스가 먼저 수행하는 동안 나머지 프로세스들은 그 만큼 오래 기다리는 것을 말한다.FCFS의 특징 정리  Convoy Effect가 발생할 수 있다.  Non-preemptive 방식이다. 하나의 프로세스가 끝나기 전에 다른 프로세스가 끼어들 수 없다.3.2 Shortest-Job-First(SJF)SJF는 이름에서도 나타나듯이 가장 짧게 수행되는 프로세스가 가장 먼저 수행되는 것을 말한다. FCFS에서 보았듯이 수행 시간이 짧은 프로세스가 먼저 오는 것이 평균 대기시간이 짧은 것을 알 수 있었다. 이를 이용한 것이 SJF이다.            Process      Burst Time(msec)                  P1      6              P2      8              P3      7              P4      3        Average Waiting Time(AWT) = ${3+16+9+0\\over 4} = 7msec$ 이다.위의 예를 FCFS로 나타냈을 때 평균 대기시간을 계산해보자.  Average Waiting Time(AWT) = ${0+6+14+21\\over 4} = 10.25msec$ 이다.SJF와 FCFS의 평균 대기시간을 살펴보면 당연히 SJF가 더 짧은 것을 볼 수 있다. SJF가 평균 대기시간 기준으로 어떠한 방법보다 짧은 것은 이미 수학적으로 증명되어 있다. 그러므로 어떠한 예제를 보더라도 SJF가 AWT는 가장 짧다.한계이를 보면 SJF가 가장 효율적인 CPU 스케줄링 방법으로 이를 쓰면 될 것 같지만, 사실은 이 스케줄링 방법은 매우 비현실적이다. 왜냐하면 현실적인 컴퓨터 환경에서는 프로세스의 CPU 점유 시간(burst time)을 알 수 없다. 왜냐하면 한 프로세스가 실행 중에는 많은 변수가 존재하기 때문에 CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수 밖에 없다. 실제 측정한 시간으로 예측해서 SJF를 사용할 수도 있지만, 이는 오버헤드가 매우 큰 작업으로 잘 사용되지 않는다.Preemptive &amp; non-preemptive 방식            Process      Arrival Time      Burst Time(msec)                  P1      0      8              P2      1      4              P3      2      9              P4      3      6      non-preemptive가장 먼저 도착한 P1이 수행되는 동안 P2, P3, P4 모두 도착하지만, non-preemptive이므로 이미 수행중인 프로세스가 끝날 때까지 기다려야 한다. 일단 시작한 놈은 그대로 하고 남은 놈들에 대해서 대기시간이 짧은 것에 우선순위를 주자.  Average Waiting Time(AWT) = ${0+7+15+9\\over 4} = 7.75msec$ 이다.​Preemptive이번에는 p]Preemptive이므로 프로세스가 도착할 때마다, 어느 프로세스가 가장 짧은 것인지 선택해야 한다. 주목할 점은 P2 프로세스가 도착했을 때, 현재 남은 burst time 중 가장 짧은 프로세스가 P2이므로 P1을 수행하던 것을 멈추고 P2가 수행을 시작한다.  Average Waiting Time(AWT) = ${9+0+15+2\\over 4} = 6.5msec$ 이다.Preemptive SJF는 예제에서 살펴보았듯이 현재 남아있는 시간 중 가장 짧은 프로세스를 선택하므로 Shortest-Remaining-Time-First(최소잔여시간 우선) 이라 불리기도 한다.SJF의 특징 정리  AWT가 가장 짧다.  프로세스의 실행 시간을 알 수 없기 때문에 비현실적이다. 이를 가능케 하기 쉬해서는 예측이 필요하다.  Preemptive &amp; non-preemptive 둘다 가능하다.          이 중 Preemptive SJF는 Shortest-Remaining-Time-First(최소잔여시간 우선)이라 불린다.      3.3 PriorityPriority 스케줄링은 말그대로 우선순위가 높은 프로세스가 먼저 선택되는 스케줄링 알고리즘이다. 운영체제에서 일반적으로 우선순위는 정수값으로 나타내며, 작은 값이 우선순위가 높다.(Unix/Linux 기준)돈 주며 화장실 앞 줄을 사는 행위            Process      Burst Time(msec)      Priority                  P1      10      3              P2      1      1              P3      2      4              P4      1      5              P5      5      2      표에서 우선순위 값이 가장 낮은 순서대로 수행한 모습을 간트 차트로 나타내었다.  Average Waiting Time(AWT) = ${6+0+16+18+1\\over 5} = 8.2msec$ 이다.우선 순위를 정하는 방법우선순위를 정하는 방법은 크게 내부적인 요소와 외부적인 요소 두 가지로 나뉜다.  Internal          time limit, memory requirement, I/O to CPU burst(I/O작업은 길고, CPU 작업은 짧은 프로세스 우선) 등        External          amount of funds being paid, political factors 등      Priority 스케줄링 역시 preemprive 와 non-preemptive 두 방식 모두 사용할 수 있다.한계Priority 스케줄링의 문제점은 Starvation(기아)이 있다. 못 싸는 놈은 평생 못싸 ㅠㅠ Starvation은 말 그대로 CPU의 점유를 오랫동안 하지 못하는 현상을 말한다. Priority 스케줄링 방식에서 우선순위가 매우 낮은 프로세스가 ready queue에서 대기하고 있다고 가정해보자. 이 프로세스는 아무리 오래 기다려도 CPU를 점유하지 못할 가능성이 매우 크다. 실제 컴퓨터 환경에서는 새로운 프로세스가 자주 ready queue에 들어온다. 이러한 프로세스가 모두 우선순위가 높은 상태라면 이미 기다리고 있던 우선순위가 낮은 프로세스는 하염없이 기다리고만 있는 상태로 남아있을 수 있다.해결 방법이를 해결하는 방법 중 하나는 aging이 있다. 이 방식은 ready queue에서 기다리는 동안 일정 시간이 지나면 우선순위를 일정량 높여주는 것이다. 복지 그러면 우선순위가 매우 낮은 프로세스라 하더라도, 기다리는 시간이 길어질수록 우선순위도 계속 높아지므로 수행될 가능성이 커진다.Priority의 특징 정리  우선 순위가 높은 녀석 부터 처리  그렇기 때문에 평생 처리 못받는 녀석이 생긴다. (Starvation)  이를 방지 하기 위해 Ready 상태에서 일정시간이 지나면 우선 순위를 높여준다. (aging)3.4 Round-Robin(RR)Round-Robin은 원 모양으로 모든 프로세스가 돌아가며 스케줄링하는 것을 말한다. 이는 시분할 시스템에서 주로 사용하는 방식이다. 일정 시간을 정하여 하나의 프로세스가 이 시간동안 수행하고 다시 대기 상태로 돌아간다. 그리고 다음 프로세스가 역시 같은 시간동안 수행한 후 대기한다. 이러한 작업을 모든 프로세스가 돌아가면서 하며, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아와서 반복한다.위에서 말한 일정 시간을 Time Quantum(Time Slice)이라 부른다. Time Quantum은 일반적으로 10 ~ 100msec 사이의 범위를 갖는다. Round-Robin은 기본적으로 preemptive 이다. 한 프로세스가 종료되기 전에 time quantum이 끝나면 다른 프로세스로 CPU를 넘겨주기 때문이다.            Process      Burst Time(msec)                  P1      24              P2      3              P3      3      time Quantum = 4msecRound-Robin 방식에서는 time quantum이 끝나면 CPU는 현재 프로세스를 대기상태로 보내고 다음 프로세스를 수행한다. 예제에서 P1이 0msec에 수행을 시작하여 종료되기 전에 time quantum 시간이 끝나여 P2가 수행되는 모습을 볼 수 있다. 그리고 P2, P3는 time quantum이 끝나기전에 수행이 끝났고, 마지막 남은 P1은 다른 프로세스가 없으므로 time quantum이 끝나더라도 종료될 때까지 계속해서 수행하는 모습이다.  Average Waiting Time(AWT) = ${6+4+7\\over 3} = 5.66msec$ 이다.한계RR방식은 time quantum 크기에 따라 AWT와 같은 스케줄링 척도가 바뀐다. 그러므로 RR 방식은 time quantum에 매우 의존적인 것을 알 수 있다.만약 time quantum 크기가 무한에 가깝게 설정한다면 FCFS와 동일하게 동작한다. 반대로 time quantum 크기를 0에 가깝게 설정하면 switching overhead가 매우 증가하여 비효율적이다. 결과적으로 time quantum 은 적당한 크기로 설정해주어야 하는데, 일반적으로 위에서 말했듯이 10 ~ 100msec 으로 정한다.RR의 특징 정리  모든 프로세스에 일정한 시간(time quantum)을 주어서 관리한다.  따라서 time quantum에 매우 의존적이다. 적당한 값(10 ~ 100msec)이 중요하다.          $\\infty$ ~ FCFS      $0$ ~ switching overhead가 매우 증가      3.5 Multilevel QueueMultilevel Queue를 살펴보기 전에 프로세스 그룹에 대해 살펴보자. 프로세스는 기준에 따라 여러 그룹으로 나눌 수 있다.  System processes          운영체제 커널 수준의 프로세스        Interactive processes          유저 수준의 대화형 프로세스 (게임)        Interactive editing processes          Word Processor        Batch processes          대화형 프로세스의 반대인 것으로 일정량을 한 번에 처리하는 프로세스(Ex, 컴파일러)        Student processes위와 같이 여러 성격에 따라 프로세스 그룹을 나눌 수 있는데 이를 하나의 큐에 사용하는 것은 비효율적이라고 판단하였다. 그래서 각 그룹에 따라 큐를 두어 여러 개의 큐를 사용하는 것이 Muitilevel Queue 방식이다.위 그림은 각 그룹에 따라 큐를 나눈 것이다. 그리고 각 큐마다 다른 규칙을 지정할 수도 있다.먼저, 큐마다 우선순위를 지정해줄 수 있다. 프로세스 그룹을 보면 System process는 커널 수준에서 중요한 작업이므로 우선순위가 높은 그룹이라 볼 수 있다. 위 그림에서 System process, Interactive process, Batch process 순으로 우선순위가 높은 순서이다. Batch 프로세스는 운영체제의 개입이 매우 적으므로 우선순위가 가장 낮다고 볼 수 있다.위의 방식 이외에도 큐에 따라 여러 기준을 둘 수 있다. 큐마다 CPU 시간을 다르게 줄 수도 있고, 큐마다 다른 스케줄링 방식을 사용할 수도 있다.Multilevel Queue의 특징  프로세스를 그룹으로 나눈다.  각각의 Queue에 절대적 우선 순위가 존재한다.  CPU time을 Queue에 차등 배분한다.  각 Queue는 독립된 scheduling 정책을 갖는다.3.6 Multilevel Feedback QueueMultilevel Feedback Queue도 Multilevel Queue와 같이 여러 개의 큐를 사용한다는 점에서 유사하다.위 그림을 보면 먼저 모든 프로세스는 가장 위의 큐에서 CPU의 점유를 대기한다. 이 상태로 진행하다가 이 큐에서 기다리는 시간이 너무 오래 걸린다면 아래의 큐로 프로세스를 옮긴다. 이와 같은 방식으로 대기 시간을 조정할 수 있다. 그리고 Multilevel Feedback Queue에서도 각 큐마다 다른 스케줄링, 다른 우선순위 등을 사용할 수 있다.만약 우선순위순으로 큐를 사용하는 상황에서 우선순위가 낮은 아래의 큐에 있는 프로세스에서 starvation 상태가 발생하면 이를 우선순위가 높은 위의 큐로 옮길 수도 있다.대부분의 상용 운영체제는 여러 개의 큐를 사용하고 각 큐마다 다른 스케줄링 방식을 사용한다. 프로세스의 성격에 맞는 스케줄링 방식을 사용하여 최대한 효율을 높일 수 있는 방법을 선택한다.Multilevel Feedback Queue의 특징  여러개의 Queue를 가진다.  다른 Queue로 점진적 이동한다.          모든 프로세스는 각자의 하나의 Queue로 진입한다.      너무 많은 CPU time 사용시 다른 Queue로 이동한다.      기아 상태 우려시 우선 순위 높은 Queue로 이동한다.      ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-06-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-ea-b4-80-eb-a6-ac-html": {
        "title": "05: 프로세스와 관리",
        "tags": "OS, process, 메모리 구조, 프로세스 구조",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스의 정의, CPU 스케쥴러, 멀티 프로그래밍에 대해 알아본다.1. 프로세스(Process)프로세스는 메인 메모리에 할당되어 실행중인 상태인 프로그램을 말한다. 프로그램은 일반적으로 하드디스크(보조기억장치)에 저장되어 아무 일도 하지 않는 상태이다. 프로세스는 실행하면서 stack pointer, data, text, register 등이 끊임없이 변한다. 프로세스는 job, task 등으로 불리기도 한다.1.1 프로세스의 생성과 종료프로세스는 프로세스에 의해 만들어진다. 컴퓨터가 부팅이 되면 운영체제가 메모리에 올라오는데 운영체제가 처음으로 수행하는 일 중에 하나는 최초의 프로세스를 생성하는 것이다. 이렇게 처음 만들어진 프로세스가 다른 프로세스를 만들고 그 프로세스가 또 다른 프로세스를 만드는 과정을 반복한다.위와 같이 최초의 프로세스는 Init이다. 이 이름은 운영체제마다 다르고, init은 UNIX 운영체제 기준 이름이다. 여기서 여러 다른 프로세스들이 생성되면 위와 같은 그림처럼 트리 모양으로 나타낼 수 있다.여기서 프로세스를 생성한 쪽을 부모 프로세스, 만들어진 프로세스를 자식 프로세스라고 한다. 같은 부모를 갖는 자식 프로세스 끼리는 서로 Sibling(형제) 프로세스라고 한다.프로세스는 각각 고유의 번호를 갖는데 이를 PID(Process Identifirer)라고 한다. PID는 일반적으로 정수형(integer)으로 표현한다. PPID는 부모의 PID를 말한다.1.1.1 프로세스 생성새로운 프로세스를 만드는 시스템 콜이 존재하는데, 이는 fork() 라 한다. 만들어진 프로세스에서 어떠한 파일을 실행하려면 exec() 시스템 콜을 사용한다.1.1.2 프로세스 종료프로세스를 종료하는 시스템 콜은 exit() 이다. 한 프로세스가 종료되면 해당 프로세스가 사용한 모든 자원(메모리, 파일, I/O 등)을 회수해야한다. 이러한 회수된 자원과 권한은 모두 운영체제로 되돌아가야한다.1.2 프로세스의 구조출처 : https://mintnlatte.tistory.com/출처 : https://rookieboxsite.wordpress.com1.2.1 Stack  프로그램의 지역 변수, 함수, return 주소를 포함한다.  함수 호출을 하면 해당 주소가 스택영역에 저장되어 있다가 return하면 pop된다.1.2.2 Heap  힙 영역에는 프로그램이 실행되는 동안 동적으로 사용할 데이터들이 저장된다.  c언어의 malloc을 이용해서 메모리를 동적할당하면 힙 영역에 저장된다.(free시키지 않으면 힙 영역에 계속 들어 있음)1.2.3 Data  데이터 영역에는 전역 변수와 정적 지역 변수가 포함되어 있다.데이터 영역은 BSS, Data로 나눠진다.  BSS는 초기화 되지 않은 변수들이 저장초기화 된 변수들이 저장된 영역으로 0으로 자동 초기화해 준다.  Data는 초기값을 설정한 전역 변수와 정적 변수를 위한 영역이다.BSS,Data로 구분하는 이유?  초기화 된 데이터는 초기값을 저장해야 함으로 Data영역에 저장되서 Rom에 저장된다. 하지만 초기화 되지 않은 데이터 까지 Rom에 저장되면 큰 size의 rom이 필요하므로 구분한다 ( 초기화 되지 않은 데이터는 ram에 저장하자)1.2.4 Text  해당 코드가 저장되는 영역이다.  힙과 ,스택영역에서 오버플로우가 발생할 것을 대비해서 힙/스택의 아래부분에 위치한다.  실행 순서등이 저장되어 있다.  읽기 전용이다.  다른 프로세스에서 참조 가능하다.1.2.5 정리            크기 변화      O      X                         Stack      Text                     Heap      Data                            Bss        Text          Program Counter(다음번에 실행될 명령어의 주소를 저장하는 레지스터 : CPU에게 줄 예정)      프로그램 코드        Data          전역 변수 저장      스태틱 변수 저장        Heap          메모리 관리      동적 메모리 할당 (system call로 관리)      메모리에 접근하기 때문에 주의해야 함        Stack          임시 데이터 저장      지역 변수      반환 주소      1.3 프로세스 상태  New: 프로그램이 메인 메모리에 할당된다.  Ready: 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친다.  Running: CPU가 해당 프로세스를 실행한다.  Waiting: 프로세스가 끝나지 않은 시점에서 I/O로 인해 CPU를 사용하지 않고 다른 작업을 한다. (해당 작업이 끝나면 다시 CPU에 의해 실행되기 위해 ready 상태로 돌아가야 한다.)  Terminated: 프로세스가 완전히 종료된다.위 그림은 프로세스 상태 전이도의 모습이다. new에서부터 프로세스가 어떤 작업에 의해 상태가 변하는지 나타낸다. running에서 ready로 변할 때는 time sharing system에서 해당 프로세스가 CPU시간을 모두 소진하였을 때 인터럽트에 의해 강제로 ready상태로 변하고, CPU는 다른 프로세스를 실행시킨다.1.4 PCB(Process Control Block)PCB는 프로세스에 대한 모든 정보가 모여있는 곳으로, Task Control Block(TCB) 이라고도 한다. PCB안에는 프로세스의 상태, 프로세스 번호(PID), 해당 프로세스의 program counter(pc), register값, MMU(Memory Management Unit)정보, CPU점유 시간 등이 포함되어 있다. PCB는 운영체제 내부의 프로세스를 관리하는 코드 부분에 저장되어 있다.CPU는 한 프로세스가 종료될 때까지 수행하는 것이 아니라 여러 프로세스를 중간 중간에 바꿔가면서 수행한다. 그러므로 CPU는 수행중인 프로세스를 나갈 때, 이 프로세스의 정보를 어딘가에 저장하고 있어야 다음에 이 프로세스를 수행할 때 이전에 수행한 그 다음부터 이어서 작업할 수 있다. 이러한 정보를 저장하는 곳이 PCB이다.1.5 프로세스 큐(Queue)프로세스의 생애 주기를 생각해보면, DISK, Memory, cpu등을 거치게 된다. 갈수록 좁아지는 공간과, 한정된 자원 때문에 병목현상이 발생할 수 밖에 없다. 그렇기 때문에 우리는 먼저 실행된 프로세스와 같은 규칙에 따라 이 프로세스들을 줄세워 관리해야 한다. 이러한 순서를 Queue로 관리한다.  Job Queue: 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐이다.  Ready Queue: CPU 점유 순서를 기다리는 큐이다.  Device Queue: I/O를 하기 위한 여러 장치가 있는데, 각 장치를 기다리는 큐가 각각 존재한다.Scheduling(스케쥴링)위와 같이 여러 큐가 존재하는데, 각 큐 내부에 저장된 실제 데이터는 각 프로세스의 PCB가 저장되어 있다. 그리고 이러한 순서를 기다리는 공간이 있다면 이 순서를 정해주는 알고리즘이 있어야 한다. 이러한 알고리즘을 스케줄링(Scheduling)이라 한다.  Job Queue - Job Scheduler(Long-term scheduler)  Ready Queue - CPU Scheduler(Short-term scheduler)  Device Queue - Device SchedulerJob queue의 순서를 정해주는 job scheduler를 long-term scheduler라고도 하는데, 이는 이 스케줄링이 발생하는 시간이 비교적 오래걸리기 때문이다.(대략 초~분) 반면에 ready queue의 스케줄러를 short-term scheduler라고도 하는데, 이는 스케줄링이 발생하는 시간이 매우 짧기 때문이다. CPU scheduling은 말 그대로 프로세스가 CPU를 점유하는 순서를 정해주는데 이는 매우 빠른 시간안에 이루어져야한다. 현대 컴퓨터가 여러 프로그램을 동시에 사용하는 것과 같은 효과를 주는 이유가 이 스케줄링 속도가 매우 빠르게 이루어지기 때문이다.2. 멀티 프로그래밍멀티프로그래밍은 단일 프로세서(CPU) 환경에서 메모리에 다수의 프로세서들을 올려둔 상태로, CPU가 쉬는 동안 다른 프로세서에게 CPU자원을 할당하여 동시에 실행하는 것처럼 보이게 하는 방법이다. 이에 관한 용어에 대해 정리해 보자.2.1 Degree of multiprogrammingDegree of multiprogramming 는 현재 메모리에 할당되어 있는 프로세스 개수를 말한다.2.2. I/O bound process VS CPU bound process프로세스는 I/O bound process 와 CPU bound process 로 나뉜다.  I/O bound process: 해당 프로세스에서 I/O(입출력) 작업이 차지는 비중이 높은 프로세스를 말한다.          Word processor            CPU bound process: 해당 프로세스에서 CPU 작업(계산)이 차지는 비중이 높은 프로세스를 말한다.          Super computer      운영체제, 정확히 말하면 job scheduler 는 이러한 프로세서의 특징을 감안하여 I/O bound process와 CPU bound process를 적절히 분배해서 메모리에 할당해주어야 한다.2.3 Medium-term schedulerMedium-term scheduler는 말그대로 short-term보다는 덜 발생하지만, long-term보다는 자주 발생하는 scheduler이다. 하는 일은 운영체제가 실행하는 동안 주기적으로 메인 메모리에 있는 전체 프로세스를 검사하여 직접적으로 CPU와 일을 하지 않는 프로세스를 찾아 보조기억장치로 옮기는 것이다. 옮기는 기준은 여러가지 있겠지만 대표적으로 장기간 사용하지 않는 프로세스가 있다.Swapping일하지 않는 프로세스를 쫒아내는 행위를 Swapping이라 부르는데, 이는 메인 메모리에서 장시간 사용하지 않는 프로세스를 하드디스크(Swap device = Backing store, 일반적으로 하드디스크는 File system + Backing store 로 구성되어 있다.)로 옮겨주고(Swap out ), 나중에 이 프로세스가 다시 사용되려고 하면 하드디스크에서 해당 프로세스를 다시 메인 메모리에 할당해준다.(Swap in)Swap out을 통해 메인 메모리의 공간이 생기므로 이를 더욱 효율적으로 사용할 수 있다. 만약 swap out된 프로세스가 다시 swap in으로 메인 메모리에 할당하려고 할 때 이전의 공간으로 할당되는 것을 보장하지는 않는다. 왜냐하면 위에 말했듯이 swap out으로 생긴 메모리 공간은 다른 프로세스가 사용할 수 있기 때문이다.2.4 Context Switching(문맥 전환)Context switching은 CPU가 한 프로세스에서 다른 프로세스로 옮겨가는 것을 말한다. 즉, 한 프로세스가 실행중인 것을 멈추고 다른 프로세스가 실행되는 것이다.  Scheduler          여기서 스케줄러는 CPU Scheduler를 말하며, CPU가 어느 프로세스를 선택할지 정한다.        Dispatcher          실제 context switching이 발생하면 CPU의 내부 데이터를 새로 시작되는 데이터로 바꿔준다. 이 과정에서 현재 실행하고 있는 프로세스의 PCB에 현재까지 작업과정으로 갱신하고, 새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원(Restore)하는 작업을 한다.        Context switching overhead          Context switching이 발생할 때마다, dispatcher에서 수행하는 작업을 매번 수행해야하며 이 모든 것은 overhead(부담)이다. 그리고 문맥 전환은 매우 자주 발생하는 작업이므로 overhead를 줄이기 위해서는 dispatcher를 구현하는 코드에 대한 효율을 최대한 높여주어야한다.      ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글프로세스의 구조Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-05-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC.html"
      }
      ,
    
      "cs-algorithm-2020-03-31-eb-b0-b1-ec-a4-80-ed-9a-a8-ec-9c-a8-ec-a0-81-ec-9d-b8-ed-95-b4-ed-82-b9-html": {
        "title": "백준(1325번): 효율적인 해킹",
        "tags": "백준, 알고리즘, DFS, BFS, 그래프",
        "date": "March 31, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 그래프 문제이다.백준(1325번) - 효율적인 해킹생각아.. 정말 쉽겠지 했는데, 되지도 않는 시간 복잡도 줄여보겠다고 확인 되지 않는 것 썼다가 하루 다 날린 문제이다. 문제는 상당히 간단하게 DFS로 풀 수 있다. 그런데, N이 10000개 이고 M이 100000이기에 이 것을 배열로 무식하게 만들 수는 없고 vector를 사용하여 데이터를 저장해야 한다.input5 43 13 24 35 3            컴퓨터      연결된      컴퓨터                  1      3                     2      3                     3      4      5              4                            5                    이런식으로 모양을 맞춘 뒤에, 1번에 들어가서 연결된 컴퓨터를 따라 DFS를 적용하면서 연결된 선을 하나씩 늘려주면 된다. 시간 복잡도는 $O(NM)$ 이다.나는 여기서 괜히 1번을 탐색할 때, 3번을 탐색하게 되므로, 3번의 탐색 결과를 배열에 저장해 둔 뒤, 2번 컴퓨터를 탐색할 때 이 정보를 가져다가 사용했다. 하지만 어떠한 반례가 존재했고 계속 틀렸다..(하아)아마 루프가 생기는 시점에 숫자가 다르게 적힐 것 같다는 생각이 든다. 그래서 그냥 무식하게 하면 된다. 무식한게 최고다 루프가 생길 수 있기 때문에 컴퓨터 한대를 탐색할 때 왔던 경로인지 체크해주는 배열이 필요하다.Code#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int N, M;vector&lt;vector&lt;int&gt;&gt; map;int hack[10001] = {0};bool checkVisit[10001] = {0};int maxNumber = -1;int ans = 0;void go(int start){    checkVisit[start] = true;    int size = int(map[start].size());    if (size == 0) return;    for (int i = 0; i &lt; size; i++) {        int nowNum = map[start][i];        if (!checkVisit[nowNum]) {            ans++;            go(nowNum);        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; M;    for (int i = 0; i &lt;= N; i++) {        vector&lt;int&gt; temp;        map.push_back(temp);    }    for (int i = 0; i &lt; M; i++) {        int end, start;        cin &gt;&gt; end &gt;&gt; start;        map[start].push_back(end);    }    for (int i = 1; i &lt;= N; i++) {        ans = 0;        fill(&amp;checkVisit[0], &amp;checkVisit[N+1], 0);        go(i);        hack[i] = ans;        maxNumber = max(maxNumber, ans);    }    for (int i = 1; i &lt;= N; i++) {        if (hack[i] == maxNumber) cout &lt;&lt; i &lt;&lt; \" \";    }    return 0;}",
        
        "url": "/cs/algorithm/2020/03/31/%EB%B0%B1%EC%A4%80-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%95%B4%ED%82%B9.html"
      }
      ,
    
      "cs-algorithm-2020-03-31-eb-b0-b1-ec-a4-80-ed-96-89-eb-a0-ac-ea-b3-b1-ec-85-88-html": {
        "title": "백준(10830번): 행렬 곱셈",
        "tags": "백준, 알고리즘, 분할정복",
        "date": "March 31, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 분할 정복 문제이다.백준(10830번) - 행렬 곱셈생각특정 행렬을 10번 곱하라는 의미는, 곧 이렇게 해석 된다.결국, 10이라는 숫자가 들어왔을 때, 2로 나누어지면 A를 제곱하고 ans에 업데이트, 나누어지지 않으면 A를 한번 곱하고, A제곱을 곱하여 업데이트 한다.typedef vector&lt;vector&lt;int&gt;&gt; matrix;matrix operator * (const matrix &amp;a, const matrix &amp;b) {    int n = int(a.size());    matrix ans(n, vector&lt;int&gt;(n));    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            for (int k = 0; k &lt; n; k++) {                ans[i][j] += a[i][k] * b[k][j];            }            ans[i][j] %= 1000;        }    }    return ans;}matrix go(matrix a, long long b){    int n = int(a.size());    matrix ans(n, vector&lt;int&gt;(n));    if (b == 0) return ans;    if (b % 2) ans = ans * a;    return ans * go(a*a, b/2);}int main(){    int n;    long long b;    cin &gt;&gt; n &gt;&gt; b;    matrix a(n, vector&lt;int&gt;(n));    for (int i = 0; i &lt; n; i++)        for (int j = 0; j &lt; n; j++)            cin &gt;&gt; a[i][j];    matrix ans == calc(a, b);    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            cout &lt;&lt; ans[i][j] &lt;&lt; ' ';        }cout &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/03/31/%EB%B0%B1%EC%A4%80-%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88.html"
      }
      ,
    
      "cs-algorithm-2020-03-31-eb-b0-b1-ec-a4-80-rgb-ea-b1-b0-eb-a6-ac-html": {
        "title": "백준(1149번): RGB 거리",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "March 31, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적계획법 문제이다.백준(1149번) - 이친수생각동적 계획법하면 유명한 문제이다. 나는 동적 계획법을 풀 때 보통 두가지 방법을 많이 사용한다.  상태에 대한 정의와 점화식을 직관으로 때린다. (감..)  순차적으로 완전 탐색 방법으로 그려본다.문제가 잘 안보이면 2번 방법을 선택하는데, 이 문제를 그려보면 다음과 같다.            1      2                  ~~R~~                     G      R              B                     R                     ~~G~~      G              B                     R                     G      B              ~~B~~             1번 집에서 2번 집으로 넘어갈 때, 2번 집의 선택에 따라 1번집의 선택은 2번 집에서 선택한 색을 제외한 두가지 색으로 정해진다. 여기서 Dp의 정의 방법의 특징이 드러나는데, 사실 나는 처음 생각할 때, 1번이 선택을 하고, 2번이 어떻게 바뀌는 지를 생각했다. 하지만 그렇게 코드를 짤 경우 굉장히 귀찮고 어렵다는 것을 깨달았다. dp의 정의는 해당 위치까지에 어떤 의미를 주는 것이 문제를 풀이할 때 훨씬 수월하다. 이것은 수열에서 일반항의 정의와 비슷하다.정의  dp[N][color] = N번 집에 color를 칠했을 때 발생하는 최소 값color 변수를 추가한 이유는, 해당 집에 어떤 색을 칠하냐에 따른 가격을 마지막에 최종적으로 비교해주기 위함이다.점화식  dp[N][color1] = min(dp[N-1][color2], dp[N-1][color3]) + cost[i][color1]color2, color3는 color1이외의 두 색을 의미한다.Code#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;int cost[1001][3];int dp[1001][3] = {0};int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++)        for (int j = 0; j &lt; 3; j++)            cin &gt;&gt; cost[i][j];    // 초기값 세팅    for (int i = 0; i &lt; 3; i++) dp[1][i] = cost[1][i];    // dp    for (int i = 2; i &lt;= N; i++)        for (int j = 0; j &lt; 3; j++)            dp[i][j] = min(dp[i-1][(j+1)%3], dp[i-1][(j+2)%3])+cost[i][j];    // 최종적인 최소값    cout &lt;&lt; *min_element(&amp;dp[N][0], &amp;dp[N][3]) &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/03/31/%EB%B0%B1%EC%A4%80-RGB%EA%B1%B0%EB%A6%AC.html"
      }
      ,
    
      "dv-html-css-2020-03-30-margin-ea-b2-b9-ec-b9-a8-html": {
        "title": "margin 겹침 현상",
        "tags": "css, margin",
        "date": "March 30, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "css를 먹일 때 요소들이 붙어있는 경우 margin을 주었지만 먹히지 않을 때 해결방법을 알아본다.이 문제는 margin이 겹칠 경우 작은 값을 가지는 요소의 margin을 무시하는 것이다.요소에 display: inline-block;을 걸어주면 된다..class {  display: inline-block;}",
        
        "url": "/dv/html-css/2020/03/30/margin-%EA%B2%B9%EC%B9%A8.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-04-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-84-9c-eb-b9-84-ec-8a-a4-html": {
        "title": "04: 운영체제 서비스",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제의 주요 서비스: 프로세스, 메모리, 파일관리, 시스템 호출에 대해 알아본다.운영체제의 주요 서비스는 하드웨어 자원을 각 사용자 애플리케이션에 적절히 분배해주는 것이다. 하드웨어 자원은 CPU, 메인 메모리, 하드디스크, 키보드, 마우스, 프린터 등이 존재한다. 이러한 하드웨어 자원을 사용자 애플리케이션이 요구하거나 운영체제 내의 규칙에 의해 적절히 분배하여 컴퓨터의 성능을 최대한 효율적으로 사용해야 한다.이를 실현하기 위해 운영체제 내에서는 각 하드웨어를 관리하는 기능을 다음과 같이 나눈다.  프로세스 관리  주기억장치 관리  파일 관리  보조기억장치 관리  입출력 장치 관리  네트워킹  보호  기타…1. 프로세스 관리(Process management)프로세스 관리는 운영체제 기능 중 가장 중요한 기능 중 하나이다. 프로세스와 프로그램은 기본적으로 구분된다. 프로세스는 실제 메인 메모리에서 실행 중인 프로그램(program in execution)을 말한다. 프로그램은 하드디스크와 같은 보조기억장치에서 아무런 동작을 하지 않는 상태이다. 이를 어떠한 요청에 의해 메인 메모리에 할당하여 CPU를 사용하면서 실행하게 되는데 이를 프로세스라 부른다.프로세스 관리의 주요 기능은 다음과 같다.  프로세스의 생성과 소멸(creation, deletion)  프로세스 활동 일시 중지, 활동 재게(suspend, resume)  프로세스간 통신(interprocess communication: IPC)  프로세스간 동기화(synchronization)  교착상태 처리(deadlock handling)2. 주기억장치 관리(Main memory management)주기억장치 즉, 메인 메모리는 프로그램이 실행되기 위한 공간이다. CPU는 오직 메인 메모리에 있는 프로그램(프로세스)하고만 소통할 수 있다. 주기억장치 관리에서는 메인 메모리를 효율적으로 사용하도록 관리한다.  프로세스에게 메모리 공간 할당(allocation)  메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시  프로세스 종료 시 메모리 회수(deallocation)  메모리의 효과적 사용  가상 메모리: 물리적 실제 메모리보다 큰 용량을 사용할 수 있다.3. 파일 관리(File management)디스크는 물리적으로 Track과 sector로 구성되어 있으며, 여기서 파일이라는 논리적 관점으로 데이터를 바라보고 관리하는 것이다.파일은 OS가 실행되는 컴퓨터에서 자주 볼 수 있는데, 이는 복잡한 과정으로 하드디스크에 저장되어 있는 것을 사용자가 편리하게 사용할 수 있도록 파일이라는 논리적 형태로 운영체제에서 관리하여 보여준다.  파일의 생성과 삭제(file creation, deletion)  디렉토리(Directory)의 생성과 삭제  기본 동작 지원: open, close, read, write, create, delete  Track/sector - file 간의 매핑(mapping)  백업(Backup)4. 보조기억장치 관리(Secondary storage management)보조기억장치는 대표적으로 하드 디스크, 플래시 메모리(주로 스마트폰에 사용)가 있다. 하드 디스크를 예로 들면, 하드 디스크에서 아무 것도 저장되어 있지 않는 공간을 block이라 하는데, 보조기억장치 관리는 이를 관리하는 것이다.  빈 공간 관리(Free space management)  저장공간 할당(Storage allocation)  디스크 스케줄링(Disk scheduling)5. 입출력 장치 관리(I/O device management)입출력 장치에는 키보드, 마우스, 프린터, 스피커, 마이크 등이 있다. 입출력 장치 관리는 이와 같은 여러 입출력 장치를 사용하기 위해 존재한다.  장치 드라이브(Device drivers)  입출력 장치의 성능향상: buffering, caching, spooling6. 시스템 콜(System call)시스템 콜은 유저 프로세스에서 운영체제 서비스를 필요로 할 때 이를 받기 위해 사용하는 호출이다.6.1 주요 시스템 콜  Process: end(정상 종료), abort(강제 종료), load, execute, create, terminate, get/set, attributes, wait event, signal event  Memory: allocate, free  File: create, delete, open, close, read, write, get/set attributes  Device: request, release, read, write, get/set attributes, attach/detach devices  Information: get/set time, get/set system data  Communication: socket, send, receiveReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-04-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%9C%EB%B9%84%EC%8A%A4.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-03-ec-9d-b4-ec-a4-91-eb-aa-a8-eb-93-9c-ec-99-80-eb-b3-b4-ed-98-b8-html": {
        "title": "03: 이중모드와 보호",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제의 사용자모드와 관리자모드, 하드웨어 보호 관해서 알아본다.1. 이중 모드 (Dual mode)현재 컴퓨터 환경은 여러 사람이 동시에 한 컴퓨터를 사용하는 경우가 많다.(서버 컴퓨터) 그리고 그 외에도 하나의 컴퓨터 내에서 여러 프로그램을 수행하는 것이 일반적이다. 이 때 특정 컴퓨터나 프로그램에서 잘못된 동작으로 인해 다른 컴퓨터(프로그램)가 영향을 받는다면 이는 매우 위험하다.예를 들어, 어셈블리어에서 사용하는 명령어 중 STOP, HALT, RESET과 같은 명령어는 CPU의 동작과 관계된 명령어이다. 이런 명령어를한 프로그램에서 고의 또는 실수로 입력하여 전체 컴퓨터의 동작이 멈추거나 꺼진다면 이 컴퓨터의 정상적인 동작을 위해서는 재부팅을 할 수 밖에 없다. 이러한 결함을 매우 치명적이다.이런 문제점을 해결하기 위해 일반 사용자가 위와 같은 명령어들을 요청하는 것을 막을 필요가 생겼다. 여기서 이중 모드 라는 것이 나왔다.설명이중 모드는 말 그대로 모드를 아래와 같이 둘로 나누는 것이다.  사용자(User) 모드  관리자(Supervisor) 모드          = 시스템(system) 모드      = 모니터(monitor) 모드      = 특권(privileged) 모드      특권 모드에서만 내릴 수 있는 명령을 특권 명령(privileged instruction) 이라고 하며, STOP, HALT, RESET, SET_TIMER 등이 있다. 만약 사용자 모드에서 특권 명령을 사용하려고 하면 CPU에서 내부 인터럽트를 발생시켜 해당 명령어를 요청한 프로그램을 강제로 종료시킨다.이중 모드는 CPU 내부의 레지스터(register)의 비트(bit)를 활용하여 플래그(flag)로 나타낸다. 예를 들어 특권 모드일 때는 비트 값이 0 이고, 사용자 모드일 때는 비트 값을 1 로 설정하여 구분한다.상태 레지스터 (플레그 레지스터)CPU에서 다양한 산술 연산의 결과의 상태를 알려주는 플래그 비트들이 모인 레지스터이다. flag라는 이름의 어원은 경주할 때, 시작, 정지와 같은 상태를 깃발의 색, 들어올림과 같은 것으로 알렸기 때문이다. CPU에서는 연산을 수행하는데, 제약사항을 갖고 (자리수의 제한 같은) 수행하기 때문에 이를 나타낼 다양한 코드가 필요하다. 이 상태는 비트를 통해 정의되어 있으며 다양한 플래그가 존재한다.상태 레지스터의 종류Mode의 변경 과정컴퓨터가 켜진 뒤에 한 사용자 애플리케이션을 실행시키는 동안 모드가 어떻게 변하는지 살펴보자.  컴퓨터 부팅 과정 - 관리자 모드  애플리케이션 실행 과정 - 관리자 모드  애플리케이션 실행중 - 사용자 모드  인터럽트 발생 후 처리 과정 - 관리자 모드  인터럽트 처리 후 - 사용자 모드사용자가 하드웨어의 자원에 접근하는 것은 매우 위험한 동작이다. 그러므로 이러한 경우에는 모두 관리자 모드로 운영체제에서 처리하도록 한다. (프로그램에서 소프트웨어 인터럽트를 발생시켜 운영체제에 위임한다.)위의 4번 과정을 하드웨어 인터럽트로 가정하고 자세히 살펴보면 아래와 같다.  하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)  CPU에서 모드 플래그를 관리자 모드값으로 설정  해당 하드웨어 인터럽트 서비스 루틴(ISR)으로 이동 (관리자 모드)  인터럽트 처리 (관리자 모드)  인터럽트 처리 완료 후 CPU의 모드 플래그를 다시 6. 사용자 모드값으로 설정  원래의 애플리케이션 위치로 복귀 (사용자 모드)만약 사용자 모드인 상태에서 치명적인 명령어를 사용자 프로그램이 Call했을 경우에 CPU는 모드 비트를 확인하고 관리자 모드가 아닐 경우, 내부 인터럽트를 발생시킨다. (잘못된 명령을 내렸을 때 발생하는 인터럽트) 그 결과, 메모리에 올라와있는 사용자 프로그램을 종료시켜버린다.애플리케이션이 실행하는 동안에는 위와 같은 모드 변경이 반복적으로 일어나는 것을 볼 수 있다. 대부분의 CPU는 이중 모드를 지원한다.2. 하드웨어 보호이중 모드는 사용자의 접근을 제한하여 치명적인 문제가 발생하지 않도록 방지하는 보호 기능에 해당한다. 이러한 보호 기능에 대해 추가적으로 알아본다.2.1 입출력 장치 보호여러 정보들은 입출력 장치를 통해 컴퓨터로 입력되고, 외부 장치로 출력이 된다. 여기서 크게 두 가지의 문제점이 발생한다.  여러 입출력 장치의 사용으로 인한 혼선  사용자가 자신의 데이터가 아닌 다른 사용자의 데이터에 입출력을 하는 일          위와 같이 입출력 장치에 여러 사용자의 데이터가 뒤엉켜서 들어오거나 다른 사용자의 데이터에 접근하려는 경우를 막아야 한다.이를 해결하기 위해 in, out 과 같은 입출력 명령을 특권 명령으로 설정하는 것이다. 즉, 사용자 애플리케이션에서 입출력을 사용하려면 운영체제를 통해서 수행해야한다.(소프트웨어 인터럽트) 여러 프로그램이 동시에 입출력을 사용하려고 하면 운영체제 내부에서 순서를 정하여 혼선을 막아줄 수 있다.즉, 컴퓨터의 하드웨어를 사용하는 과정에서는 모두 운영체제를 거치도록 한다! 라는 대원칙이 사실 숨어있다.      만약 A, B 사용자가 있는 상황에서 A가 B의 데이터를 읽기 위해 운영체제에게 소프트웨어 인터럽트를 발생하였다고 하자. 이 때, A의 데이터와 B의 데이터는 각각 A, B만이 읽기가 가능하다고 가정하자. 그러면 인터럽트가 발생하고, CPU는 RAM에 있는 운영체제 내부의 해당 ISR로 이동하게 된다. ISR은 현재 사용자 A가 해당 데이터 B에 접근할 수 없으므로 해당 요청을 거부한다.다시보는 이 그림..2.2 메모리 보호메모리에는 운영체제뿐만 아니라 여러 개의 사용자 애플리케이션이 존재한다. 한 애플리케이션이 자신의 메모리 영역이 아닌 운영체제나 다른 애플리케이션의 메모리 영역에 침범하려하면 매우 위험하다.메모리는 일반적으로 위와 같이 구성되어 있을 것이다. 여기서 user1이 OS나 user2, user3에 접근하는 것을 막아야 한다. CPU는 address bus를 통해 메모리 주소에 접근하게 되는데, user1 프로그램이 실행되는 동안에는 user1이 할당되어 있는 메모리 주소 범위 안인 경우에만 접근하면 될 것이다. 이를 address bus에서 검사하는 것이 가장 효율적일 것이다.위의 생각으로 나온 것이 MMU(Memory Management Unit) 이다. MMU는 위의 그림처럼 address bus 중간에 설치된 하드웨어 칩으로서 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다.예를 들어, User1의 시작 주소는 1024, 끝 주소는 4048이라고 하자. User1이 수행되는 동안 운영체제는 해당 프로그램의 주소 범위를 MMU에 설정(특권 명령)하는데, base는 1024, limit는 4048이 될 것이다. 결과적으로 user1이 수행되는 동안에는 이 범위 안의 주소값인 경우에만 address bus를 통과시킨다.만약 해당 프로그램의 주소 범위 밖의 주소값이 MMU에 들어온다면, MMU에서 내부 인터럽트 를 발생시켜 CPU에 신호를 준다. 그러면 CPU는 그에 맞는 ISR로 이동하여 해당 프로그램을 강제로 종료시킨다. 이과 같은 잘못된 메모리 접근을 Segment violation 이라 한다.2.3 CPU 보호CPU 보호는 사용자의 실수 또는 고의로 인한 CPU 독점을 방지해야 한다. 하나의 프로그램이 CPU를 독점하게 되면 다른 프로그램은 수행되지 못한다.while(true){}CPU를 독점하는 가장 대표적인 예는 무한 반복이다. 위의 코드를 보면 while문의 조건문이 잘못된 것을 볼 수 있다. 비교 연산자가 아닌 대입 연산자를 사용하여 n값이 1이 되므로 while문의 조건은 TRUE가 된다. 이는 n값이 변하지 않는 이상 무한으로 반복된다.이를 해결하는 방법은 Timer를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킨다. 인터럽트가 발생하면 반드시 운영체제 내의 ISR로 이동하므로, 해당 ISR에서 각 프로그램의 CPU 점유 시간을 측정하여 적절히 분배되도록 조정한다.예를 들어, 한 프로그램의 CPU 점유 시간이 비정상적으로 오래 걸리는 경우, 강제로 다른 프로그램으로 CPU를 전환시켜 줄 수 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-03-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-02-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-9d-98-ec-97-ad-ec-82-ac-html": {
        "title": "02: 운영체제의 역사",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "일괄처리부터 시분할시스템, 최근의 고급운영체제, 인터럽트에 기반한 현대 운영체제까지 변천 역사를 알아본다.1. 초기 컴퓨터  노가다, 사람 손도 많이가, 장치도 엄청커, 비싸기도 비싸운영체제는 컴퓨터가 발전하면서 같이 발전하게 되었다. 초기 컴퓨터는 크게 3가지로 구성되었다. 카드 리더, 프로세서, 프린터이다. 카드 리더는 입력기이다. 입력은 종이에 입력할 코드에 맞는 구멍을 뚫어서 넣어주는 방식이었다. 프로세서는 현재와 비슷한 계산하는 역할이었고, 프린터는 입력에 대한 결과를 종이에 찍어서 보여주었다. 이 시기에는 운영체제도 존재하지 않았으므로, 오퍼레이터(operator)라는 컴퓨터를 사용하는 직업이 따로 있었고, 컴퓨터의 크기 또한 너무 커서 건물 전체를 사용해야할 정도였다.2. Batch processing system(일괄 처리 시스템)  코드로 반복되는 거 좀 자동화 하자!위에서 초기 컴퓨터의 상황을 살펴보았는데, 프로그램을 수행할 때마다 컴파일-&gt;링크-&gt;로딩 순서를 오퍼레이터가 직접 입력해주었다. 이러한 과정을 자동화한 것이 batch processing system 이다. 위 과정을 하나의 프로그램으로 작성하여 프로세서의 메모리안에 할당해주었는데, 이 프로그램을 resident monitor라고 불렀다.resident는 “거주” 라는 의미로 이 프로그램이 항상 프로세서안에서 거주한다는 의미로 이러한 이름을 사용하였다. 그리고 이것이 최초의 운영체제로 알려져 있다.3. Multiprogramming system(다중 프로그래밍)  CPU가 노는 시간이 너무 많은데? 쉴 동안 다른일을 시켜버리자.과거에는 컴퓨터가 매우 비싼 장비였다. 그리고 초창기 메모리의 상태는 resident monitor를 제외하고 단 하나의 애플리케이션만을 할당하여 사용하였다. 하지만 이는 매우 비효율적인 방법이었다.프로그램을 수행하는 도중에는 계산을 하는 CPU 외에도 입출력을 담당하는 I/O장치가 수행한다. 즉, CPU와 I/O장치가 교대로 동작하는데 I/O장치가 수행하는 동안에는 CPU가 아무것도 할 일이 없었다. CPU가 아무일도 안하는 상태를 idle 상태라고 말한다. 그리고 I/O장치는 CPU에 비해 매우 느리기때문에 idle 상태의 비율이 너무 높았다. 이러한 비효율적인 수행을 해결하기 위해 multiprogramming system이 나왔다. 즉 CPU를 못놀게 하자방법Multiprogramming system은 메모리에 여러 애플리케이션(프로그램)을 올리는 시스템이다. 예를 들어 a, b 두 개의 애플리케이션이 있을 떄, 처음에는 a에서 CPU 수행을 하다가 I/O장치 수행으로 넘어간다. 이 순간 CPU는 idle 상태에 있지 않고 b가 있다는 것을 보고 b의 CPU 수행을 시작한다. 이렇게 idle상태의 시간을 최대한 줄이고자 하였다. 이런 동작을 가능하게 하려면 앞서 말했듯, 메모리에 여러 어플리케이션을 올린 상태여야만 한다.한계 및 문제하지만 메모리에 여러 프로그램을 올리면서 많은 문제점이 발생했다. 가장 큰 문제점은 CPU가 어느 프로그램을 수행해야하는지 선택하는 것이다. 이러한 작업을 CPU 스케줄링이라고 하며, 이는 운영체제의 중요한 역할 중 하나이다. 그리고 여러 어플리케이션의 공간을 할당한다는 전제 조건 때문에, 새롭데 들어온 어플리케이션에 대해 어느 메모리 공간에 할당해야하는지도 큰 문제였다. 이러한 문제도 운영체제가 다뤄야 하는 중요한 과제로 남았다.4. Time-sharing system(시분할 시스템)  하나 다 끝날 때까지 기다리지 말고 Interval을 주자!시간이 지나 모니터와 키보드를 사용하면서 사용자와 컴퓨터 사이에 대화 형식이 가능해졌다. 하지만 여전히 컴퓨터 자체가 너무 비쌌기 때문에 아래와 같이 단말기(terminal) 형태로 사용하였다.각 사용자(User)들은 모니터와 키보드만을 가지고, 실제 프로세서는 하나의 단말기에 존재하여 이를 공유하여 사용하였다. 멀티 프로그래밍에서는 이와 같은 단말기 형태에서 문제가 생긴다.예를 들어, 단말기 메모리에 User1 프로그램, User2 프로그램, User3 프로그램이 할당되어 있고 User1이 먼저 CPU를 사용한다고 하자. 멀티프로그래밍에서는 User1이 CPU를 수행하고 있는 도중에는 다른 사용자는 CPU자체를 사용할 수 없다. (CPU가 하나인 환경) 그러므로 다른 사용자들은 User1이 CPU수행을 모두 마칠 때까지(또는 I/O를 만날 때까지) 기다려야한다. 하지만 이는 매우 비효율적이다.해결이를 해결하기 위해 나온 것이 time-sharing system이다. 시분할 시스템은 CPU가 하나의 프로그램을 수행하는 시간을 제한하는 것이다. 예를 들어, User1 프로그램을 일정 시간 수행하면 반드시 다음 프로그램으로 넘어가서(스위칭, switching) 또 다시 일정 시간을 수행한다. 이렇게 일정 시간을 두어 프로그램들을 번갈아 수행하면서 모든 프로그램이 공평하게 수행이 되도록 한다. 그리고 이 일정 시간은 매우 짧은 시간(ms)이므로 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 가져온다. 가장 대표적인 시분할 시스템은 Unix가 있었다.한계 및 문제시분할 시스템을 사용하면서 여러 사용자(프로세스)간에 통신이 가능해졌다. 하지만 여기서도 여전히 멀티프로그래밍에서와 같은 스케줄링과 메모리 문제가 있었다. 이를 해결하기 위해 동기화 기술, 가상 메모리 등이 이후에 나왔다.5. 고등 운영체제5.1 다중 프로세서 시스템 (Multiprocessor system)  CPU가 여러개  병렬 시스템 (parallel system)          여러개의 CPU가 동시에 처리할 수 있다.        강결합 시스템 (tightly-coupled system)          메모리에 여러 CPU가 연결되어 있다.        3가지 장점: performance, cost, reliability          여러 일꾼을 쓰니 빠르다.      싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.      하나가 망가져도 작동할 수 있다. 신뢰도가 높다.        다중 프로세서 운영체제 (Multiprocessor OS)          CPU가 늘어났기 때문에, 다른 처리 방법이 필요하다.      5.2 분산 시스템 (Distributed system)]  컴퓨터가 여러대, 근데 묶여있다.  다중 컴퓨터 시스템 (multi-computer system)여러대의 컴퓨터로 만든 시스템이다.  소결합 시스템 (loosely-coupled system)          메모리가 느슨하게 연결되어 있다.        3가지 장점: performance, cost, reliability          여러 일꾼을 쓰니 빠르다.      싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.      하나가 망가져도 작동할 수 있다. 신뢰도가 높다.            분산 운영체제 (Distributed OS)          다른 컴퓨터들을 관리해야 하기 때문에 새로운 처리 방법이 필요하다.      5.3 실시간 시스템 (Real-time system)  시간 제약: Deadline  공장 자동화 (FA), 군사, 항공, 우주  실시간 운영체제 (Real-time OS = RTOS)6. 인터럽트 기반 시스템(Interrupt based system)현대 운영체제는 인터럽트 기반 시스템이다. 그렇다면 인터럽트는 무엇인가?6.1 인터럽트컴퓨터에 전원이 들어오면 위에서 말했듯이 부팅이 시작된다. 먼저, POST과정이 시작되고 그 후에 부트 로더가 하드 디스크에 있는 운영체제 프로그램을 RAM에 가져와 할당한다. 할당된 운영체제는 컴퓨터의 전원이 꺼질 때까지 상주(resident)한다.부팅이 끝나고 운영체제가 동작하는 동안 수 많은 인터럽트가 발생할 수 있다. 예를 들어, 사용자가 마우스를 움직인다고 가정하자. 이 동작을 컴퓨터는 어떻게 알 수 있을까? 바로 인터럽트를 통해 알 수 있다. 마우스를 움직이는 순간, 마우스에서 인터럽트 전기 신호가 발생하여 이를 CPU에게 보낸다. CPU는 이를 감지하고, 자신이 하던 일을 멈춘 후에 이 인터럽트 신호를 처리하기 위해 운영체제 내부에 있는 인터럽트를 처리하는 코드(interrupt service routine, ISR)로 이동한다. 이 곳에 마우스가 움직일 때 어떻게 동작해야하는지가 내포되어 있어 이를 수행한다.6.2 인터럽트의 종류와 동작방법이러한 하드웨어에서 발생한 인터럽트를 하드웨어 인터럽트(Hardwore Interrupt) 라고 한다. 인터럽트라고 하면 기본적으로 하드웨어 인터럽트를 말하지만, 소프트웨어에서도 인터럽트를 요청을 할 수 있다. 이를 소프트웨어 인터럽트(Software Interrupt) 라고 한다. 소프트웨어 인터럽트는 명령어로 직접 인터럽트 전기 신호를 CPU에게 보낼 수 있다. 즉, 프로그램에서 swi, int 와 같은 어셈블리어 명령어를 수행하는 것이다. (명령어는 운영체제마다 다르다. 위의 명령어는 CPU에서 어셈블리어 코드 중 일종으로, interupt를 처리하라는 명령어이다.)예를 들어, 마우스로 워드 작성 프로그램을 실행시킨다고 하자. 워드 작성 프로그램을 실행시키는 것까지는 하드웨어 인터럽트가 수행된다.(마우스가 이동하여 더블 클릭으로 실행하는 경우이다.) 이 프로그램에서 사용자가 하드디스크에 있는 다른 워드 파일을 읽고 싶은 경우, 소프트웨어 인터럽트를 발생시킨다. 소프트웨어 인터럽트 역시 하드웨어 인터럽트와 동일하게 운영체제 내부에 해당 인터럽트를 처리하는 코드(ISR)가 존재하여 이 곳으로 이동한다. 여기서 하드디스크에서 읽을 파일을 찾아서 반환해주는 수행을 처리하는 것이다.마지막으로 내부 인터럽트(Internal Interrupt)가 있다. 내부 인터럽트는 프로그램을 수행하는 도중에 발생하는 예외 상황을 처리한다. 대표적인 예로 0으로 나누는 동작이다. 프로그램의 내부에 result = a / 0; 이와 같은 코드가 있을 때, CPU는 내부 인터럽트를 발생시켜 운영체제안에 있는 ISR로 이동한다. 이 경우에는 DividedByZero 라는 ISR로 이동한다. 여기서 잘못된 동작을 수행한 프로그램을 강제로 종료시킨다.운영체제는 평소에는 대기 상태에 있으면서 인터럽트가 발생하는 순간 작업을 수행한다. 그 인터럽트의 종류에 따라 운영체제 내부에 위치한 ISR로 이동하여 그에 맞는 처리를 한다. 위에서 설명한 하드웨어 인터럽트 과정을 그림으로 간단히 표현하면 아래와 같다.위 그림은 사용자 애플리케이션을 실행하기 위해 하드웨어를 사용하는 모습이다. 애플리케이션이 실행하는 중에도 계속해서 인터럽트는 발생한다. 워드 작성 프로그램을 예를 들면 키보드로 글을 작성하는 경우, 하드디스크에 있는 파일을 불러오는 경우 모두 인터럽트가 발생한다. 그러므로 CPU는 애플리케이션과 운영체제 내부를 교대로 수행하는 모습을 볼 수 있다.정리정리하면, 인터럽트는 CPU에게 보내는 전기 신호로서 인터럽트가 발생하면 CPU는 하던 일을 중지하고 해당 인터럽트를 처리하기 위해 운영체제 내부에 있는 ISR로 이동하여 수행한다. 그리고 수행이 끝나면 원래 위치로 돌아간다. 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부 인터럽트로 총 세 가지가 존재한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-02-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%EC%82%AC.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-eb-9e-80-eb-ac-b4-ec-97-87-ec-9d-b8-ea-b0-80-html": {
        "title": "01: 운영체제란 무엇인가?",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제에 대한 정의, 역할에 대해 알아본다.운영체제는 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어이다. 일반적으로 사용하는 모든 프로그램은 운영체제에서 그 자원을 관리한다.목적운영체제를 사용하는 가장 큰 목적은 하드웨어의 관리이다. 컴퓨터를 나타내는 가장 상징적인 장치는 CPU이지만, 추가적으로 많은 장치와 상호작용하며 동작한다. 그렇기에 이러한 하드웨어를 관리하는 소프트웨어가 있어야 효율적으로 컴퓨터를 사용할 수 있다. 하드웨어를 직접적으로 사용하는 것이 아니기 때문에, 이를 효율적으로 사용하기 위해서는 운영체제의 성능이 좋아야 한다.두번째로는 사용자에게 편의를 제공하는 것이다. 운영체제가 없을 경우, 우리는 하드웨어 단에서 하드 코딩으로 원하는 작업을 실행해야 한다. 이는 매우 생산성이 떨어지는 방법이다. 그렇기 때문에 이런 자원 관리 측면을 자동으로 해주는 소프트웨어를 통해, 원하는 작업에만 몰두할 수 있는 환경을 제공한다.정리운영체제는 컴퓨터의 성능을 높히고(performance), 사용자에게 편의성을 제공(Convenience)을 목적으로 하는 컴퓨터 하드웨어 관리 프로그램이다.부팅 (Booting)컴퓨터를 사용하기 위해서 가장 먼저하는 행동은 전원버튼을 누르는 것이다. 그렇다면, 전원을 눌렀을 때, 시작해야 하는 작업들이 있을 것이다. 우리가 실제로 사용할 수 있는 운영체제가 실행되기 이전에 다양한 작업을 해야하는데, 이 작업을 부팅 이라 한다.어떻게 실행할 수 있을까?기본적인 컴퓨터 구조는 위와 같다. 이 상황에서 부팅을 한다고 생각해보자. 컴퓨터는 원하는 작업을 실행할 때, Disk, RAM, CPU, RAM, Disk 순의 과정을 거치며 작동하게 된다. 그런데, 부팅을 하는 경우에는 어떻게 해야할까? 사실 Disk는 컴퓨터 입장에서는 보조 장치이다. 컴퓨터라고 부를 수 있는 실질적인 부분은 CPU, RAM이 전부이기 때문에 처음 부팅을 시작하면 CPU 에 부팅시 필요한 작업을 넘겨줄 수 없다.따라서 우리는 일반적으로 프로그램이 동작하는 방식인 Disk, RAM, CPU 과정을 거칠 수 없기 때문에, 부팅에 한해서 RAM에 항상 저장된 공간을 필요로하게 되었는데, 그것이 ROM이다.RAM과 ROM을 함께 Main Memory라 부른다.  ROM: 비휘발성 으로 메모리에서 극히 일부를 차지한다.(수 KB)  RAM: 휘발성 으로 메모리의 대부분을 차지하며 실제 프로그램이 할당되는 곳이다.(수 MB ~ 수 GB)부팅시 하는 작업(엄밀한 정의의 부팅)  ROM의 정보를 읽는다.  ROM안에 있는 POST(Power-On-Self-Test), 부트 로더(Boot-Loader)를 실행한다.POST는 전원이 켜지면 가장 처음에 실행되는 프로그램으로, 현재 컴퓨터의 상태를 검사한다. 이 것에는 장치가 연결되어 있는지, 멀쩡한 지 등의 상태를 뜻한다.부트 로더는 하드디스크에 저장되어 있는 운영체제를 찾아서 메인 메모리(RAM)에 가지고 온다. 이러한 부트 로더의 과정을 부팅이라고 한다.이렇게 메모리에 올라온 OS는 컴퓨터를 종료하기 전까지 계속 메모리에 상주한다.구조운영체제는 크게 커널(Kernel)과 명령어 해석기(Command interpreter, shell)로 나뉜다.커널(Kernel)은 운영체제의 핵심인 하드웨어를 다루는 코드를 말한다. 이 부분이 핵심이 때문에, Kernel에 따라 운영체제가 달라진다. 예를 들어 페도라, 우분투 등이 리눅스 운영체제라 부르는 것은, 이 운영체제가 리눅스 커널을 사용하기 때문이다.명령어 해석기(Command interpreter, shell)는 이 커널로 만들어진 코드를 동작하기 위해 만들어진 부분이다. Interface라고 볼 수 있다. GUI(Graphical User Interface)나 CLI(Command Line Interface) 같은 방식으로 운영체제에 명령을 요청할 수 있다.위치사용자 프로그램(Application)은 특정 운영체제에 맞춰서 만든다. 그러므로 한 애플리케이션은 서로 다른 운영체제에서 수행할 수 없다. (하드웨어가 같은 것은 전혀 상관이 없다.) 예를 들면 Windows에서 수행하는 프로그램을 그대로 Linux에 옮기면 수행되지 않는다. 이전 글에서 보았듯이 사용자 프로그램은 자원을 OS를 통해 요청한다. 그렇기 때문에 해당 운영체제의 Interface를 따라야 하고, 그렇기 때문에 운영체제가 다를 경우 동작할 수 없다.추가적으로 국가에 비유하여 생각해 볼 수도 있다.영토, 정부, 가족, 개인 비유ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-01-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html"
      }
      ,
    
      "cs-structure-2020-03-27-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ea-b0-80-ed-95-98-eb-8a-94-ec-9d-bc-html": {
        "title": "07: 운영 체제가 하는 일",
        "tags": "컴퓨터 구조, 운영체제, 스케쥴링, 가상메모리",
        "date": "March 27, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "운영 체제가 하는 일을 간단하게 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.운영체제가 하는 일  접근 제어 + 동기화 + 관리전산 자원을 관리한다. 대표적인 전산 자원은 CPU, RAM 등이 있다. 스타판 프로게이머프로그램’들’ 관리하기  Process를 관리한정된 자원으로 많은 프로그램들이 동작해야 한다. 어쩔 수 없이 나눠서 사용해야 한다.아래 단어들의 의미를 모른다면, 용어를 알고 다시 읽자.하드웨어, 운영체제, 프로세스, 스레드 용어 정리Scheduling  멀티 프로세스 운영체제에서 하나의 CPU가 복수의 프로세스를 실행하기 위해 CPU를 사용하는 순서를 정해주는 작업이렇게 다양한 프로세스를 동시에 작업하게 되면, 스레드가 CPU를 사용하고 있을 떄, 사용하고 있다고 알려주는 동기화가 매우 중요하다.Virtual Memory System  RAM과 HDD를 하나의 논리적 메모리로 추상화시킨 메모리 관리 방법프로세스가 운영체제로 부터 메모리를 할당 받는 일은 시간이 많이 걸리는 일이다. 그렇기 때문에 최대한 RAM 공간에 할당 받은 채로 존재하는 것이 속도를 높일 수 있는 방법이다. 또한 여러개의 프로세스를 사용할 경우, RAM 공간을 초과하여 프로세스가 동작하지 않는다. 이런 부분들을 해결하기 위해 HDD 공간을 활용한 것이 가상 메모리 시스템이다.단위이 곳에서 모든 메모리는 Page라는 단위로 관리된다. HDD와 RAM을 왔다갔다 하는 단위이다. 이 중에는 Paged 될 수 있는 페이징 풀 영역과 절대로 Paged 되면 안되는 비 페이징 풀 영역이 있다.Virtual Memory의 구성집의 공간을 가족 구성원들이 나눠쓰듯이 프로세스의 가상 메모리 공간을 thread가 나눠서 사용한다. 이 나눠서 사용하는 공간을 Stack이라 한다. 이 thread에 할당된 메모리 공간이 stack을 사용하여 관리되기 때문에 Stack이라 불린다.프로세스는 Heap과 실행 코드 영역을 갖는다.운영체제 정리 05: 프로세스 관리동작 방법  RAM이 꽉찼는 지 확인한다.  꽉찼다면 현재 RAM 공간 중에 사용하지 않는 프로세스가 할당된 공간이 있다면 이것을 HDD 공간에 복사해둔다. Page Out(Swap Out)  RAM 공간이 비게 될 경우 복사해 둔 공간을 다시 RAM으로 복사한다. Page in(Swap in)프로세스 별 가상 메모리의 크기이러한 가상 메모리 시스템이 있기 때문에, 프로세스가 실행 되고 할당 받는 메모리 공간은 4GB로 할당한다. 이 크기는 현실적으로 RAM만 사용한다면 말이 안되는 소리지만, 가상 메모리를 사용하게 되면 문제없다.",
        
        "url": "/cs/structure/2020/03/27/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C%EA%B0%80-%ED%95%98%EB%8A%94-%EC%9D%BC.html"
      }
      ,
    
      "dv-javascripts-2020-03-26-javascript-window-event-html": {
        "title": "window resize event",
        "tags": "development, javascript, resize",
        "date": "March 26, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "자바스크립트의 window 이벤트를 알아본다.resizewindow.addEventListener(\"resize\", changeContent);function changeContent(event) {  const cat = document.getElementById(\"js-cat\");  const cv = document.getElementById(\"category-cv\");  const math = document.getElementById(\"category-math\");  const ds = document.getElementById(\"category-ds\");  const cs = document.getElementById(\"category-cs\");  const dv = document.getElementById(\"category-dv\");  const about = document.getElementById(\"category-about\");  if (event.target.innerWidth &lt; 710) {    cv.innerText = \"📜\";    math.innerText = \"✖\";    ds.innerText = \"📈\";    cs.innerText = \"💾\";    dv.innerText = \"📱\";    about.innerText = \"😎\";    cat.style.justifyContent = \"space-around\";  } else {    cv.innerText = \"CV\";    math.innerText = \"Math\";    ds.innerText = \"Data Science\";    cs.innerText = \"Computer Science\";    dv.innerText = \"Development\";    about.innerText = \"About\";    cat.style.justifyContent = \"center\";    console.log(cat);  }}이 코드는 내 블로그 카테고리를 수정할 때 만든 코드이다.",
        
        "url": "/dv/javascripts/2020/03/26/javascript-window-event.html"
      }
      ,
    
      "dv-html-css-2020-03-26-safari-longline-scroll-html": {
        "title": "Safari: long line scroll 작동 안함",
        "tags": "Browser, Safari, css",
        "date": "March 26, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "근본적인 문제는 Safari pre태그의 초기값 때문이다.이것을 해결하기 위해서는 다음의 코드를 추가하면 된다..site-content pre {  overflow-wrap: normal;}Reference참고",
        
        "url": "/dv/html-css/2020/03/26/Safari-longline-scroll.html"
      }
      ,
    
      "cs-structure-2020-03-26-ec-9e-90-eb-a3-8c-ea-b5-ac-ec-a1-b0-ec-99-80-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "06: 자료구조와 알고리즘",
        "tags": "컴퓨터 구조, 자료구조, 알고리즘",
        "date": "March 26, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "컴퓨터에서 사용하는 자료구조와 알고리즘을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.자료를 정리해야 하는 이유  정리를 잘 해둬야 필요할 때 빨리 꺼내 쓸 수 있다!처음엔 몰랐지만.. 갈 수록 유지 보수를 위해 정리하는 것이 중요함을 느낀다.. ㅠㅠ어떻게 정리할까?  정리 는 상황에 맞는 적절한 규칙이 존재한다.일련번호도 아무런 규칙이 없어보이지만, 그 숫자들에 규칙이 존재한다.자료구조선형 구조배열  물리적으로 순차적인 자료구조장점  단순하다.  한 자료에서 다음 자료 넘어갈 때 생각할 것이 없다. 인덱스가 단순 증가한다.단점  크기를 늘리거나 줄이려면 구조를 변경해야 한다.  중간에 새로운 자료를 넣거나 빼는 경우 문제가 발생한다.Linked List  화살표룰 가지고 원하는 요소를 가리키는 구조장점  순서를 바꾸기 매우 쉽다.  중간에 새로운 자료를 넣거나 뺴기가 쉽다.단점  한 자료 접근 후 다음으로 넘어가기 위해서 위치정보를 활용해 찾아가야한다.  찾아간다는 점에서 배열에 비해 복잡하다.Stack  뚜껑식 김치 냉장고 : 출입구가 하나다!사용처  되돌아 가기 위한 구조한 스텝 전진하고, 전으로 가기 위해서는 pop 한다.  가장 최근 값을 가져온다  대칭 구조Queue  줄을 선다!버스에서 줄을 서는 것이나 은행의 대기열을 생각하면 된다. 이 때 버스는 순차적으로 처리가 진행이 되고, 은행은 병렬적으로 처리된다. 각각을 순차 처리, 병렬 처리라 한다.비선형 구조Binary Tree선형 구조, 정렬이 안된 상황에서 특정 값을 찾는다고 생각해보자. 이런 경우 해당 배열의 크기만큼 탐색을 진행해야 한다. 결과적으로 선형 구조에서 값을 찾는 것은 상대적으로 효과적이지 않다.그래서 새로운 구조가 필요했는데 그 중 가장 효과적으로 사용한 구조가 이진 트리이다.이진 트리에 대한 내용 정리선형 구조, 비선형 구조 비교                   비선형      선형                  구조      복잡      간단              접근효율      좋다      나쁘다      물론 데이터 개수에 따라 판단을 달라질 수 있다. 상황 판단을 잘해야 한다.알고리즘Sort선형 구조에서 정렬하는 방법에 대해 생각해본다. 이 부분은 나열만 해두겠다.정렬에 대한 기초적 내용 정리선형 구조에서의 정렬 알고리즘  Bubble  Quick  Merge  Selection  Insertion  Heap  Radix",
        
        "url": "/cs/structure/2020/03/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "dv-tips-2020-03-25-latex-align-html": {
        "title": "Latex equation 예쁘게 맞추기",
        "tags": "LaTex, equation, align",
        "date": "March 25, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "LaTex 에서 align을 사용하여 방정식을 예쁘게 맞춰보자.수식 전개를 하다보면, 계속해서 등호를 사용하여 수식의 변경요소를 보여줄 필요가 있다.으으 못생겼다이런 경우 Latex 수식을 시작할 떄 align 속성을 걸어주면 예쁘게 사용할 수 있다.\\begin{align}A &amp; = B \\\\&amp; = C \\\\&amp;= \\cdots \\\\&amp;= Z.\\end{align}",
        
        "url": "/dv/tips/2020/03/25/Latex-align.html"
      }
      ,
    
      "cs-structure-2020-03-25-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-88-ab-ec-9e-90-eb-a1-9c-eb-aa-a8-eb-93-a0-ea-b2-83-ec-9d-84-eb-8b-a4-eb-a3-a8-eb-8a-94-eb-b0-a9-eb-b2-95-html": {
        "title": "05: 숫자로 모든 것을 다루는 방법",
        "tags": "컴퓨터 구조, 글자, ASCII, Text, binary, rendering, 렌더링, 아스키",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "컴퓨터가 모든 것을 숫자로 다루는 방식을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.컴퓨터로 글자를 나타내는 방법ASCII Code  숫자와 글자에 대한 함수관계를 정의한다.출처바이너리 코드(binary Code)실제로 담고 있는 정보를 Text 형태로 보여주면 ASCII Code 형태가 되고, 이것을 컴퓨터가 이해하는 방식인 숫자(보통 16진수)로 표현해 놓으면 이것을 바이너리 코드라 한다.결과적으로 사람이 읽을 수 있는 텍스트 파일 이외에 컴퓨터 저장이나 처리 목적을 위해 코드를 숫자로 변경해 놓은(인코딩) 데이터를 말한다.컴퓨터가 사진을 다루는 방법  특정 화소 하나를 숫자로 표시하고 이를 모아 사진으로 그린다.이미지 파일 형식  해당 화소를 표현하는 방식(규칙)에 대한 것.Rendering  숫자로 되어 있는 것을 글자와 사진으로 그려내는 것!이 속도가 중요하다! 렌더링이라는 것이 정확히 무엇인지 몰랐는데… 휴우",
        
        "url": "/cs/structure/2020/03/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%88%AB%EC%9E%90%EB%A1%9C-%EB%AA%A8%EB%93%A0%EA%B2%83%EC%9D%84-%EB%8B%A4%EB%A3%A8%EB%8A%94-%EB%B0%A9%EB%B2%95.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-9d-b4-ec-b9-9c-ec-88-98-html": {
        "title": "백준(2193번): 이친수",
        "tags": "백준, 알고리즘, 동적계획법, 피보나치",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 동적계획법 문제이다.백준(2193번) - 이친수생각이 문제의 핵심은, 최고자리 숫자가 0 또는 1일 때의 상황을 분리해서 생각해보는 것이다. 이유는 나열하면 금방 알아차릴 수 있다.            N      1             2             3                                0      X      00      X      000      X                     1      O      01      X      001      X                                   10      O      010      X                                   11      X      011      X                                                 100      O                                                 101      O                                                 110      X                                                 111      X                            1             1             2      여기서 N이 2 일 때를 생각해보면, 앞자리에 1이 있어야 하고, 그 뒤는 0으로 시작해야 한다. 0으로 시작한 이후에는 이친수가 와야한다. 그럴 경우에 새로운 이친수가 만들어진다. 따라서 N이 증가함에 따라 다음 자리수의 이친수를 만들기 위해서는 최고자리가 0인 상황에서 다음 숫자부터 가지는 이친수를 저장할 필요가 있다.정의  dp[N][0] : N자리수의 최고자리가 0일 경우 이후 자리수에서 가질 수 있는 이친수의 개수  dp[N][1] : N자리수의 최고자리가 1일 경우 가질 수 있는 이친수의 개수점화식  dp[N][0] = dp[N-1][0] + dp[N-1][1];최고자리수가 0일 때, 위의 정의에 맞는 개수를 구하기 위해서는 그 다음 자리의 수가 1인 경우와, 0인 경우가 있다. 따라서 그 두 경우를 모두 더해주어야 내가 원하는 수를 구할 수 있다.  dp[N][1] = dp[N-1][0];1인 경우에는 무조건 다음 자리수가 0으로 시작하는 이친수를 구해야 하므로 위와 같다.Code// 실버3 : 백준 2193번 이친수#include &lt;iostream&gt;using namespace std;int main(){    int N;    long long dp[91][2];    cin &gt;&gt; N;    dp[1][0] = 1;    dp[1][1] = 1;    for (int i = 2; i &lt;= N; i++) {        dp[i][0] = dp[i-1][0] + dp[i-1][1];        dp[i][1] = dp[i-1][0];    }    cout &lt;&lt; dp[N][1] &lt;&lt; '\\n';}피보나치 수열그런데 위의 점화식을 잘 정리하면 우리가 알고있는 피보나치 수열의 형태가 나온다.다이나믹은 끝이 없다.",
        
        "url": "/cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%9D%B4%EC%B9%9C%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-8b-9c-eb-a6-ac-ec-96-bc-eb-84-98-eb-b2-84-html": {
        "title": "백준(1431번): 시리얼 넘버",
        "tags": "백준, 알고리즘, 정렬",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 정렬 문제이다.백준(1431번) - 시리얼 넘버생각문제에서 하라는 대로 비교만 하면 된다.Code// 실버3 : 백준 1431번 시리얼 번호#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;string arr[1002];bool compare(string a, string b){    int sizeA = int(a.size()), sizeB = int(b.size());    if (sizeA &gt; sizeB) return false;    else if (sizeA &lt; sizeB) return true;    else {        int sumA = 0, sumB = 0;        for (int i = 0; i &lt; sizeA; i++) {            if (0 &lt;= a[i]-'0' &amp;&amp; a[i]-'0' &lt;= 9) sumA += a[i]-'0';        }        for (int i = 0; i &lt; sizeA; i++) {            if (0 &lt;= b[i]-'0' &amp;&amp; b[i]-'0' &lt;= 9) sumB += b[i]-'0';        }        if (sumA &lt; sumB) return true;        else if (sumA &gt; sumB) return false;        else {            return a &lt; b;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; arr[i];    }    sort(&amp;arr[0], &amp;arr[N], compare);    for (int i = 0; i &lt; N; i++) {        cout &lt;&lt; arr[i] &lt;&lt; '\\n';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%8B%9C%EB%A6%AC%EC%96%BC-%EB%84%98%EB%B2%84.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-83-89-ec-a2-85-ec-9d-b4-eb-b6-99-ec-9d-b4-ea-b8-b0-html": {
        "title": "백준(17136번): 색종이 붙이기",
        "tags": "백준, 알고리즘, 구현, 완전탐색, DFS, 삼성 역량 테스트",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 완전탐색 문제이다. 삼성 A형 기출이다.백준(17136번) - 시리얼 넘버생각시간이 1초라, 제한 시간에 들어올 수 있는지 시간 복잡도 계산부터 진행했다. 최악의 경우 100개의 공간에 모두 1이 차있는 경우 한 개의 공간에서 색종이를 5번 검사해야 한다.백트래킹을 해야 하나 고민했지만, 다행히 이 문제의 경우 한 개의 공간에서 5개의 경우의 수가 무조건적으로 발생하지 않는다는 점을 고려하여 풀이를 진행했다. 구현에 앞서 중요하게 생각한 것들은 다음과 같다.  종이의 수는 5장이다. 이 부분을 업데이트 해준다.  칠했다는 것을 표현하고, 이 부분은 탐색을 하지 않는다.  칠할 수 없는 곳은 칠하지 않고 다음 옵션으로 넘어간다.  끝나는 조건은 모든 1이 색칠이 되었을 때이다.설계main입력을 받는다.    이 때, 입력이 1인 경우 이 위치만 저장한다.1의 개수를 저장해 둔다.탐색한다.탐색 후 값을 출력한다.탐색 함수만약 현재까지 칠한 개수가 1의 개수와 같다면 answer를 업데이트 한다.현재 depth의 1의 위치를 가져온다.이 위치에 색종이가 붙어있지 않다면    5개의 색종이를 순차적으로 비교한다. 이 때 큰 색종이 부터 탐색한다.        만약 현재 색종이가 남아있다면            만약 해당 색종이를 붙일 수 있다면                색종이를 칠한다                색종이의 개수를 하나 감소시킨다                색종이를 붙이고, 다음 위치에서 탐색한다.                색종이의 개수를 하나 증가시킨다                색종이를 뗀다            색종이를 붙일 수 없다면                다음 색종이를 탐색한다        현재 색종이가 남아있지 않다면            다음 색종이를 탐색한다이 위치에 색종이가 붙어있다면    다음 위치에서 탐색한다.Code// 골드3 : 백준 17136번 색종이 붙여넣기#include &lt;iostream&gt;#include &lt;vector&gt;#define INF 2000000000using namespace std;int globalAns = INF, N = 0;int map[10][10] = {0};vector&lt;pair&lt;int, int&gt;&gt; position;pair&lt;int, int&gt; action[5] = {make_pair(5, 5),                            make_pair(4, 5),                            make_pair(3, 5),                            make_pair(2, 5),                            make_pair(1, 5)};void fillSquare(int y, int x, int num, int value){    for (int i = y; i &lt; y+num; i++)        for (int j = x; j &lt; x+num; j++)            map[i][j] = value;}bool isFillPossible(int y, int x, int num){    for (int i = y; i &lt; y+num; i++) {        for (int j = x; j &lt; x+num; j++) {            if (!(0 &lt;= i &amp;&amp; i &lt; 10 &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; 10)) return false;            if (map[i][j] == 0 || map[i][j] == 2) return false;        }    }    return true;}void go(int depth, int localAns, int paint){    if (paint == N) {        globalAns = min(globalAns, localAns);        return;    }    int y = position[depth].first, x = position[depth].second;    if (map[y][x] == 1) {        for (int i = 0; i &lt; 5; i++) {            int squareSize = action[i].first, &amp;squareCount = action[i].second;            if (squareCount != 0) {                if (isFillPossible(y, x, squareSize)) {                    fillSquare(y, x, squareSize, 2);                    squareCount--;                    go(depth+1, localAns+1, paint+(squareSize*squareSize));                    squareCount++;                    fillSquare(y, x, squareSize, 1);                }            } else continue;        }    } else go(depth+1, localAns, paint);}int main(){    for (int i = 0; i &lt; 10; i++) {        for (int j = 0; j &lt; 10; j++) {            cin &gt;&gt; map[i][j];            if (map[i][j] == 1) position.push_back(make_pair(i, j));        }    }    N = int(position.size());    go(0, 0, 0);    if (globalAns == INF) {        if (position.size() == 0) cout &lt;&lt; 0;        else cout &lt;&lt; -1;    }    else cout &lt;&lt; globalAns;    cout &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%83%89%EC%A2%85%EC%9D%B4-%EB%B6%99%EC%9D%B4%EA%B8%B0.html"
      }
      ,
    
      "dv-c-2020-03-24-cin-cout-eb-b9-a0-eb-a5-b4-ea-b2-8c-html": {
        "title": "입출력 빠르게 받는 방법",
        "tags": "c++, iostream, 입출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "ios_base 라이브러리의 함수를 통해 입출력을 빠르게 받는 방법을 알아본다. 출처 : https://coding-insider.tistory.com확연하게 cin, cout이 느리다는 것을 알 수 있다.적용ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);main 함수안에 위의 코드를 적어주면 빠른 입출력이 가능하다.설명  ios_base::sync_with_stdio(false)C 입출력 함수와 C++ 입출력 스트림의 동기화를 해제하는 것이다. 이걸 쓰면 C, C++ 입출력 함수를 섞어 쓰면 안된다.  cin.tie(NULL); cout.tie(NULL);cin과 cout 의 tie를 해제하는 것이다. 자세한 설명을 모르겠다.  std::endl -&gt; '\\n'endl도 역시 불러오는 것이기 때문에 속도가 매우 느리다.주의 사항하지만 이 방법은 일종의 편법이기 때문에, 사용시 주의가 필요하다.  scanf, printf와 함께 사용하면 안된다.  싱글 쓰레드 환경에서만 사용 가능하다. (알고리즘 문제풀이시에 사용, 실무에서는 사용 X)",
        
        "url": "/dv/c++/2020/03/24/cin-cout-%EB%B9%A0%EB%A5%B4%EA%B2%8C.html"
      }
      ,
    
      "cs-structure-2020-03-24-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ea-b8-b0-ec-96-b5-ec-9e-a5-ec-b9-98-ec-97-90-eb-8c-80-ed-95-9c-ec-9d-b4-ed-95-b4-html": {
        "title": "04: 기억장치에 대한 이해",
        "tags": "컴퓨터 구조, 기억장치",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "기억 장치의 동작방법에 대해 이해해보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.Memory Device계층 구조출처 : https://programmer-student.tistory.com쉬운 이해를 위한 도표            기억장치      분류                  캐시      책상              RAM      책꽂이              HDD      도서관      컴퓨터가 관리하는 방법 - 관리 체계  컴퓨터는 모든 것이 숫자이다.그래서 기억 공간도 번호를 붙여 관리한다. 이와 같은 관리 체계는 아파트 단지를 동, 호로 관리하는 것과 비슷하다.  RAM에 있는 n번 번호에 있는 정보를 가져와  그 정보를 CPU에서 사용할 연산 저장 공간에 저장해  연산을 수행해  RAM의 m번 공간에 저장해여기서 CPU에서 저장하는 공간의 명칭이 register이다.레지스터  개별 기억 공간마다 고유 이름을 붙인다.기본적으로 레지스터는 많은 저장 공간을 갖고 있지 않다. 그래서 이 각각에 이름을 붙여 관리한다.주기억장치(RAM)  일련 번호를 붙인다.위에서 언급했던 번호에 해당하는 것이 보통 RAM에 대한 설명이다.  신발장 번호 : 주소신발 : 정보이 신발장을 컴퓨터는 약 43억 개 갖고 있는데, 이 숫자는 $2^32$ 가지에 해당하는 숫자이다. 저 숫자를 표시하기 위해서 32비트가 필요하다.보조 기억장치(HDD, SDD)  트랙 번호와 섹터 번호를 붙여 관리한다.Track중심부로 부터 밖으로 나가는 원들 중 하나를 말한다.Sector원을 균등하게 부채꼴 모양으로 나눈 것들중 하나를 섹터라 말한다.Format 이란?하드디스크의 섹터와 트랙을 구성하는 작업을 말한다. Format을 하면 데이터가 다 날아가는 이유는, 하드디스크에 정보를 저장하는 체계인 트랙과 섹터를 재구성하기 때문이다.파일 시스템하드 디스크에 내가 가진 파일의 위치를 Track, Sector로 나타낸 표            파일이름      Track      Sector                  a.mp3      1      1      이런 파일 시스템은 File Allocation Table (FAT), NTFS.. 등등 엄청 많다. 내가 파일을 삭제하면, 이 파일 시스템의 Delete Field에 True로 체크가 되고, 이 공간은 운영체제에서 쓰기 가능한 공간으로 바뀐다. 그래서 디스크 복구같은 것이 가능한 것.디스크 조각 모음하드디스크는 기본적으로 원의 형태를 띈 모양으로 구성되어 있고, 이것을 Arm을 사용해 읽는다. 그래서 갖는 특징이 있는데, 같은 track에 내가 사용하는 데이터가 모여있는 경우 입출력 속도가 빠르다. 하지만 만약에 데이터가 다른 트랙, 다른 섹터에 분산되어 있다면 이 파일을 읽기 위해서 Arm이 여러번 움직어야 한다. 관성 때문에 Arm의 속도가 느려지고 결과적으로 입출력 속도의 감소가 이루어진다.이렇게 흩어져 있는 파일을 같은 track이나 그 근처로 모으는 작업을 디스크 조각 모음이라 한다.전체 흐름  HDD에 몇번 트랙, 몇번 섹터에서 정보를 읽어와  그걸 RAM의 몇번 주소에 저장해라  그리고 그걸 다시가져와서 CPU에 EAX라는 이름을 가진 레지스터에 저장해라컴퓨터가 연산하는 과정이제 메모리가 어떻게 구성되어 있는 지를 대충 알았다면, 실제 연산과정을 들여다 보자.  캐시 메모리는 CPU 그 자체다.RAM은 CPU의 연산을 돕기위한 연습장이다.맨 위에서 보았듯이 메모리가 정보를 불러오는 데에는 속도가 존재한다. 전체적인 과정은 HDD, RAM, Resister 순으로 입출력이 일어나는데, 이 때 속도차이가 나므로 CPU가 빠르게 연산을 처리하는데 문제가 생긴다.그래서 이 병목구조를 탈피하기 위해서 CPU, RAM 등에 캐시 메모리를 두어 이 부분을 해소한다. 캐시 메모리는 CPU가 연산을 수행하는 동안 다음에 필요한 정보를 RAM에서 미리 가져와 저장하는 역을 한다. 그 결과 CPU는 RAM에서 정보를 가져올 때 걸리는 시간을 캐시에서 가져오므로써 시간적 이득을 가질 수 있다.CPU ALUALU는 가산기를 뜻한다. CPU에 대해서 배울 때, 이는 연산 처리 장치이고 모든 연산은 가산기 하나로 가능하다고 배웠다. 결과적으로 Core 하나에는 ALU하나가 들어있다고 생각하면 된다. 쿼드코어 컴퓨터는 가산기가 4개 존재한다.64bit 컴퓨터CPU가 연산을 처리할 때 발생하는 input, output의 단위가 64bit 만큼의 정보를 단위로 연산을 수행한다는 의미이다.전체 과정  RAM에서 정보를 가져온다  캐시 메모리에서 정보를 읽는다.  레지스터로 해당 값을 옮긴다.  ALU에서 연산을 수행한다.  결과를 레지스터로 복사한다.  그 값을 RAM으로 옮긴다.이런 작업을 코드라 한다. 그런데 CPU(기계)에게 명령하는 코드이므로 기계어 코드라 한다.",
        
        "url": "/cs/structure/2020/03/24/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-b2-b4-ec-8a-a4-ed-8c-90-eb-8b-a4-ec-8b-9c-ec-b9-a0-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1018번): 체스판 다시 칠하기",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현, 완전탐색",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버5 : 완전 탐색 문제이다.백준(1018번) - 체스판 다시 칠하기대표적인 완전 탐색 문제이다.체스판이 될 수 있는 모든 경우에 대해서 몇번의 flip을 해야하는지 세고, 이를 갱신해주면 풀린다.이 때, 체스판의 규칙을 잘 파악하는 것이 중요하다.Example                   1      2      3      4      5      6      7      8                  1      W      B      W      B      W      B      W      B              2      B      W      B      W      B      W      B      W              3      W      B      W      B      W      B      W      B              4      B      W      B      B      B      W      B      W              5      W      B      W      B      W      B      W      B              6      B      W      B      W      B      W      B      W              7      W      B      W      B      W      B      W      B              8      B      W      B      W      B      W      B      W      1행에서, 맨 마지막인 8열은 B이고, 그 다음 행의 첫번째는 B이다. 계속해서 엇갈려서 발생하는 것이 아니고, 행이 끝날 때, 마지막 요소가 다음 요소가 된다. 또한 추가적으로 체스판은 시작 위치의 표식이 어떤 것이냐에 따라 모양이 정해진다. 이 부분에서 생각할 수 있는 것은, 같은 모양이나 시작 위치의 표식만 바뀐다. 라는 것이다.구현이 것을 구현하기 위한 단계를 생각해보자.  우리는 체스판의 크기에 따라 몇 개의 작은 체스판을 조사해야 하는지 정해야 한다.  그 안에 들어갔을 때, 시작 위치의 표식을 설정해 주어야 한다.  체스판을 만들 수 있는 방법을 진행하며 다른 부분을 체크하고 count 해야한다.Code// 실버5 : 백준 1018번 체스판 다시 칠하기#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool map[50][50];int N, M;int ans = 2000000000;void go(int y, int x){    // 각각의 작은 체스판에서 시작 위치의 표식을 W, B으로 설정한다.    // bool으로 잡았기 때문에 0 또는 1로 모델링이 가능하다.    for (int mode = 0; mode &lt;= 1; mode++) {        int localAns = 0;        for (int i = y; i &lt; y+8; i++) {            // 이 부분이 행이 끝났을 떄 표식을            // 다음행에 가져가도록 하는 코드이다.            mode = !mode;            for (int j = x; j &lt; x+8; j++) {                if (mode != map[i][j]) {                    localAns++;                }                mode = !mode;            }        }        // 각각에 대해 ans를 업데이트 해준다.        ans = min(ans, localAns);    }}int main(){    cin &gt;&gt; N &gt;&gt; M;    // 1, 0으로 바꿔서 넣어주었다. W = 1, B = 0    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt; M; j++) {            char temp;            cin &gt;&gt; temp;            if (temp == 'W') map[i][j] = 1;            else map[i][j] = 0;        }    }    // 체스판 모양에 따라 발생할 수 있는    // 작은 체스판의 시작 위치를 결정한다.    for (int i = 0; i &lt;= N-8; i++) {        for (int j = 0; j &lt;= M-8; j++) {            go(i, j);        }    }    cout &lt;&lt; ans &lt;&lt;'\\n';}",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%B2%B4%EC%8A%A4%ED%8C%90-%EB%8B%A4%EC%8B%9C-%EC%B9%A0%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-88-a8-eb-b0-94-ea-bc-ad-ec-a7-88-html": {
        "title": "백준(1697번): 숨바꼭질",
        "tags": "백준, 알고리즘, BFS, 그래프",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 그래프 문제이다.백준(1697번) - 숨바꼭질이 문제의 핵심은, 해당 위치에서 3가지의 선택을 할 수 있다는 점이다. 이 3가지의 선택 각각에 해당하는 위치에서 또 3가지의 선택을 할 수 있다. 그 선택을 연이어한 결과 문제의 답이 있다.하지만 이 문제는 DFS로 접근할 수 없는데, 그 이유는, 각각의 선택을 깊이 기준으로 탐색했을 때, 답에 다다르지 못하는 상황이 있을 수 있기 때문이다. 따라서 무한 루프에 빠지거나, 혹은 이 부분을 거르는 코드를 작성해야 하는데 상당히 번거롭다.이런 경우 오히려 BFS로 생각했을 때, 문제가 확 와닿는 경우가 많다. BFS로 탐색할 경우, 시간의 기준으로 완전 탐색하기 때문에 이 문제의 의도와 정확히 맞아 떨어진다. 최대한 짧은 시간에 답과 일치할 경우 반복문을 빠져나오면 되기 때문이다. 따라서 위치에 따른 시간을 저장할 필요가 있다.이 때, 선택지에 $+1, -1$이 있고 중간중간 $\\times2$ 도 있어 중복되는 위치에 방문할 가능성이 있다. 이 부분의 시간 복잡도를 줄이기 위해 메모리를 사용하여 코드를 짰다.Code// 실버1 : 백준 1697번 숨바꼭질#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int N = 0, K = 0;bool map[100001] = {0};int main(){    cin &gt;&gt; N &gt;&gt; K;    queue&lt;pair&lt;int, int&gt;&gt; q;    int ans = 0;    q.push(make_pair(N, 0));    while (!q.empty()) {        int now = q.front().first, time = q.front().second;        q.pop();        if (map[now] == true) continue;        map[now] = true;        if (now == K) {            ans = time; break;        }        if (now-1 &gt;= 0) q.push(make_pair(now-1, time+1));        if (now+1 &lt;= 100000) q.push(make_pair(now+1, time+1));        if (now*2 &lt;= 100000) q.push(make_pair(now*2, time+1));    }    cout &lt;&lt; ans &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-86-8c-ec-9a-a9-eb-8f-8c-ec-9d-b4-ec-98-88-ec-81-98-ea-b2-8c-ec-b6-9c-eb-a0-a5-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1022번): 소용돌이 예쁘게 출력하기",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현, 출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 구현 문제이다.백준(1022번) - 소용돌이 예쁘게 출력하기상당히 갑갑했다. 일단 무한개의 소용돌이가 생길 수 있다는 점에서 기존의 달팽이 문제처럼 생각하면 안된다라는 판단이 들었다. 발생하는 모든 숫자를 저장한다면 메모리 초과가 날 것이 분명했기 때문이다.그래서 이 부분을 꼭 저장해야 하나? 하는 생각이 들었고, 문제에서 제시하는 규칙에 따라 소용돌이 를 만들어가면서 제시하는 좌표 내에 위치했을 때, 이를 저장해주는 방식으로 문제를 해결하기로 했다.이 과정에서 생각해야 하는 중요 문제는 다음과 같았다.  소용돌이를 만드는 규칙  들어왔을 때, 저장하는 배열과의 관계  출력시 공백 처리소용돌이 규칙            num      direction      linecount                  1      ➡      1              2      ⬆      1              3      ⬅      2              4      ⬇      2              5      ➡      3              6      ⬆      3              7      ⬅      4              8      ⬇      4              9      ➡      5      출처 : https://jksk0115.tistory.com/총 4번의 방향전환 속에 고려해야 하는 점은 몇 칸 전진? 이다. 잘 보게 되면, 방향과 방향에 따른 count와 방향과의 관계가 나온다.배열과의 관계  map[y-r1][x-c1] = num;현재 좌표는 음수를 갖고 있는 상태이다. index는 음수일 수 없으므로 우리는 이것을 평행이동 하여 (0,0) 의 상태에 저장해야 한다. 이 때, r1, c1 만큼 평행이동 한다면 정확하게 원하는 위치에 저장할 수 있다.출력시 공백 처리내가 원하는 위치에 있는 것들을 배열에 넣을 때, 가장 긴 숫자가 무엇인지 알아야 한다. 이 때, C++에 integer의 길이는 알아내기 어려우므로 string으로 바꾸어 길이를 알아내는 방법을 사용하도록 하자.이 길이보다 작은 숫자에 대해서는 그 차만큼 공백을 출력하여 문제가 원하는 답을 도출하자.입출력이 많으므로 ios_base::sync_with_stdio(false); 를 사용하자.C++ - 입출력 빠르게 받는 방법Code// 골드4 : 백준 1022번 소용돌이 예쁘게 출력하기#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int r1, r2, c1, c2;int map[50][5] = {0};int y = 0, x = 0, dir_count = 0;int linecount = 1, step = 0, num = 1, dir = 0;int map_count = 0, max_num = -1, maxLength = -1;int dy[4] = {0, -1, 0, 1}, dx[4] = {1, 0, -1, 0};int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2;    while (true) {        // 현재 위치가 원하는 위치인지 확인        if (r1 &lt;= y &amp;&amp; y &lt;= r2 &amp;&amp; c1 &lt;= x &amp;&amp; x &lt;= c2) {            max_num = max(max_num, num);            map[y-r1][x-c1] = num;            map_count++;            if (map_count == (r2-r1+1)*(c2-c1+1)) {                break;            }        }        // 소용돌이 좌표 등 속성 갱신        y += dy[dir];        x += dx[dir];        step++;        num++;        // 방향 갱신        if (step == linecount) {            dir_count++;            step = 0;            dir = (dir+1)%4;            if (dir_count == 2) {                dir_count = 0;                linecount++;            }        }    }    // map 안에서 갖는 최고 길이    maxLength = int(to_string(max_num).size());    for (int i = 0; i &lt; r2-r1+1; i++) {        for (int j = 0; j &lt; c2-c1+1; j++) {            string stringOut = to_string(map[i][j]);            if (stringOut.size() &lt; maxLength) {                for (int i = 0; i &lt; maxLength-stringOut.size(); i++) {                    cout &lt;&lt; \" \";                }            }            cout &lt;&lt; stringOut &lt;&lt; \" \";        }cout &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%9A%A9%EB%8F%8C%EC%9D%B4-%EC%98%88%EC%81%98%EA%B2%8C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-eb-a1-9c-eb-98-90-html": {
        "title": "백준(6603번): 로또",
        "tags": "백준, 알고리즘, 완전탐색, 재귀, 출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 재귀를 통한 완전탐색 문제이다.백준(6603번) - 로또단순한 문제였다. 재귀를 통해 만들 수 있는 모든 경우를 출력하면 되는 문제였다. 나 같은 경우 재귀를 통해 들어갈 때, 탐색하지 않아도 되는 부분을 거르는 코드를 작성했다. 아마 다른 분들도 작성했을 것이다.이 문제에서 고려해야 되는 점은 다음과 같다.  어떻게 출력하게 만들 것인가?  어느 상황에서 탐색을 하지 않게 가지를 칠 것인가?출력 방법checkbox라는 배열을 만들어 깊이가 6이 되었을 때 모두 출력하였다.백트래킹이 문제는 간단한 백트레킹이지만, 써보면, 현재 위치에서 나머지 공을 선택할 수 있는 가지수와 지금 부터 선택해야 하는 가지수를 비교했다.  현재 위치로 부터 남은 공의 개수 &lt; 앞으로 선택해야 하는 공의 개수이와 같은 경우는 탐색이 불가능 하므로 함수를 콜하지 않았다.Code// 실버2 : 백준 6603번 로또#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int K = 6;int arr[14];bool checkbox[14] = {0};int N = -1;void go(int start, int count){    int restOfBallFromStart = N-(start+1);    if (count == 6) {        for (int i = 0; i &lt; N; i++)            if (checkbox[i]) cout &lt;&lt; arr[i] &lt;&lt; \" \";        cout &lt;&lt; '\\n';        return;    }    for (int i = start+1; i &lt; N; i++) {        if (restOfBallFromStart &lt; K-(count+1)) break;        else {            checkbox[i] = 1;            go(i, count+1);            checkbox[i] = 0;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    while (N != 0) {        fill(&amp;arr[0], &amp;arr[13], 0);        cin &gt;&gt; N;        for (int i = 0; i &lt; N; i++) {            cin &gt;&gt; arr[i];        }        go(-1, 0);        cout &lt;&lt; '\\n';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EB%A1%9C%EB%98%90.html"
      }
      ,
    
      "cs-structure-2020-03-23-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-cpu-html": {
        "title": "03: CPU 작동 원리",
        "tags": "컴퓨터 구조, CPU",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "CPU의 동작방법을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.디지털 회로기본적으로 연산을 수행하도록 가능하게 하는 것은 이 디지털 회로가 있기 때문이다. 이 디지털 회로는 반도체의 특징을 이용하면 가능하다. 반도체는 조건에 따라 도체가 될 수도, 부도체가 될 수도 있다. 이 성격을 이용하여 우리는 연산을 가능하게 만들 수 있다. 출처 : https://www.shutterstock.com연산 방법CPU의 핵심 기능인 연산은 어떻게 구현할까?가산기  2진수를 더하는 방법에 대한 방법이다.기본적으로 우리가 덧셈을 한다고 생각해보자. 그렇다면 우리가 덧셈을 하기 위해서 필요한 파라미터는 3개이다. 각 자리에 표현되는 a, b, 그리고 그 두 수를 더했을 때 자리올림이 발생하는지를 판단해줄 c이다.3개의 input의 결과로 자리올림을 나타내는 변수, 더한 뒤 값을 나타내는 변수 이렇게 두개의 값을 뽑아낸다. 위의 4자리 2진수의 덧셈을 수행하기 위해서는 전가산기 4개가 필요하며, 각 연산을 수행한 결과는 다음 자리수의 input으로 들어가게 된다. $C_0$는 0이다.뺄셈은..?  컴퓨터는 덧셈으로 끝난다.뺄셈은 보수의 덧셈 후 자리버림을 통해 구현이 가능하다.일반 뺄셈보수 덧셈 후 자리버림2진수에서 보수는 $0^c = 1$, $1^c=0$ 이다. 그런데 신기하게도 이 보수는 NOT연산으로 구현이 가능하다.보수란보수는 해당 숫자를 진법의 숫자에서 뺀 것을 말한다. 예를 들어 2의 보수는 $10-2=8$이다.곱셈은..?  곱셈은 더하기의 연속적인 과정이다.계속해서 더하면 곱셈구현이 가능하다. 혹은 비트 연산 중 왼쪽 shift를 사용하면 가능하다.나눗셈은?  나눗셈은 뺄셈의 연속적 과정에서 나오는 결과이다.세번 수행했고, 뺄셈이 불가능할 경우에 정지하면 몫과 나머지를 구할 수 있다.혹은 오른쪽 shifting을 하면 가능하다.0으로 나누기이런 방법이기 때문에 0으로 나누는 경우 무한루프에 진입할 수 밖에 없다. 따라서 CPU가 과열되서 터진다…. 펑!결론  CPU는 연산이 핵심이다. 그리고 그 연산은 더하기만으로 구현이 가능하다.",
        
        "url": "/cs/structure/2020/03/23/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-CPU.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ea-b0-80-ec-9e-a5-ed-81-b0-ec-a0-95-ec-82-ac-ea-b0-81-ed-98-95-ec-9d-98-eb-84-93-ec-9d-b4-html": {
        "title": "프로그래머스: 가장 큰 정사각형 찾기",
        "tags": "백준, 알고리즘, 동적계획법, 구현",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : 구현, 또는 동적 계획법을 사용하는 문제이다.프로그래머스 - 가장 큰 정사각형 찾기처음 풀이로는 빠르게 풀기 위해서 그냥 단순히 구현을 했다. 입력이 1000 x 1000 이라, 완전 탐색을 수행하더라도 로직을 최대한 덜 쓰도록 짜야된다는 생각을 하면서 짰다. 그 결과 나는 최대 넓이를 구하는 것이 목표이므로, board가 가질 수 있는 최대 변의 길이로 부터 하나씩 줄이며 가능한 정사각형을 구했을 때 return 했다.Code1#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool go(int y, int x, int len, vector&lt;vector&lt;int&gt;&gt; board){    for (int i = y; i &lt; len+y; i++){        for (int j = x; j &lt; len+x; j++){            if (board[i][j] == 0) return false;        }    }    return true;}int solution(vector&lt;vector&lt;int&gt;&gt; board){    int now = min(int(board.size()), int(board[0].size()));    int sizeY = int(board.size());    int sizeX = int(board[0].size());    while(now &gt; 0){        for (int i = 0; i &lt;= sizeY-now; i++){            for (int j = 0; j &lt;= sizeX-now; j++){                if (go(i, j, now, board)) return now*now;            }        }        now--;    }    return now;}하지만 근본적으로 최악의 경우 연산 횟수가, n^4 이다. (완전한 n^4는 아니다. 하지만 연산이 중복되는 것이 너무 많다.)  정사각형 판단 (n^2)  가능한 시작 점의 개수 (n^2)연산이 중복된다는 생각과, 또, 정사각형의 모양을 보니 작은 정사각형이 만들어져야 다음 정사각형이 만들어진다는 생각을 했다. 두 생각은 다이나믹 프로그래밍의 핵심적인 발상이기 때문에 해당 문제를 다이나믹으로 다시 구상해보기 시작했다.정의            dp적용전                           dp적용후                                       0      1      1      1      0      1      1      1              1      1      1      1      1      1      2      2              1      1      1      1      1      2      2      3              0      0      1      0      0      0      1      0        dp[y][x] = (y, x)의 위치를 포함하여 만들 수 있는 정사각형의 최대 변의 길이이렇게 정의를 하게 되면, 다음 정사각형의 변의 길이는, 상, 좌, 좌상향 대각 방향의 요소의 최소값+1에 해당하는 변의 길이로 밖에 만들 수 없다.  dp[y][x] = min(dp[y-1][x-1], dp[y][x-1], dp[y-1][x])dp는 항상 초기값을 세팅해주어야 하는데, 이 경우 y = 0일 때, x = 0 일 때 값을 고정한 상태로 점화식을 적용하면 된다. 이 때, 초기값으로 부터 answer가 도출될 수 있다는 점을 주의하자. 예외에 걸릴 수 있다. (내가)Code2#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;vector&lt;int&gt;&gt; board){    int ans = -1;    int sizeY = int(board.size());    int sizeX = int(board[0].size());    for (int i = 0; i &lt; sizeY; i++) ans = max(board[0][i], ans);    for (int i = 0; i &lt; sizeX; i++) ans = max(board[i][0], ans);    for (int i = 1; i &lt; sizeY; i++) {        for (int j = 1; j &lt; sizeX; j++) {            if (board[i][j] == 0) continue;            else {                int minNum = min(board[i-1][j], board[i-1][j-1]);                minNum = min(minNum, board[i][j-1]);                if (minNum != 0) {                    board[i][j] = minNum+1;                    ans = max(ans, board[i][j]);                }            }        }    }    return ans*ans;}",
        
        "url": "/cs/algorithm/2020/03/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%98-%EB%84%93%EC%9D%B4.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ed-94-bc-eb-b3-b4-eb-82-98-ec-b9-98-ed-95-a8-ec-88-98-html": {
        "title": "백준(1003번): 피보나치 함수",
        "tags": "백준, 알고리즘, 피보나치, 동적계획법",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 동적 계획 법을 사용하는 문제이다.백준(1003번) - 피보나치 함수Code// 백준 1003번 피보나치 함수#include &lt;iostream&gt;using namespace std;int N = 0, T = 0;int dp[50] = {0};// dp[n] = an 까지의 호출되는 1의 개수// dp[n] = dp[n-2] + dp[n-1];// 호출되는 0의 개수는, dp[n-1]과 동일하다.int main(){    dp[0] = 0;    dp[1] = 1;    for (int i = 2; i &lt; 41; i++) {        dp[i] = dp[i-1] + dp[i-2];    }    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; N;        if (N == 0) cout &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; dp[N] &lt;&lt; '\\n';        else        cout &lt;&lt; dp[N-1] &lt;&lt; \" \" &lt;&lt; dp[N] &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ec-9c-a0-ea-b8-b0-eb-86-8d-eb-b0-b0-ec-b6-94-html": {
        "title": "백준(1012번): 유기농 배추",
        "tags": "백준, 알고리즘, 유기농 배추, 그래프, DFS",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : dfs를 사용하는 기초적인 문제이다.백준(1012번) - 유기농 배추이런 문제를 풀 때, 생각보다 실수를 많이하는 부분은, testcase가 있을 때, 초기화를 하지 않는 것이다. 항상 testcase가 있는 문제는, 이 부분을 유념해야 한다. 또 초기화를 할 때, 연산이 수반되기 때문에, 어떠한 방식으로 초기화하는 것이 좋은지 생각하며 코드를 짜는 것이 바람직하다. 무조건적인 초기화는 안전성을 장담할 수 있지만 자칫하면 불필요한 연산을 수반할 수 있다.인접한 녀석들에 대해 1마리의 지렁이가 있으면 된다.1을 발견하면, dfs를 통해 인접한 것들의 값을 변경하고 globalAns의 값을 1증가시킨다.이 때, 정사각 지형을 다 탐색할 필요는 없다.나는 1이 있는 위치에서 시작해서 탐색만 하면 된다.따라서 입력 받을 때, 해당 위치만을 기억하는 배열을 하나 잡고, 이 것을 모두 확인하면 된다.Code// 백준 1012번 유기농 배추#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; baechuLoc;int T = 0;int N = 0, M = 0, baechuNum = 0, ans = 0;int map[51][51];int dy[4] = {0, 1, 0, -1}, dx[4] = {1, 0, -1, 0};void go(int now_y, int now_x){    map[now_y][now_x] = 2;    for (int i = 0; i &lt; 4; i++) {        int next_y = now_y + dy[i], next_x = now_x + dx[i];        if (map[next_y][next_x] == 1) {            go(next_y, next_x);        }    }}int main(){    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; N &gt;&gt; M &gt;&gt; baechuNum;        fill(&amp;map[0][0], &amp;map[N][M-1], 0);        baechuLoc.clear();        ans = 0;        for (int i = 0; i &lt; baechuNum; i++) {            int tempY, tempX;            cin &gt;&gt; tempY &gt;&gt; tempX;            map[tempY][tempX] = 1;            baechuLoc.push_back(make_pair(tempY, tempX));        }        for (int i = 0; i &lt; baechuNum; i++) {            if (map[baechuLoc[i].first][baechuLoc[i].second] == 1) {                go(baechuLoc[i].first, baechuLoc[i].second);                ans++;            }        }        cout &lt;&lt; ans &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%EC%9C%A0%EA%B8%B0%EB%86%8D%EB%B0%B0%EC%B6%94.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ec-98-a4-eb-a5-b4-eb-a7-89-ec-88-98-html": {
        "title": "백준(11057번): 오르막 수",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획 법을 사용하는 문제이다.백준(11057번) - 오르막 수대표적인 동적계획법 문제이다.기초적인 동적 계획법 문제를 풀 때에는 펜을 갖고 쓰는 것이 중요해보인다. 기본적으로 점화식을 갖고 해결하는 방식이기 때문에, 수열 문제를 푸는 것도 같은 사고로 접근해야 한다. 수열 문제가 눈에 들어오지 않으면 쓰면서 규칙을 찾아내듯, 이것도 손아프다고 징징대지말고 쓰면서 찬찬히 푸는 것이 문제를 가장 효과적이고 간결하게 풀 수 있는 방법이다.N : 1, N : 2            숫자      오르막 수 개수      숫자      오르막 수 개수                  0      1      공란      공란              1      1      10~19      1~9 : 9              2      1      20~29      2~9 : 8              3      1      30~39      3~9 : 7              4      1      40~49      4~9 : 6              5      1      50~59      5~9 : 5              6      1      60~69      6~9 : 4              7      1      70~79      7~9 : 3              8      1      80~89      8~9 : 2              9      1      90~99      9~9 : 1      규칙을 보게 되면, 최고 자리 수가 어떤 수이냐에 따라 그 다음 자리수는 결정이 되게 된다. 그런데 여기서 잘 보면, N : 2일 때, 최고자리수가 1인 경우, 오르막 수의 개수는 1의 자리 숫자가 1~9까지 오는 경우가 모두 오르막 수가 될 수 있다.추가적으로 최고자리수가 2인 경우는, 일의 자리 숫자가 2인 경우부터 발생하는 모든 오르막 수를 더함으로서 만들어진다.이 규칙을 자세히 보면, 변화하는 파라미터는 총 두개이다.  최고자리의 수  최고자리에 위치하는 숫자이 두가지 특징을 가지고 dp를 정의하고, 점화식을 세워보자.  dp[N][m] = N 자리수를 가지는 수가 M의 숫자를 가질 때 가질 수 있는 오르막 수의 개수  dpdp[N] = N 자리수를 가지는 수가 가질 수 있는 오르막 수의 개수이렇게 정의했을 때, dp 점화식의 정의는 다음과 같다.이걸 가지고 dpdp 점화식을 세우면 다음과 같다.수식도 세웠으니 이제 구현만 하면 된다. 이때, dp를 수행하기 위해서는 초기값을 설정해 줘야 하는데, 이 경우에는 N : 1 인 경우에 해당하는 모든 숫자에 1의 값을 준 뒤에 시작해야 한다.Code// 백준 11057번 오르막 수#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;int dp[1001][10] = {0};int dpdp[1001] = {0};int mod = 10007;int main(){    cin &gt;&gt; N;    // 초기값 세팅    for (int i = 0; i &lt; 10; i++) {        dp[1][i] = 1;    }    dpdp[1] = 10;    for (int i = 2; i &lt;= N ; i++) {        // dp[N][M]을 구하는 코드        for (int j = 1; j &lt; 10; j++) {            for (int k = j; k &lt; 10; k++) {                dp[i][j] += dp[i-1][k];                dp[i][j] %= mod;            }        }        // dpdp[N]을 구하는 코드        for (int j = 0; j &lt; 10; j++) {            dpdp[i] += dp[i][j];        }        dpdp[i] += dpdp[i-1];        dpdp[i] %= mod;    }    // 정답    cout &lt;&lt; dpdp[N] &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%EC%98%A4%EB%A5%B4%EB%A7%89%EC%88%98.html"
      }
      ,
    
      "dv-sp-2020-03-22-react-movie-app-clone-html": {
        "title": "Movie App Clone",
        "tags": "side-project, clone-coding, movie-app",
        "date": "March 22, 2020",
        "author": "",
        "category": "DV/SP",
        "content": "React를 사용하여 동적인 느낌이 나는 movie app을 만들어보았다.React-Movie-App",
        
        "url": "/dv/sp/2020/03/22/react-movie-app-clone.html"
      }
      ,
    
      "dv-sp-2020-03-22-html-css-kakaotalkclone-html": {
        "title": "KaKaoTalkClone",
        "tags": "side-project, clone-coding, kakaotalk",
        "date": "March 22, 2020",
        "author": "",
        "category": "DV/SP",
        "content": "카카오톡 디자인을 클론 코딩해보았다.카카오톡 클론 코딩",
        
        "url": "/dv/sp/2020/03/22/html-css-kakaotalkClone.html"
      }
      ,
    
      "cs-structure-2020-03-22-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-bit-ec-a7-84-eb-b2-95-eb-b3-80-ed-99-98-html": {
        "title": "02: bit, 진법 변환",
        "tags": "컴퓨터 구조, bit, 진법",
        "date": "March 22, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "bit와 진법 변환에 대해 알아본다.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.bit  1bit는 전기 스위치 1개이고, ON/OFF 두가지 상태를 표시할 수 있다.1bit는 2진수 한자리 숫자를 표현할 수 있다.결국 두가지 상태의 조합으로 우리는 숫자를 표시할 수 있다. 이 조합을 표현하는데 있어 가장 작은 단위를 bit라 한다.4bit  4bit로는 16진수 한자리를 표현할 수 있다.16진수는 0~F(0~15) 까지 한 자리에 쓴다.            2진수(4bit)      16진수                  1010      A(10)              1011      B(11)              1100      C(12)              1101      D(13)              1110      E(14)              1111      F(15)      byte  8bit : 영문자 한 글자를 저장할 수 있는 기억 공간의 최소단위가장 작은 단위가 bit라면, 기억공간을 관리하는데 가장 작은 단위는 1byte이다.연습            16진수      2진수      10진수      용량                  0x73      0111 0011      $16^1\\times7+16^0\\times3=115$      1byte      ",
        
        "url": "/cs/structure/2020/03/22/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-bit-%EC%A7%84%EB%B2%95%EB%B3%80%ED%99%98.html"
      }
      ,
    
      "cs-structure-2020-03-21-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-9a-a9-ec-96-b4-ec-a0-95-eb-a6-ac-html": {
        "title": "01: 용어 정리",
        "tags": "컴퓨터 구조, 용어",
        "date": "March 21, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.PC 조립 과정 보며 구조 이해하기컴퓨터 하드웨어 구성 요약다나와다나와이곳에 가면 컴퓨터 용어에 대한 간단한 설명들을 쉽게 알 수 있다.컴퓨터란?CPU가 가장 중요하다. 컴퓨터의 기본 정체성은 연산을 하는 기계이기 때문에, 이 연산을 담당하는 CPU가 컴퓨터를 거의 대표한다고 볼 수 있다. 요리에 비유한다면 좋은 칼, 좋은 도구 등이 될 수 있겠다.하지만 재료가 없으면 요리를 할 수 없다. 따라서 우리는 CPU가 연산을 수행할 수 있도록 재료에 해당하는 메모리를 주어야 한다. 그 과정에서 보조 기억 장치인 RAM, HDD, SDD 등이 필요하다.Interface  주변기기와 연결되는 지점기본적으로 컴퓨터는 CPU, RAM으로 동작한다. 이 때 추가적인 기억 장치인 HDD, SDD들이 이 컴퓨터에 연결할 때 사용하는 것이 interface이다. 현재는 SATA라는 interface를 사용한다. SATA는 interface 중 하나이며, 어떤 장치를 연결하느냐에 따라 필요한 interface는 달라질 수 있다.운영체제에서 사용하는 용어기본적인 용어에 대해 이해하고 넘어가자.동시성  여러 일을 여러 사람이 각자 동시에 하는 것행위도 여러개, 주체도 여러개병렬성  같은 일을 여러 사람이 동시에 하는 것군대 삽질 분대가 다같이행위는 하나, 주체는 여러개병렬성은 동시성에 포함된다.원자성  쪼개어 나눌 수 없는 연속된 일어떤 일을 최대한 쪼갰을 때의 가장 작은 단위의 행위원자성은 병렬성을 가지는 상태에서 동기화 라는 작업이 중요하다.의존성  전제조건행위에 대한 의존, 존립에 대한 의존출근(행위)출근 하기 위한 방법이 버스를 타야 가능하다고 생각해보자. 그렇다면 출근이라는 행위는 버스에 의존적이다.자동차 부품(존립)자동차를 구성하는 다양한 부품은 자동차라는 객체가 사라지면 그 부품들의 존재도 사라진다. 그렇다면 부품이라는 존립은 자동차에대해 의존성을 가진다.동기화  원자성을 가지는 행위에 대해 시작과 끝을 알리는 행위화장실 들어갈 때 문잠구는 거규칙 준수의 개념과도 비슷하다.예를 들어, 100개의 인형에 눈을 다는 작업이 있다고 하자. 그렇다면 이 작업은 동시성을 가진다. 그리고 같은 작업을 여럿이 달려들어 수행할 수 있기 때문에 병렬성도 가진다. 이 때, 하나의 인형에 눈을 다는 작업은 원자성을 가진다고 가정하자. 즉, 눈을 다는 작업은 한 사람만이 수행할 수 있고 눈을 다는 작업은 연속적이기 때문에 방해받을 수 없다. 이런 경우에 사람이 1000명이 있더라도 작업에 투입될 수 있는 최대 인원은 100명이다. 그런데 만약 하나의 작업을 수행하고 있는 인원에게 일이 없는 다른 사람이 방해한다면, 해당 작업은 충돌이 발생한다. 이런 과정을 막기 위해서 작업을 수행하는 인원은, 작업을 수행하기 전에 나 작업시작한다! 처럼 알려주는 행위가 필수적으로 요구된다. 이러한 알림을 동기화 라고 한다.교착상태(Deadlock)  이러지도 저러지도 못하는 상태화장실에 휴지 없어서 못나오는 상태원자성을 보장 받는 행위에 대해서 행위가 끝나야 다음 처리가 이루어지는 상황에서 특정 조건 때문에 행위가 끝나지 않아 멈춰버리는 상태를 말한다. 심각한 논리적 오류 때문에 발생한다.예외처리 잘해라하드웨어, 운영체제, 프로세스, 스레드  컴퓨터가 ‘영토’라면 운영체제는 ‘정부조직’스레드는 ‘개인’이고 프로세스는 ‘가족’컴퓨터라는 하드웨어를 가지고 System software인 운영체제와, User software인 프로세스가 돌아가게 된다.Kernel  운영체제의 근간을 이루는 핵심 코드어떠한 방식으로 자원을 나눠주고, 프로세스를 관리하는지, 프로그램이 요구하는 시스템 콜 같은 중요한 작업을 수행하는 코드를 말한다. 그렇기에 어떤 커널을 사용하느냐에 따라 OS의 정체성이 규정된다. 이 부분이 손상될 경우 OS가 사용 불가능해 진다.Virtual Memory가족들은 보통 집에서 생활한다. 이 집은 컴퓨터에 대응해서 생각하면, 메모리 공간이다. 각각의 프로세스는 이러한 전용 공간, 즉 가상 메모리를 갖는다.Thread가족 안에 구성원들이 있고, 이 구성원들은 각자 자유로이 활동하듯이 프로세스 내에서 작동하는 개별 흐름(thread)이다. 해당 스레드는 속한 프로세스에 할당된 자원을 공유한다.스레드는 프로그램의 흐름(연산의 흐름)에 있어서 가장 작은 단위를 뜻한다.",
        
        "url": "/cs/structure/2020/03/21/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC.html"
      }
      ,
    
      "dv-html-css-2020-03-20-transition-display-none-html": {
        "title": "opacity를 사용하여 display none animation 만들기",
        "tags": "css, transition, opacity",
        "date": "March 20, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "Html&lt;div class=\"chat__write--container\"&gt;  &lt;input    type=\"text\"    class=\"chat__write\"    placeholder=\"Send message\"    class=\"chat__write-input\"  /&gt;  &lt;div class=\"chat__icon-left chat__icon\"&gt;    &lt;i class=\"far fa-plus-square\"&gt;&lt;/i&gt;  &lt;/div&gt;  &lt;div class=\"chat__icon-right chat__icon\"&gt;    &lt;span class=\"chat__write-icon\"&gt;      &lt;i class=\"far fa-smile-wink\"&gt;&lt;/i&gt;    &lt;/span&gt;    &lt;span class=\"chat__write-icon\"&gt;      &lt;i class=\"fas fa-microphone\"&gt;&lt;/i&gt;    &lt;/span&gt;  &lt;/div&gt;&lt;/div&gt;  위의 상황에서 문자를 보내는 것을 클릭했다고 생각해보자. 그 경우, 주변에 있는 아이콘이 사라졌으면 좋겠다. 그런데, 그 아이콘의 속성을 display: none;으로 할 경우, 애니메이션 효과를 넣을 수 없게 된다.그래서 속성의 값중 실수 값을 가질 수 있으면서 같은 효과를 내는 opacity 속성을 사용한다.CSS.chat__write:focus ~ .chat__icon {  opacity: 0;}.chat__icon {  font-size: 23px;  transition: opacity 0.5s ease-in-out;}여기서 ~ 선택자는, 형제 선택자이다.중요여기서, 중요한 것은, 내가 없애고 싶은 아이콘은, input 태그 뒤에 있어야 한다는 점이다. 만약 그렇지 않다면 애니메이션이 적용되지 않는다. 결과적으로 CSS로 어떤 효과를 주고 싶을 때는, 내가 액션을 취할 태그를 html 문서의 앞에 적어주어야 동작한다.",
        
        "url": "/dv/html-css/2020/03/20/transition-display-none.html"
      }
      ,
    
      "dv-html-css-2020-03-20-navbar-fixed-html": {
        "title": "navbar, footer 고정하기",
        "tags": "css, position, fixed",
        "date": "March 20, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "상단 navbar나 footer 같이 고정할 필요성이 있는 html 요소를 어떻게 빠르게 만들지 정리했다.이 부분을 생각할 때 조금 어려웠던 것은, navbar 같은 경우, 어떻게 html 구조를 짜야되는 지 였다. 하지만 조금만 생각해보니, 굳이 떼어내서 구조화할 필요 없이 그냥 필요한 요소들을 만들고, 이를 보여주는 방식, css에서 display만 변화시키면 되는 문제였다.물론, 이 과정에서 class 이름을 바꾸고 body를 해당 nav의 높이 만큼 padding 혹은 margin을 주어야 하지만, html 구조에 있어 navbar는 그대로 두어도 상관없다.",
        
        "url": "/dv/html-css/2020/03/20/navbar-fixed.html"
      }
      ,
    
      "dv-html-css-2020-03-19-span-height-is-not-block-html": {
        "title": "span의 height는 block 속성이 아니다.",
        "tags": "css, span, height, block",
        "date": "March 19, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "text는 span 태그에 넣어서 관리한다.div안에 text를 넣으면 좋지 않다.이번에 겪은 문제로는 box-shadow가 먹지 않았다.그렇다고 div에 있던 텍스트를 span으로 교체하면 문제가 생긴다.span 태그는 기본적으로 inline 속성을 강하게 띈다.그렇기 때문에 다음 그림과 같이 margin을 먹였음에도 불구하고 내가 원하는 모양대로 속성이 먹히지 않는다.div와 span의 가장 큰 차이는 display: block, inline따라서 만약에 다 뒤집어 엎고 교체하기 싫다면, display: block 속성을 추가해주면 된다.결론가장 좋은 방법은, text를 쓰는 공간에는 span을 써주고, 이 공간 자체를 box처럼 쓰고 싶다면 display block을 써주자.또는 아예 box와 textbox를 구분해서 만들어주는 것도 좋은 방법이다.",
        
        "url": "/dv/html-css/2020/03/19/span-height-is-not-block.html"
      }
      ,
    
      "dv-html-css-2020-03-19-position-fixed-center-ec-a0-95-eb-a0-ac-html": {
        "title": "position fixed에서 중앙 정렬하기",
        "tags": "css, center-arrangement, position, fixed",
        "date": "March 19, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "position : fixed에서 중앙 정렬하는 방법.class {  position: fixed;  /* fixed를 쓸 때에는 width, height를 명시해줘야 한다. */  width: 80%;  /* left, right는 해당 요소의 위치 시작점을 결정한다. 그런데, 이때, margin의 양 값을 auto로 줌으로써 마진을 주어 해당 요소의 양 끝 위치를 각각 0으로 만들어준다. */  margin: 0 auto;  left: 0;  right: 0;  /* 다른 것들 */  display: flex;  background-color: red;  padding: 20px 50px;  border-radius: 40px;}",
        
        "url": "/dv/html-css/2020/03/19/position-fixed-center-%EC%A0%95%EB%A0%AC.html"
      }
      ,
    
      "dv-javascripts-2020-03-18-ea-b0-9c-eb-b0-9c-ed-99-98-ea-b2-bd-ec-84-b8-ed-8c-85-html": {
        "title": "개발 환경 초기 세팅",
        "tags": "development, setting",
        "date": "March 18, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "개발을 시작하기 전에 환경 설정해야 하는 것들을 적어둔다.      gitignore        git setting : 이 부분은, terminal에서 clone 후, vscode로 여는 것이 가장 깔끔했다. 그 경우 remote 설정도 안해줘도 순탄하다.  왜 잘 작동을 안하는가ㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹ ㅇㄹ. ㄴㅇㄹㄴㅇㄹ.ㄴㅇㄹㄴㅇㄹ안녕하세요.ㄴㅇㄹㄴㅇ.ㄴㅇ란우라ㅣㄴㅇㄹㄴ앙ㄴㄹㄴㅇㄹ.ㄴ일ㄴㅇㄹㄴㅇ룬ㅇ린ㅇㄴㅇㄹ ㄴㅇ룬ㅇㄴㅇ라ㅣㄴ울ㄴㅇ룬ㅇㄹsdfsdf;sdfsdf",
        
        "url": "/dv/javascripts/2020/03/18/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%B8%ED%8C%85.html"
      }
      ,
    
      "dv-javascripts-2020-02-28-js-html": {
        "title": "개발 시 고려해야 하는 점",
        "tags": "JS, develop",
        "date": "February 28, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "개발 시작하기 전에 플로우를 기록해 둔다.html  그룹을 잘 묶어서 짠다.  하나의 기능이 들어간다고 하더라도 2중으로 그룹화 하는 것이 좋다.  입력 단위는 업데이트 되는 단위로 묶어준다.CSS  reset.css 파일 만들고 복사  내가 사용한 css 파일에 import  기본적으로 항상 css는 body 태그에 대해 설정을 하고 시작하는 것이 좋다. body 태그 안에서 설정해줘야 하는 것은 기본적으로 배경색과 폰트정도가 있다.  집합구조를 잘 생각해서 짠다.  css에서 먹일 때도 명확하게 이 객체의 위치를 명시적으로 적은 후에 걸어준다.JS      여거개의 객체 tag에 대해 같은 이벤트를 얻고 싶을 떄는 id로 js#@%@%이렇게 저장하는 것이아니고 class로 저장한다. 그 이후에 ‘getElementByClassName’으로 불러오면, 자동으로 배열로 모든 class에 해당하는 녀석을 가져온다.        이 때 불러와진 녀석은 배열이 아니다. 유사배열이다. JSON 파일과 같다고 보면 된다. 즉, a[0] 처럼 접근은 가능하나, Array의 메서드를 사용할 수 없다.    for (let i = 0; i &lt; colors.length; i++) {  const element = colors[i];  element.addEventListener(\"click\", handleColorChanging);}        Array.from(colors).forEach(item =&gt; {  console.log(item);  item.addEventListener(\"click\", handleColorChanging);});        따라서 이 두 코드는 같은 작동을 한다.        querySelector 사용처는 다음과 같다. 일반적으로 하나밖에 없는 이름을 갖고 있는 태그라면 querySelector를 쓰는게 좋아보인다.이 경우, 해당 객체에서 다시 querySelector를 사용할 수 있기 때문에, 사용하기 편리하다. 다만 가장 위에 있는 객체하나만을 들고 오기 때문에 여러개가 있을 경우 좋지 않다. 여러개를 들고 올 경우에는 getElementClassName을 사용하는 것이 좋아보인다. 이경우 HTMLCollenction이라는 객체로 들고오며, 이를 Array로 바꿔 사용하면 편리하다. getElementId 는 하나만 빠르게 들고올 떄 사용하면 편리하다.  ",
        
        "url": "/dv/javascripts/2020/02/28/JS.html"
      }
      
    
  };
</script>

<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" charset="utf-8"></script>-->
<script src="./js/lunr.min.js" charset="utf-8"></script>
<script src="/assets/js/search.js" charset="utf-8"></script></section>
</article></div>

    


<footer class="site-footer">
	<p class="text">이전 블로그 <a href="https://egg-money.tistory.com">완숙의 에그머니</a>
</p>
</footer>


  </body>
</html>
