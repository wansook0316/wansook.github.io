<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | 완숙의 에그머니🍳</title>
	<meta name="description"
		content="개발, 데이터, 통계, 수학를 좋아하는 반항아의 블로그">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="완숙의 에그머니🍳"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Nanum+Gothic|Jua|Nanum+Gothic+Coding|Source+Code+Pro|Nanum+Myeongjo:400|Noto+Sans+KR:100,300" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
    <!--
	

    -->
	<!-- Google Analytics -->
	
	<script>
		(function (i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date(); a = s.createElement(o),
			m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'UA-156961472-1', 'auto');
		ga('send', 'pageview');
	</script>
	
  
  <!-- Latex -->
<!--
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
-->
  
    
	<script>
console.log(window)

window.addEventListener("resize", changeContent);
window.addEventListener("load", changeContent);

function changeContent(event){
  const width = window.innerWidth;
  console.log(event);
  const cat = document.getElementById("js-cat");
  const cv = document.getElementById("category-cv");
  const math = document.getElementById("category-math");
  const ds = document.getElementById("category-ds");
  const cs = document.getElementById("category-cs");
  const dv = document.getElementById("category-dv");
  const about = document.getElementById("category-about");
  if (width < 710) {
    cv.innerText = "📜"
    math.innerText = "✖"
    ds.innerText = "📈"
    cs.innerText = "💾"
    dv.innerText = "📱"
    about.innerText = "😎"
    cat.style.justifyContent = "space-around"
  } else {
    cv.innerText = "CV"
    math.innerText = "Math"
    ds.innerText = "Data Science"
    cs.innerText = "Computer Science"
    dv.innerText = "Development"
    about.innerText = "About"
    cat.style.justifyContent = "center"
  }
  
}

</script>

	 
</head>
  <body>
    <header class="site-header">
    <div class="site-title-nav">
        <div class="branding">
            
            <a href="/">
                <img class="avatar" src="/assets/img/avatar.png" alt=""/>
            </a>
            
            <h1 class="site-title">
                <a href="/">완숙의 에그머니🍳</a>
            </h1>
        </div>
    </div>
    <nav class="site-nav">
            <ul>
<!--
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                <li>
                    <a class="page-link" href="/about/">
                        About Me
                    </a>
                </li>
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
-->
                <!-- Social icons from Font Awesome, if enabled  -->
<!--                














<li>
	<a href="https://github.com/wansook0316" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>





























-->

                <!-- Search bar -->
                <li>
                














<li>
	<a href="https://github.com/wansook0316" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>






























                </li>
                
                <li>
                <form action="/search.html" method="get">
                    <input type="text" id="search-box" name="query" placeholder="Search" class="">
                    <button type="submit" class="">
                        <i class="fa fa-fw fa-search"></i>
                    </button>
                </form>
                </li>
                
                
            </ul>
        </nav>
  
  
  
  
  

</header>

<div class="site-category">
    <ul class='cat1' id="js-cat">

      
      <li><a id="category-cv"href="/"> </a>
        <ul>
            <li><a href="/CV/Projects">Projects</a></li>
            <li><a href="/CV/Awards">Awards</a></li>
            <li><a href="/CV/Papers">Papers</a></li>
            <li><a href="/CV/ExtraCurricular Act">ExtraCurricular Act</a></li>
            <li><a href="/CV/InternShip">InternShip</a></li>
            <li><a href="/CV/Language">Language</a></li>
            <li><a href="/CV/Education">Education</a></li>
            <li><a href="/CV/Cources">Cources</a></li>
        </ul>
      </li>
      
      <li><a id="category-math"href="/"> </a>
        <ul>
            <li><a href="/Math/Mathematical Statistics">Statistics</a></li>
            <li><a href="/Math/Linear Algebra">Linear Algebra</a></li>
            <li><a href="/Math/Calculus">Calculus</a></li>
        </ul>
      </li>

      <li><a id="category-ds" href="/"> </a>
        <ul>
          <li><a href="/DS/R">R</a></li>
          <li><a href="/DS/ESL">ESL</a></li>
          <li><a href="/DS/ML">Machine Learning</a></li>
        </ul>
      </li>
      
      <li><a id = "category-cs" href="/"> </a>
        <ul>
          <li><a href="/CS/Database">Database</a></li>
          <li><a href="/CS/Algorithm">Algorithm</a></li>
          <li><a href="/CS/Structure">Structure</a></li>
          <li><a href="/CS/OS">OS</a></li>
        </ul>
      </li>


      <li><a id="category-dv" href="/"> </a>
        <ul>
          <li><a href="/DV/Ubuntu">Ubuntu</a></li>
          <li><a href="/DV/Python">Python</a></li>
          <li><a href="/DV/C++">C++</a></li>
          <li><a href="/DV/HTML">HTML</a></li>
          <li><a href="/DV/CSS">CSS</a></li>
          <li><a href="/DV/JavaScript">JavaScript</a></li>
          <li><a href="/DV/React">React</a></li>
          <li><a href="/DV/Django">Django</a></li>
          <li><a href="/DV/Git">Git</a></li>
          <li><a href="/DV/Tips">Tips</a></li>
          <li><a href="/DV/SP">Side Project</a></li>
        </ul>
      </li>

      
      <li><a id="category-about" href="/about/"> </a></li>
      
    
  
<!--    <ul class="cat2">-->
      
<!--  </ul>-->
    </ul>
  
  </div>

    <div class="content">
      <article class="feature-image">
  <header style="background-image: url('/assets/img/30.jpg')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "dv-c-2020-04-05-ec-a0-95-ec-a0-81-eb-b3-80-ec-88-98-html": {
        "title": "정적 변수 (static)",
        "tags": "c++, static",
        "date": "April 5, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "c++에서 static 키워드를 갖는 정적 변수에 대해서 알아본다.필요성  지역이 사라져도 변수는 유지되어야 해!지역 변수, 전역 변수 말고 c++에는 이상한 녀석이 하나 더 있다. 정적 변수라는 것이 그것인데, 아니 이게 왜 필요하지..?함수를 호출했는데, 이 함수를 몇 번 호출했는지 알고 싶다. 그러면, 사실 가능한 방법은 전역변수로 이 함수가 호출되었을 때 값을 증가시키면 된다.int count = 0;void call(){    count++;    cout &lt;&lt; conut &lt;&lt; '\\n';}int main(){    call();    call();    call();    call();    call();    return 0;}하지만, 이렇게 되면 프로그램의 안정성이 너무 떨어진다. 이름이 겹치는 문제도 생기고, 해당 변수의 역할은 함수의 호출 횟수만을 체크하는 것인데, 너무 범위가 크게 잡혀있기 때문이다. 결국 Scope를 줄이고 싶은 것이다.이런 경우 static을 적어주면, 전역변수처럼 행동하되, 이 녀석의 Scope는 해당 함수를 호출했을 때로 줄어들게 된다.void call(){    static int count = 0;    count++;    cout &lt;&lt; conut &lt;&lt; '\\n';}int main(){    call();    call();    call();    call();    call();    return 0;}특징 정리  메모리 공간에서 정적 변수는 전역 변수가 저장되는 Data 영역에 저장된다.          프로세스 구조        초기값을 주지 않을 경우 항상 0으로 초기화 되며 프로그램을 실행시킬 때 한번만 초기화 된다.          이 부분은 매우 중요한데, 실제로 함수가 실행될 때, 값이 변하는 것 같지만, 영향을 주지 않는다. 그렇기 때문에 원하는 결과인 1, 2, 3, 4 ,5가 출력된다.      ",
        
        "url": "/dv/c++/2020/04/05/%EC%A0%95%EC%A0%81%EB%B3%80%EC%88%98.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-12-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-5-html": {
        "title": "12: 프로세스 동기화 Part 5",
        "tags": "OS, Synchronization, monitor",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "현재 사용하는 동기화 도구인 모니터(Monitor)에 대해서 알아본다.세마포는 실제로 매우 오래된 동기화 도구이다. 현재에는 모니터(monitor)라는 동기화 도구를 주로 사용하며, 이는 좀 더 고수준의 동기화 기능을 제공한다.1. 모니터 구조Semaphore의 구조는 위와 같았다. 그렇다면 monitor는 무엇이 다를까?위는 모니터의 구조를 간단히 나타낸 그림이다. 모니터는 공유 자원 + 공유 자원 접근함수로 이루어져 있고, 2개의 큐를 가지고 있다. 각각 mutual exclusion(상호배타) queue, conditional synchronization(조건동기) queue이다.  상호배타 큐는 말그대로 공유 자원에 하나의 프로세스만 진입하도록 하기 위한 큐이다.  조건동기 큐는 이미 공유자원을 사용하고 있는 프로세스가 특정한 호출 wait()을 통해 조건동기 큐로 들어갈 수 있다.조건동기 큐에 들어가 있는 프로세스는 공유자원을 사용하고 있는 다른 프로세스에 의해 깨워줄 수 있다. 이 역시 깨워주는 프로세스에서 특정한 호출 notify()을 해주며, 깨워주더라도 이미 공유자원을 사용하고 있는 프로세스가 해당 구역을 나가야 비로소 큐에 있던 프로세스가 실행된다.2. monitor in java자바는 모니터를 제공하는 대표적인 언어이며, 자바의 모든 개체는 모니터가 될 수 있다. 그렇다면 자바를 통해 모니터에 대한 예제를 살펴보자.class C {  private int value, ...;     // 공유 변수  synchronized void Foo() {   // 배타동기    // ...  }  synchronized void Goo() {    // ...  }  void H() {    // ...  }}위 코드는 모니터를 사용하고 있는 클래스이다. value와 같은 변수들은 여러 쓰레드가 공유하고 있는 변수로 볼 수 있고, synchronized 키워드는 배타동기를 수행하는 함수를 말한다. 즉, 해당 함수에는 단 하나의 쓰레드만 접근할 수 있다.Foo() 함수와 Goo() 함수는 synchronized 키워드를 통해 상호배타 함수로 선언하였는데, 이는 “둘 다 같은 임계구역을 갖는다”는 의미이다. 다시 말해서, Foo() 함수에 한 쓰레드가 수행 중이라면, Foo() 함수뿐 아니라 Goo() 함수에도 다른 쓰레드는 접근할 수 없다. 반면에 H() 함수는 일반 함수인데, 이 함수에서는 공통 변수에 대한 업데이트를 하지 않는다는 것을 예상할 수 있다. (여러 쓰레드가 동시에 접근가능하다.)조건동기는 특정한 메서드 호출로 사용할 수 있다.wait(): 호출한 쓰레드를 조건동기 큐에 삽입한다.notify(): 조건동기 큐에 있는 하나의 쓰레드를 깨워준다.notifyAll(): 조건동기 큐에 있는 모든 쓰레드를 깨워준다.모니터 역시, 세마포에서 할 수 있는 기능인 Mutual exclusion, Ordering을 모두 할 수 있다. 예제를 통해 이를 살펴보자.3. Problem Solving by Monitormonitor를 사용하여 지금까지 배운 문제들을 해결하는 방법에 대해 알아보자.3.1 BankAccount Problem이전에 세마포에서 살펴본 은행계좌 문제를 통해 세마포 대신 모니터를 사용해서 Mutual exclusion, Ordering을 구현해보자.3.1.1 Mutual Exclusionclass Test {\tpublic static void main(String[] args)\tthrows InterruptedException {\t\tBankAccount b = new\t\tBankAccount();\t\tParent p = new Parent(b);\t\tChild c = new Child(b);\t\tp.start();\t\tc.start();\t\tp.join();\t\tc.join();\t\tSystem.out.println( \"\\nbalance = \" + b.getBalance());\t}}class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tsynchronized void withdraw(int amt) {\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}class Parent extends Thread {\tBankAccount b;\tParent(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;100; i++)\t\t\tb.deposit(1000);\t}}class Child extends Thread {\tBankAccount b;\tChild(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;100; i++)\t\t\tb.withdraw(1000);\t}}코드가 매우 간단해졌다..!{:.center-text}위 코드에서 볼 수 있듯이, 세마포를 사용할 때보다 모니터를 사용하면 매우 간결하게 코드를 구현할 수 있다. 세마포를 선언하고 number of permit 값을 설정하는 대신, synchronized 키워드 하나로 이를 대체한 것을 볼 수 있다.+++++++++++++++++++++++------------------------------------------+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------balance = 0실행 결과는 위와 같고, balance값이 정상적으로 0을 출력한다.3.1.2 Mutual Ordeing은행계좌 문제를 살펴보기전에, ordering을 하기 위해 모니터를 어떻게 사용하는지 보자.            P1      P2                         wait()              section 1      section 2              notify()             위 구조는 프로세스 순서를 P1, P2 순서로 실행하기 원하는 경우이며, 이는 세마포와 매우 유사한 것을 알 수 있다. 그러면 은행계좌 문제를 모니터로 구현하는데, 입금 먼저 수행, 출금 먼저 수행, 입금 출금 반복 수행 3가지를 각각 구현해보자. 그리고 위 코드에서 수정하는 부분은 순서를 정하는 입금, 출금함수이므로 이 부분을 대변하는 BankAccount만 수정하자.입금 먼저 수행하기먼저 입금시작하면 기다리라고 하면된다.class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tnotify();\t}\tsynchronized void withdraw(int amt) {\t\twhile (balance &lt;= 0)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------------------------------------------------balance = 0출금 먼저 수행하기먼저 출금시작하면 기다리라고 하면된다.class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\twhile (balance == 0)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tsynchronized void withdraw(int amt) {\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tnotify();\t}\tint getBalance() {\t\treturn balance;\t}}----------------------------------------------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++balance = 0입금 출금 반복 수행하기입금 넣고 기다리고 출금 넣고 기다리고를 반복하면 된다!class BankAccount {\tint balance;\tboolean p_turn = true;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tnotify();\t\tp_turn = false;\t\ttry {\t\t\twait();\t\t} catch (InterruptedException e) {}\t}\tsynchronized void withdraw(int amt) {\t\twhile (p_turn)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tnotify();\t\tp_turn = true;\t}\tint getBalance() {\t\treturn balance;\t}}+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-balance = 03.2 전통적 동기화 문제10: 전통적인 동기화 문제들을 수정해본다!2.1 Producer-Consumer ProblemSemaphore를 사용하면 상호 배제 sem, 가득 차있을 때 block하는 sem, 비어있을 때 block하는 sem 총 3개를 사용했어야 했다. 하지만 이번에는 코드가 간단해진다!class Buffer {    int[] buf;    int size, count, in, out;    Buffer(int size) {        buf = new int[size];        this.size = size;        count = in = out = 0;    }    synchronized void insert(int item) {        while (count == size)            try {                wait();            } catch (InterruptedException e) {}        buf[in] = item;        in = (in+1)%size;        notify();        count++;    }    synchronized int remove() {        while (count == 0)            try {                wait();            } catch (InterruptedException e) {}        int item = buf[out];        out = (out+1)%size;        count--;        notify();        return item;    }}class Producer extends Thread {    Buffer b;    int N;    Producer(Buffer b, int N) {        this.b = b; this.N = N;    }    public void run() {        for (int i=0; i&lt;N; i++)            b.insert(i);    }}class Consumer extends Thread {    Buffer b;    int N;    Consumer(Buffer b, int N) {        this.b = b; this.N = N;    }    public void run() {        int item;        for (int i=0; i&lt;N; i++)            item = b.remove();    }}class Test {    public static void main(String[] arg) {        Buffer b = new Buffer(100);        Producer p = new Producer(b, 10000);        Consumer c = new Consumer(b, 10000);        p.start();        c.start();        try {            p.join();            c.join();        } catch (InterruptedException e) {}        System.out.println(\"Number of items in the buf is \" + b.count);    }}Number of items in the buf is 02.2 The Dining Philosopher Problemclass Philosopher extends Thread {    int id; // philosopher id\tChopstick lstick, rstick;    Philosopher(int id, Chopstick lstick, Chopstick rstick) {        this.id = id;        this.lstick = lstick;        this.rstick = rstick;    }    public void run() {        try {            while (true) {                lstick.acquire();                rstick.acquire();                eating();                lstick.release();                rstick.release();                thinking();            }        }catch (InterruptedException e) { }    }    void eating() {        System.out.println(\"[\" + id + \"] eating\");    }    void thinking() {        System.out.println(\"[\" + id + \"] thinking\");    }}class Chopstick {    private boolean inUse = false;    synchronized void acquire() throws InterruptedException {        while (inUse)            wait();        inUse = true;    }    synchronized void release() {        inUse = false;        notify();    }}class Test {    static final int num = 5; // number of philosphers &amp; chopsticks    public static void main(String[] args) {        int i;        /* chopsticks */        Chopstick[] stick = new Chopstick[num];        for (i=0; i&lt;num; i++)            stick[i] = new Chopstick();        /* philosophers */        Philosopher[] phil = new Philosopher[num];        for (i=0; i&lt;num; i++)            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);        /* let philosophers eat and think */        for (i=0; i&lt;num; i++)            phil[i].start();    }}이 코드는 교착상태를 해결하지 않은 상태이다. 해결 하기 위해서는 circular wait 조건을 불만족하도록 만들면 된다. 이 부분에서는 쉽게 동기화 문제를 해결할 수 있음을 보고가면 된다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-12-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-5.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-11-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-4-html": {
        "title": "11: 프로세스 동기화 Part 4",
        "tags": "OS, Synchronization, Deadlock",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스 동기화에서 발생하는 논리적 오류인 교착 상태(Deadlock)에 대해 알아본다.Deadlock (교착 상태)교착 상태는 어떠한 자원을 갖고 있는 상황에서 문제가 발생한다. 자동차 교차로를 생각해보자. A자동차도 신호를 받았고, B 자동차도 신호를 받았다. 그래서 두 자동차가 움직이는 것에 논리적 오류가 없지만, 두 자동차가 갈 수 없는 상황이 발생한다. 바로 출근 시간 길 막힘이다. 길이 막혀 아무런 동작도 수행할 수 없다. 이런 상황을 교착상태라 한다.프로세스는 실행을 위해 CPU, 메모리, 파일 등 여러 하드웨어 자원이 필요하다. 이를 운영체제에서 프로세스가 요구하는 자원을 적절히 분배해준다. 예를 들어, 한 프로세스가 A 자원을 가지고 있는 상태에서 B 자원을 요구하고 있다. 하지만 B 자원은 다른 프로세스 역시 요구하고 있는 자원인데, 이러한 상황에서 자원을 분배하는 순서가 잘못되면 교착상태에 빠지게 된다.1. 교착상태 필요 조건(Necessary Conditions)교착상태가 일어나기 위한 필요 조건이 네 가지가 존재한다. 이는 필요 조건이므로, 네 가지가 모두 해당된다고 해서 반드시 교착상태가 일어나는 것은 아니다. 단지 일어날 가능성이 발생한다.하지만 네가지 조건 중 하나라도 해당되지 않으면 교착 상태는 일어나지 않는다. 즉, 4가지 조건에 모두 해당되면 Deadlock의 가능성이 있으나, 그렇지 않다면 Deadlock은 일어나지 않는다.  Mutual exclusion (상호배타)          한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다.                  젓가락은 한 철학자가 사용하고 있으면 이 젓가락은 사용할 수 없으므로 상호배타적이다.                      No Preemption (비선점)          한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.                  한 철학자가 젓가락을 집은 상태에서 다른 철학자가 이 젓가락을 뺏을 수 없다.                      Hold and wait (보유 및 대기)          한 프로세스가 자원을 가지고 있는 상태에서 대기한다.                  철학자는 왼쪽 젓가락을 가지고 있는 상태에서 오른쪽 젓가락을 집기 위해 대기한다.                      Circular wait (환형대기)          프로세스가 요구하는 자원의 방향이 원형을 이룬다.                  모든 철학자는 왼쪽 젓가락부터 집을 수 있다.                    교착상태는 위 네 가지 조건을 모두 만족하더라도 매우 드물게 일어나는 현상이지만, 한 번 교착상태에 빠지면 프로세스가 무한 루프에 빠져 수행하지 못하고 해당 프로세스가 가지고 있는 자원은 아무도 사용하지 못한다. 이는 전체 컴퓨터 환경에 매우 치명적이다. 그리고 교착상태에 의한 오류를 해결하기는 매우 힘들다.2. 자원(Resources)교착 상태가 발생하는 가장 큰 원인은 결국 자원의 문제이다. 따라서 이 자원을 어떻게 이용하고 있는 지 파악하는 것이 중요하다.하드웨어 자원은 여러 개가 존재하고 동일한 형식(type)의 자원이 존재할 수 있다. 예를 들어, 같은 CPU가 2개있는 환경이 있다. 이러한 자원 하나하나를 instance라고 한다.자원은 프로세스가 직접적으로 사용할 수 없고, 운영체제에 요청(request)하면 운영체제가 제공해준다. 그 후 프로세스는 이 자원을 사용(use)하고 모든 사용이 끝나면 이를 반납(release)한다.요청(request) -&gt; 사용(use) -&gt; 반납(release)2.1 자원 할당도(Resource Allocation Graph)자원 할당도는 어떤 자원이 어떤 프로세스에 할당되었는지 또는 어느 프로세스가 어느 자원을 할당 받으려고 기다리는지를 그림으로 나타낸 것이다.            용어      모양                  Resource(자원)      사각형              Instance(인스턴스)      점              Process(프로세스)      원              할당      화살표      R1은 P1에 할당되어 있는 상태이고, P2는 R1을 요청하고 있는 상태이다.자원 할당도를 사용하는 이유는 교착상태의 필요조건을 한 눈에 볼 수 있기 때문이다. 자원 할당도를 분석할 때 mutual exclusion(한번에 하나)과 no-preemption(강제로 못 뺏는다.)은 기본으로 적용된다.Hold and wait는 화살표를 통해 한 프로세스가 인스턴스를 할당받았고 다른 자원을 가리키고 있다면, 이 상황은 Hold and wait인 상태이다.Circular wait 역시 화살표 방향이 원형을 이루고 있다면 이는 환형대기인 상태이다.이런 그림을 보면 Circular wait 조건을 가지고 있어 교착 상태의 가능성을 가지고 있다.위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.4. 교착상태 처리4.1 교착상태 방지 (Deadlock Prevention)교착상태 방지는 교착상태 필요조건 네 가지 중 최소 한 가지를 만족시키지 않도록 만드는 것이다.  상호배타(Mutual exclusion)          상호배타를 없애기 위해서는 자원을 공유 가능하게 만들어야 한다. 하지만 현실적으로 이러한 방법이 불가능한 경우가 많다.        비선점(No preemption)          비선점을 없애러면 반대로 선점이 가능하도록 만들어야 한다. 이 역시 대부분의 자원에게는 불가능한 방법이다. CPU는 강제로 스위칭하는 것이 가능한 경우가 있지만, 대부분의 경우에는 불가능하다. 가령 프린터를 수행하는 중간에 다른 프로세스가 이를 선점하는 것은 불가능하다고 볼 수 있다.        보유 및 대기(Hold &amp; Wait)          이 조건을 없애려면 자원을 가지고 있는 상태에서 다른 자원을 기다리지 않도록 만든다. 만약 여러 개의 자원이 필요하다면 필요한 모든 자원을 얻을 수 있는 경우에만 해당 자원을 요청한다. 또는 필요한 자원 중 일부만 가지는 경우 할당받은 자원을 모두 운영체제에 반납한다. 하지만 이와 같은 방법은 자원의 활용률을 저하시키고, starvation 현상이 발생하는 단점이 있다.      왼쪽 젓가락을 가진 상태에서 오른쪽 젓가락을 요청했는데, 이미 할당되어 있다면, 왼쪽 젓가락도 할당해제 한다.        환형대기(Circular wait)          이 조건을 없애는 것은 위 세 가지 조건보다는 할 수 있는 확률이 높다. 대표적인 예는 모든 자원에 번호를 부여하여 이 번호에 대한 오름차순으로 자원을 요청하는 것이다. 이 역시 자원의 활용률을 저하시키는 단점이 있다.      네 가지 방법을 살펴본 결과 가장 현실적인 방법은 hold &amp; wait나 circular wait 조건을 없애는 것이다. 하지만 둘 다 자원을 비효율적으로 사용하게 되는 단점을 가지고 있다. 그래서 이와 같이 교착상태 방지 방법은 군사, 우주, 의료와 같은 크리티컬한 곳에서 사용하는 것이 좋다.철학자 문제에 적용위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.Circular wait 조건을 없애기 위해 짝수 번호 철학자는 왼쪽 젓가락, 오른쪽 젓가락 순서로, 홀수 번호 철학자는 반대 순서인 오른쪽 젓가락, 왼쪽 젓가락 순서로 집는다고 하자.위 그림은 circular wait 조건을 없앤 식사하는 철학자 문제의 자원 할당도이다. 화살표가 원형을 만들지 않는 것을 볼 수 있다.// Philosopher Thread run functionpublic void run() {    try {        while (true) {            if (id % 2 == 0) {                lstick.acquire();                rstick.acquire();            }            else {                rstick.acquire();                lstick.acquire();            }            eating();            lstick.release();            rstick.release();            thinking();        }    }catch (InterruptedException e) { }}이전 글에서 있던 철학자가 젓가락을 집는 코드를 수정했다. 위와 같이 코드를 변경하고 실제로 수행하면 무한 반복문이 끝나지않고 정상적으로 계속되는 것을 확인할 수 있다.4.2 교착상태 회피 (Deadlock Avoidance)교착상태 회피와 방지의 차이점은 교착상태를 다르게 접근하는 것이다. 교착상태 회피에서는 교착상태를 자원 요청에 대한 잘못된 승인으로 판단한다. OS단에서 요청에 대해 잘 관리를 해주었다면 해결할 수 있다고 생각하는 것이다.이러한 접근은 은행과 비슷하다. 은행이 투자를 할 때, 안전한 곳과 안전하지 않은 곳을 잘 분리하여 투자해야, 위기 상황에서 부도가 나지 않을 것이다. 마찬가지로, OS에서 deadlock이 나지 않는 방법으로 할당해주는 방법이 교착 상태 회피이다.따라서, 교착상태 회피에서는 안전한 할당(Safe allocation)과 불안정한 할당(Unsafe allocation) 두 가지로 나뉜다.안전한 할당현재 운영체제에는 magnetic tape 자원이 총 12개가 있고, 이를 요청하는 3개의 프로세스가 있다.            process      Max needs      Current needs                  P0      10      5              P1      4      2              P2      9      2        Current needs          한 프로세스가 한 번 요청을 할 때 요구하는 개수        Max needs          프로세스를 정상적으로 끝내기 위해 필요한 총 개수      운영체제 입장에서 3개의 프로세스가 모두 수행될 때까지 자원을 분배해보자.  order : 순서  process : 프로세스 이름  needs : 프로세스가 필요로 하는 tape의 개수  possible : 할당이 가능한지 판단하는 변수  state : 해당 프로세스의 진행 상태  dealloc : 할당 해제 되었는지 확인하는 변수  tapeSize : 현재까지 할당되어 사용할 수 있는 tape의 개수  wait : 할당 받지 못해 대기하는 지 유무            order      process      needs      possible      state      dealloc      tapeSize      wait                  1      P0      5      O      5/10      X      12-&gt;7      X              2      P1      2      O      2/4      X      7-&gt;5      X              3      P2      2      O      2/9      X      5-&gt;3      X              4      P0      5      X      5/10      X      3      O              5      P1      2      O      4/4      O      3-&gt;1-&gt;5      X              6      P0      5      O      10/10      O      5-&gt;0-&gt;10      X              7      P2      2      O      4/9      O      10-&gt;8-&gt;12      X              8      P2      2      O      6/9      O      12-&gt;10-&gt;12      X              9      P2      2      O      8/9      O      12-&gt;10-&gt;12      X              10      P2      2      O      9/9      O      12-&gt;11-&gt;12      X        P0에게 5개를 할당한다.(5/10) =&gt; 현재 magnetic tape 개수: 7  P1에게 2개를 할당한다.(2/4) =&gt; 현재 magnetic tape 개수: 5  P2에게 2개를 할당한다.(2/9) =&gt; 현재 magnetic tape 개수: 3  다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 3개이므로 할당해줄 수 없다.  P1에게 2개를 할당한다.(4/4) =&gt; 현재 magnetic tape 개수: 1          P1은 필요한 4개의 magnetic tape을 받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 5        대기하고 있던 P0에게 5개를 할당한다.(10/10) =&gt; 현재 magnetic tape 개수: 0          P0 역시 필요한 자원을 모두 할당받았으므로, 종료 후 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 10        P2는 현재 필요한 magnetic tape 개수가 7개이고, 현재 남아있는 magnetic tape 개수 10개이므로 정상적으로 수행가능하다. (7~10)이 예제에서는 3개의 프로세스가 모두 정상적으로 자원을 할당받고 종료할 수 있었다. 이를 안전한 할당이라 한다. 다음 예제를 보자.불안전한 할당            process      Max needs      Current needs                  P0      10      5              P1      4      2              P2      9      3      이 예제 역시 운영체제가 보유하고 있는 총 magnetic tape 개수는 12개이고, 3개의 프로세스가 존재한다. 자원을 분배해보자.            order      process      needs      possible      state      dealloc      tapeSize      wait                  1      P0      5      O      5/10      X      12-&gt;7      X              2      P1      2      O      2/4      X      7-&gt;5      X              3      P2      3      O      3/9      X      5-&gt;2      X              4      P0      5      X      5/10      X      2      O              5      P1      2      O      4/4      O      2-&gt;0-&gt;4      X              6      P0      5      X      5/10      X      4      O              7      P2      3      O      6/9      X      4-&gt;1      X              8      P0      5      X      5/10      X      1      O              9      P2      3      X      6/9      X      1      O              10      P0      5      X      5/10      X      1      O              11      P2      3      X      6/9      X      1      O              $\\vdots$                                                         P0에게 5개를 할당한다.(5/10) =&gt; 현재 magnetic tape 개수: 7  P1에게 2개를 할당한다.(2/4) =&gt; 현재 magnetic tape 개수: 5  P2에게 3개를 할당한다.(3/9) =&gt; 현재 magnetic tape 개수: 2  다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 2개이므로 할당해줄 수 없다.  P1에게 2개를 할당한다.(4/4) =&gt; 현재 magnetic tape 개수: 0          P1은 필요한 자원을 모두 할당받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 4        대기하고 있던 P0는 아직 할당받으르 수 없다.  P2에게 3개를 할당한다.(6/9) =&gt; 현재 magnetic tape 개수: 1  현재 남아있는 magnetic tape 개수는 1개이고, P0가 요구하는 개수는 5개, P2는 3개이므로 두 프로세스 모두 할당받을 수 없다. (8~)이 예제에서 남은 magnetic tape 개수가 요구하는 개수보다 적으므로 자원을 할당해줄 수 없다. 그러므로 P0, P2 프로세스는 자원을 하염없이 기다리게 된다. 이를 불안전한 할당이라 하고, 그 결과 교착상태에 빠지게 된다.교착상태 회피는 마치 대출전문 은행과 유사하게 동작하므로, 해결 방법을 Banker’s Algorithm이라 한다. 돈이 있어야 값지4.3 교착상태 검출 및 복구 (Deadlock Detection &amp; Recovery)교착상태 검출 및 복구는 교착상태 자체가 매우 드문 현상이므로 자유롭게 자원을 분배하다가 교착상태가 발생하면 이를 정상적인 상태로 복구하는 것이다.1번과 2번 방법은 사전에 교착상태를 일어나지 않도록 하는 방법이지만, 교착상태 검출 및 복구 방법은 교착상태가 일어나는 것을 허용한다. 그 대신, 교착상태가 일어났을 때 이를 인지하고 복구를 해야 한다.교착상태가 일어나는 것을 감지하기 위해 운영체제 내부에서 주기적으로 교착상태가 발생하였는지 검사해야한다. 그 주기의 길이가 짧으면 그 만큼 오버헤드가 크고, 주기가 길면 오버헤드는 줄일 수 있지만 복구 가능성이 낮아진다.복구하는 방법은 교착상태가 발생하는지 주기적으로 검사하듯이 메모리의 상태를 주기적으로 메모리에 저장해놓고 만약 교착상태가 발생하면 그 이전 상태로 되돌리는 방법이 있다. 그 외에도 일부 프로세스를 강제로 종료하거나 자원을 강제로 선점하여 프로세스에게 할당해주는 방법 등이 있다.정상적인 상태로 복구한다는 장점이 있지만, 복구를 제대로 하지 못할 수도 있고, 검출을 위해 추가적인 오버헤드가 발생한다는 단점이 있다.3.4 교착상태 무시교착상태의 필요조건 네 가지를 모두 만족하더라도 교착상태가 반드시 일어나는 것이 아니라고 했듯이, 교착상태는 매우 드문 상황이다. 그러므로 이를 위해 오버헤드를 감수하는 것이 비효율적인 환경도 존재한다. 그러한 환경은 교착상태에 대한 아무런 조치를 하지 않는 방법도 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-11-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-4.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-10-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-3-html": {
        "title": "10: 프로세스 동기화 Part 3",
        "tags": "OS, Synchronization, Deadlock",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "전통적인 동기화 문제에 대해서 알아본다.현실적으로 찾아보았을 때, 동기화가 잘 되지 않으면 발생하는 문제들이 많다. 은행 계좌 문제와 같은 전통적으로 알려진 동기화 문제들에 대해서 알아본다.1. Producer-Consumer Problem생산자-소비자 문제는 생산자가 데이터를 생산하면 소비자는 그 데이터를 소비하는 형태의 문제이다. 컴퓨터 환경에서 예를 보면, 컴파일러 -&gt; 어셈블러, 웹 서버 -&gt; 웹 클라이언트 등이 있다. 컴파일러에서 생성한 어셈블리어는 어셈블러에서 이를 소비하여 기계어를 만든다.생산자-소비자 관계를 간단히 그림으로 나타내면 위와 같다. 이 관계의 대부분은 생산자에서 생산한 데이터 양을 소비자가 한 번에 소비하는 경우는 드물다. 생산한 데이터는 중간의 buffer 라는 저장 공간(메모리 공간)에 저장해두고 소비자는 여기서 필요한 만큼 가져간다. 창고와 같다.버퍼의 크기는 현실적으로 유한하다. 그러므로 생산자는 버퍼 공간이 가득 차면 더 이상 저장할 수 없다. 소비자는 버퍼가 비어 있으면 가져올 수 없다. 이러한 유한한 버퍼 크기를 bounded buffer 라고 한다.정리  생산자 소비자 문제          생산자 : 데이터 생산, 소비자 : 데이터 소비      컴파일러 -&gt; 어셈블러, 파일 서버 -&gt; 클라이언트, 웹서버 -&gt; 웹 클라이언트        Bounded Buffer          Buffer란 생산자와 소비자 사이에 존재하는 창고와 같음      생산자와 소비자 사이의 속도 차이를 보완하기 위해 필요함      버퍼 크기는 유한하다.                  생산자는 가득 차면 넣을 수 없다.          소비자는 버퍼가 비면 뺄 수 없다.                    1.1 CodeMainclass Test {\tpublic static void main(String[] arg) {\t\tBuffer b = new Buffer(100);\t\tProducer p = new Producer(b, 10000);\t\tConsumer c = new Consumer(b, 10000);\t\tp.start();\t\tc.start();\t\ttry {\t\t\tp.join();\t\t\tc.join();\t\t} catch (InterruptedException e) {}\t\tSystem.out.println(\"Number of items in the buf is \" + b.count);\t}}Buffer Class이 부분을 주목해서 봐야 한다.class Buffer {\tint[] buf; // buf: Bounded buffer\tint size;\t// size: 버퍼 크기\tint count; // count: 버퍼에 저장된 데이터 개수\tint in; // in: 생산한 데이터를 담을 버퍼 인덱스\tint out; // out: 소비할 데이터를 가리키는 버퍼 인덱스\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t}\tvoid insert(int item) {\t\t/* check if buf is full */\t\twhile (count == size)\t\t\t;\t\t/* buf is not full */\t\tbuf[in] = item;\t\tin = (in+1)%size; //  Circular Queue\t\tcount++;\t}\tint remove() {\t\t/* check if buf is empty */\t\twhile (count == 0)\t\t\t;\t\t/* buf is not empty */\t\tint item = buf[out];\t\tout = (out+1)%size; //  Circular Queue\t\tcount--;\t\treturn item;\t}}Buffer 클래스의 멤버 변수를 보면  buf: Bounded buffer  size: 버퍼 크기  count: 버퍼에 저장된 데이터 개수  in: 생산한 데이터를 담을 버퍼 인덱스  out: 소비할 데이터를 가리키는 버퍼 인덱스Producer/****** 생산자 ******/class Producer extends Thread {\tBuffer b;\tint N;\tProducer(Buffer b, int N) {\t\tthis.b = b; this.N = N;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;N; i++)\t\t\tb.insert(i);\t}}Consumer/****** 소비자 ******/class Consumer extends Thread {\tBuffer b;\tint N;\tConsumer(Buffer b, int N) {\t\tthis.b = b; this.N = N;\t}\tpublic void run() {\t\tint item;\t\tfor (int i=0; i&lt;N; i++)\t\t\titem = b.remove();\t}}만약 생성자가 데이터를 계속 생성하여 버퍼의 마지막 인덱스로 가면 그 다음은 처음으로 되돌아간다. (circular buffer) 소비하는 것도 마찬가지이다.main을 보면 크기가 100인 버퍼를 생성하고 2개의 쓰레드가 각각 생산자와 소비자 역할을 하여 각각 10000번씩 생산하고 소비한다. 정상적인 결과는 count값이 0이 출력되야 한다.하지만 실제 코드를 수행하면 무한 루프에 빠지거나, count값에 전혀 예상하지 않은 값이 출력된다.이 문제 당연하게도 동기화 문제이다. 생산자와 소비자가 동시에 접근하는 공통 변수인 buf, count 를 두 프로세스가 동시에 업데이트하기 때문이다. 다시 말하면 임계구역에 동시에 접근한 것이다.1.2 동기화 해결해결방법은 앞서 배웠던 세마포를 사용하여 mutual exclusion을 보장하는 것이다. 임계구역을 동시에 접근하는 것을 방지하고 하나의 프로세스만 허용해야한다. sem이라고 선언하지 않고 mutex라 선언한다. 지금 만드는 semaphore는 mutual exclusion을 막는 역할을 하기 때문이다.Buffer Classclass Buffer {\tint[] buf;\tint size;\tint count;\tint in;\tint out;\tSemaphore mutex;   // 세마포 선언\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t\tmutex = new Semaphore(1);\t}\tvoid insert(int item) {\t\t/* check if buf is full */\t\twhile (count == size)\t\t\t;\t\t/* buf is not full */\t\ttry {            mutex.acquire();            buf[in] = item;            in = (in+1)%size;            count++;            mutex.release();\t\t} catch(InterruptedException e) {}\t}\tint remove() {\t\t/* check if buf is empty */\t\twhile (count == 0)\t\t\t;\t\t/* buf is not empty */\t\ttry {\t\t\tmutex.acquire();\t\t\tint item = buf[out];\t\t\tout = (out+1)%size;\t\t\tcount--;\t\t\tmutex.release();\t\t\treturn item;\t\t} catch(InterruptedException e) {}\t\treturn -1;\t}}위는 임계구역에 세마포를 추가한 코드이다. 임계구역은 위에서 말했듯이 buf, count 에 접근하는 영역이므로 insert(), remove() 함수 내부에 선언한 것을 볼 수 있다.1.3 Busy waiting여기서 한 가지 더 문제점이 있다. 바로 busy waiting 이다. 위에서 busy waiting은 생산과 소비하기 전에 버퍼가 가득 찼는지 비어 있는지 확인하는 무한 반복문을 말한다. 이는 아무 일도 하지 않으면서 무한으로 반복하여 CPU를 점유하고 있으므로 매우 비효율적이다. 이를 해결할 수 있는 것도 세마포이다.class Buffer {\tint[] buf;\tint size;\tint count;\tint in;\tint out;\tSemaphore mutex, full, empty;\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t\tmutex = new Semaphore(1);\t\tfull = new Semaphore(0);\t\tempty = new Semaphore(size);\t}\tvoid insert(int item) {\t\ttry {            empty.acquire();    // 버퍼의 비어있는 공간을 1 감소시킨다.(비어있는 공간이 없으면 block)            mutex.acquire();            buf[in] = item;            in = (in+1)%size;            count++;            mutex.release();            full.release();    // 버퍼의 찬 공간을 1 증가시킨다.          } catch(InterruptedException e) {}\t}\tint remove() {\t\ttry {            full.acquire();    // 버퍼의 찬 공간을 1 감소시킨다.(버퍼가 모두 비어있으면 block)            mutex.acquire();            int item = buf[out];            out = (out+1)%size;            count--;            mutex.release();            empty.release();   // 버퍼의 비어있는 공간을 1 증가시킨다.            return item;          } catch(InterruptedException e) {}\t\treturn -1;\t}}busy waiting을 없애기 위해 두 개의 세마포를 더 추가하였다.  empty: 버퍼에서 비어있는 공간의 개수(초기값 size)  full: 버퍼에서 차있는 공간의 개수(초기값 0)추가한 세마포 변수는 위와 같고, empty는 초기화할 때 버퍼는 모두 비어있으므로 버퍼의 크기로 초기화하고 full은 초기 버퍼에는 아무런 데이터가 없으므로 0으로 초기화한다.데이터를 생성하기 전에 비어있는 공간이 있는지 확인한다. 없다면 empty세마포의 value값이 -1이 되므로 block이 되고, 있다면 임계구역 내부로 진입하여 데이터를 생성한다. 생성이 완료되면 full세마포의 value값을 1 증가시킨다.(소비자는 반대로 동작한다고 볼 수 있다. 코드참고) 이 코드를 실행시켜보면 정상적으로 결과값이 0이 출력되는 것을 확인할 수 있다.2. Readers-Writers ProblemReaders-Writers 문제는 대표적으로 공통 데이터베이스에 접근하는 경우가 있다. 하나의 데이터베이스에 여러 프로세스(readers, writers)가 접근하므로, 데이터베이스는 임계구역으로 설정해야한다. 즉, 한 번에 한 개의 프로세스만 접근가능하도록 해야하는데 이는 매우 비효율적이다.비효율을 해결하기 위해 데이터베이스에 접근하는 프로세스 종류를 reader와 writer로 나눈다. 그리고 reader는 데이터베이스 내의 정보를 바꾸지 않고 읽기만 하는 프로세스이므로, 여러 reader 프로세스가 동시에 데이터베이스를 접근하는 것을 허용한다. writer는 데이터베이스 내용을 바꾸는 프로세스이므로 당연히 mutual exclusion 을 보장해야한다.2.1 분류Readers-Writers 문제는 우선순위에 따라 여러 경우로 나눌 수 있다.  The first R/W problem (readers-preference): 이 방법은 reader 프로세스에 우선권을 주는 것이다. 만약, 한 reader 프로세스가 데이터베이스를 읽고 있는 동안 writer 프로세스가 오면 당연히 접근하지 못하고 기다린다. 이 상황에서 다른 reader 프로세스가 들어온다면, writer 프로세스가 기다리는 것을 무시하고 데이터베이스에 접근하여 읽는다. 그 결과, 두 reader가 동시에 데이터베이스를 읽는 상황이 된다.  The second R/W problem (writers-preference): 위 방법과 반대로 writer 프로세스가 기다리는 상황에서 다른 reader 프로세스가 들어온다면, 기존의 writer 프로세스 다음 순서로 기다려야한다.  The third R/W problem: 아무에게도 우선순위를 주지 않는다.3. Dining Philosopher Problem식사하는 철학자 문제는 원형 테이블에 5명의 철학자와 5개의 젓가락이 있는 상황이 있다고 하자. 각 철학자는 생각하고 식사하고 생각하고 식사하고를 반복한다. 단, 식사를 하기 위해서는 2개의 젓가락이 필요하다.이 상황을 프로그래밍을 해보자. 젓가락은 한 철학자가 가져가면 다른 철학자는 이 젓가락을 사용할 수 없다. 즉, 한 젓가락에 동시에 접근할 수 있는 철학자는 한 명뿐이므로 젓가락은 세마포로 만들 수 있다.(number of permit = 1) 한 철학자가 식사를 하려고 하면, 왼쪽 젓가락과 오른쪽 젓가락 순서로 가져가고, 식사가 끝나면 동일하게 왼쪽 젓가락, 오른쪽 젓가락 순서로 내려놓는다.3.1 Codeimport java.util.concurrent.Semaphore;class Philosopher extends Thread {\tint id; // philosopher id\tSemaphore lstick, rstick; // left, right chopsticks\tPhilosopher(int id, Semaphore lstick, Semaphore rstick) {\t\tthis.id = id;\t\tthis.lstick = lstick;\t\tthis.rstick = rstick;\t}\tpublic void run() {\t\ttry {\t\t\twhile (true) {\t\t\t\tlstick.acquire();\t\t\t\trstick.acquire();\t\t\t\teating();\t\t\t\tlstick.release();\t\t\t\trstick.release();\t\t\t\tthinking();\t\t\t}\t\t}catch (InterruptedException e) { }\t}\tvoid eating() {\t\tSystem.out.println(\"[\" + id + \"] eating\");\t}\tvoid thinking() {\t\tSystem.out.println(\"[\" + id + \"] thinking\");\t}}class Test {\tstatic final int num = 5; // number of philosphers &amp; chopsticks\tpublic static void main(String[] args) {        int i;        /* chopsticks */        Semaphore[] stick = new Semaphore[num];        for (i=0; i&lt;num; i++)            stick[i] = new Semaphore(1);        /* philosophers */        Philosopher[] phil = new Philosopher[num];        for (i=0; i&lt;num; i++)            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);        /* let philosophers eat and think */        for (i=0; i&lt;num; i++)            phil[i].start();      }}5개의 젓가락 세마포와 5명의 철학자 쓰레드를 생성한다. 각 철학자 쓰레드에는 무한 반복문으로 왼쪽 젓가락과 오른쪽 젓가락을 순서대로 집은 후 식사를 하고(몇 번 철학자가 식사했다는 것을 화면에 출력), 다시 왼쪽 젓가락, 오른쪽 젓가락 순으로 내려놓고 생각을 한다.단순히 코드를 봐서는 문제점이 없어보인다. 하지만 이를 수행하면 중간에 멈추고 더이상 실행되지 않는다.이는 대표적인 starvation 문제중 하나이다. 모든 철학자가 식사를 하지 못하고 굶어죽는 상황이라고 할 수 있다.이는 매우 드문 상황으로 모든 철학자가 동시에 식사를 하려고 왼쪽 젓가락을 집었다고 하자. 그러면 5명의 철학자가 5개의 젓가락을 모두 집어든 상황이다. 그 결과, 남아있는 젓가락은 더 이상없고 모든 철학자가 반대편 젓가락을 들기 위해 기다리고 있다. 하지만 식사할 수 있는 철학자는 없으므로 아무도 젓가락은 내려놓지 않고 하염없이 기다리고 있다.이러한 상황을 교착상태(deadlock) 라고 한다. 오오미ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-10-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-3.html"
      }
      ,
    
      "cs-algorithm-2020-04-03-eb-b0-b1-ec-a4-80-ec-b5-9c-ec-86-8c-ea-b0-92-html": {
        "title": "백준(10868번): 최소값",
        "tags": "백준, 알고리즘, 세그먼트트리",
        "date": "April 3, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플래티넘5 : 세그먼트 트리 문제이다.백준(10868번) - 최소값생각            0      1      2      3      4      5      6                  4      1      7      5      2      9      8      입력값이 이렇게 주어진다고 생각해보자. 이 상태에서 3~6까지의 최소값을 구하는 것은, 단순한 방법으로 구해도 $O(n^2)$으로 풀 수 있다. 하지만 이러한 확인(쿼리)가 많아진다면, 급격하게 시간 복잡도가 올라간다. 따라서 이 문제에서 제시하는 m(100000) 개에 대해서 n(100000)을 모두 확인하는 방법으로 간다면 문제를 풀 수 없다.($O(n^2)$)문제의 원인그렇다면 어느 부분에서 연산이 많이 걸리는 지 생각해보자. 가장 큰 부분을 판단을 중복으로 한다는 것이다. 0~3까지의 최소값을 구하는 것과, 1~4까지의 최소값을 구하는 과정에는 1~3까지의 최소값을 비교하는 과정이 중복된다. 그렇다면, 처음에 주어진 index를 나누어, 그 나눈 구간에 대해 최소값을 구해놓으면 어떨까?어떻게 나눌까?나누겠다는 생각이 들고 난 후에는, 어떻게 하면 잘 나눌 수 있을 지에 대해 고민했다. 이 부분은 트리가 가장 용이하다. 정보를 저장하는 자료구조 중, 탐색에 있어 시간복잡도가 log이다. 나누는 방법은 생각 보다 간단하다.Tree 구조트리의 구조는 모양의 변화를 가지는 것이다. 우리가 보통 가지는 선형 리스트를 조금 바꾸어 생각하면 쉽게 트리 구조를 만들 수 있다.이렇게 2의 제곱수만큼의 개수를 아래쪽으로 옮기면서 쌓으면 트리 구조가 된다. 이 때, 중요한 것은 가장 위층으로 부터 아래로 내려오는데 그 index들의 관계를 아는 것이다. 잘 보면, 1에서 2, 3은 $2\\times 1$, $2\\times 1 + 1$ 과 같다. 왼쪽 트리, 오른쪽 트리로 가는 관계는 계속 일관성을 가진다.Segment Tree그렇다면 이번에는 이 트리 구조를 이 문제에 맞는 모양으로 바꾸어 보자. 우리는 최소값을 미리 저장하기 위해 트리구조를 사용하기로 했는데, 그 구조를 아래와 같이 만들어서 생각해보자.기본적인 트리구조는 같지만 추가된 변수가 있다. 그것은 index의 시작과 끝을 나타내는 start~end 변수이다. 이렇게 나누었다고 가정하고, 2~5까지의 최소값을 얻기위해 조사해야 하는 Node의 개수를 파악해보자.이렇게 3개의 값만 조사하면 최소값을 얻을 수 있다! 이 때 발생하는 시간 복잡도는 $log(N)$ 이다. depth가 내려갈 수록 반씩 조사를 덜 할 수 있기 때문이다.tree에 필요한 node 수위 예시에서 총 7개의 원소를 넣기 위해 필요한 node의 개수는 총 13개 이다. 이 13개를 다 넣기 위해 필요한 트리의 깊이는 총 4이다. 이 값을 얻기 위한 수식은 다음과 같다.보통의 tree는 input으로 들어오는 요소의 개수와 트리의 node번호가 일치하지만, 이 경우는 depth가 1개 추가되므로 1을 더해주어야 한다. 이것을 코드로 구현하면 다음과 같다.h = ceil(log2(n))+1;treeSize = (1 &lt;&lt; h);&lt;&lt;은 shift 연산자로, 2진 연산을 할 때, 자리수를 올려주는 역할을 한다.init (초기화)처음에 input을 받고서, 가장 먼저 해야하는 일은, input을 tree안에 넣는 것이다. 그런데 우리가 설계한 세그먼트 트리를 생각해보면, 이 친구는 아래 node가 결정된 뒤에 상위 노드가 결정될 수 있다. 재귀로 짜면 해결될 것이다.void init(vector&lt;int&gt;&amp; input, vector&lt;int&gt;&amp; tree, int node, int start, int end){    if (start == end) {        tree[node] = input[start];        return;    }    init(input, tree, 2*node, start, (start+end)/2);    init(input, tree, 2*node+1, (start+end)/2+1, end);    tree[node] = min(tree[2*node], tree[2*node+1]);    return;}init 함수의 argument로는 input 벡터, tree 벡터, 내가 기록할 node의 index, 처음 node가 커버하게 될 index의 시작과 끝이 필요하다. 그 뒤로는 아까 트리 구조에서 본 왼쪽, 오른쪽 노드로 가는 함수 관계에 따라 init함수를 계속 수행하면 된다. 종료조건은, 그림에서 보았듯이 start와 end과 같아지는 지점에서 input에 start 해당하는 index의 값을 넣어준다.find저장된 자료구조에서 찾는 과정이다. 내가 찾으려고 하는 범위을 left, right 라 하고, 내가 처음에 탐색을 시작할 노드의 번호를 node, 그 노드가 커버하는 index의 범위를 start, end라 하자. tree의 가장 위부터 탐색을 시작할 때, 범위에 걸리는 녀석들만 비교의 대상이 되어야 한다. 이런 범위를 따져보면 총 3가지로 나눌 수 있다.  left, right 사이에 현재 노드의 커버범위가 들어온다.          후보로 선정한다.        left, right 와 현재 노드의 커버범위가 전혀 겹치지 않는다.          버린다.        애매하게 걸친다.          더 깊이 들어가서 조사한다.      이 과정을 구현하면 다음과 같다.int findMin(vector&lt;int&gt;&amp; tree, int node, int start, int end, int left, int right){    if (left &gt; end || right &lt; start) {        return INF;    } else if (left &lt;= start &amp;&amp; end &lt;= right){        return tree[node];    }    int a = findMin(tree, 2*node, start, (start+end)/2, left, right);    int b = findMin(tree, 2*node+1, (start+end)/2+1, end, left, right);    return min(a, b);}Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int INF = 1111111111;void init(vector&lt;int&gt;&amp; input, vector&lt;int&gt;&amp; tree, int node, int start, int end){    if (start == end) {        tree[node] = input[start];        return;    }    init(input, tree, 2*node, start, (start+end)/2);    init(input, tree, 2*node+1, (start+end)/2+1, end);    tree[node] = min(tree[2*node], tree[2*node+1]);    return;}int findMin(vector&lt;int&gt;&amp; tree, int node, int start, int end, int left, int right){    if (left &gt; end || right &lt; start) {        return INF;    } else if (left &lt;= start &amp;&amp; end &lt;= right){        return tree[node];    }    int a = findMin(tree, 2*node, start, (start+end)/2, left, right);    int b = findMin(tree, 2*node+1, (start+end)/2+1, end, left, right);    return min(a, b);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    int n, m;    cin &gt;&gt; n &gt;&gt; m;    int h = int(ceil(log2(n)))+1;    int treeSize = (1 &lt;&lt; h);    vector&lt;int&gt; tree(treeSize, INF);    vector&lt;int&gt; a(n);    for (int i = 0; i &lt; n; i++) {       cin &gt;&gt; a[i];    }    init(a, tree, 1, 0, n-1);    for (int i = 0; i &lt; m; i++) {        int left, right;        cin &gt;&gt; left &gt;&gt; right;        cout &lt;&lt; findMin(tree, 1, 0, n-1, left-1, right-1) &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/04/03/%EB%B0%B1%EC%A4%80-%EC%B5%9C%EC%86%8C%EA%B0%92.html"
      }
      ,
    
      "cs-algorithm-2020-04-03-eb-b0-b1-ec-a4-80-ea-b5-ac-ea-b0-84-ed-95-a9-ea-b5-ac-ed-95-98-ea-b8-b0-html": {
        "title": "백준(2042번): 구간 합 구하기",
        "tags": "백준, 알고리즘, 세그먼트트리",
        "date": "April 3, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플래티넘5 : 세그먼트 트리 문제이다.백준(2042번) - 구간 합 구하기생각전형적인 세그먼트 트리 문제이다. 구간에 대한 합을 연속된 쿼리로 물어보는 경우인데, 이런 경우 단순하게 짜면 그냥 펑!이다. 이 문제 같은 경우는 추가적으로 수가 변형되는데, 이전 백준(10868번): 최소값에서 한 단계 업그레이드 되었다고 보면된다.update업데이트는 별 것 없다. 내가 바꾸고 싶은 녀석의 트리 하위 노드에 접속하여, 그 노드가 영향을 주는 노드만 쏙쏙 업데이트 해주면 된다. 만약 2번 값을 바꾸고 싶다면 2번이 영향을 주는 노드는 파란색 노드들 이다.void update(int changed_index, ll changed_value, int index, int start, int end){        if (start == end) {           nodes[index] = changed_value;           return;        }        int mid = (start+end)/2;        if (start &lt;= changed_index &amp;&amp; changed_index &lt;= mid) {            update(changed_index, changed_value, 2*index, start, mid);        } else {            update(changed_index, changed_value, 2*index+1, mid+1, end);        }        nodes[index] = nodes[2*index] + nodes[2*index+1];    }사실 이 부분을 생각할 때, 위 방법 말고, 차이를 다 더해주는 방법을 생각했는데 좋지 않아 적지 않는다.Code이번에는 클래스로 구현했다. 그런데, 클래스로 구현하면 속도가 매우 느리다고 한다. private 키워드도 느리니 쓰지 말라한다. 흥. 구조체로 구현하라고 한다.#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, m, k;ll arr[1000001];class SegmentTree{private:    ll* nodes;    ll* input;public:    SegmentTree(int size, ll* input){        int h = ceil(log2(size))+1;        int treeSize = (1 &lt;&lt; h);        nodes = new ll[treeSize];        this-&gt;input = input;        init(1, 0, size-1);    }    ~SegmentTree(){        delete[] nodes;    }    void init(int index, int start, int end){        if (start == end) {            nodes[index] = input[start];            return;        }        int mid = (start+end)/2;        init(2*index, start, mid);        init(2*index+1, mid+1, end);        nodes[index] = nodes[index*2] + nodes[index*2+1];    }    ll findSum(int index, int start, int end, int left, int right){        if (left &gt; end || right &lt; start){            return 0;        } else if (left &lt;= start &amp;&amp; end &lt;= right){            return nodes[index];        }        int mid = (start+end)/2;        return findSum(2*index, start, mid, left, right) + findSum(2*index+1, mid+1, end, left, right);    }    void update(int changed_index, ll changed_value, int index, int start, int end){        if (start == end) {           nodes[index] = changed_value;           return;        }        int mid = (start+end)/2;        if (start &lt;= changed_index &amp;&amp; changed_index &lt;= mid) {            update(changed_index, changed_value, 2*index, start, mid);        } else {            update(changed_index, changed_value, 2*index+1, mid+1, end);        }        nodes[index] = nodes[2*index] + nodes[2*index+1];    }};int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for (int i = 0; i &lt; n; i++) {        cin &gt;&gt; arr[i];    }    SegmentTree st(n, arr);    int changeCount = 0, printCount = 0;    while (!(changeCount == m &amp;&amp; printCount == k)) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        if (a == 1) {            ll c;            cin &gt;&gt; c;            changeCount++;            st.update(b-1, c, 1, 0, n-1);        } else {            int c;            cin &gt;&gt; c;            printCount++;            cout &lt;&lt; st.findSum(1, 0, n-1, b-1, c-1) &lt;&lt; '\\n';        }    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/03/%EB%B0%B1%EC%A4%80-%EA%B5%AC%EA%B0%84-%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-03-eb-b0-b1-ec-a4-80-ea-b3-b5-ed-95-ad-html": {
        "title": "백준(10775번): 공항",
        "tags": "백준, 알고리즘, 유니온파인드",
        "date": "April 3, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드2 : 유니언 파인드 문제이다.백준(10775번) - 공항생각이런 문제는 정말 비행기가 온다고 생각하고 푸는 것이 가장 좋은 것 같다. 그러니까 모든 문제는 시뮬레이션을 제대로 하는 것이 중요.. 총 5개의 게이트가 있다고 하자. 그 때, 4번으로 비행기가 들어온다. 그럼 4번에 배정하는 것이 맞다. 그런데 또 4번으로 들어온다. 이 문제는 4번 보다 작은 게이트에만 비행기가 들어올 수 있으므로 들어갈 수 있는 게이트는 1, 2, 3이다. 그런데, 문제 특징 상 원하는 게이트보다 작은 부분에만 들어갈 수 있으므로 가장 많은 비행기를 넣기 위해서는 원하는 게이트에서 작은 숫자를 가진 게이트 중, 숫자가 가장 큰 게이트에 들어가는 것이 최선이다.(응?) 이해를 위해 표를 그려보자.            gate      1      2      3      4      5                         0      0      0      1      0      이 상황에서 3번 게이트로 들어올 경우 두가지 그림이 가능하다.            gate      1      2      3      4      5                         1      0      0      1      0                  gate      1      2      3      4      5                         0      0      1      1      0      1번 표의 경우, 만약 1번으로 들어오는 비행기가 있다고 하면, 이 비행기는 이미 게이트가 차 있으므로 들어가지 못한다. 그래서 총 숫자는 2이다. 2번 표에서는 1번 게이트가 비어있으므로 비행기를 댈 수 있다. 그 결과 정답은 3이다. 이렇게, 비행기가 들어오는 방법은 원하는 게이트보다 작거나 같은 게이트 중 비어있는 게이트에서 가장 큰 숫자를 가진 게이트 순서로 도킹해야한다.유니온 파인드위에서 생각한 것은, 대안 게이트를 찾는 방법이다. 그런데 생각해보면, 이 대안 게이트는 그래프로 볼 수 있다.gate     : 1, 2, 3, 4, 5airplain : 4, 4, 3, 1위와 같은 순서로 비행기가 들어온다고 했을 때의 그림을 보자.airplain 4airplain 4airplain 3airplain 1이 과정에서, 신경써주어야 하는 것은, 해당 게이트의 대안 게이트의 번호가 무엇인지이다! 무조건 처음에는 비행기가 왔을 때, 자신의 게이트에 넣는 것은 확정이므로, 처음 도킹 위치의 초기값은 자기 자신의 게이트 이다. 이제 비행기가 들어오면서, 어떠한 방법으로 이것을 업데이트 해줄지 고민하면 된다.대안 게이트 합치기기본적으로 대안 게이트의 위치는 나보다 하나 작은 녀석의 게이트이다. 하지만 그 위치에도 이미 도킹이 되어 있다면, 그 녀석의 대안 게이트를 또 찾아야 한다. 그러므로 대안 게이트를 찾아서 업데이트 할 때는 나보다 작은 녀석을 기반으로 하되, 그녀석의 최종적인 대안 게이트를 찾아야 한다. 유니온 파인드 알고리즘에서 이 대안 게이트는 조상에 치환되는 개념으로 볼 수 있다. 결국은 조상을 찾아서, 그 조상으로 업데이트를 진행해야 한다.종료조건은 간단하다. 문제에서 보여주듯 원하는 게이트보다 작은 게이트들이 다 도킹이 된 상태면 종료한다. 이 조건은, 알고리즘 상에서 대안 게이트의 번호가 0이 되는 것과 동치이다. 0번 게이트는 없으므로 도킹할 수 없다.알고리즘  초기 게이트의 위치를 대안 게이트의 번호를 자기자신의 게이트를 가리키도록 한다.  비행기가 들어올 때, 대안 게이트를 찾는다.  대안 게이트를 찾으면, 대안 게이트에 비행기가 도킹했다고 생각하고 도킹한 비행기의 숫자를 늘린다.  대안 게이트에 비행기가 들어왔으므로, 방금 도킹한 비행기의 대안 게이트를 찾는다.  만약, 대안 게이트의 번호가 0인 경우 현재까지 도킹한 비행기를 출력하고 종료한다.Code#include &lt;iostream&gt;using namespace std;int n, m;int parent[100001];int ans = 0;int find(int gate){    if (gate == parent[gate]){        return gate;    }    return parent[gate] = find(parent[gate]);     // 탐색하는 과정에서 있었던 대안 게이트를 최종 값으로 업데이트한다.}// 게이트의 최종 대안 게이트로 업데이트 한다.void unite(int x, int y) {    x = find(x);    y = find(y);    parent[x] = y;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        parent[i] = i;    }    for (int i = 0; i &lt; m; i++) {        int command;        cin &gt;&gt; command;        int empty_gate = find(command);        if (empty_gate == 0) {            break;        }        ans++;        unite(empty_gate, empty_gate-1); // 기본적으로 나보다 하나 작은 게이트와 합친다.    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/04/03/%EB%B0%B1%EC%A4%80-%EA%B3%B5%ED%95%AD.html"
      }
      ,
    
      "cs-algorithm-2020-04-02-eb-b0-b1-ec-a4-80-ec-a7-91-ed-95-a9-ec-9d-98-ed-91-9c-ed-98-84-html": {
        "title": "백준(1717번): 집합의 표현",
        "tags": "백준, 알고리즘, 유니온파인드",
        "date": "April 2, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 유니온 파인드 문제이다.백준(1717번) - 집합의 표현생각문제를 이해해보자. 먼저 처음에 아무일도 하지 않을 경우에 입력된 n에 대해서 0 ~ n까지의 바구니가 생긴다. 그 다음, m개의 명령이 들어온다. 명령은 해당 원소가 들어있는 바구니를 합치는 것, 그리고 해당 원소가 같은 바구니에 들어있는 지 확인하는 것이다.그렇다면 핵심은, 현재 어떻게 내가 들어가 있는 바구니를 찾을 것인가? 그리고 찾았다면 어떤식으로 합쳐서 가지고 있을 것인가? 이다. 결국 집합을 만들고, 서로소 인지를 확인하는 문제이다.가장 단순하게 생각해보자. 처음에 모든 바구니는 자기자신만을 원소로 갖는 바구니를 가진다. 이 상태에서 1번 바구니와 3번 바구니를 합치라는 명령이 내려올 때, 우리는 일반적으로 이것을 동등하게 생각하고 연결하려 한다. 하지만 이렇게 생각할 경우에 해당 바구니에 대한 번호를 재정의 해야 한다. 예를 들어, (1, 2)가 들어있는 바구니는 몇번 바구니라 정의해야 할까? 또 추가적으로 3이 들어온 경우 (1, 2, 3)은 몇번 바구니 일까? 바구니에 원소가 추가될 경우 계속하여 바구니의 이름을 재정의 해야 한다.그러니 위계 질서를 줘보자. 1번 바구니와 2번 바구니를 합친다는 명령이 내려왔을 때 2번 바구니는 1번을 따른다. (2-&gt;1) 그리고 3번 바구니는 2번을 따른다고 하면 (3-&gt;2-&gt;1)로 준다. 그리고 이렇게 생성된 바구니의 번호를 1이라 하면, 합치는 과정을 통한다하더라도 합쳐진 집합의 번호는 가장 먼저 합쳐진, 즉 조상 원소의 번호라 지칭할 수 있다. 즉, 위의 바구니는 1번 바구니라 할 수 있고, 다른 합쳐진 집합이 있다하더라도 이 집합의 조상은 독립적으로 유지된다.(3-&gt;2-&gt;1) = 1번 바구니(4-&gt;5) = 5번 바구니5번 바구니와 3번 바구니를 합해라.=&gt; (4-&gt;5-&gt;3-&gt;2-&gt;1) = 1번 바구니문제 발생하지만 이 경우에는 문제가 발생하는데, (2-&gt;1), (5-&gt;4) 인 경우가 있다고 하자. 이 때 5번이 2번 바구니에 속한다고 할 경우 이 논리대로라면 (5-&gt;2-&gt;1)이 된다. 그런데 사실은 4번도 1번 바구니에 속해야 한다. 논리적 오류가 발생한다.이 문제는 바구니가 속하는 기준이 한 방향이기 때문이다. 하지만 속하는 기준을 여러개로 만들지 않아도 해결이 가능하다.해결 방법아까 조상을 만들고, 추가된 집합에 대한 바구니 번호를 가장 위에 있는 조상의 번호를 따르기로 했다. 위에서 발생한 문제에 대해 해당 번호가 어떤 바구니(조상)에 있는지 확인하고 그 바구니끼리 연결한다면 해당 문제는 해결된다.(2-&gt;1) = 1번 바구니(5-&gt;4) = 4번 바구니5번 바구니와 2번 바구니를 합쳐라.5번의 조상 : 4번2번의 조상 : 1번(4-&gt;1)로 바꿔버린다.=&gt; (2-&gt;1), (5-&gt;4-&gt;1)이렇게 된 경우 1번 바구니에 해당한 번호는 2, 4, 5로 원하는 결론이다.구현이것을 구현하는 것이 어려워 보이지만, 단순하다. 위에서 결국 필요한 것은 내 원소의 번호, 그리고 그 원소가 따르는 번호이다. 그리고 그 따르는 것들의 바구니 번호는 가장 위에 기초가 되는 조상 번호가 대표한다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      3      4      5      6      7      7 80 1 31 1 70 7 61 7 10 3 70 4 20 1 11 1 1line 10 1 3 // 1번과 3번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      3      4      5      6      7      1의 조상 번호 : 13의 조상 번호 : 33번이 따르는 바구니를 1로 바꾼다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      6      7      line 21 1 7 // 1번과 7번은 같은 바구니이니?            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      6      7      7의 조상 번호 : 71의 조상 번호 : 1Noline 30 7 6 // 7번과 6번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      6      7      7의 조상 번호 : 76의 조상 번호 : 66번은 7번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      7      line 41 7 1 // 7번과 1번은 같은 바구니이니?            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      7      7의 조상 번호 : 71의 조상 번호 : 1Noline 50 3 7 // 3번과 7번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      7      3의 조상 번호 : 17의 조상 번호 : 77번은 3번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      3      line 60 4 2 // 4번과 2번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      3      4의 조상 번호 : 42의 조상 번호 : 22번은 4번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      4      1      4      5      7      3      line 70 1 1 // 1번과 1번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      3      1의 조상 번호 : 11의 조상 번호 : 11번은 1번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      4      1      4      5      7      3      line 81 1 1 // 1번과 1번은 같은 바구니이니?            바구니      0      1      2      3      4      5      6      7                  번호      0      1      4      1      4      5      7      3      1의 조상 번호 : 11의 조상 번호 : 1Yes결론이런 방식으로 업데이트 하는 과정을 거치면, 묶인 집합을 효과적으로 찾을 수 있다. 결론적으로 구현해야 하는 함수는 find, union 함수이다.findfind 함수같은 경우에는, 특정 원소에 대해 물었을 때, 그 녀석이 속한 바구니를 끝까지 찾아 어떤 바구니인지 반환한다.unionunion 함수는 명령이 들어왔을 때, 각각이 속해있는 바구니를 찾고 그 바구니를 연결한다. 이 때, 중요한 것은 해당 원소의 바구니 번호를 찾아야 한다는 것이다.#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n, m;int box[1000001];int find(int elem){    if (elem == box[elem]) {        return elem;    }    return find(box[elem]);}void merge(int elem1, int elem2){    box[find(elem2)] = find(elem1);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt;= n; i++) {        box[i] = i;    }    for (int i = 0; i &lt; m; i++) {        int command, elem1, elem2;        cin &gt;&gt; command &gt;&gt; elem1 &gt;&gt; elem2;        if (command) {            if (find(elem1) == find(elem2)) {                cout &lt;&lt; \"YES\" &lt;&lt; '\\n';            } else {                cout &lt;&lt; \"NO\" &lt;&lt; '\\n';            }        } else {            merge(elem1, elem2);        }    }    return 0;}시간 복잡도 문제하지만 위의 코드대로 한다면 문제가 발생한다. 그 이유는 원소의 개수가 많아짐에 따라 어떤 바구니에 들어있는지 탐색하는 시간이 오래걸리기 때문이다. 예제 입력에 대한 마지막 상황을 보자.            바구니번호      0      1      2      3      4      5      6      7                  따르는 번호      0      1      4      1      4      5      7      3      이 상황에서, 6은 어느 바구니에 있을까? (6-&gt;7-&gt;3-&gt;1) 로, 1번 바구니에 있다. 만약, 6번을 0번이 속한 바구니와 합치라는 명령이 들어온다면 4번의 연산을 수행해야 한다. 그렇다면, 극단적인 경우에, n개의 원소가 순차적으로 얽혀있고 (n-&gt;n-1-&gt;n-2-&gt;…) n이라는 원소를 특정 바구니에 합치라는 명령이 들어올 경우, $O(n)$ 의 시간 복잡도를 갖는다. 이 때, 수행하는 명령의 개수가 m일 경우 $O(nm)$ 의 시간 복잡도를 갖는다. 현재 문제에서 n = 100000, m = 1000000이므로 시간 초과가 난다.해결이 문제는 해결이 간단한데, find 함수에 찾는 과정에서, 최종 조상의 번호를 아예 해당 원소의 바구니라고 저장해버리는 것이다. 이 상황에서는 원소가 속해있는 바구니 번호가 중요한 것이지, 그 과정에서 발생하는 그래프가 중요한 것이 아니기 때문이다.#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n, m;int box[1000001];int find(int elem){    if (elem == box[elem]) {        return elem;    }    return box[elem] = find(box[elem]);}void merge(int elem1, int elem2){    box[find(elem2)] = find(elem1);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt;= n; i++) {        box[i] = i;    }    for (int i = 0; i &lt; m; i++) {        int command, elem1, elem2;        cin &gt;&gt; command &gt;&gt; elem1 &gt;&gt; elem2;        if (command) {            if (find(elem1) == find(elem2)) {                cout &lt;&lt; \"YES\" &lt;&lt; '\\n';            } else {                cout &lt;&lt; \"NO\" &lt;&lt; '\\n';            }        } else {            merge(elem1, elem2);        }    }    return 0;}",
        
        "url": "/cs/algorithm/2020/04/02/%EB%B0%B1%EC%A4%80-%EC%A7%91%ED%95%A9%EC%9D%98-%ED%91%9C%ED%98%84.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-09-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-2-html": {
        "title": "09: 프로세스 동기화 Part 2",
        "tags": "OS, Synchronization, Semaphore",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스 동기화 도구에 대해 알아본다.Semaphore(세마포)Semaphoresms 깃발이라는 네덜란드 단어이다. 옛날에는 기찻길에서 공유하는 길이 있을 때, 깃발 표식으로 오고감의 신호를 주고 받았다. 이러한 맥락에서, Critical section을 사용하는 쓰레드에 사용하는 방법의 이름으로 붙게 되었다.위의 그림을 보면 공유하는 기찻길이 하나이다. 이 경우 공유 자원이 1이라 볼 수 있다. 하나의 기차가 지나갈 때 1을 감소시키고, 다 지나간 뒤에 1을 증가시키는 일을 반복한다. 그리고 다른 기차가 지나가려고 할 때, Semaphore가 0인 경우에는 정지하고 1인 경우에 순차적으로 지나가게 하면 해결된다. 이렇게 Semaphore가 0, 1인 경우를 Binary Semaphore라 한다.공유 자원이 꼭 1개일 필요는 없다. 여러개의 자원인 상황도 존재한다. 가령 위의 기차 그림에서 통과해서 갈 수 있는 공유 기찻길이 5개라면, 공유자원은 5이다. 이런 경우를 counting semaphore라 한다.1. 구현위의 예시에서 보듯, 깃발은 총 두가지가 필요하다. 지나가는 경우에는 감소, 지나간 뒤에는 증가이다. 초기에는 P, V로 불렸다.(네덜란드에서 만들어져 네덜란드어의 약자이다.) 현재에는 P는 test를 의미하며 acquire() 로 사용하고, V는 increment를 의미하며 release() 로 사용한다. acquire()는 자원이 사용가능한지 확인하고, 사용가능하다면 사용하고 그렇지 않다면 대기한다. release()는 자원을 내놓고, 다음 자원을 실행시킨다.자바를 통해 세마포 구조를 간단히 살펴보면 아래와 같다.class Semaphore {  int value;      // number of permits  Semaphore(int value) {    // ...  }  void acquire() {    value--;    if (value &lt; 0) {      // add this process/thread to list      // block    }  }  void release() {    value++;    if (value &lt;= 0) {      // remove a process P from list      // wakeup P    }  }}위 코드에서 acquire() 는 value값을 감소시키고 만약 value값이 0보다 작으면(가용자원을 모두 사용함) 이미 해당 임계구역에 어느 프로세스가 존재한다는 의미이므로 현재 프로세스는 접근하지 못하도록 막아야한다. 이를 list라는 기다리는 줄에 추가한 뒤 block을 걸어준다.(list는 일반적으로 큐로 되어있다.)release() 는 value값을 증가시키고, 만약 value값이 0보다 같거나 작으면 임계구역에 진입하려고 대기하는 프로세스가 list에 남아있다는 의미이므로 그 중에서 하나를 꺼내어 임계구역을 수행할 수 있도록 해주어야 한다.세마포를 그림으로 나타내면 위와 같다. list는 실제로 큐로 볼 수 있다. acquire()에 의해 block되는 프로세스는 세마포 내부에 있는 큐에 삽입된 후, 다른 프로세스가 임계구역을 나오면서 release()를 호출하여 세마포 큐에 있는 프로세스를 깨워야 한다.(다시 ready queue로 보낸다.)위에서 살펴본 것처럼 세마포는 일반적으로 Mutual exclusion을 위해 사용된다.운영체제 정리 08: 프로세스 동기화 &lt;1. 발생 이유와 목적&gt;Bank Account Problem(은행 계좌 문제) 해결이전 글에서 보았던 은행 계좌 문제에 세마포를 적용해보자. 위에서 임계구역은 BankAccount 클래스 내부의 입출력하는 부분인 것을 보았다. 여기에 세마포를 적용해보면 아래와 같다.import java.util.concurrent.Semaphore;  // 세마포를 사용하기 위해 파일 가장 위에 추가해야 한다.class BankAccount {\tint balance;\tSemaphore sem;\tBankAccount() {   // BankAccount 클래스의 생성자가 호출되면 세마포를 만든다.\t\tsem = new Semaphore(1);  // value 값을 1로 초기화한다.\t}\tvoid deposit(int amount) {\t\ttry {\t\t\tsem.acquire();   // 임계구역에 들어가기를 요청한다.\t\t} catch (InterruptedException e) {}\t    /* 임계 구역 */\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();   // 임계구역에서 나간다.\t}\tvoid withdraw(int amount) {\t\ttry {\t\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t    /* 임계 구역 */\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tsem.release();\t}\tint getBalance() {\t\treturn balance;\t}}value 값은 임계구역에 몇 개의 프로세스를 접근할 것인지 정하는 것과 같다. 지금은 임계 구역에 하나의 프로세스만 접근가능하기 때문에 1 로 초기화 한다. (위 코드를 제외한 부분은 동일하다.) 이 코드를 수행하면 아래와 같은 결과가 나온다.// +,- 출력 생략balance = 0정상적으로 잔액이 0원이 나온 것을 확인할 수 있다. 이 코드는 임계구역의 문제를 해결하였으므로 몇 번을 수행하여도 같은 결과값이 출력된다.2. Ordering세마포는 mutual exclusion뿐 아니라 ordering을 하기 위해서도 사용한다. 즉, 프로세스의 실행 순서를 원하는 순서로 설정 할 수 있다.예를 들어, 프로세스가 P1, P2 두 개가 있다고 가정하자. 원하는 순서는 P1, P2 순으로 실행하기를 원한다. 그러면 아래와 같이 설정해줄 수 있다.// 초기 semaphore 값 = 0sem value = 0            P1      P2                         sem.acquire()              section 1      section 2              sem.release()             P1이 먼저 실행된 경우  Section 1 이전에 아무런 동작이 없으므로 바로 수행한다.  sem.release() 를 만나면 value값을 1 증가시키고, 세마포 큐에 있는 프로세스를 깨워주는데 현재에는 큐에 프로세스가 없으므로 아무 동작도 하지 않는다.  P2가 실행된다.  P2의 sem.acquire() 를 만나면 현재 value값은 1이고 이를 1감소시키면 0이 된다. value = 0이면 block을 하지 않으므로, 무사히 Section 2가 수행된다.P2가 먼저 실행된 경우  Section 2 이전에 sem.acquire() 가 있으므로 이를 수행하는데, 현재 value값은 0이고 이를 1 감소 시키면 -1 이 된다. value값이 음수면 해당 프로세스를 block시킨다.(세마포 큐에 삽입한다.)  P1이 실행되면 Section 1이 바로 수행된다.  sem.release() 를 만나면 value값을 1 증가시키고, 세마포 큐에 있는 P2 프로세스를 깨워준다.(현재 value = 0)  P2의 Section 2가 수행된다.위에서 두 가지 경우를 살펴보았듯이, P1, P2 둘 중 어느 것을 먼저 실행하여도 결과적으로 P1 -&gt; P2 순서로 수행하는 것을 알 수 있다.입금 출금 순서로 은행계좌 문제 해결하기위에서 계속 살펴봤던 은행계좌 문제에서 ordering을 적용해보자. 프로세스의 실행 순서는 반드시 입금, 출금 순서로 수행해야한다.class BankAccount {\tint balance;\tSemaphore sem, semOrder;\tBankAccount() {\t\tsem = new Semaphore(1);\t\tsemOrder = new Semaphore(0);   // Ordeing을 위한 세마포\t}\tvoid deposit(int amount) {\t\ttry {\t\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();\t\tsemOrder.release();   // block된 출금 프로세스가 있다면 깨워준다.\t}\tvoid withdraw(int amount) {\t\ttry {\t\t\tsemOrder.acquire();   // 출금을 먼저하려고 하면 block한다.\t\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tsem.release();\t}\tint getBalance() {\t\treturn balance;\t}}위처럼 코드를 수정할 수 있다. Ordering을 위한 semOrder 세마포 변수를 선언하고, 출금하는 동작 앞에 acquire(), 입금하는 동작 뒤에 release() 를 추가하였다.+++++++++++++++++++++++++------------+++++-----+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------------------------------balance = 0실행 결과는 위와 같다. +(입금)가 맨 앞에서 실행한 모습을 볼 수 있다.(입금, 출금 횟수는 100번으로 줄였다.)만약, 입금, 출금, 입금, 출금, … 교대로 출력하도록 하려면 세마포를 두 개 사용하여 아래와 같이 구현할 수 있다.void deposit(int amount) {\ttry {\t\tsem.acquire();\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();\t\tsemWithraw.release();\t\tsemDeposit.acquire();   // 입금후에는 반드시 출금을 해야 하므로 자신을 block한다.\t} catch (InterruptedException e) {}}void withdraw(int amount) {\ttry {\t\tsemWithraw.acquire();  // 입금보다 먼저 수행하는 것을 막는다.\t\tsem.acquire();\t} catch (InterruptedException e) {}\tint temp = balance - amount;\tSystem.out.print(\"-\");\tbalance = temp;\tsem.release();\tsemDeposit.release();  // 출금 수행이 완료되면 block되었던 입금 프로세스를 깨워준다.}int getBalance() {\treturn balance;}+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-balance = 0ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-09-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-2.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-08-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-1-html": {
        "title": "08: 프로세스 동기화 Part 1",
        "tags": "OS, Synchronization, Critical Section Problem",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스 동기화가 발생하는 예시와 목적, 그리고 그것을 해결하기 위한 원칙에 대해 알아본다.1. 프로세스 동기화란?  하나의 자원을 한 순간에 하나의 프로세스(쓰레드)만이 이용하도록 제어하는 것1.1 배경현대 컴퓨터의 메모리에는 여러 프로세스가 존재하는데, 이러한 프로세스들이 하나의 공유 메모리나 또 다른 프로세스에 접근할 때는 매우 신중해야 한다. 이처럼 한 프로세스가 다른 프로세스에게 영향을 받거나 주는 프로세스를 Cooperating process라고 한다. 반대로 아무런 영향을 미치지 않는 독립적인 프로세스는 Independent process이다.현대 컴퓨터 환경에는 cooperating process가 훨씬 많이 존재하고, 이들은 서로 영향을 미치기 때문에 데이터나 흐름에 대한 동기화가 매우 중요하다. 프로세스 사이에 동기화를 하는 것을 프로세스 동기화(Process Synchronization) 라고 한다.(현재에는 대부분 쓰레드 기준으로 스위칭을 하므로, Thread synchronization으로 많이 불린다.)1.2 필요성대표적인 예로 기차표 예매가 있다. 어느 시간에 한 좌석의 기차표는 반드시 하나만 존재해야한다. 그런데 이를 예매하려는 사용자(프로세스)는 여러 명이다. 이 사용자들이 동시에 하나의 좌석 기차표를 구매하려고 하면 어떠한 일이 발생할까? 실제 환경에서는 당연하게도 동기화 문제를 해결한 시스템이므로 한 사람만이 기차표를 예매할 수 있을 것이다. 만약 동기화에 문제가 발생한다면 한 기차표를 여러 사람이 예매하는 불상사가 발생할 수 있다.1.3 목표프로세스 동기화는 여러 프로세스가 공유하는 자원의 일관성을 유지하는 것이다. 가령 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때 이 프로세스들의 순서를 정하여 데이터의 일관성을 유지시켜주어야 한다. 이 부분에 대한 자세한 목적은 아래의 예를 파악하며 문제를 인지한 후에 명확하게 재정의하겠다.2. Bank Account Problem(은행 계좌 문제)동기화의 필요성을 가장 잘 느낄 수 있는 은행 계좌 문제에 대해 알아본다.2.1 문제 설명동기화 문제 중에서 대표적인 은행 계좌 문제를 살펴보자. 은행에는 하나의 계좌에 입금, 출금을 할 수 있다. 여기서 계좌는 공유하는 자원이고, 입금과 출금은 각각 프로세스라고 볼 수 있다. 부모님이 자식에게 입금을 하고, 자식은 출금을 하는 상황을 자바로 구현한 코드는 아래와 같다.// 계좌class BankAccount {\tint balance;\tvoid deposit(int amount) {\t\tbalance = balance + amount;\t}\tvoid withdraw(int amount) {\t\tbalance = balance - amount;\t}\tint getBalance() {\t\treturn balance;\t}}입금, 출금, 잔액조회 함수를 멤버함수로 갖는 클래스를 구현한다.// 입금 프로세스class Parent extends Thread {\tBankAccount b;  // 생성자는 공유하는 계좌를 초기값으로 가진다.\tParent(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {   // run(): 쓰레드가 실제로 동작하는 부분(치환)\t\tfor (int i = 0; i &lt; 100; i++)\t\t  b.deposit(1000);\t}}멤버 변수로 계좌를 가지고, 이것을 생성할 때 인자로 받는 클래스이다. 해당 클래스에서 run()은 입금을 100번 수행한다.// 출금 프로세스class Child extends Thread {\tBankAccount b;  // 생성자는 공유하는 계좌를 초기값으로 가진다.\tChild(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i = 0; i &lt; 100; i++)\t\t  b.withdraw(1000);\t}}멤버 변수로 계좌를 가지고, 이것을 생성할 때 인자로 받는 클래스이다. 해당 클래스에서 run()은 출금을 100번 수행한다.// Test.javaclass Test {\tpublic static void main(String[] args) throws InterruptedException {\t\tBankAccount b = new BankAccount();\t\tParent p = new Parent(b);\t\tChild c = new Child(b);\t\tp.start();   // start(): 쓰레드를 실행하는 메서드\t\tc.start();\t\tp.join();    // join(): 쓰레드가 끝나기를 기다리는 메서드\t\tc.join();\t\tSystem.out.println(\"balance = \" + b.getBalance());\t}}main 함수에서는 위에서 만든 클래스들을 사용하여, 계좌를 공유하는 두 개의 쓰레드를 만든다. 그리고 부모, 자식 클래스에서 각각 입금과 출금을 100번씩 수행하고, 결과적으로 남은 잔액을 조회한다. 잔액은 0이 나와야 할 것이다.// Resultbalance = 0이 결과는 정상적이다. 100번 1,000원을 입금하고, 100번 1,000원을 출금하면 잔액은 0원이 남는다. 위 코드는 2개의 쓰레드가 동작하고 있음에도 불구하고 동기화 문제가 발생할 확률은 매우 낮다. 반복이 100번 밖에 안 일어나는 매우 간단한 코드 이기 때문이다.2.2 동기화 문제 발생실제 상황에서는, 입금, 출금 명령을 내리고 이 명령이 전달되는데 까지 시간이 소요된다. 그런 상황을 만들기 위해 출금하는 과정에서 temp라는 필요없는 변수를 추가하고, +,-를 출력하고, 반복 횟수를 1000번으로 늘렸다.// 계좌class BankAccount {\tint balance;\tvoid deposit(int amount) {\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tvoid withdraw(int amount) {\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}// Result++++++++++++++++++++++++++++++++++------------------------------------------------------------------------------------------------------------------------+++++++++----------------------------------------------++++++++++++++++++++++++++++++++----+++++++-+++++----+++--------------------------------------------------------+++++++-++++-+++++++++-------++++++++++++++++++++++++++++++++++++++++++++++++++++++++---------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-++++++++++++-------------------++++++++++++++++++++-++++++++++++++++++++++++++++++++-+-------------------------------------------------------------------------+++++++++++-+++++++----------------------------------------+-------+------------+------+------------------------------------------------------------------------+-------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------+-------+----------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+--------------------------+-------------------------------------------------------------------------------++---------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++balance = 1000000+는 입금을 한 경우, -는 출금을 한 경우이고, 주목할 점은 balance값이 0이 아닌 1000000이라는 알 수 없는 값이 출력되었다. 또한 여러번 실행할 경우 100000이라는 값이 고정되어 출력되는 것도 아니다. 결과가 불일치하며, 비일관적이다. (비일관적인 이유는 운영체제에서 쓰레드를 스위칭하는 패턴이 매번 다르기 때문이다.)약간의 시간 지연을 준 것만으로도 여러 쓰레드가 하나의 공유 자원을 사용하는 프로그램은 망가지게 된다.2.3 왜 발생할까?이러한 문제가 발생하는 원인은 공통변수(common variable)에 대한 동시 업데이트(concurrent update) 때문이다.위 예제에서 공통 변수는 계좌의 잔액이다. 이에 접근하는 프로세스의 코드를 보면 다음과 같다.balance = balance + amount;   // 입금balance = balance - amount;   // 출금이는 자바 문법에서는 한 줄이라 문제가 없어 보이지만, 로우 레벨(어셈블리어)로 내려가면 여러 줄로 구현된다. 예를 들어, balance를 업데이트 하는 하이 레벨 코드 1줄이 로우 레벨에서 3줄로 구현된다고 하자.  공유 변수인 현재 잔액을 복사한다.  현재 잔액에서 명령을 수행한다.  나온 결과를 가지고 잔액을 갱신한다.그런데, parent가 수행하던 도중에 1000번을 다 수행하지 못한 상황에서 interrupt(이 경우에는 시간 지연을 걸었으므로 timer interrupt가 되겠다.)가 걸려 2번 라인에서 멈췄다고 생각해보자. parent가 1000원을 입금했지만, 업데이트가 되지 않아 여전히 현재 잔액은 0이다.이번에는 child가 부모님이 용돈을 넣은 줄 알고 신나서 돈을 뽑는 상황을 생각해보자. 잔액을 확인했더니, 아직 0이다. 그래서 child는 마이너스 통장을 통해 돈은 인출하고 현재 잔액은 -1000이 된다.따라서 이 경우, 입금과 인출이라는 행위는 프로세스 입장에서 원자성을 갖는 행위이므로 동기화가 필수적이다. 기억이 안난다면 이 글을 보자.가볍게 이해하는 컴퓨터 01: 용어 정리3. 임계구역(Critical section) 문제위의 예에서 보았던 문제를 임계구역 문제라 한다. 임계구역은 여러 개의 쓰레드가 수행되는 시스템에서 각 쓰레드들이 공유하는 데이터(변수, 테이블, 파일 등)를 변경하는 코드 영역을 말한다. 이는 동기화에서 중요한 문제 중 하나이다. 은행계좌 문제에서의 임계구역은 다음과 같다.void deposit(int amount) {  balance = balance + amount;}void withdraw(int amount) {  balance = balance - amount;}3.1 해결 방법임계구역을 해결하기 위해서는 3가지 조건이 만족해야한다.  Mutual exclusion(상호배타)          오직 한 쓰레드만이 진입 가능하다. 한 쓰레드가 임계구역에서 수행 중인 상태에서는 다른 쓰레드는 절대 이 구역에 접근할 수 없다.        Progress(진행)          한 임계구역에 접근하는 쓰레드를 결정하는 것은 유한 시간 이내에 이루어져야한다.      누가 먼저 들어갈 것인지 빠르게 결정해라        Bounded waiting(유한대기)          임계구역으로 진입하기 위해 대기하는 모든 쓰레드는 유한 시간 이내에 해당 임계구역으로 진입할 수 있어야 한다.      기다리는 모든 쓰레드가 진입가능하도록 만들어라.      4. 프로세스/쓰레드 동기화의 목적  원하는 결과값을 도출하도록 임계구역 문제를 해결한다.  프로세스의 실행 순서를 원하는대로 제어한다.  Busy wait 등과 같은 비효율성을 제거한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-08-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-07-ec-93-b0-eb-a0-88-eb-93-9c-html": {
        "title": "07: 쓰레드(Thread)",
        "tags": "OS, CPU, Thread",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "Thread에 대해서 알아본다.쓰레드(Thread)  쓰레드는 프로그램 내부의 흐름(맥)이다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void){  int n = 1;  int m = 10;  cout &lt;&lt; n * m;  while(n &lt; m)    n++;  cout &lt;&lt; \"end\" &lt;&lt; endl;}이런 코드는 하나의 흐름을 가지고 있고 이것을 쓰레드라 부른다. 일반적으로 하나의 프로그램은 하나의 쓰레드를 갖는다.다중 쓰레드(Mulitithreads)하나의 프로그램에 쓰레드가 2개 이상 존재하는 것을 다중 쓰레드라고 한다. 이렇게 한 프로그램에 여러 개의 쓰레드 즉, 흐름이 있을 수 있는 이유는 쓰레드가 빠른 시간 간격으로 스위칭되기 때문이다. 이러한 동작으로 사용자는 여러 쓰레드가 동시에 실행되는 것처럼 보인다.이 때, 동시에 수행되는 것 처럼 보이는 것을 concurrent, 실제 동시에 수행되는 것을 simultaneous라고 한다.  concurrent          CPU가 하나인 환경에서 스위칭에 의해 동시에 수행        simultaneous          여러개의 CPU 환경에서 실제로 동시에 수행되는 경우      예시다중 쓰레드를 사용하는 대표적인 예는 Web browser 이다. 화면을 출력하는 쓰레드와 데이터를 읽어오는 쓰레드가 기본적으로 따로 수행하고 있다. 그 외에도 Word processor, Media player 등 현재 대부분의 프로그램은 다중 쓰레드로 동작한다.현대 운영체제의 Switching 단위이전의 CPU 스케줄링에서 하나의 프로세스가 수행하다가 다른 프로세스로 넘어간다고 하였는데, 이는 예전의 방식이다. 현재 운영체제에서는 대부분 다중 쓰레드를 지원하기 때문에 하나의 프로세스 안에서 여러 쓰레드를 수행하다가 다른 프로세스로 넘어가서 그 프로세스의 쓰레드를 수행한다. 그러므로 현대 운영체제의 context switching 단위는 프로세스가 아닌 쓰레드 단위이다.Thread VS Precess이 부분을 제대로 이해하기 위해 process를 보고오자.가볍게 이해하는 컴퓨터 07: 운영 체제가 하는 일운영체제 정리 05: 프로세스 관리프로세스는 다른 프로세스와 완전히 독립적이다. 해당 프로세스가 가지는 구조로는 Code, Data, Heap, Stack이 있다. 이 때 쓰레드는 자기가 속한 프로세스의 일부 메모리를 공유한다. 집이라면 각 개인 구성원이 거실을 공유하는 셈이다.            공유      독립                  Code      Stack              Data      PC(program counter)              Heap      SP(stack pointer)                     Registers      Thread가 독립적 요소를 가져야 하는 이유현대 운영체제는 결국 Context Switching의 최소단위를 thread로 잡고 있기 때문이다. 결국 CPU가 처리하는 것은 thread이고, 그렇기 때문에 현재 실행 흐름을 독립적으로 기록할 필요가 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-07-%EC%93%B0%EB%A0%88%EB%93%9C.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-06-cpu-ec-8a-a4-ec-bc-80-ec-a5-b4-eb-a7-81-html": {
        "title": "06: CPU 스케쥴링",
        "tags": "OS, CPU, Scheduling",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "CPU 스케쥴링에 대해 알아본다.CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다. 이때 다음 프로세스가 어느 프로세스인지를 선택하는 알고리즘을 CPU Scheduling 알고리즘이라고 한다. 간단히 생각해보면 먼저 온 프로세스가 먼저 실행되는 것이 가장 좋을 것이라 생각할 수 있다. 하지만 여러 상황에서 사용되는 컴퓨터 환경에서 꼭 이러한 방법이 좋다고 할 수 없다. (단순한 환경에서도 이 방법이 반드시 빠른 것도 아니다.) 그러므로 CPU 스케줄링에는 여러가지 방법이 존재한다.1. 스케쥴링의 유형유형으로는 Preemptive 와 Non-preemptive가 있다.1.1 PreemptivePreemptive(선점)은 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생한 것도 아니고 모든 작업을 끝내지도 않았는데, 다른 프로세스가 해당 CPU를 강제로 점유 할 수 있다. 즉, 프로세스가 정상적으로 수행중인 가운데 다른 프로세스가 CPU를 강제로 점유하여 실행할 수 있는 것이다. 급똥 우선순위1.2 Non-preemptiveNon-preemptive(비선점)은 말 그대로 preemptive와 반대이다. 한 프로세스가 한 번 CPU를 점유했다면, I/O나 인터럽트 발생 또는 프로세스 종료가 될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다. 순서대로 들어가자2. Scheduling criteriaScheduling criteria(척도)는 스케줄링의 효율을 분석하는 기준들이다.  CPU Utilization(이용률, %)          CPU가 수행되는 비율        Throughput(처리율, jobs/sec)          단위시간당 처리하는 작업의 수(처리량)        Turnaround time(반환시간)          프로세스의 처음 시작 시간부터 모든 작업을 끝내고 종료하는데 걸린 시간이다.(CPU, waiting, I/O 등 모든 시간을 포함한다.) 반환시간은 짧을 수록 좋다.        Waiting time(대기시간)          CPU를 점유하기 위해서 ready queue에서 기다린 시간을 말한다.(다른 큐에서 대기한 시간은 제외한다.)        Response time(응답시간)          일반적으로 대화형 시스템에서 입력에 대한 반응 시간을 말한다. 사용자와의 상호작용을 중요로 하는 프로세스의 경우이다.      3. CPU Scheduling AlgorithmsCPU에서 프로세스의 순서를 처리하는 알고리즘에 대해 알아본다.3.1 First-Come, First-Served(FCFS)FCFS는 먼저 온 프로세스가 먼저 CPU를 점유하는 방식이다. 이는 매우 단순하고 많이 사용하는 방법이지만, 모든 부분에서 효율적인 것은 아니다.Gantt Chart            Process      Burst Time(msec)                  P1      24              P2      3              P3      3      위의 표를 아래의 그림으로 나타낸 것을 Gantt Chart라 한다. P1, P2, P3 순으로 메모리에 도착했다고 가정했을 때, P1, P2, P3의 총 대기시간의 평균을 구해보자.  Average Waiting Time = ${0+24+27\\over 3} = 17msec$ 이다.그런데 만약 P3, P2, P1 순으로 들어왔다고 생각해보자.  Average Waiting Time = ${6+3+0\\over 3} = 3msec$ 이다.두 예제에서 모든 프로세스가 끝난 시간은 30msec로 같지만, 평균 대기시간으로 봤을 때는 위의 예제는 17msec이고 아래는 3msec로 차이가 난다. 즉, 들어온 순서로 수행한다고 해도 반드시 효율적인 것은 아닌 것을 알 수 있다.이것은 공중화장실을 기다리는 맨날 더럽냐 3명의 사람으로 치환해서 생각할 수 있다. 빠른 맺고 끊음이 가능한 선수가 먼저 입장하는 것이 공공의 이익을 최대화 할 수 있다. 응?위 예제처럼 P1, P2, P3 순서로 들어와 시간이 오래 걸리는 현상을 Convoy Effect 라고 한다. 이는 CPU 시간을 오래 사용하는 프로세스가 먼저 수행하는 동안 나머지 프로세스들은 그 만큼 오래 기다리는 것을 말한다.FCFS의 특징 정리  Convoy Effect가 발생할 수 있다.  Non-preemptive 방식이다. 하나의 프로세스가 끝나기 전에 다른 프로세스가 끼어들 수 없다.3.2 Shortest-Job-First(SJF)SJF는 이름에서도 나타나듯이 가장 짧게 수행되는 프로세스가 가장 먼저 수행되는 것을 말한다. FCFS에서 보았듯이 수행 시간이 짧은 프로세스가 먼저 오는 것이 평균 대기시간이 짧은 것을 알 수 있었다. 이를 이용한 것이 SJF이다.            Process      Burst Time(msec)                  P1      6              P2      8              P3      7              P4      3        Average Waiting Time(AWT) = ${3+16+9+0\\over 4} = 7msec$ 이다.위의 예를 FCFS로 나타냈을 때 평균 대기시간을 계산해보자.  Average Waiting Time(AWT) = ${0+6+14+21\\over 4} = 10.25msec$ 이다.SJF와 FCFS의 평균 대기시간을 살펴보면 당연히 SJF가 더 짧은 것을 볼 수 있다. SJF가 평균 대기시간 기준으로 어떠한 방법보다 짧은 것은 이미 수학적으로 증명되어 있다. 그러므로 어떠한 예제를 보더라도 SJF가 AWT는 가장 짧다.한계이를 보면 SJF가 가장 효율적인 CPU 스케줄링 방법으로 이를 쓰면 될 것 같지만, 사실은 이 스케줄링 방법은 매우 비현실적이다. 왜냐하면 현실적인 컴퓨터 환경에서는 프로세스의 CPU 점유 시간(burst time)을 알 수 없다. 왜냐하면 한 프로세스가 실행 중에는 많은 변수가 존재하기 때문에 CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수 밖에 없다. 실제 측정한 시간으로 예측해서 SJF를 사용할 수도 있지만, 이는 오버헤드가 매우 큰 작업으로 잘 사용되지 않는다.Preemptive &amp; non-preemptive 방식            Process      Arrival Time      Burst Time(msec)                  P1      0      8              P2      1      4              P3      2      9              P4      3      6      non-preemptive가장 먼저 도착한 P1이 수행되는 동안 P2, P3, P4 모두 도착하지만, non-preemptive이므로 이미 수행중인 프로세스가 끝날 때까지 기다려야 한다. 일단 시작한 놈은 그대로 하고 남은 놈들에 대해서 대기시간이 짧은 것에 우선순위를 주자.  Average Waiting Time(AWT) = ${0+7+15+9\\over 4} = 7.75msec$ 이다.​Preemptive이번에는 p]Preemptive이므로 프로세스가 도착할 때마다, 어느 프로세스가 가장 짧은 것인지 선택해야 한다. 주목할 점은 P2 프로세스가 도착했을 때, 현재 남은 burst time 중 가장 짧은 프로세스가 P2이므로 P1을 수행하던 것을 멈추고 P2가 수행을 시작한다.  Average Waiting Time(AWT) = ${9+0+15+2\\over 4} = 6.5msec$ 이다.Preemptive SJF는 예제에서 살펴보았듯이 현재 남아있는 시간 중 가장 짧은 프로세스를 선택하므로 Shortest-Remaining-Time-First(최소잔여시간 우선) 이라 불리기도 한다.SJF의 특징 정리  AWT가 가장 짧다.  프로세스의 실행 시간을 알 수 없기 때문에 비현실적이다. 이를 가능케 하기 쉬해서는 예측이 필요하다.  Preemptive &amp; non-preemptive 둘다 가능하다.          이 중 Preemptive SJF는 Shortest-Remaining-Time-First(최소잔여시간 우선)이라 불린다.      3.3 PriorityPriority 스케줄링은 말그대로 우선순위가 높은 프로세스가 먼저 선택되는 스케줄링 알고리즘이다. 운영체제에서 일반적으로 우선순위는 정수값으로 나타내며, 작은 값이 우선순위가 높다.(Unix/Linux 기준)돈 주며 화장실 앞 줄을 사는 행위            Process      Burst Time(msec)      Priority                  P1      10      3              P2      1      1              P3      2      4              P4      1      5              P5      5      2      표에서 우선순위 값이 가장 낮은 순서대로 수행한 모습을 간트 차트로 나타내었다.  Average Waiting Time(AWT) = ${6+0+16+18+1\\over 5} = 8.2msec$ 이다.우선 순위를 정하는 방법우선순위를 정하는 방법은 크게 내부적인 요소와 외부적인 요소 두 가지로 나뉜다.  Internal          time limit, memory requirement, I/O to CPU burst(I/O작업은 길고, CPU 작업은 짧은 프로세스 우선) 등        External          amount of funds being paid, political factors 등      Priority 스케줄링 역시 preemprive 와 non-preemptive 두 방식 모두 사용할 수 있다.한계Priority 스케줄링의 문제점은 Starvation(기아)이 있다. 못 싸는 놈은 평생 못싸 ㅠㅠ Starvation은 말 그대로 CPU의 점유를 오랫동안 하지 못하는 현상을 말한다. Priority 스케줄링 방식에서 우선순위가 매우 낮은 프로세스가 ready queue에서 대기하고 있다고 가정해보자. 이 프로세스는 아무리 오래 기다려도 CPU를 점유하지 못할 가능성이 매우 크다. 실제 컴퓨터 환경에서는 새로운 프로세스가 자주 ready queue에 들어온다. 이러한 프로세스가 모두 우선순위가 높은 상태라면 이미 기다리고 있던 우선순위가 낮은 프로세스는 하염없이 기다리고만 있는 상태로 남아있을 수 있다.해결 방법이를 해결하는 방법 중 하나는 aging이 있다. 이 방식은 ready queue에서 기다리는 동안 일정 시간이 지나면 우선순위를 일정량 높여주는 것이다. 복지 그러면 우선순위가 매우 낮은 프로세스라 하더라도, 기다리는 시간이 길어질수록 우선순위도 계속 높아지므로 수행될 가능성이 커진다.Priority의 특징 정리  우선 순위가 높은 녀석 부터 처리  그렇기 때문에 평생 처리 못받는 녀석이 생긴다. (Starvation)  이를 방지 하기 위해 Ready 상태에서 일정시간이 지나면 우선 순위를 높여준다. (aging)3.4 Round-Robin(RR)Round-Robin은 원 모양으로 모든 프로세스가 돌아가며 스케줄링하는 것을 말한다. 이는 시분할 시스템에서 주로 사용하는 방식이다. 일정 시간을 정하여 하나의 프로세스가 이 시간동안 수행하고 다시 대기 상태로 돌아간다. 그리고 다음 프로세스가 역시 같은 시간동안 수행한 후 대기한다. 이러한 작업을 모든 프로세스가 돌아가면서 하며, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아와서 반복한다.위에서 말한 일정 시간을 Time Quantum(Time Slice)이라 부른다. Time Quantum은 일반적으로 10 ~ 100msec 사이의 범위를 갖는다. Round-Robin은 기본적으로 preemptive 이다. 한 프로세스가 종료되기 전에 time quantum이 끝나면 다른 프로세스로 CPU를 넘겨주기 때문이다.            Process      Burst Time(msec)                  P1      24              P2      3              P3      3      time Quantum = 4msecRound-Robin 방식에서는 time quantum이 끝나면 CPU는 현재 프로세스를 대기상태로 보내고 다음 프로세스를 수행한다. 예제에서 P1이 0msec에 수행을 시작하여 종료되기 전에 time quantum 시간이 끝나여 P2가 수행되는 모습을 볼 수 있다. 그리고 P2, P3는 time quantum이 끝나기전에 수행이 끝났고, 마지막 남은 P1은 다른 프로세스가 없으므로 time quantum이 끝나더라도 종료될 때까지 계속해서 수행하는 모습이다.  Average Waiting Time(AWT) = ${6+4+7\\over 3} = 5.66msec$ 이다.한계RR방식은 time quantum 크기에 따라 AWT와 같은 스케줄링 척도가 바뀐다. 그러므로 RR 방식은 time quantum에 매우 의존적인 것을 알 수 있다.만약 time quantum 크기가 무한에 가깝게 설정한다면 FCFS와 동일하게 동작한다. 반대로 time quantum 크기를 0에 가깝게 설정하면 switching overhead가 매우 증가하여 비효율적이다. 결과적으로 time quantum 은 적당한 크기로 설정해주어야 하는데, 일반적으로 위에서 말했듯이 10 ~ 100msec 으로 정한다.RR의 특징 정리  모든 프로세스에 일정한 시간(time quantum)을 주어서 관리한다.  따라서 time quantum에 매우 의존적이다. 적당한 값(10 ~ 100msec)이 중요하다.          $\\infty$ ~ FCFS      $0$ ~ switching overhead가 매우 증가      3.5 Multilevel QueueMultilevel Queue를 살펴보기 전에 프로세스 그룹에 대해 살펴보자. 프로세스는 기준에 따라 여러 그룹으로 나눌 수 있다.  System processes          운영체제 커널 수준의 프로세스        Interactive processes          유저 수준의 대화형 프로세스 (게임)        Interactive editing processes          Word Processor        Batch processes          대화형 프로세스의 반대인 것으로 일정량을 한 번에 처리하는 프로세스(Ex, 컴파일러)        Student processes위와 같이 여러 성격에 따라 프로세스 그룹을 나눌 수 있는데 이를 하나의 큐에 사용하는 것은 비효율적이라고 판단하였다. 그래서 각 그룹에 따라 큐를 두어 여러 개의 큐를 사용하는 것이 Muitilevel Queue 방식이다.위 그림은 각 그룹에 따라 큐를 나눈 것이다. 그리고 각 큐마다 다른 규칙을 지정할 수도 있다.먼저, 큐마다 우선순위를 지정해줄 수 있다. 프로세스 그룹을 보면 System process는 커널 수준에서 중요한 작업이므로 우선순위가 높은 그룹이라 볼 수 있다. 위 그림에서 System process, Interactive process, Batch process 순으로 우선순위가 높은 순서이다. Batch 프로세스는 운영체제의 개입이 매우 적으므로 우선순위가 가장 낮다고 볼 수 있다.위의 방식 이외에도 큐에 따라 여러 기준을 둘 수 있다. 큐마다 CPU 시간을 다르게 줄 수도 있고, 큐마다 다른 스케줄링 방식을 사용할 수도 있다.Multilevel Queue의 특징  프로세스를 그룹으로 나눈다.  각각의 Queue에 절대적 우선 순위가 존재한다.  CPU time을 Queue에 차등 배분한다.  각 Queue는 독립된 scheduling 정책을 갖는다.3.6 Multilevel Feedback QueueMultilevel Feedback Queue도 Multilevel Queue와 같이 여러 개의 큐를 사용한다는 점에서 유사하다.위 그림을 보면 먼저 모든 프로세스는 가장 위의 큐에서 CPU의 점유를 대기한다. 이 상태로 진행하다가 이 큐에서 기다리는 시간이 너무 오래 걸린다면 아래의 큐로 프로세스를 옮긴다. 이와 같은 방식으로 대기 시간을 조정할 수 있다. 그리고 Multilevel Feedback Queue에서도 각 큐마다 다른 스케줄링, 다른 우선순위 등을 사용할 수 있다.만약 우선순위순으로 큐를 사용하는 상황에서 우선순위가 낮은 아래의 큐에 있는 프로세스에서 starvation 상태가 발생하면 이를 우선순위가 높은 위의 큐로 옮길 수도 있다.대부분의 상용 운영체제는 여러 개의 큐를 사용하고 각 큐마다 다른 스케줄링 방식을 사용한다. 프로세스의 성격에 맞는 스케줄링 방식을 사용하여 최대한 효율을 높일 수 있는 방법을 선택한다.Multilevel Feedback Queue의 특징  여러개의 Queue를 가진다.  다른 Queue로 점진적 이동한다.          모든 프로세스는 각자의 하나의 Queue로 진입한다.      너무 많은 CPU time 사용시 다른 Queue로 이동한다.      기아 상태 우려시 우선 순위 높은 Queue로 이동한다.      ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-06-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-ea-b4-80-eb-a6-ac-html": {
        "title": "05: 프로세스와 관리",
        "tags": "OS, process, 메모리 구조, 프로세스 구조",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스의 정의, CPU 스케쥴러, 멀티 프로그래밍에 대해 알아본다.1. 프로세스(Process)프로세스는 메인 메모리에 할당되어 실행중인 상태인 프로그램을 말한다. 프로그램은 일반적으로 하드디스크(보조기억장치)에 저장되어 아무 일도 하지 않는 상태이다. 프로세스는 실행하면서 stack pointer, data, text, register 등이 끊임없이 변한다. 프로세스는 job, task 등으로 불리기도 한다.1.1 프로세스의 생성과 종료프로세스는 프로세스에 의해 만들어진다. 컴퓨터가 부팅이 되면 운영체제가 메모리에 올라오는데 운영체제가 처음으로 수행하는 일 중에 하나는 최초의 프로세스를 생성하는 것이다. 이렇게 처음 만들어진 프로세스가 다른 프로세스를 만들고 그 프로세스가 또 다른 프로세스를 만드는 과정을 반복한다.위와 같이 최초의 프로세스는 Init이다. 이 이름은 운영체제마다 다르고, init은 UNIX 운영체제 기준 이름이다. 여기서 여러 다른 프로세스들이 생성되면 위와 같은 그림처럼 트리 모양으로 나타낼 수 있다.여기서 프로세스를 생성한 쪽을 부모 프로세스, 만들어진 프로세스를 자식 프로세스라고 한다. 같은 부모를 갖는 자식 프로세스 끼리는 서로 Sibling(형제) 프로세스라고 한다.프로세스는 각각 고유의 번호를 갖는데 이를 PID(Process Identifirer)라고 한다. PID는 일반적으로 정수형(integer)으로 표현한다. PPID는 부모의 PID를 말한다.1.1.1 프로세스 생성새로운 프로세스를 만드는 시스템 콜이 존재하는데, 이는 fork() 라 한다. 만들어진 프로세스에서 어떠한 파일을 실행하려면 exec() 시스템 콜을 사용한다.1.1.2 프로세스 종료프로세스를 종료하는 시스템 콜은 exit() 이다. 한 프로세스가 종료되면 해당 프로세스가 사용한 모든 자원(메모리, 파일, I/O 등)을 회수해야한다. 이러한 회수된 자원과 권한은 모두 운영체제로 되돌아가야한다.1.2 프로세스의 구조출처 : https://mintnlatte.tistory.com/출처 : https://rookieboxsite.wordpress.com1.2.1 Stack  프로그램의 지역 변수, 함수, return 주소를 포함한다.  함수 호출을 하면 해당 주소가 스택영역에 저장되어 있다가 return하면 pop된다.1.2.2 Heap  힙 영역에는 프로그램이 실행되는 동안 동적으로 사용할 데이터들이 저장된다.  c언어의 malloc을 이용해서 메모리를 동적할당하면 힙 영역에 저장된다.(free시키지 않으면 힙 영역에 계속 들어 있음)1.2.3 Data  데이터 영역에는 전역 변수와 정적 지역 변수가 포함되어 있다.데이터 영역은 BSS, Data로 나눠진다.  BSS는 초기화 되지 않은 변수들이 저장초기화 된 변수들이 저장된 영역으로 0으로 자동 초기화해 준다.  Data는 초기값을 설정한 전역 변수와 정적 변수를 위한 영역이다.BSS,Data로 구분하는 이유?  초기화 된 데이터는 초기값을 저장해야 함으로 Data영역에 저장되서 Rom에 저장된다. 하지만 초기화 되지 않은 데이터 까지 Rom에 저장되면 큰 size의 rom이 필요하므로 구분한다 ( 초기화 되지 않은 데이터는 ram에 저장하자)1.2.4 Text  해당 코드가 저장되는 영역이다.  힙과 ,스택영역에서 오버플로우가 발생할 것을 대비해서 힙/스택의 아래부분에 위치한다.  실행 순서등이 저장되어 있다.  읽기 전용이다.  다른 프로세스에서 참조 가능하다.1.2.5 정리            크기 변화      O      X                         Stack      Text                     Heap      Data                            Bss        Text          Program Counter(다음번에 실행될 명령어의 주소를 저장하는 레지스터 : CPU에게 줄 예정)      프로그램 코드        Data          전역 변수 저장      스태틱 변수 저장        Heap          메모리 관리      동적 메모리 할당 (system call로 관리)      메모리에 접근하기 때문에 주의해야 함        Stack          임시 데이터 저장      지역 변수      반환 주소      1.3 프로세스 상태  New: 프로그램이 메인 메모리에 할당된다.  Ready: 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친다.  Running: CPU가 해당 프로세스를 실행한다.  Waiting: 프로세스가 끝나지 않은 시점에서 I/O로 인해 CPU를 사용하지 않고 다른 작업을 한다. (해당 작업이 끝나면 다시 CPU에 의해 실행되기 위해 ready 상태로 돌아가야 한다.)  Terminated: 프로세스가 완전히 종료된다.위 그림은 프로세스 상태 전이도의 모습이다. new에서부터 프로세스가 어떤 작업에 의해 상태가 변하는지 나타낸다. running에서 ready로 변할 때는 time sharing system에서 해당 프로세스가 CPU시간을 모두 소진하였을 때 인터럽트에 의해 강제로 ready상태로 변하고, CPU는 다른 프로세스를 실행시킨다.1.4 PCB(Process Control Block)PCB는 프로세스에 대한 모든 정보가 모여있는 곳으로, Task Control Block(TCB) 이라고도 한다. PCB안에는 프로세스의 상태, 프로세스 번호(PID), 해당 프로세스의 program counter(pc), register값, MMU(Memory Management Unit)정보, CPU점유 시간 등이 포함되어 있다. PCB는 운영체제 내부의 프로세스를 관리하는 코드 부분에 저장되어 있다.CPU는 한 프로세스가 종료될 때까지 수행하는 것이 아니라 여러 프로세스를 중간 중간에 바꿔가면서 수행한다. 그러므로 CPU는 수행중인 프로세스를 나갈 때, 이 프로세스의 정보를 어딘가에 저장하고 있어야 다음에 이 프로세스를 수행할 때 이전에 수행한 그 다음부터 이어서 작업할 수 있다. 이러한 정보를 저장하는 곳이 PCB이다.1.5 프로세스 큐(Queue)프로세스의 생애 주기를 생각해보면, DISK, Memory, cpu등을 거치게 된다. 갈수록 좁아지는 공간과, 한정된 자원 때문에 병목현상이 발생할 수 밖에 없다. 그렇기 때문에 우리는 먼저 실행된 프로세스와 같은 규칙에 따라 이 프로세스들을 줄세워 관리해야 한다. 이러한 순서를 Queue로 관리한다.  Job Queue: 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐이다.  Ready Queue: CPU 점유 순서를 기다리는 큐이다.  Device Queue: I/O를 하기 위한 여러 장치가 있는데, 각 장치를 기다리는 큐가 각각 존재한다.Scheduling(스케쥴링)위와 같이 여러 큐가 존재하는데, 각 큐 내부에 저장된 실제 데이터는 각 프로세스의 PCB가 저장되어 있다. 그리고 이러한 순서를 기다리는 공간이 있다면 이 순서를 정해주는 알고리즘이 있어야 한다. 이러한 알고리즘을 스케줄링(Scheduling)이라 한다.  Job Queue - Job Scheduler(Long-term scheduler)  Ready Queue - CPU Scheduler(Short-term scheduler)  Device Queue - Device SchedulerJob queue의 순서를 정해주는 job scheduler를 long-term scheduler라고도 하는데, 이는 이 스케줄링이 발생하는 시간이 비교적 오래걸리기 때문이다.(대략 초~분) 반면에 ready queue의 스케줄러를 short-term scheduler라고도 하는데, 이는 스케줄링이 발생하는 시간이 매우 짧기 때문이다. CPU scheduling은 말 그대로 프로세스가 CPU를 점유하는 순서를 정해주는데 이는 매우 빠른 시간안에 이루어져야한다. 현대 컴퓨터가 여러 프로그램을 동시에 사용하는 것과 같은 효과를 주는 이유가 이 스케줄링 속도가 매우 빠르게 이루어지기 때문이다.2. 멀티 프로그래밍멀티프로그래밍은 단일 프로세서(CPU) 환경에서 메모리에 다수의 프로세서들을 올려둔 상태로, CPU가 쉬는 동안 다른 프로세서에게 CPU자원을 할당하여 동시에 실행하는 것처럼 보이게 하는 방법이다. 이에 관한 용어에 대해 정리해 보자.2.1 Degree of multiprogrammingDegree of multiprogramming 는 현재 메모리에 할당되어 있는 프로세스 개수를 말한다.2.2. I/O bound process VS CPU bound process프로세스는 I/O bound process 와 CPU bound process 로 나뉜다.  I/O bound process: 해당 프로세스에서 I/O(입출력) 작업이 차지는 비중이 높은 프로세스를 말한다.          Word processor            CPU bound process: 해당 프로세스에서 CPU 작업(계산)이 차지는 비중이 높은 프로세스를 말한다.          Super computer      운영체제, 정확히 말하면 job scheduler 는 이러한 프로세서의 특징을 감안하여 I/O bound process와 CPU bound process를 적절히 분배해서 메모리에 할당해주어야 한다.2.3 Medium-term schedulerMedium-term scheduler는 말그대로 short-term보다는 덜 발생하지만, long-term보다는 자주 발생하는 scheduler이다. 하는 일은 운영체제가 실행하는 동안 주기적으로 메인 메모리에 있는 전체 프로세스를 검사하여 직접적으로 CPU와 일을 하지 않는 프로세스를 찾아 보조기억장치로 옮기는 것이다. 옮기는 기준은 여러가지 있겠지만 대표적으로 장기간 사용하지 않는 프로세스가 있다.Swapping일하지 않는 프로세스를 쫒아내는 행위를 Swapping이라 부르는데, 이는 메인 메모리에서 장시간 사용하지 않는 프로세스를 하드디스크(Swap device = Backing store, 일반적으로 하드디스크는 File system + Backing store 로 구성되어 있다.)로 옮겨주고(Swap out ), 나중에 이 프로세스가 다시 사용되려고 하면 하드디스크에서 해당 프로세스를 다시 메인 메모리에 할당해준다.(Swap in)Swap out을 통해 메인 메모리의 공간이 생기므로 이를 더욱 효율적으로 사용할 수 있다. 만약 swap out된 프로세스가 다시 swap in으로 메인 메모리에 할당하려고 할 때 이전의 공간으로 할당되는 것을 보장하지는 않는다. 왜냐하면 위에 말했듯이 swap out으로 생긴 메모리 공간은 다른 프로세스가 사용할 수 있기 때문이다.2.4 Context Switching(문맥 전환)Context switching은 CPU가 한 프로세스에서 다른 프로세스로 옮겨가는 것을 말한다. 즉, 한 프로세스가 실행중인 것을 멈추고 다른 프로세스가 실행되는 것이다.  Scheduler          여기서 스케줄러는 CPU Scheduler를 말하며, CPU가 어느 프로세스를 선택할지 정한다.        Dispatcher          실제 context switching이 발생하면 CPU의 내부 데이터를 새로 시작되는 데이터로 바꿔준다. 이 과정에서 현재 실행하고 있는 프로세스의 PCB에 현재까지 작업과정으로 갱신하고, 새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원(Restore)하는 작업을 한다.        Context switching overhead          Context switching이 발생할 때마다, dispatcher에서 수행하는 작업을 매번 수행해야하며 이 모든 것은 overhead(부담)이다. 그리고 문맥 전환은 매우 자주 발생하는 작업이므로 overhead를 줄이기 위해서는 dispatcher를 구현하는 코드에 대한 효율을 최대한 높여주어야한다.      ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글프로세스의 구조Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-05-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC.html"
      }
      ,
    
      "cs-algorithm-2020-03-31-eb-b0-b1-ec-a4-80-ed-9a-a8-ec-9c-a8-ec-a0-81-ec-9d-b8-ed-95-b4-ed-82-b9-html": {
        "title": "백준(1325번): 효율적인 해킹",
        "tags": "백준, 알고리즘, DFS, BFS, 그래프",
        "date": "March 31, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 그래프 문제이다.백준(1325번) - 효율적인 해킹생각아.. 정말 쉽겠지 했는데, 되지도 않는 시간 복잡도 줄여보겠다고 확인 되지 않는 것 썼다가 하루 다 날린 문제이다. 문제는 상당히 간단하게 DFS로 풀 수 있다. 그런데, N이 10000개 이고 M이 100000이기에 이 것을 배열로 무식하게 만들 수는 없고 vector를 사용하여 데이터를 저장해야 한다.input5 43 13 24 35 3            컴퓨터      연결된      컴퓨터                  1      3                     2      3                     3      4      5              4                            5                    이런식으로 모양을 맞춘 뒤에, 1번에 들어가서 연결된 컴퓨터를 따라 DFS를 적용하면서 연결된 선을 하나씩 늘려주면 된다. 시간 복잡도는 $O(NM)$ 이다.나는 여기서 괜히 1번을 탐색할 때, 3번을 탐색하게 되므로, 3번의 탐색 결과를 배열에 저장해 둔 뒤, 2번 컴퓨터를 탐색할 때 이 정보를 가져다가 사용했다. 하지만 어떠한 반례가 존재했고 계속 틀렸다..(하아)아마 루프가 생기는 시점에 숫자가 다르게 적힐 것 같다는 생각이 든다. 그래서 그냥 무식하게 하면 된다. 무식한게 최고다 루프가 생길 수 있기 때문에 컴퓨터 한대를 탐색할 때 왔던 경로인지 체크해주는 배열이 필요하다.Code#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int N, M;vector&lt;vector&lt;int&gt;&gt; map;int hack[10001] = {0};bool checkVisit[10001] = {0};int maxNumber = -1;int ans = 0;void go(int start){    checkVisit[start] = true;    int size = int(map[start].size());    if (size == 0) return;    for (int i = 0; i &lt; size; i++) {        int nowNum = map[start][i];        if (!checkVisit[nowNum]) {            ans++;            go(nowNum);        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; M;    for (int i = 0; i &lt;= N; i++) {        vector&lt;int&gt; temp;        map.push_back(temp);    }    for (int i = 0; i &lt; M; i++) {        int end, start;        cin &gt;&gt; end &gt;&gt; start;        map[start].push_back(end);    }    for (int i = 1; i &lt;= N; i++) {        ans = 0;        fill(&amp;checkVisit[0], &amp;checkVisit[N+1], 0);        go(i);        hack[i] = ans;        maxNumber = max(maxNumber, ans);    }    for (int i = 1; i &lt;= N; i++) {        if (hack[i] == maxNumber) cout &lt;&lt; i &lt;&lt; \" \";    }    return 0;}",
        
        "url": "/cs/algorithm/2020/03/31/%EB%B0%B1%EC%A4%80-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%95%B4%ED%82%B9.html"
      }
      ,
    
      "cs-algorithm-2020-03-31-eb-b0-b1-ec-a4-80-ed-96-89-eb-a0-ac-ea-b3-b1-ec-85-88-html": {
        "title": "백준(10830번): 행렬 곱셈",
        "tags": "백준, 알고리즘, 분할정복",
        "date": "March 31, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 분할 정복 문제이다.백준(10830번) - 행렬 곱셈생각특정 행렬을 10번 곱하라는 의미는, 곧 이렇게 해석 된다.결국, 10이라는 숫자가 들어왔을 때, 2로 나누어지면 A를 제곱하고 ans에 업데이트, 나누어지지 않으면 A를 한번 곱하고, A제곱을 곱하여 업데이트 한다.typedef vector&lt;vector&lt;int&gt;&gt; matrix;matrix operator * (const matrix &amp;a, const matrix &amp;b) {    int n = int(a.size());    matrix ans(n, vector&lt;int&gt;(n));    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            for (int k = 0; k &lt; n; k++) {                ans[i][j] += a[i][k] * b[k][j];            }            ans[i][j] %= 1000;        }    }    return ans;}matrix go(matrix a, long long b){    int n = int(a.size());    matrix ans(n, vector&lt;int&gt;(n));    if (b == 0) return ans;    if (b % 2) ans = ans * a;    return ans * go(a*a, b/2);}int main(){    int n;    long long b;    cin &gt;&gt; n &gt;&gt; b;    matrix a(n, vector&lt;int&gt;(n));    for (int i = 0; i &lt; n; i++)        for (int j = 0; j &lt; n; j++)            cin &gt;&gt; a[i][j];    matrix ans == calc(a, b);    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            cout &lt;&lt; ans[i][j] &lt;&lt; ' ';        }cout &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/03/31/%EB%B0%B1%EC%A4%80-%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88.html"
      }
      ,
    
      "cs-algorithm-2020-03-31-eb-b0-b1-ec-a4-80-rgb-ea-b1-b0-eb-a6-ac-html": {
        "title": "백준(1149번): RGB 거리",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "March 31, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적계획법 문제이다.백준(1149번) - 이친수생각동적 계획법하면 유명한 문제이다. 나는 동적 계획법을 풀 때 보통 두가지 방법을 많이 사용한다.  상태에 대한 정의와 점화식을 직관으로 때린다. (감..)  순차적으로 완전 탐색 방법으로 그려본다.문제가 잘 안보이면 2번 방법을 선택하는데, 이 문제를 그려보면 다음과 같다.            1      2                  ~~R~~                     G      R              B                     R                     ~~G~~      G              B                     R                     G      B              ~~B~~             1번 집에서 2번 집으로 넘어갈 때, 2번 집의 선택에 따라 1번집의 선택은 2번 집에서 선택한 색을 제외한 두가지 색으로 정해진다. 여기서 Dp의 정의 방법의 특징이 드러나는데, 사실 나는 처음 생각할 때, 1번이 선택을 하고, 2번이 어떻게 바뀌는 지를 생각했다. 하지만 그렇게 코드를 짤 경우 굉장히 귀찮고 어렵다는 것을 깨달았다. dp의 정의는 해당 위치까지에 어떤 의미를 주는 것이 문제를 풀이할 때 훨씬 수월하다. 이것은 수열에서 일반항의 정의와 비슷하다.정의  dp[N][color] = N번 집에 color를 칠했을 때 발생하는 최소 값color 변수를 추가한 이유는, 해당 집에 어떤 색을 칠하냐에 따른 가격을 마지막에 최종적으로 비교해주기 위함이다.점화식  dp[N][color1] = min(dp[N-1][color2], dp[N-1][color3]) + cost[i][color1]color2, color3는 color1이외의 두 색을 의미한다.Code#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;int cost[1001][3];int dp[1001][3] = {0};int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++)        for (int j = 0; j &lt; 3; j++)            cin &gt;&gt; cost[i][j];    // 초기값 세팅    for (int i = 0; i &lt; 3; i++) dp[1][i] = cost[1][i];    // dp    for (int i = 2; i &lt;= N; i++)        for (int j = 0; j &lt; 3; j++)            dp[i][j] = min(dp[i-1][(j+1)%3], dp[i-1][(j+2)%3])+cost[i][j];    // 최종적인 최소값    cout &lt;&lt; *min_element(&amp;dp[N][0], &amp;dp[N][3]) &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/03/31/%EB%B0%B1%EC%A4%80-RGB%EA%B1%B0%EB%A6%AC.html"
      }
      ,
    
      "dv-css-2020-03-30-margin-ea-b2-b9-ec-b9-a8-html": {
        "title": "margin 겹침 현상",
        "tags": "css, margin",
        "date": "March 30, 2020",
        "author": "",
        "category": "DV/CSS",
        "content": "css를 먹일 때 요소들이 붙어있는 경우 margin을 주었지만 먹히지 않을 때 해결방법을 알아본다.이 문제는 margin이 겹칠 경우 작은 값을 가지는 요소의 margin을 무시하는 것이다.요소에 display: inline-block;을 걸어주면 된다..class {  display: inline-block;}",
        
        "url": "/dv/css/2020/03/30/margin-%EA%B2%B9%EC%B9%A8.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-04-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-84-9c-eb-b9-84-ec-8a-a4-html": {
        "title": "04: 운영체제 서비스",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제의 주요 서비스: 프로세스, 메모리, 파일관리, 시스템 호출에 대해 알아본다.운영체제의 주요 서비스는 하드웨어 자원을 각 사용자 애플리케이션에 적절히 분배해주는 것이다. 하드웨어 자원은 CPU, 메인 메모리, 하드디스크, 키보드, 마우스, 프린터 등이 존재한다. 이러한 하드웨어 자원을 사용자 애플리케이션이 요구하거나 운영체제 내의 규칙에 의해 적절히 분배하여 컴퓨터의 성능을 최대한 효율적으로 사용해야 한다.이를 실현하기 위해 운영체제 내에서는 각 하드웨어를 관리하는 기능을 다음과 같이 나눈다.  프로세스 관리  주기억장치 관리  파일 관리  보조기억장치 관리  입출력 장치 관리  네트워킹  보호  기타…1. 프로세스 관리(Process management)프로세스 관리는 운영체제 기능 중 가장 중요한 기능 중 하나이다. 프로세스와 프로그램은 기본적으로 구분된다. 프로세스는 실제 메인 메모리에서 실행 중인 프로그램(program in execution)을 말한다. 프로그램은 하드디스크와 같은 보조기억장치에서 아무런 동작을 하지 않는 상태이다. 이를 어떠한 요청에 의해 메인 메모리에 할당하여 CPU를 사용하면서 실행하게 되는데 이를 프로세스라 부른다.프로세스 관리의 주요 기능은 다음과 같다.  프로세스의 생성과 소멸(creation, deletion)  프로세스 활동 일시 중지, 활동 재게(suspend, resume)  프로세스간 통신(interprocess communication: IPC)  프로세스간 동기화(synchronization)  교착상태 처리(deadlock handling)2. 주기억장치 관리(Main memory management)주기억장치 즉, 메인 메모리는 프로그램이 실행되기 위한 공간이다. CPU는 오직 메인 메모리에 있는 프로그램(프로세스)하고만 소통할 수 있다. 주기억장치 관리에서는 메인 메모리를 효율적으로 사용하도록 관리한다.  프로세스에게 메모리 공간 할당(allocation)  메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시  프로세스 종료 시 메모리 회수(deallocation)  메모리의 효과적 사용  가상 메모리: 물리적 실제 메모리보다 큰 용량을 사용할 수 있다.3. 파일 관리(File management)디스크는 물리적으로 Track과 sector로 구성되어 있으며, 여기서 파일이라는 논리적 관점으로 데이터를 바라보고 관리하는 것이다.파일은 OS가 실행되는 컴퓨터에서 자주 볼 수 있는데, 이는 복잡한 과정으로 하드디스크에 저장되어 있는 것을 사용자가 편리하게 사용할 수 있도록 파일이라는 논리적 형태로 운영체제에서 관리하여 보여준다.  파일의 생성과 삭제(file creation, deletion)  디렉토리(Directory)의 생성과 삭제  기본 동작 지원: open, close, read, write, create, delete  Track/sector - file 간의 매핑(mapping)  백업(Backup)4. 보조기억장치 관리(Secondary storage management)보조기억장치는 대표적으로 하드 디스크, 플래시 메모리(주로 스마트폰에 사용)가 있다. 하드 디스크를 예로 들면, 하드 디스크에서 아무 것도 저장되어 있지 않는 공간을 block이라 하는데, 보조기억장치 관리는 이를 관리하는 것이다.  빈 공간 관리(Free space management)  저장공간 할당(Storage allocation)  디스크 스케줄링(Disk scheduling)5. 입출력 장치 관리(I/O device management)입출력 장치에는 키보드, 마우스, 프린터, 스피커, 마이크 등이 있다. 입출력 장치 관리는 이와 같은 여러 입출력 장치를 사용하기 위해 존재한다.  장치 드라이브(Device drivers)  입출력 장치의 성능향상: buffering, caching, spooling6. 시스템 콜(System call)시스템 콜은 유저 프로세스에서 운영체제 서비스를 필요로 할 때 이를 받기 위해 사용하는 호출이다.6.1 주요 시스템 콜  Process: end(정상 종료), abort(강제 종료), load, execute, create, terminate, get/set, attributes, wait event, signal event  Memory: allocate, free  File: create, delete, open, close, read, write, get/set attributes  Device: request, release, read, write, get/set attributes, attach/detach devices  Information: get/set time, get/set system data  Communication: socket, send, receiveReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-04-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%9C%EB%B9%84%EC%8A%A4.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-03-ec-9d-b4-ec-a4-91-eb-aa-a8-eb-93-9c-ec-99-80-eb-b3-b4-ed-98-b8-html": {
        "title": "03: 이중모드와 보호",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제의 사용자모드와 관리자모드, 하드웨어 보호 관해서 알아본다.1. 이중 모드 (Dual mode)현재 컴퓨터 환경은 여러 사람이 동시에 한 컴퓨터를 사용하는 경우가 많다.(서버 컴퓨터) 그리고 그 외에도 하나의 컴퓨터 내에서 여러 프로그램을 수행하는 것이 일반적이다. 이 때 특정 컴퓨터나 프로그램에서 잘못된 동작으로 인해 다른 컴퓨터(프로그램)가 영향을 받는다면 이는 매우 위험하다.예를 들어, 어셈블리어에서 사용하는 명령어 중 STOP, HALT, RESET과 같은 명령어는 CPU의 동작과 관계된 명령어이다. 이런 명령어를한 프로그램에서 고의 또는 실수로 입력하여 전체 컴퓨터의 동작이 멈추거나 꺼진다면 이 컴퓨터의 정상적인 동작을 위해서는 재부팅을 할 수 밖에 없다. 이러한 결함을 매우 치명적이다.이런 문제점을 해결하기 위해 일반 사용자가 위와 같은 명령어들을 요청하는 것을 막을 필요가 생겼다. 여기서 이중 모드 라는 것이 나왔다.설명이중 모드는 말 그대로 모드를 아래와 같이 둘로 나누는 것이다.  사용자(User) 모드  관리자(Supervisor) 모드          = 시스템(system) 모드      = 모니터(monitor) 모드      = 특권(privileged) 모드      특권 모드에서만 내릴 수 있는 명령을 특권 명령(privileged instruction) 이라고 하며, STOP, HALT, RESET, SET_TIMER 등이 있다. 만약 사용자 모드에서 특권 명령을 사용하려고 하면 CPU에서 내부 인터럽트를 발생시켜 해당 명령어를 요청한 프로그램을 강제로 종료시킨다.이중 모드는 CPU 내부의 레지스터(register)의 비트(bit)를 활용하여 플래그(flag)로 나타낸다. 예를 들어 특권 모드일 때는 비트 값이 0 이고, 사용자 모드일 때는 비트 값을 1 로 설정하여 구분한다.상태 레지스터 (플레그 레지스터)CPU에서 다양한 산술 연산의 결과의 상태를 알려주는 플래그 비트들이 모인 레지스터이다. flag라는 이름의 어원은 경주할 때, 시작, 정지와 같은 상태를 깃발의 색, 들어올림과 같은 것으로 알렸기 때문이다. CPU에서는 연산을 수행하는데, 제약사항을 갖고 (자리수의 제한 같은) 수행하기 때문에 이를 나타낼 다양한 코드가 필요하다. 이 상태는 비트를 통해 정의되어 있으며 다양한 플래그가 존재한다.상태 레지스터의 종류Mode의 변경 과정컴퓨터가 켜진 뒤에 한 사용자 애플리케이션을 실행시키는 동안 모드가 어떻게 변하는지 살펴보자.  컴퓨터 부팅 과정 - 관리자 모드  애플리케이션 실행 과정 - 관리자 모드  애플리케이션 실행중 - 사용자 모드  인터럽트 발생 후 처리 과정 - 관리자 모드  인터럽트 처리 후 - 사용자 모드사용자가 하드웨어의 자원에 접근하는 것은 매우 위험한 동작이다. 그러므로 이러한 경우에는 모두 관리자 모드로 운영체제에서 처리하도록 한다. (프로그램에서 소프트웨어 인터럽트를 발생시켜 운영체제에 위임한다.)위의 4번 과정을 하드웨어 인터럽트로 가정하고 자세히 살펴보면 아래와 같다.  하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)  CPU에서 모드 플래그를 관리자 모드값으로 설정  해당 하드웨어 인터럽트 서비스 루틴(ISR)으로 이동 (관리자 모드)  인터럽트 처리 (관리자 모드)  인터럽트 처리 완료 후 CPU의 모드 플래그를 다시 6. 사용자 모드값으로 설정  원래의 애플리케이션 위치로 복귀 (사용자 모드)만약 사용자 모드인 상태에서 치명적인 명령어를 사용자 프로그램이 Call했을 경우에 CPU는 모드 비트를 확인하고 관리자 모드가 아닐 경우, 내부 인터럽트를 발생시킨다. (잘못된 명령을 내렸을 때 발생하는 인터럽트) 그 결과, 메모리에 올라와있는 사용자 프로그램을 종료시켜버린다.애플리케이션이 실행하는 동안에는 위와 같은 모드 변경이 반복적으로 일어나는 것을 볼 수 있다. 대부분의 CPU는 이중 모드를 지원한다.2. 하드웨어 보호이중 모드는 사용자의 접근을 제한하여 치명적인 문제가 발생하지 않도록 방지하는 보호 기능에 해당한다. 이러한 보호 기능에 대해 추가적으로 알아본다.2.1 입출력 장치 보호여러 정보들은 입출력 장치를 통해 컴퓨터로 입력되고, 외부 장치로 출력이 된다. 여기서 크게 두 가지의 문제점이 발생한다.  여러 입출력 장치의 사용으로 인한 혼선  사용자가 자신의 데이터가 아닌 다른 사용자의 데이터에 입출력을 하는 일          위와 같이 입출력 장치에 여러 사용자의 데이터가 뒤엉켜서 들어오거나 다른 사용자의 데이터에 접근하려는 경우를 막아야 한다.이를 해결하기 위해 in, out 과 같은 입출력 명령을 특권 명령으로 설정하는 것이다. 즉, 사용자 애플리케이션에서 입출력을 사용하려면 운영체제를 통해서 수행해야한다.(소프트웨어 인터럽트) 여러 프로그램이 동시에 입출력을 사용하려고 하면 운영체제 내부에서 순서를 정하여 혼선을 막아줄 수 있다.즉, 컴퓨터의 하드웨어를 사용하는 과정에서는 모두 운영체제를 거치도록 한다! 라는 대원칙이 사실 숨어있다.      만약 A, B 사용자가 있는 상황에서 A가 B의 데이터를 읽기 위해 운영체제에게 소프트웨어 인터럽트를 발생하였다고 하자. 이 때, A의 데이터와 B의 데이터는 각각 A, B만이 읽기가 가능하다고 가정하자. 그러면 인터럽트가 발생하고, CPU는 RAM에 있는 운영체제 내부의 해당 ISR로 이동하게 된다. ISR은 현재 사용자 A가 해당 데이터 B에 접근할 수 없으므로 해당 요청을 거부한다.다시보는 이 그림..2.2 메모리 보호메모리에는 운영체제뿐만 아니라 여러 개의 사용자 애플리케이션이 존재한다. 한 애플리케이션이 자신의 메모리 영역이 아닌 운영체제나 다른 애플리케이션의 메모리 영역에 침범하려하면 매우 위험하다.메모리는 일반적으로 위와 같이 구성되어 있을 것이다. 여기서 user1이 OS나 user2, user3에 접근하는 것을 막아야 한다. CPU는 address bus를 통해 메모리 주소에 접근하게 되는데, user1 프로그램이 실행되는 동안에는 user1이 할당되어 있는 메모리 주소 범위 안인 경우에만 접근하면 될 것이다. 이를 address bus에서 검사하는 것이 가장 효율적일 것이다.위의 생각으로 나온 것이 MMU(Memory Management Unit) 이다. MMU는 위의 그림처럼 address bus 중간에 설치된 하드웨어 칩으로서 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다.예를 들어, User1의 시작 주소는 1024, 끝 주소는 4048이라고 하자. User1이 수행되는 동안 운영체제는 해당 프로그램의 주소 범위를 MMU에 설정(특권 명령)하는데, base는 1024, limit는 4048이 될 것이다. 결과적으로 user1이 수행되는 동안에는 이 범위 안의 주소값인 경우에만 address bus를 통과시킨다.만약 해당 프로그램의 주소 범위 밖의 주소값이 MMU에 들어온다면, MMU에서 내부 인터럽트 를 발생시켜 CPU에 신호를 준다. 그러면 CPU는 그에 맞는 ISR로 이동하여 해당 프로그램을 강제로 종료시킨다. 이과 같은 잘못된 메모리 접근을 Segment violation 이라 한다.2.3 CPU 보호CPU 보호는 사용자의 실수 또는 고의로 인한 CPU 독점을 방지해야 한다. 하나의 프로그램이 CPU를 독점하게 되면 다른 프로그램은 수행되지 못한다.while(true){}CPU를 독점하는 가장 대표적인 예는 무한 반복이다. 위의 코드를 보면 while문의 조건문이 잘못된 것을 볼 수 있다. 비교 연산자가 아닌 대입 연산자를 사용하여 n값이 1이 되므로 while문의 조건은 TRUE가 된다. 이는 n값이 변하지 않는 이상 무한으로 반복된다.이를 해결하는 방법은 Timer를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킨다. 인터럽트가 발생하면 반드시 운영체제 내의 ISR로 이동하므로, 해당 ISR에서 각 프로그램의 CPU 점유 시간을 측정하여 적절히 분배되도록 조정한다.예를 들어, 한 프로그램의 CPU 점유 시간이 비정상적으로 오래 걸리는 경우, 강제로 다른 프로그램으로 CPU를 전환시켜 줄 수 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-03-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-02-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-9d-98-ec-97-ad-ec-82-ac-html": {
        "title": "02: 운영체제의 역사",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "일괄처리부터 시분할시스템, 최근의 고급운영체제, 인터럽트에 기반한 현대 운영체제까지 변천 역사를 알아본다.1. 초기 컴퓨터  노가다, 사람 손도 많이가, 장치도 엄청커, 비싸기도 비싸운영체제는 컴퓨터가 발전하면서 같이 발전하게 되었다. 초기 컴퓨터는 크게 3가지로 구성되었다. 카드 리더, 프로세서, 프린터이다. 카드 리더는 입력기이다. 입력은 종이에 입력할 코드에 맞는 구멍을 뚫어서 넣어주는 방식이었다. 프로세서는 현재와 비슷한 계산하는 역할이었고, 프린터는 입력에 대한 결과를 종이에 찍어서 보여주었다. 이 시기에는 운영체제도 존재하지 않았으므로, 오퍼레이터(operator)라는 컴퓨터를 사용하는 직업이 따로 있었고, 컴퓨터의 크기 또한 너무 커서 건물 전체를 사용해야할 정도였다.2. Batch processing system(일괄 처리 시스템)  코드로 반복되는 거 좀 자동화 하자!위에서 초기 컴퓨터의 상황을 살펴보았는데, 프로그램을 수행할 때마다 컴파일-&gt;링크-&gt;로딩 순서를 오퍼레이터가 직접 입력해주었다. 이러한 과정을 자동화한 것이 batch processing system 이다. 위 과정을 하나의 프로그램으로 작성하여 프로세서의 메모리안에 할당해주었는데, 이 프로그램을 resident monitor라고 불렀다.resident는 “거주” 라는 의미로 이 프로그램이 항상 프로세서안에서 거주한다는 의미로 이러한 이름을 사용하였다. 그리고 이것이 최초의 운영체제로 알려져 있다.3. Multiprogramming system(다중 프로그래밍)  CPU가 노는 시간이 너무 많은데? 쉴 동안 다른일을 시켜버리자.과거에는 컴퓨터가 매우 비싼 장비였다. 그리고 초창기 메모리의 상태는 resident monitor를 제외하고 단 하나의 애플리케이션만을 할당하여 사용하였다. 하지만 이는 매우 비효율적인 방법이었다.프로그램을 수행하는 도중에는 계산을 하는 CPU 외에도 입출력을 담당하는 I/O장치가 수행한다. 즉, CPU와 I/O장치가 교대로 동작하는데 I/O장치가 수행하는 동안에는 CPU가 아무것도 할 일이 없었다. CPU가 아무일도 안하는 상태를 idle 상태라고 말한다. 그리고 I/O장치는 CPU에 비해 매우 느리기때문에 idle 상태의 비율이 너무 높았다. 이러한 비효율적인 수행을 해결하기 위해 multiprogramming system이 나왔다. 즉 CPU를 못놀게 하자방법Multiprogramming system은 메모리에 여러 애플리케이션(프로그램)을 올리는 시스템이다. 예를 들어 a, b 두 개의 애플리케이션이 있을 떄, 처음에는 a에서 CPU 수행을 하다가 I/O장치 수행으로 넘어간다. 이 순간 CPU는 idle 상태에 있지 않고 b가 있다는 것을 보고 b의 CPU 수행을 시작한다. 이렇게 idle상태의 시간을 최대한 줄이고자 하였다. 이런 동작을 가능하게 하려면 앞서 말했듯, 메모리에 여러 어플리케이션을 올린 상태여야만 한다.한계 및 문제하지만 메모리에 여러 프로그램을 올리면서 많은 문제점이 발생했다. 가장 큰 문제점은 CPU가 어느 프로그램을 수행해야하는지 선택하는 것이다. 이러한 작업을 CPU 스케줄링이라고 하며, 이는 운영체제의 중요한 역할 중 하나이다. 그리고 여러 어플리케이션의 공간을 할당한다는 전제 조건 때문에, 새롭데 들어온 어플리케이션에 대해 어느 메모리 공간에 할당해야하는지도 큰 문제였다. 이러한 문제도 운영체제가 다뤄야 하는 중요한 과제로 남았다.4. Time-sharing system(시분할 시스템)  하나 다 끝날 때까지 기다리지 말고 Interval을 주자!시간이 지나 모니터와 키보드를 사용하면서 사용자와 컴퓨터 사이에 대화 형식이 가능해졌다. 하지만 여전히 컴퓨터 자체가 너무 비쌌기 때문에 아래와 같이 단말기(terminal) 형태로 사용하였다.각 사용자(User)들은 모니터와 키보드만을 가지고, 실제 프로세서는 하나의 단말기에 존재하여 이를 공유하여 사용하였다. 멀티 프로그래밍에서는 이와 같은 단말기 형태에서 문제가 생긴다.예를 들어, 단말기 메모리에 User1 프로그램, User2 프로그램, User3 프로그램이 할당되어 있고 User1이 먼저 CPU를 사용한다고 하자. 멀티프로그래밍에서는 User1이 CPU를 수행하고 있는 도중에는 다른 사용자는 CPU자체를 사용할 수 없다. (CPU가 하나인 환경) 그러므로 다른 사용자들은 User1이 CPU수행을 모두 마칠 때까지(또는 I/O를 만날 때까지) 기다려야한다. 하지만 이는 매우 비효율적이다.해결이를 해결하기 위해 나온 것이 time-sharing system이다. 시분할 시스템은 CPU가 하나의 프로그램을 수행하는 시간을 제한하는 것이다. 예를 들어, User1 프로그램을 일정 시간 수행하면 반드시 다음 프로그램으로 넘어가서(스위칭, switching) 또 다시 일정 시간을 수행한다. 이렇게 일정 시간을 두어 프로그램들을 번갈아 수행하면서 모든 프로그램이 공평하게 수행이 되도록 한다. 그리고 이 일정 시간은 매우 짧은 시간(ms)이므로 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 가져온다. 가장 대표적인 시분할 시스템은 Unix가 있었다.한계 및 문제시분할 시스템을 사용하면서 여러 사용자(프로세스)간에 통신이 가능해졌다. 하지만 여기서도 여전히 멀티프로그래밍에서와 같은 스케줄링과 메모리 문제가 있었다. 이를 해결하기 위해 동기화 기술, 가상 메모리 등이 이후에 나왔다.5. 고등 운영체제5.1 다중 프로세서 시스템 (Multiprocessor system)  CPU가 여러개  병렬 시스템 (parallel system)          여러개의 CPU가 동시에 처리할 수 있다.        강결합 시스템 (tightly-coupled system)          메모리에 여러 CPU가 연결되어 있다.        3가지 장점: performance, cost, reliability          여러 일꾼을 쓰니 빠르다.      싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.      하나가 망가져도 작동할 수 있다. 신뢰도가 높다.        다중 프로세서 운영체제 (Multiprocessor OS)          CPU가 늘어났기 때문에, 다른 처리 방법이 필요하다.      5.2 분산 시스템 (Distributed system)]  컴퓨터가 여러대, 근데 묶여있다.  다중 컴퓨터 시스템 (multi-computer system)여러대의 컴퓨터로 만든 시스템이다.  소결합 시스템 (loosely-coupled system)          메모리가 느슨하게 연결되어 있다.        3가지 장점: performance, cost, reliability          여러 일꾼을 쓰니 빠르다.      싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.      하나가 망가져도 작동할 수 있다. 신뢰도가 높다.            분산 운영체제 (Distributed OS)          다른 컴퓨터들을 관리해야 하기 때문에 새로운 처리 방법이 필요하다.      5.3 실시간 시스템 (Real-time system)  시간 제약: Deadline  공장 자동화 (FA), 군사, 항공, 우주  실시간 운영체제 (Real-time OS = RTOS)6. 인터럽트 기반 시스템(Interrupt based system)현대 운영체제는 인터럽트 기반 시스템이다. 그렇다면 인터럽트는 무엇인가?6.1 인터럽트컴퓨터에 전원이 들어오면 위에서 말했듯이 부팅이 시작된다. 먼저, POST과정이 시작되고 그 후에 부트 로더가 하드 디스크에 있는 운영체제 프로그램을 RAM에 가져와 할당한다. 할당된 운영체제는 컴퓨터의 전원이 꺼질 때까지 상주(resident)한다.부팅이 끝나고 운영체제가 동작하는 동안 수 많은 인터럽트가 발생할 수 있다. 예를 들어, 사용자가 마우스를 움직인다고 가정하자. 이 동작을 컴퓨터는 어떻게 알 수 있을까? 바로 인터럽트를 통해 알 수 있다. 마우스를 움직이는 순간, 마우스에서 인터럽트 전기 신호가 발생하여 이를 CPU에게 보낸다. CPU는 이를 감지하고, 자신이 하던 일을 멈춘 후에 이 인터럽트 신호를 처리하기 위해 운영체제 내부에 있는 인터럽트를 처리하는 코드(interrupt service routine, ISR)로 이동한다. 이 곳에 마우스가 움직일 때 어떻게 동작해야하는지가 내포되어 있어 이를 수행한다.6.2 인터럽트의 종류와 동작방법이러한 하드웨어에서 발생한 인터럽트를 하드웨어 인터럽트(Hardwore Interrupt) 라고 한다. 인터럽트라고 하면 기본적으로 하드웨어 인터럽트를 말하지만, 소프트웨어에서도 인터럽트를 요청을 할 수 있다. 이를 소프트웨어 인터럽트(Software Interrupt) 라고 한다. 소프트웨어 인터럽트는 명령어로 직접 인터럽트 전기 신호를 CPU에게 보낼 수 있다. 즉, 프로그램에서 swi, int 와 같은 어셈블리어 명령어를 수행하는 것이다. (명령어는 운영체제마다 다르다. 위의 명령어는 CPU에서 어셈블리어 코드 중 일종으로, interupt를 처리하라는 명령어이다.)예를 들어, 마우스로 워드 작성 프로그램을 실행시킨다고 하자. 워드 작성 프로그램을 실행시키는 것까지는 하드웨어 인터럽트가 수행된다.(마우스가 이동하여 더블 클릭으로 실행하는 경우이다.) 이 프로그램에서 사용자가 하드디스크에 있는 다른 워드 파일을 읽고 싶은 경우, 소프트웨어 인터럽트를 발생시킨다. 소프트웨어 인터럽트 역시 하드웨어 인터럽트와 동일하게 운영체제 내부에 해당 인터럽트를 처리하는 코드(ISR)가 존재하여 이 곳으로 이동한다. 여기서 하드디스크에서 읽을 파일을 찾아서 반환해주는 수행을 처리하는 것이다.마지막으로 내부 인터럽트(Internal Interrupt)가 있다. 내부 인터럽트는 프로그램을 수행하는 도중에 발생하는 예외 상황을 처리한다. 대표적인 예로 0으로 나누는 동작이다. 프로그램의 내부에 result = a / 0; 이와 같은 코드가 있을 때, CPU는 내부 인터럽트를 발생시켜 운영체제안에 있는 ISR로 이동한다. 이 경우에는 DividedByZero 라는 ISR로 이동한다. 여기서 잘못된 동작을 수행한 프로그램을 강제로 종료시킨다.운영체제는 평소에는 대기 상태에 있으면서 인터럽트가 발생하는 순간 작업을 수행한다. 그 인터럽트의 종류에 따라 운영체제 내부에 위치한 ISR로 이동하여 그에 맞는 처리를 한다. 위에서 설명한 하드웨어 인터럽트 과정을 그림으로 간단히 표현하면 아래와 같다.위 그림은 사용자 애플리케이션을 실행하기 위해 하드웨어를 사용하는 모습이다. 애플리케이션이 실행하는 중에도 계속해서 인터럽트는 발생한다. 워드 작성 프로그램을 예를 들면 키보드로 글을 작성하는 경우, 하드디스크에 있는 파일을 불러오는 경우 모두 인터럽트가 발생한다. 그러므로 CPU는 애플리케이션과 운영체제 내부를 교대로 수행하는 모습을 볼 수 있다.정리정리하면, 인터럽트는 CPU에게 보내는 전기 신호로서 인터럽트가 발생하면 CPU는 하던 일을 중지하고 해당 인터럽트를 처리하기 위해 운영체제 내부에 있는 ISR로 이동하여 수행한다. 그리고 수행이 끝나면 원래 위치로 돌아간다. 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부 인터럽트로 총 세 가지가 존재한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-02-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%EC%82%AC.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-eb-9e-80-eb-ac-b4-ec-97-87-ec-9d-b8-ea-b0-80-html": {
        "title": "01: 운영체제란 무엇인가?",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제에 대한 정의, 역할에 대해 알아본다.운영체제는 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어이다. 일반적으로 사용하는 모든 프로그램은 운영체제에서 그 자원을 관리한다.목적운영체제를 사용하는 가장 큰 목적은 하드웨어의 관리이다. 컴퓨터를 나타내는 가장 상징적인 장치는 CPU이지만, 추가적으로 많은 장치와 상호작용하며 동작한다. 그렇기에 이러한 하드웨어를 관리하는 소프트웨어가 있어야 효율적으로 컴퓨터를 사용할 수 있다. 하드웨어를 직접적으로 사용하는 것이 아니기 때문에, 이를 효율적으로 사용하기 위해서는 운영체제의 성능이 좋아야 한다.두번째로는 사용자에게 편의를 제공하는 것이다. 운영체제가 없을 경우, 우리는 하드웨어 단에서 하드 코딩으로 원하는 작업을 실행해야 한다. 이는 매우 생산성이 떨어지는 방법이다. 그렇기 때문에 이런 자원 관리 측면을 자동으로 해주는 소프트웨어를 통해, 원하는 작업에만 몰두할 수 있는 환경을 제공한다.정리운영체제는 컴퓨터의 성능을 높히고(performance), 사용자에게 편의성을 제공(Convenience)을 목적으로 하는 컴퓨터 하드웨어 관리 프로그램이다.부팅 (Booting)컴퓨터를 사용하기 위해서 가장 먼저하는 행동은 전원버튼을 누르는 것이다. 그렇다면, 전원을 눌렀을 때, 시작해야 하는 작업들이 있을 것이다. 우리가 실제로 사용할 수 있는 운영체제가 실행되기 이전에 다양한 작업을 해야하는데, 이 작업을 부팅 이라 한다.어떻게 실행할 수 있을까?기본적인 컴퓨터 구조는 위와 같다. 이 상황에서 부팅을 한다고 생각해보자. 컴퓨터는 원하는 작업을 실행할 때, Disk, RAM, CPU, RAM, Disk 순의 과정을 거치며 작동하게 된다. 그런데, 부팅을 하는 경우에는 어떻게 해야할까? 사실 Disk는 컴퓨터 입장에서는 보조 장치이다. 컴퓨터라고 부를 수 있는 실질적인 부분은 CPU, RAM이 전부이기 때문에 처음 부팅을 시작하면 CPU 에 부팅시 필요한 작업을 넘겨줄 수 없다.따라서 우리는 일반적으로 프로그램이 동작하는 방식인 Disk, RAM, CPU 과정을 거칠 수 없기 때문에, 부팅에 한해서 RAM에 항상 저장된 공간을 필요로하게 되었는데, 그것이 ROM이다.RAM과 ROM을 함께 Main Memory라 부른다.  ROM: 비휘발성 으로 메모리에서 극히 일부를 차지한다.(수 KB)  RAM: 휘발성 으로 메모리의 대부분을 차지하며 실제 프로그램이 할당되는 곳이다.(수 MB ~ 수 GB)부팅시 하는 작업(엄밀한 정의의 부팅)  ROM의 정보를 읽는다.  ROM안에 있는 POST(Power-On-Self-Test), 부트 로더(Boot-Loader)를 실행한다.POST는 전원이 켜지면 가장 처음에 실행되는 프로그램으로, 현재 컴퓨터의 상태를 검사한다. 이 것에는 장치가 연결되어 있는지, 멀쩡한 지 등의 상태를 뜻한다.부트 로더는 하드디스크에 저장되어 있는 운영체제를 찾아서 메인 메모리(RAM)에 가지고 온다. 이러한 부트 로더의 과정을 부팅이라고 한다.이렇게 메모리에 올라온 OS는 컴퓨터를 종료하기 전까지 계속 메모리에 상주한다.구조운영체제는 크게 커널(Kernel)과 명령어 해석기(Command interpreter, shell)로 나뉜다.커널(Kernel)은 운영체제의 핵심인 하드웨어를 다루는 코드를 말한다. 이 부분이 핵심이 때문에, Kernel에 따라 운영체제가 달라진다. 예를 들어 페도라, 우분투 등이 리눅스 운영체제라 부르는 것은, 이 운영체제가 리눅스 커널을 사용하기 때문이다.명령어 해석기(Command interpreter, shell)는 이 커널로 만들어진 코드를 동작하기 위해 만들어진 부분이다. Interface라고 볼 수 있다. GUI(Graphical User Interface)나 CLI(Command Line Interface) 같은 방식으로 운영체제에 명령을 요청할 수 있다.위치사용자 프로그램(Application)은 특정 운영체제에 맞춰서 만든다. 그러므로 한 애플리케이션은 서로 다른 운영체제에서 수행할 수 없다. (하드웨어가 같은 것은 전혀 상관이 없다.) 예를 들면 Windows에서 수행하는 프로그램을 그대로 Linux에 옮기면 수행되지 않는다. 이전 글에서 보았듯이 사용자 프로그램은 자원을 OS를 통해 요청한다. 그렇기 때문에 해당 운영체제의 Interface를 따라야 하고, 그렇기 때문에 운영체제가 다를 경우 동작할 수 없다.추가적으로 국가에 비유하여 생각해 볼 수도 있다.영토, 정부, 가족, 개인 비유ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-01-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html"
      }
      ,
    
      "cs-structure-2020-03-27-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ea-b0-80-ed-95-98-eb-8a-94-ec-9d-bc-html": {
        "title": "07: 운영 체제가 하는 일",
        "tags": "컴퓨터 구조, 운영체제, 스케쥴링, 가상메모리",
        "date": "March 27, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "운영 체제가 하는 일을 간단하게 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.운영체제가 하는 일  접근 제어 + 동기화 + 관리전산 자원을 관리한다. 대표적인 전산 자원은 CPU, RAM 등이 있다. 스타판 프로게이머프로그램’들’ 관리하기  Process를 관리한정된 자원으로 많은 프로그램들이 동작해야 한다. 어쩔 수 없이 나눠서 사용해야 한다.아래 단어들의 의미를 모른다면, 용어를 알고 다시 읽자.하드웨어, 운영체제, 프로세스, 스레드 용어 정리Scheduling  멀티 프로세스 운영체제에서 하나의 CPU가 복수의 프로세스를 실행하기 위해 CPU를 사용하는 순서를 정해주는 작업이렇게 다양한 프로세스를 동시에 작업하게 되면, 스레드가 CPU를 사용하고 있을 떄, 사용하고 있다고 알려주는 동기화가 매우 중요하다.Virtual Memory System  RAM과 HDD를 하나의 논리적 메모리로 추상화시킨 메모리 관리 방법프로세스가 운영체제로 부터 메모리를 할당 받는 일은 시간이 많이 걸리는 일이다. 그렇기 때문에 최대한 RAM 공간에 할당 받은 채로 존재하는 것이 속도를 높일 수 있는 방법이다. 또한 여러개의 프로세스를 사용할 경우, RAM 공간을 초과하여 프로세스가 동작하지 않는다. 이런 부분들을 해결하기 위해 HDD 공간을 활용한 것이 가상 메모리 시스템이다.단위이 곳에서 모든 메모리는 Page라는 단위로 관리된다. HDD와 RAM을 왔다갔다 하는 단위이다. 이 중에는 Paged 될 수 있는 페이징 풀 영역과 절대로 Paged 되면 안되는 비 페이징 풀 영역이 있다.Virtual Memory의 구성집의 공간을 가족 구성원들이 나눠쓰듯이 프로세스의 가상 메모리 공간을 thread가 나눠서 사용한다. 이 나눠서 사용하는 공간을 Stack이라 한다. 이 thread에 할당된 메모리 공간이 stack을 사용하여 관리되기 때문에 Stack이라 불린다.프로세스는 Heap과 실행 코드 영역을 갖는다.운영체제 정리 05: 프로세스 관리동작 방법  RAM이 꽉찼는 지 확인한다.  꽉찼다면 현재 RAM 공간 중에 사용하지 않는 프로세스가 할당된 공간이 있다면 이것을 HDD 공간에 복사해둔다. Page Out(Swap Out)  RAM 공간이 비게 될 경우 복사해 둔 공간을 다시 RAM으로 복사한다. Page in(Swap in)프로세스 별 가상 메모리의 크기이러한 가상 메모리 시스템이 있기 때문에, 프로세스가 실행 되고 할당 받는 메모리 공간은 4GB로 할당한다. 이 크기는 현실적으로 RAM만 사용한다면 말이 안되는 소리지만, 가상 메모리를 사용하게 되면 문제없다.",
        
        "url": "/cs/structure/2020/03/27/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C%EA%B0%80-%ED%95%98%EB%8A%94-%EC%9D%BC.html"
      }
      ,
    
      "dv-javascripts-2020-03-26-javascript-window-event-html": {
        "title": "window resize event",
        "tags": "development, javascript, resize",
        "date": "March 26, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "자바스크립트의 window 이벤트를 알아본다.resizewindow.addEventListener(\"resize\", changeContent);function changeContent(event) {  const cat = document.getElementById(\"js-cat\");  const cv = document.getElementById(\"category-cv\");  const math = document.getElementById(\"category-math\");  const ds = document.getElementById(\"category-ds\");  const cs = document.getElementById(\"category-cs\");  const dv = document.getElementById(\"category-dv\");  const about = document.getElementById(\"category-about\");  if (event.target.innerWidth &lt; 710) {    cv.innerText = \"📜\";    math.innerText = \"✖\";    ds.innerText = \"📈\";    cs.innerText = \"💾\";    dv.innerText = \"📱\";    about.innerText = \"😎\";    cat.style.justifyContent = \"space-around\";  } else {    cv.innerText = \"CV\";    math.innerText = \"Math\";    ds.innerText = \"Data Science\";    cs.innerText = \"Computer Science\";    dv.innerText = \"Development\";    about.innerText = \"About\";    cat.style.justifyContent = \"center\";    console.log(cat);  }}이 코드는 내 블로그 카테고리를 수정할 때 만든 코드이다.",
        
        "url": "/dv/javascripts/2020/03/26/javascript-window-event.html"
      }
      ,
    
      "dv-css-2020-03-26-safari-longline-scroll-html": {
        "title": "Safari: long line scroll 작동 안함",
        "tags": "Browser, Safari, css",
        "date": "March 26, 2020",
        "author": "",
        "category": "DV/CSS",
        "content": "사파리에서 code block을 담당하는 pre 태그에서 long line scroll이 안되는 문제를 해결한다.참고근본적인 문제는 Safari pre태그의 초기값 때문이다.이것을 해결하기 위해서는 다음의 코드를 추가하면 된다..site-content pre {  overflow-wrap: normal;}",
        
        "url": "/dv/css/2020/03/26/Safari-longline-scroll.html"
      }
      ,
    
      "cs-structure-2020-03-26-ec-9e-90-eb-a3-8c-ea-b5-ac-ec-a1-b0-ec-99-80-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "06: 자료구조와 알고리즘",
        "tags": "컴퓨터 구조, 자료구조, 알고리즘",
        "date": "March 26, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "컴퓨터에서 사용하는 자료구조와 알고리즘을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.자료를 정리해야 하는 이유  정리를 잘 해둬야 필요할 때 빨리 꺼내 쓸 수 있다!처음엔 몰랐지만.. 갈 수록 유지 보수를 위해 정리하는 것이 중요함을 느낀다.. ㅠㅠ어떻게 정리할까?  정리 는 상황에 맞는 적절한 규칙이 존재한다.일련번호도 아무런 규칙이 없어보이지만, 그 숫자들에 규칙이 존재한다.자료구조선형 구조배열  물리적으로 순차적인 자료구조장점  단순하다.  한 자료에서 다음 자료 넘어갈 때 생각할 것이 없다. 인덱스가 단순 증가한다.단점  크기를 늘리거나 줄이려면 구조를 변경해야 한다.  중간에 새로운 자료를 넣거나 빼는 경우 문제가 발생한다.Linked List  화살표룰 가지고 원하는 요소를 가리키는 구조장점  순서를 바꾸기 매우 쉽다.  중간에 새로운 자료를 넣거나 뺴기가 쉽다.단점  한 자료 접근 후 다음으로 넘어가기 위해서 위치정보를 활용해 찾아가야한다.  찾아간다는 점에서 배열에 비해 복잡하다.Stack  뚜껑식 김치 냉장고 : 출입구가 하나다!사용처  되돌아 가기 위한 구조한 스텝 전진하고, 전으로 가기 위해서는 pop 한다.  가장 최근 값을 가져온다  대칭 구조Queue  줄을 선다!버스에서 줄을 서는 것이나 은행의 대기열을 생각하면 된다. 이 때 버스는 순차적으로 처리가 진행이 되고, 은행은 병렬적으로 처리된다. 각각을 순차 처리, 병렬 처리라 한다.비선형 구조Binary Tree선형 구조, 정렬이 안된 상황에서 특정 값을 찾는다고 생각해보자. 이런 경우 해당 배열의 크기만큼 탐색을 진행해야 한다. 결과적으로 선형 구조에서 값을 찾는 것은 상대적으로 효과적이지 않다.그래서 새로운 구조가 필요했는데 그 중 가장 효과적으로 사용한 구조가 이진 트리이다.이진 트리에 대한 내용 정리선형 구조, 비선형 구조 비교                   비선형      선형                  구조      복잡      간단              접근효율      좋다      나쁘다      물론 데이터 개수에 따라 판단을 달라질 수 있다. 상황 판단을 잘해야 한다.알고리즘Sort선형 구조에서 정렬하는 방법에 대해 생각해본다. 이 부분은 나열만 해두겠다.정렬에 대한 기초적 내용 정리선형 구조에서의 정렬 알고리즘  Bubble  Quick  Merge  Selection  Insertion  Heap  Radix",
        
        "url": "/cs/structure/2020/03/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "dv-tips-2020-03-25-latex-align-html": {
        "title": "Latex equation 예쁘게 맞추기",
        "tags": "LaTex, equation, align",
        "date": "March 25, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "LaTex 에서 align을 사용하여 방정식을 예쁘게 맞춰보자.수식 전개를 하다보면, 계속해서 등호를 사용하여 수식의 변경요소를 보여줄 필요가 있다.으으 못생겼다이런 경우 Latex 수식을 시작할 떄 align 속성을 걸어주면 예쁘게 사용할 수 있다.\\begin{align}A &amp; = B \\\\&amp; = C \\\\&amp;= \\cdots \\\\&amp;= Z.\\end{align}",
        
        "url": "/dv/tips/2020/03/25/Latex-align.html"
      }
      ,
    
      "cs-structure-2020-03-25-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-88-ab-ec-9e-90-eb-a1-9c-eb-aa-a8-eb-93-a0-ea-b2-83-ec-9d-84-eb-8b-a4-eb-a3-a8-eb-8a-94-eb-b0-a9-eb-b2-95-html": {
        "title": "05: 숫자로 모든 것을 다루는 방법",
        "tags": "컴퓨터 구조, 글자, ASCII, Text, binary, rendering, 렌더링, 아스키",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "컴퓨터가 모든 것을 숫자로 다루는 방식을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.컴퓨터로 글자를 나타내는 방법ASCII Code  숫자와 글자에 대한 함수관계를 정의한다.출처바이너리 코드(binary Code)실제로 담고 있는 정보를 Text 형태로 보여주면 ASCII Code 형태가 되고, 이것을 컴퓨터가 이해하는 방식인 숫자(보통 16진수)로 표현해 놓으면 이것을 바이너리 코드라 한다.결과적으로 사람이 읽을 수 있는 텍스트 파일 이외에 컴퓨터 저장이나 처리 목적을 위해 코드를 숫자로 변경해 놓은(인코딩) 데이터를 말한다.컴퓨터가 사진을 다루는 방법  특정 화소 하나를 숫자로 표시하고 이를 모아 사진으로 그린다.이미지 파일 형식  해당 화소를 표현하는 방식(규칙)에 대한 것.Rendering  숫자로 되어 있는 것을 글자와 사진으로 그려내는 것!이 속도가 중요하다! 렌더링이라는 것이 정확히 무엇인지 몰랐는데… 휴우",
        
        "url": "/cs/structure/2020/03/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%88%AB%EC%9E%90%EB%A1%9C-%EB%AA%A8%EB%93%A0%EA%B2%83%EC%9D%84-%EB%8B%A4%EB%A3%A8%EB%8A%94-%EB%B0%A9%EB%B2%95.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-9d-b4-ec-b9-9c-ec-88-98-html": {
        "title": "백준(2193번): 이친수",
        "tags": "백준, 알고리즘, 동적계획법, 피보나치",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 동적계획법 문제이다.백준(2193번) - 이친수생각이 문제의 핵심은, 최고자리 숫자가 0 또는 1일 때의 상황을 분리해서 생각해보는 것이다. 이유는 나열하면 금방 알아차릴 수 있다.            N      1             2             3                                0      X      00      X      000      X                     1      O      01      X      001      X                                   10      O      010      X                                   11      X      011      X                                                 100      O                                                 101      O                                                 110      X                                                 111      X                            1             1             2      여기서 N이 2 일 때를 생각해보면, 앞자리에 1이 있어야 하고, 그 뒤는 0으로 시작해야 한다. 0으로 시작한 이후에는 이친수가 와야한다. 그럴 경우에 새로운 이친수가 만들어진다. 따라서 N이 증가함에 따라 다음 자리수의 이친수를 만들기 위해서는 최고자리가 0인 상황에서 다음 숫자부터 가지는 이친수를 저장할 필요가 있다.정의  dp[N][0] : N자리수의 최고자리가 0일 경우 이후 자리수에서 가질 수 있는 이친수의 개수  dp[N][1] : N자리수의 최고자리가 1일 경우 가질 수 있는 이친수의 개수점화식  dp[N][0] = dp[N-1][0] + dp[N-1][1];최고자리수가 0일 때, 위의 정의에 맞는 개수를 구하기 위해서는 그 다음 자리의 수가 1인 경우와, 0인 경우가 있다. 따라서 그 두 경우를 모두 더해주어야 내가 원하는 수를 구할 수 있다.  dp[N][1] = dp[N-1][0];1인 경우에는 무조건 다음 자리수가 0으로 시작하는 이친수를 구해야 하므로 위와 같다.Code// 실버3 : 백준 2193번 이친수#include &lt;iostream&gt;using namespace std;int main(){    int N;    long long dp[91][2];    cin &gt;&gt; N;    dp[1][0] = 1;    dp[1][1] = 1;    for (int i = 2; i &lt;= N; i++) {        dp[i][0] = dp[i-1][0] + dp[i-1][1];        dp[i][1] = dp[i-1][0];    }    cout &lt;&lt; dp[N][1] &lt;&lt; '\\n';}피보나치 수열그런데 위의 점화식을 잘 정리하면 우리가 알고있는 피보나치 수열의 형태가 나온다.다이나믹은 끝이 없다.",
        
        "url": "/cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%9D%B4%EC%B9%9C%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-8b-9c-eb-a6-ac-ec-96-bc-eb-84-98-eb-b2-84-html": {
        "title": "백준(1431번): 시리얼 넘버",
        "tags": "백준, 알고리즘, 정렬",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 정렬 문제이다.백준(1431번) - 시리얼 넘버생각문제에서 하라는 대로 비교만 하면 된다.Code// 실버3 : 백준 1431번 시리얼 번호#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;string arr[1002];bool compare(string a, string b){    int sizeA = int(a.size()), sizeB = int(b.size());    if (sizeA &gt; sizeB) return false;    else if (sizeA &lt; sizeB) return true;    else {        int sumA = 0, sumB = 0;        for (int i = 0; i &lt; sizeA; i++) {            if (0 &lt;= a[i]-'0' &amp;&amp; a[i]-'0' &lt;= 9) sumA += a[i]-'0';        }        for (int i = 0; i &lt; sizeA; i++) {            if (0 &lt;= b[i]-'0' &amp;&amp; b[i]-'0' &lt;= 9) sumB += b[i]-'0';        }        if (sumA &lt; sumB) return true;        else if (sumA &gt; sumB) return false;        else {            return a &lt; b;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; arr[i];    }    sort(&amp;arr[0], &amp;arr[N], compare);    for (int i = 0; i &lt; N; i++) {        cout &lt;&lt; arr[i] &lt;&lt; '\\n';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%8B%9C%EB%A6%AC%EC%96%BC-%EB%84%98%EB%B2%84.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-83-89-ec-a2-85-ec-9d-b4-eb-b6-99-ec-9d-b4-ea-b8-b0-html": {
        "title": "백준(17136번): 색종이 붙이기",
        "tags": "백준, 알고리즘, 구현, 완전탐색, DFS, 삼성 역량 테스트",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 완전탐색 문제이다. 삼성 A형 기출이다.백준(17136번) - 시리얼 넘버생각시간이 1초라, 제한 시간에 들어올 수 있는지 시간 복잡도 계산부터 진행했다. 최악의 경우 100개의 공간에 모두 1이 차있는 경우 한 개의 공간에서 색종이를 5번 검사해야 한다.백트래킹을 해야 하나 고민했지만, 다행히 이 문제의 경우 한 개의 공간에서 5개의 경우의 수가 무조건적으로 발생하지 않는다는 점을 고려하여 풀이를 진행했다. 구현에 앞서 중요하게 생각한 것들은 다음과 같다.  종이의 수는 5장이다. 이 부분을 업데이트 해준다.  칠했다는 것을 표현하고, 이 부분은 탐색을 하지 않는다.  칠할 수 없는 곳은 칠하지 않고 다음 옵션으로 넘어간다.  끝나는 조건은 모든 1이 색칠이 되었을 때이다.설계main입력을 받는다.    이 때, 입력이 1인 경우 이 위치만 저장한다.1의 개수를 저장해 둔다.탐색한다.탐색 후 값을 출력한다.탐색 함수만약 현재까지 칠한 개수가 1의 개수와 같다면 answer를 업데이트 한다.현재 depth의 1의 위치를 가져온다.이 위치에 색종이가 붙어있지 않다면    5개의 색종이를 순차적으로 비교한다. 이 때 큰 색종이 부터 탐색한다.        만약 현재 색종이가 남아있다면            만약 해당 색종이를 붙일 수 있다면                색종이를 칠한다                색종이의 개수를 하나 감소시킨다                색종이를 붙이고, 다음 위치에서 탐색한다.                색종이의 개수를 하나 증가시킨다                색종이를 뗀다            색종이를 붙일 수 없다면                다음 색종이를 탐색한다        현재 색종이가 남아있지 않다면            다음 색종이를 탐색한다이 위치에 색종이가 붙어있다면    다음 위치에서 탐색한다.Code// 골드3 : 백준 17136번 색종이 붙여넣기#include &lt;iostream&gt;#include &lt;vector&gt;#define INF 2000000000using namespace std;int globalAns = INF, N = 0;int map[10][10] = {0};vector&lt;pair&lt;int, int&gt;&gt; position;pair&lt;int, int&gt; action[5] = {make_pair(5, 5),                            make_pair(4, 5),                            make_pair(3, 5),                            make_pair(2, 5),                            make_pair(1, 5)};void fillSquare(int y, int x, int num, int value){    for (int i = y; i &lt; y+num; i++)        for (int j = x; j &lt; x+num; j++)            map[i][j] = value;}bool isFillPossible(int y, int x, int num){    for (int i = y; i &lt; y+num; i++) {        for (int j = x; j &lt; x+num; j++) {            if (!(0 &lt;= i &amp;&amp; i &lt; 10 &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; 10)) return false;            if (map[i][j] == 0 || map[i][j] == 2) return false;        }    }    return true;}void go(int depth, int localAns, int paint){    if (paint == N) {        globalAns = min(globalAns, localAns);        return;    }    int y = position[depth].first, x = position[depth].second;    if (map[y][x] == 1) {        for (int i = 0; i &lt; 5; i++) {            int squareSize = action[i].first, &amp;squareCount = action[i].second;            if (squareCount != 0) {                if (isFillPossible(y, x, squareSize)) {                    fillSquare(y, x, squareSize, 2);                    squareCount--;                    go(depth+1, localAns+1, paint+(squareSize*squareSize));                    squareCount++;                    fillSquare(y, x, squareSize, 1);                }            } else continue;        }    } else go(depth+1, localAns, paint);}int main(){    for (int i = 0; i &lt; 10; i++) {        for (int j = 0; j &lt; 10; j++) {            cin &gt;&gt; map[i][j];            if (map[i][j] == 1) position.push_back(make_pair(i, j));        }    }    N = int(position.size());    go(0, 0, 0);    if (globalAns == INF) {        if (position.size() == 0) cout &lt;&lt; 0;        else cout &lt;&lt; -1;    }    else cout &lt;&lt; globalAns;    cout &lt;&lt; '\\n';    return 0;}",
        
        "url": "/cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%83%89%EC%A2%85%EC%9D%B4-%EB%B6%99%EC%9D%B4%EA%B8%B0.html"
      }
      ,
    
      "dv-c-2020-03-24-cin-cout-eb-b9-a0-eb-a5-b4-ea-b2-8c-html": {
        "title": "입출력 빠르게 받는 방법",
        "tags": "c++, iostream, 입출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "ios_base 라이브러리의 함수를 통해 입출력을 빠르게 받는 방법을 알아본다. 출처 : https://coding-insider.tistory.com확연하게 cin, cout이 느리다는 것을 알 수 있다.적용ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);main 함수안에 위의 코드를 적어주면 빠른 입출력이 가능하다.설명  ios_base::sync_with_stdio(false)C 입출력 함수와 C++ 입출력 스트림의 동기화를 해제하는 것이다. 이걸 쓰면 C, C++ 입출력 함수를 섞어 쓰면 안된다.  cin.tie(NULL); cout.tie(NULL);cin과 cout 의 tie를 해제하는 것이다. 자세한 설명을 모르겠다.  std::endl -&gt; '\\n'endl도 역시 불러오는 것이기 때문에 속도가 매우 느리다.주의 사항하지만 이 방법은 일종의 편법이기 때문에, 사용시 주의가 필요하다.  scanf, printf와 함께 사용하면 안된다.  싱글 쓰레드 환경에서만 사용 가능하다. (알고리즘 문제풀이시에 사용, 실무에서는 사용 X)",
        
        "url": "/dv/c++/2020/03/24/cin-cout-%EB%B9%A0%EB%A5%B4%EA%B2%8C.html"
      }
      ,
    
      "cs-structure-2020-03-24-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ea-b8-b0-ec-96-b5-ec-9e-a5-ec-b9-98-ec-97-90-eb-8c-80-ed-95-9c-ec-9d-b4-ed-95-b4-html": {
        "title": "04: 기억장치에 대한 이해",
        "tags": "컴퓨터 구조, 기억장치",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "기억 장치의 동작방법에 대해 이해해보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.Memory Device계층 구조출처 : https://programmer-student.tistory.com쉬운 이해를 위한 도표            기억장치      분류                  캐시      책상              RAM      책꽂이              HDD      도서관      컴퓨터가 관리하는 방법 - 관리 체계  컴퓨터는 모든 것이 숫자이다.그래서 기억 공간도 번호를 붙여 관리한다. 이와 같은 관리 체계는 아파트 단지를 동, 호로 관리하는 것과 비슷하다.  RAM에 있는 n번 번호에 있는 정보를 가져와  그 정보를 CPU에서 사용할 연산 저장 공간에 저장해  연산을 수행해  RAM의 m번 공간에 저장해여기서 CPU에서 저장하는 공간의 명칭이 register이다.레지스터  개별 기억 공간마다 고유 이름을 붙인다.기본적으로 레지스터는 많은 저장 공간을 갖고 있지 않다. 그래서 이 각각에 이름을 붙여 관리한다.주기억장치(RAM)  일련 번호를 붙인다.위에서 언급했던 번호에 해당하는 것이 보통 RAM에 대한 설명이다.  신발장 번호 : 주소신발 : 정보이 신발장을 컴퓨터는 약 43억 개 갖고 있는데, 이 숫자는 $2^32$ 가지에 해당하는 숫자이다. 저 숫자를 표시하기 위해서 32비트가 필요하다.보조 기억장치(HDD, SDD)  트랙 번호와 섹터 번호를 붙여 관리한다.Track중심부로 부터 밖으로 나가는 원들 중 하나를 말한다.Sector원을 균등하게 부채꼴 모양으로 나눈 것들중 하나를 섹터라 말한다.Format 이란?하드디스크의 섹터와 트랙을 구성하는 작업을 말한다. Format을 하면 데이터가 다 날아가는 이유는, 하드디스크에 정보를 저장하는 체계인 트랙과 섹터를 재구성하기 때문이다.파일 시스템하드 디스크에 내가 가진 파일의 위치를 Track, Sector로 나타낸 표            파일이름      Track      Sector                  a.mp3      1      1      이런 파일 시스템은 File Allocation Table (FAT), NTFS.. 등등 엄청 많다. 내가 파일을 삭제하면, 이 파일 시스템의 Delete Field에 True로 체크가 되고, 이 공간은 운영체제에서 쓰기 가능한 공간으로 바뀐다. 그래서 디스크 복구같은 것이 가능한 것.디스크 조각 모음하드디스크는 기본적으로 원의 형태를 띈 모양으로 구성되어 있고, 이것을 Arm을 사용해 읽는다. 그래서 갖는 특징이 있는데, 같은 track에 내가 사용하는 데이터가 모여있는 경우 입출력 속도가 빠르다. 하지만 만약에 데이터가 다른 트랙, 다른 섹터에 분산되어 있다면 이 파일을 읽기 위해서 Arm이 여러번 움직어야 한다. 관성 때문에 Arm의 속도가 느려지고 결과적으로 입출력 속도의 감소가 이루어진다.이렇게 흩어져 있는 파일을 같은 track이나 그 근처로 모으는 작업을 디스크 조각 모음이라 한다.전체 흐름  HDD에 몇번 트랙, 몇번 섹터에서 정보를 읽어와  그걸 RAM의 몇번 주소에 저장해라  그리고 그걸 다시가져와서 CPU에 EAX라는 이름을 가진 레지스터에 저장해라컴퓨터가 연산하는 과정이제 메모리가 어떻게 구성되어 있는 지를 대충 알았다면, 실제 연산과정을 들여다 보자.  캐시 메모리는 CPU 그 자체다.RAM은 CPU의 연산을 돕기위한 연습장이다.맨 위에서 보았듯이 메모리가 정보를 불러오는 데에는 속도가 존재한다. 전체적인 과정은 HDD, RAM, Resister 순으로 입출력이 일어나는데, 이 때 속도차이가 나므로 CPU가 빠르게 연산을 처리하는데 문제가 생긴다.그래서 이 병목구조를 탈피하기 위해서 CPU, RAM 등에 캐시 메모리를 두어 이 부분을 해소한다. 캐시 메모리는 CPU가 연산을 수행하는 동안 다음에 필요한 정보를 RAM에서 미리 가져와 저장하는 역을 한다. 그 결과 CPU는 RAM에서 정보를 가져올 때 걸리는 시간을 캐시에서 가져오므로써 시간적 이득을 가질 수 있다.CPU ALUALU는 가산기를 뜻한다. CPU에 대해서 배울 때, 이는 연산 처리 장치이고 모든 연산은 가산기 하나로 가능하다고 배웠다. 결과적으로 Core 하나에는 ALU하나가 들어있다고 생각하면 된다. 쿼드코어 컴퓨터는 가산기가 4개 존재한다.64bit 컴퓨터CPU가 연산을 처리할 때 발생하는 input, output의 단위가 64bit 만큼의 정보를 단위로 연산을 수행한다는 의미이다.전체 과정  RAM에서 정보를 가져온다  캐시 메모리에서 정보를 읽는다.  레지스터로 해당 값을 옮긴다.  ALU에서 연산을 수행한다.  결과를 레지스터로 복사한다.  그 값을 RAM으로 옮긴다.이런 작업을 코드라 한다. 그런데 CPU(기계)에게 명령하는 코드이므로 기계어 코드라 한다.",
        
        "url": "/cs/structure/2020/03/24/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-b2-b4-ec-8a-a4-ed-8c-90-eb-8b-a4-ec-8b-9c-ec-b9-a0-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1018번): 체스판 다시 칠하기",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현, 완전탐색",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버5 : 완전 탐색 문제이다.백준(1018번) - 체스판 다시 칠하기대표적인 완전 탐색 문제이다.체스판이 될 수 있는 모든 경우에 대해서 몇번의 flip을 해야하는지 세고, 이를 갱신해주면 풀린다.이 때, 체스판의 규칙을 잘 파악하는 것이 중요하다.Example                   1      2      3      4      5      6      7      8                  1      W      B      W      B      W      B      W      B              2      B      W      B      W      B      W      B      W              3      W      B      W      B      W      B      W      B              4      B      W      B      B      B      W      B      W              5      W      B      W      B      W      B      W      B              6      B      W      B      W      B      W      B      W              7      W      B      W      B      W      B      W      B              8      B      W      B      W      B      W      B      W      1행에서, 맨 마지막인 8열은 B이고, 그 다음 행의 첫번째는 B이다. 계속해서 엇갈려서 발생하는 것이 아니고, 행이 끝날 때, 마지막 요소가 다음 요소가 된다. 또한 추가적으로 체스판은 시작 위치의 표식이 어떤 것이냐에 따라 모양이 정해진다. 이 부분에서 생각할 수 있는 것은, 같은 모양이나 시작 위치의 표식만 바뀐다. 라는 것이다.구현이 것을 구현하기 위한 단계를 생각해보자.  우리는 체스판의 크기에 따라 몇 개의 작은 체스판을 조사해야 하는지 정해야 한다.  그 안에 들어갔을 때, 시작 위치의 표식을 설정해 주어야 한다.  체스판을 만들 수 있는 방법을 진행하며 다른 부분을 체크하고 count 해야한다.Code// 실버5 : 백준 1018번 체스판 다시 칠하기#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool map[50][50];int N, M;int ans = 2000000000;void go(int y, int x){    // 각각의 작은 체스판에서 시작 위치의 표식을 W, B으로 설정한다.    // bool으로 잡았기 때문에 0 또는 1로 모델링이 가능하다.    for (int mode = 0; mode &lt;= 1; mode++) {        int localAns = 0;        for (int i = y; i &lt; y+8; i++) {            // 이 부분이 행이 끝났을 떄 표식을            // 다음행에 가져가도록 하는 코드이다.            mode = !mode;            for (int j = x; j &lt; x+8; j++) {                if (mode != map[i][j]) {                    localAns++;                }                mode = !mode;            }        }        // 각각에 대해 ans를 업데이트 해준다.        ans = min(ans, localAns);    }}int main(){    cin &gt;&gt; N &gt;&gt; M;    // 1, 0으로 바꿔서 넣어주었다. W = 1, B = 0    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt; M; j++) {            char temp;            cin &gt;&gt; temp;            if (temp == 'W') map[i][j] = 1;            else map[i][j] = 0;        }    }    // 체스판 모양에 따라 발생할 수 있는    // 작은 체스판의 시작 위치를 결정한다.    for (int i = 0; i &lt;= N-8; i++) {        for (int j = 0; j &lt;= M-8; j++) {            go(i, j);        }    }    cout &lt;&lt; ans &lt;&lt;'\\n';}",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%B2%B4%EC%8A%A4%ED%8C%90-%EB%8B%A4%EC%8B%9C-%EC%B9%A0%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-88-a8-eb-b0-94-ea-bc-ad-ec-a7-88-html": {
        "title": "백준(1697번): 숨바꼭질",
        "tags": "백준, 알고리즘, BFS, 그래프",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 그래프 문제이다.백준(1697번) - 숨바꼭질이 문제의 핵심은, 해당 위치에서 3가지의 선택을 할 수 있다는 점이다. 이 3가지의 선택 각각에 해당하는 위치에서 또 3가지의 선택을 할 수 있다. 그 선택을 연이어한 결과 문제의 답이 있다.하지만 이 문제는 DFS로 접근할 수 없는데, 그 이유는, 각각의 선택을 깊이 기준으로 탐색했을 때, 답에 다다르지 못하는 상황이 있을 수 있기 때문이다. 따라서 무한 루프에 빠지거나, 혹은 이 부분을 거르는 코드를 작성해야 하는데 상당히 번거롭다.이런 경우 오히려 BFS로 생각했을 때, 문제가 확 와닿는 경우가 많다. BFS로 탐색할 경우, 시간의 기준으로 완전 탐색하기 때문에 이 문제의 의도와 정확히 맞아 떨어진다. 최대한 짧은 시간에 답과 일치할 경우 반복문을 빠져나오면 되기 때문이다. 따라서 위치에 따른 시간을 저장할 필요가 있다.이 때, 선택지에 $+1, -1$이 있고 중간중간 $\\times2$ 도 있어 중복되는 위치에 방문할 가능성이 있다. 이 부분의 시간 복잡도를 줄이기 위해 메모리를 사용하여 코드를 짰다.Code// 실버1 : 백준 1697번 숨바꼭질#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int N = 0, K = 0;bool map[100001] = {0};int main(){    cin &gt;&gt; N &gt;&gt; K;    queue&lt;pair&lt;int, int&gt;&gt; q;    int ans = 0;    q.push(make_pair(N, 0));    while (!q.empty()) {        int now = q.front().first, time = q.front().second;        q.pop();        if (map[now] == true) continue;        map[now] = true;        if (now == K) {            ans = time; break;        }        if (now-1 &gt;= 0) q.push(make_pair(now-1, time+1));        if (now+1 &lt;= 100000) q.push(make_pair(now+1, time+1));        if (now*2 &lt;= 100000) q.push(make_pair(now*2, time+1));    }    cout &lt;&lt; ans &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-86-8c-ec-9a-a9-eb-8f-8c-ec-9d-b4-ec-98-88-ec-81-98-ea-b2-8c-ec-b6-9c-eb-a0-a5-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1022번): 소용돌이 예쁘게 출력하기",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현, 출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 구현 문제이다.백준(1022번) - 소용돌이 예쁘게 출력하기상당히 갑갑했다. 일단 무한개의 소용돌이가 생길 수 있다는 점에서 기존의 달팽이 문제처럼 생각하면 안된다라는 판단이 들었다. 발생하는 모든 숫자를 저장한다면 메모리 초과가 날 것이 분명했기 때문이다.그래서 이 부분을 꼭 저장해야 하나? 하는 생각이 들었고, 문제에서 제시하는 규칙에 따라 소용돌이 를 만들어가면서 제시하는 좌표 내에 위치했을 때, 이를 저장해주는 방식으로 문제를 해결하기로 했다.이 과정에서 생각해야 하는 중요 문제는 다음과 같았다.  소용돌이를 만드는 규칙  들어왔을 때, 저장하는 배열과의 관계  출력시 공백 처리소용돌이 규칙            num      direction      linecount                  1      ➡      1              2      ⬆      1              3      ⬅      2              4      ⬇      2              5      ➡      3              6      ⬆      3              7      ⬅      4              8      ⬇      4              9      ➡      5      출처 : https://jksk0115.tistory.com/총 4번의 방향전환 속에 고려해야 하는 점은 몇 칸 전진? 이다. 잘 보게 되면, 방향과 방향에 따른 count와 방향과의 관계가 나온다.배열과의 관계  map[y-r1][x-c1] = num;현재 좌표는 음수를 갖고 있는 상태이다. index는 음수일 수 없으므로 우리는 이것을 평행이동 하여 (0,0) 의 상태에 저장해야 한다. 이 때, r1, c1 만큼 평행이동 한다면 정확하게 원하는 위치에 저장할 수 있다.출력시 공백 처리내가 원하는 위치에 있는 것들을 배열에 넣을 때, 가장 긴 숫자가 무엇인지 알아야 한다. 이 때, C++에 integer의 길이는 알아내기 어려우므로 string으로 바꾸어 길이를 알아내는 방법을 사용하도록 하자.이 길이보다 작은 숫자에 대해서는 그 차만큼 공백을 출력하여 문제가 원하는 답을 도출하자.입출력이 많으므로 ios_base::sync_with_stdio(false); 를 사용하자.C++ - 입출력 빠르게 받는 방법Code// 골드4 : 백준 1022번 소용돌이 예쁘게 출력하기#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int r1, r2, c1, c2;int map[50][5] = {0};int y = 0, x = 0, dir_count = 0;int linecount = 1, step = 0, num = 1, dir = 0;int map_count = 0, max_num = -1, maxLength = -1;int dy[4] = {0, -1, 0, 1}, dx[4] = {1, 0, -1, 0};int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2;    while (true) {        // 현재 위치가 원하는 위치인지 확인        if (r1 &lt;= y &amp;&amp; y &lt;= r2 &amp;&amp; c1 &lt;= x &amp;&amp; x &lt;= c2) {            max_num = max(max_num, num);            map[y-r1][x-c1] = num;            map_count++;            if (map_count == (r2-r1+1)*(c2-c1+1)) {                break;            }        }        // 소용돌이 좌표 등 속성 갱신        y += dy[dir];        x += dx[dir];        step++;        num++;        // 방향 갱신        if (step == linecount) {            dir_count++;            step = 0;            dir = (dir+1)%4;            if (dir_count == 2) {                dir_count = 0;                linecount++;            }        }    }    // map 안에서 갖는 최고 길이    maxLength = int(to_string(max_num).size());    for (int i = 0; i &lt; r2-r1+1; i++) {        for (int j = 0; j &lt; c2-c1+1; j++) {            string stringOut = to_string(map[i][j]);            if (stringOut.size() &lt; maxLength) {                for (int i = 0; i &lt; maxLength-stringOut.size(); i++) {                    cout &lt;&lt; \" \";                }            }            cout &lt;&lt; stringOut &lt;&lt; \" \";        }cout &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%9A%A9%EB%8F%8C%EC%9D%B4-%EC%98%88%EC%81%98%EA%B2%8C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-eb-a1-9c-eb-98-90-html": {
        "title": "백준(6603번): 로또",
        "tags": "백준, 알고리즘, 완전탐색, 재귀, 출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 재귀를 통한 완전탐색 문제이다.백준(6603번) - 로또단순한 문제였다. 재귀를 통해 만들 수 있는 모든 경우를 출력하면 되는 문제였다. 나 같은 경우 재귀를 통해 들어갈 때, 탐색하지 않아도 되는 부분을 거르는 코드를 작성했다. 아마 다른 분들도 작성했을 것이다.이 문제에서 고려해야 되는 점은 다음과 같다.  어떻게 출력하게 만들 것인가?  어느 상황에서 탐색을 하지 않게 가지를 칠 것인가?출력 방법checkbox라는 배열을 만들어 깊이가 6이 되었을 때 모두 출력하였다.백트래킹이 문제는 간단한 백트레킹이지만, 써보면, 현재 위치에서 나머지 공을 선택할 수 있는 가지수와 지금 부터 선택해야 하는 가지수를 비교했다.  현재 위치로 부터 남은 공의 개수 &lt; 앞으로 선택해야 하는 공의 개수이와 같은 경우는 탐색이 불가능 하므로 함수를 콜하지 않았다.Code// 실버2 : 백준 6603번 로또#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int K = 6;int arr[14];bool checkbox[14] = {0};int N = -1;void go(int start, int count){    int restOfBallFromStart = N-(start+1);    if (count == 6) {        for (int i = 0; i &lt; N; i++)            if (checkbox[i]) cout &lt;&lt; arr[i] &lt;&lt; \" \";        cout &lt;&lt; '\\n';        return;    }    for (int i = start+1; i &lt; N; i++) {        if (restOfBallFromStart &lt; K-(count+1)) break;        else {            checkbox[i] = 1;            go(i, count+1);            checkbox[i] = 0;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    while (N != 0) {        fill(&amp;arr[0], &amp;arr[13], 0);        cin &gt;&gt; N;        for (int i = 0; i &lt; N; i++) {            cin &gt;&gt; arr[i];        }        go(-1, 0);        cout &lt;&lt; '\\n';    }    return 0;}",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EB%A1%9C%EB%98%90.html"
      }
      ,
    
      "cs-structure-2020-03-23-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-cpu-html": {
        "title": "03: CPU 작동 원리",
        "tags": "컴퓨터 구조, CPU",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "CPU의 동작방법을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.디지털 회로기본적으로 연산을 수행하도록 가능하게 하는 것은 이 디지털 회로가 있기 때문이다. 이 디지털 회로는 반도체의 특징을 이용하면 가능하다. 반도체는 조건에 따라 도체가 될 수도, 부도체가 될 수도 있다. 이 성격을 이용하여 우리는 연산을 가능하게 만들 수 있다. 출처 : https://www.shutterstock.com연산 방법CPU의 핵심 기능인 연산은 어떻게 구현할까?가산기  2진수를 더하는 방법에 대한 방법이다.기본적으로 우리가 덧셈을 한다고 생각해보자. 그렇다면 우리가 덧셈을 하기 위해서 필요한 파라미터는 3개이다. 각 자리에 표현되는 a, b, 그리고 그 두 수를 더했을 때 자리올림이 발생하는지를 판단해줄 c이다.3개의 input의 결과로 자리올림을 나타내는 변수, 더한 뒤 값을 나타내는 변수 이렇게 두개의 값을 뽑아낸다. 위의 4자리 2진수의 덧셈을 수행하기 위해서는 전가산기 4개가 필요하며, 각 연산을 수행한 결과는 다음 자리수의 input으로 들어가게 된다. $C_0$는 0이다.뺄셈은..?  컴퓨터는 덧셈으로 끝난다.뺄셈은 보수의 덧셈 후 자리버림을 통해 구현이 가능하다.일반 뺄셈보수 덧셈 후 자리버림2진수에서 보수는 $0^c = 1$, $1^c=0$ 이다. 그런데 신기하게도 이 보수는 NOT연산으로 구현이 가능하다.보수란보수는 해당 숫자를 진법의 숫자에서 뺀 것을 말한다. 예를 들어 2의 보수는 $10-2=8$이다.곱셈은..?  곱셈은 더하기의 연속적인 과정이다.계속해서 더하면 곱셈구현이 가능하다. 혹은 비트 연산 중 왼쪽 shift를 사용하면 가능하다.나눗셈은?  나눗셈은 뺄셈의 연속적 과정에서 나오는 결과이다.세번 수행했고, 뺄셈이 불가능할 경우에 정지하면 몫과 나머지를 구할 수 있다.혹은 오른쪽 shifting을 하면 가능하다.0으로 나누기이런 방법이기 때문에 0으로 나누는 경우 무한루프에 진입할 수 밖에 없다. 따라서 CPU가 과열되서 터진다…. 펑!결론  CPU는 연산이 핵심이다. 그리고 그 연산은 더하기만으로 구현이 가능하다.",
        
        "url": "/cs/structure/2020/03/23/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-CPU.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ea-b0-80-ec-9e-a5-ed-81-b0-ec-a0-95-ec-82-ac-ea-b0-81-ed-98-95-ec-9d-98-eb-84-93-ec-9d-b4-html": {
        "title": "프로그래머스: 가장 큰 정사각형 찾기",
        "tags": "백준, 알고리즘, 동적계획법, 구현",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : 구현, 또는 동적 계획법을 사용하는 문제이다.프로그래머스 - 가장 큰 정사각형 찾기처음 풀이로는 빠르게 풀기 위해서 그냥 단순히 구현을 했다. 입력이 1000 x 1000 이라, 완전 탐색을 수행하더라도 로직을 최대한 덜 쓰도록 짜야된다는 생각을 하면서 짰다. 그 결과 나는 최대 넓이를 구하는 것이 목표이므로, board가 가질 수 있는 최대 변의 길이로 부터 하나씩 줄이며 가능한 정사각형을 구했을 때 return 했다.Code1#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool go(int y, int x, int len, vector&lt;vector&lt;int&gt;&gt; board){    for (int i = y; i &lt; len+y; i++){        for (int j = x; j &lt; len+x; j++){            if (board[i][j] == 0) return false;        }    }    return true;}int solution(vector&lt;vector&lt;int&gt;&gt; board){    int now = min(int(board.size()), int(board[0].size()));    int sizeY = int(board.size());    int sizeX = int(board[0].size());    while(now &gt; 0){        for (int i = 0; i &lt;= sizeY-now; i++){            for (int j = 0; j &lt;= sizeX-now; j++){                if (go(i, j, now, board)) return now*now;            }        }        now--;    }    return now;}하지만 근본적으로 최악의 경우 연산 횟수가, n^4 이다. (완전한 n^4는 아니다. 하지만 연산이 중복되는 것이 너무 많다.)  정사각형 판단 (n^2)  가능한 시작 점의 개수 (n^2)연산이 중복된다는 생각과, 또, 정사각형의 모양을 보니 작은 정사각형이 만들어져야 다음 정사각형이 만들어진다는 생각을 했다. 두 생각은 다이나믹 프로그래밍의 핵심적인 발상이기 때문에 해당 문제를 다이나믹으로 다시 구상해보기 시작했다.정의            dp적용전                           dp적용후                                       0      1      1      1      0      1      1      1              1      1      1      1      1      1      2      2              1      1      1      1      1      2      2      3              0      0      1      0      0      0      1      0        dp[y][x] = (y, x)의 위치를 포함하여 만들 수 있는 정사각형의 최대 변의 길이이렇게 정의를 하게 되면, 다음 정사각형의 변의 길이는, 상, 좌, 좌상향 대각 방향의 요소의 최소값+1에 해당하는 변의 길이로 밖에 만들 수 없다.  dp[y][x] = min(dp[y-1][x-1], dp[y][x-1], dp[y-1][x])dp는 항상 초기값을 세팅해주어야 하는데, 이 경우 y = 0일 때, x = 0 일 때 값을 고정한 상태로 점화식을 적용하면 된다. 이 때, 초기값으로 부터 answer가 도출될 수 있다는 점을 주의하자. 예외에 걸릴 수 있다. (내가)Code2#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;vector&lt;int&gt;&gt; board){    int ans = -1;    int sizeY = int(board.size());    int sizeX = int(board[0].size());    for (int i = 0; i &lt; sizeY; i++) ans = max(board[0][i], ans);    for (int i = 0; i &lt; sizeX; i++) ans = max(board[i][0], ans);    for (int i = 1; i &lt; sizeY; i++) {        for (int j = 1; j &lt; sizeX; j++) {            if (board[i][j] == 0) continue;            else {                int minNum = min(board[i-1][j], board[i-1][j-1]);                minNum = min(minNum, board[i][j-1]);                if (minNum != 0) {                    board[i][j] = minNum+1;                    ans = max(ans, board[i][j]);                }            }        }    }    return ans*ans;}",
        
        "url": "/cs/algorithm/2020/03/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%98-%EB%84%93%EC%9D%B4.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ed-94-bc-eb-b3-b4-eb-82-98-ec-b9-98-ed-95-a8-ec-88-98-html": {
        "title": "백준(1003번): 피보나치 함수",
        "tags": "백준, 알고리즘, 피보나치, 동적계획법",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 동적 계획 법을 사용하는 문제이다.백준(1003번) - 피보나치 함수Code// 백준 1003번 피보나치 함수#include &lt;iostream&gt;using namespace std;int N = 0, T = 0;int dp[50] = {0};// dp[n] = an 까지의 호출되는 1의 개수// dp[n] = dp[n-2] + dp[n-1];// 호출되는 0의 개수는, dp[n-1]과 동일하다.int main(){    dp[0] = 0;    dp[1] = 1;    for (int i = 2; i &lt; 41; i++) {        dp[i] = dp[i-1] + dp[i-2];    }    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; N;        if (N == 0) cout &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; dp[N] &lt;&lt; '\\n';        else        cout &lt;&lt; dp[N-1] &lt;&lt; \" \" &lt;&lt; dp[N] &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ec-9c-a0-ea-b8-b0-eb-86-8d-eb-b0-b0-ec-b6-94-html": {
        "title": "백준(1012번): 유기농 배추",
        "tags": "백준, 알고리즘, 유기농 배추, 그래프, DFS",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : dfs를 사용하는 기초적인 문제이다.백준(1012번) - 유기농 배추이런 문제를 풀 때, 생각보다 실수를 많이하는 부분은, testcase가 있을 때, 초기화를 하지 않는 것이다. 항상 testcase가 있는 문제는, 이 부분을 유념해야 한다. 또 초기화를 할 때, 연산이 수반되기 때문에, 어떠한 방식으로 초기화하는 것이 좋은지 생각하며 코드를 짜는 것이 바람직하다. 무조건적인 초기화는 안전성을 장담할 수 있지만 자칫하면 불필요한 연산을 수반할 수 있다.인접한 녀석들에 대해 1마리의 지렁이가 있으면 된다.1을 발견하면, dfs를 통해 인접한 것들의 값을 변경하고 globalAns의 값을 1증가시킨다.이 때, 정사각 지형을 다 탐색할 필요는 없다.나는 1이 있는 위치에서 시작해서 탐색만 하면 된다.따라서 입력 받을 때, 해당 위치만을 기억하는 배열을 하나 잡고, 이 것을 모두 확인하면 된다.Code// 백준 1012번 유기농 배추#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; baechuLoc;int T = 0;int N = 0, M = 0, baechuNum = 0, ans = 0;int map[51][51];int dy[4] = {0, 1, 0, -1}, dx[4] = {1, 0, -1, 0};void go(int now_y, int now_x){    map[now_y][now_x] = 2;    for (int i = 0; i &lt; 4; i++) {        int next_y = now_y + dy[i], next_x = now_x + dx[i];        if (map[next_y][next_x] == 1) {            go(next_y, next_x);        }    }}int main(){    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; N &gt;&gt; M &gt;&gt; baechuNum;        fill(&amp;map[0][0], &amp;map[N][M-1], 0);        baechuLoc.clear();        ans = 0;        for (int i = 0; i &lt; baechuNum; i++) {            int tempY, tempX;            cin &gt;&gt; tempY &gt;&gt; tempX;            map[tempY][tempX] = 1;            baechuLoc.push_back(make_pair(tempY, tempX));        }        for (int i = 0; i &lt; baechuNum; i++) {            if (map[baechuLoc[i].first][baechuLoc[i].second] == 1) {                go(baechuLoc[i].first, baechuLoc[i].second);                ans++;            }        }        cout &lt;&lt; ans &lt;&lt; '\\n';    }}",
        
        "url": "/cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%EC%9C%A0%EA%B8%B0%EB%86%8D%EB%B0%B0%EC%B6%94.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ec-98-a4-eb-a5-b4-eb-a7-89-ec-88-98-html": {
        "title": "백준(11057번): 오르막 수",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획 법을 사용하는 문제이다.백준(11057번) - 오르막 수대표적인 동적계획법 문제이다.기초적인 동적 계획법 문제를 풀 때에는 펜을 갖고 쓰는 것이 중요해보인다. 기본적으로 점화식을 갖고 해결하는 방식이기 때문에, 수열 문제를 푸는 것도 같은 사고로 접근해야 한다. 수열 문제가 눈에 들어오지 않으면 쓰면서 규칙을 찾아내듯, 이것도 손아프다고 징징대지말고 쓰면서 찬찬히 푸는 것이 문제를 가장 효과적이고 간결하게 풀 수 있는 방법이다.N : 1, N : 2            숫자      오르막 수 개수      숫자      오르막 수 개수                  0      1      공란      공란              1      1      10~19      1~9 : 9              2      1      20~29      2~9 : 8              3      1      30~39      3~9 : 7              4      1      40~49      4~9 : 6              5      1      50~59      5~9 : 5              6      1      60~69      6~9 : 4              7      1      70~79      7~9 : 3              8      1      80~89      8~9 : 2              9      1      90~99      9~9 : 1      규칙을 보게 되면, 최고 자리 수가 어떤 수이냐에 따라 그 다음 자리수는 결정이 되게 된다. 그런데 여기서 잘 보면, N : 2일 때, 최고자리수가 1인 경우, 오르막 수의 개수는 1의 자리 숫자가 1~9까지 오는 경우가 모두 오르막 수가 될 수 있다.추가적으로 최고자리수가 2인 경우는, 일의 자리 숫자가 2인 경우부터 발생하는 모든 오르막 수를 더함으로서 만들어진다.이 규칙을 자세히 보면, 변화하는 파라미터는 총 두개이다.  최고자리의 수  최고자리에 위치하는 숫자이 두가지 특징을 가지고 dp를 정의하고, 점화식을 세워보자.  dp[N][m] = N 자리수를 가지는 수가 M의 숫자를 가질 때 가질 수 있는 오르막 수의 개수  dpdp[N] = N 자리수를 가지는 수가 가질 수 있는 오르막 수의 개수이렇게 정의했을 때, dp 점화식의 정의는 다음과 같다.이걸 가지고 dpdp 점화식을 세우면 다음과 같다.수식도 세웠으니 이제 구현만 하면 된다. 이때, dp를 수행하기 위해서는 초기값을 설정해 줘야 하는데, 이 경우에는 N : 1 인 경우에 해당하는 모든 숫자에 1의 값을 준 뒤에 시작해야 한다.Code// 백준 11057번 오르막 수#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;int dp[1001][10] = {0};int dpdp[1001] = {0};int mod = 10007;int main(){    cin &gt;&gt; N;    // 초기값 세팅    for (int i = 0; i &lt; 10; i++) {        dp[1][i] = 1;    }    dpdp[1] = 10;    for (int i = 2; i &lt;= N ; i++) {        // dp[N][M]을 구하는 코드        for (int j = 1; j &lt; 10; j++) {            for (int k = j; k &lt; 10; k++) {                dp[i][j] += dp[i-1][k];                dp[i][j] %= mod;            }        }        // dpdp[N]을 구하는 코드        for (int j = 0; j &lt; 10; j++) {            dpdp[i] += dp[i][j];        }        dpdp[i] += dpdp[i-1];        dpdp[i] %= mod;    }    // 정답    cout &lt;&lt; dpdp[N] &lt;&lt; '\\n';}",
        
        "url": "/cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%EC%98%A4%EB%A5%B4%EB%A7%89%EC%88%98.html"
      }
      ,
    
      "dv-sp-2020-03-22-react-movie-app-clone-html": {
        "title": "Movie App Clone",
        "tags": "side-project, clone-coding, movie-app",
        "date": "March 22, 2020",
        "author": "",
        "category": "DV/SP",
        "content": "React를 사용하여 동적인 느낌이 나는 movie app을 만들어보았다.React-Movie-App",
        
        "url": "/dv/sp/2020/03/22/react-movie-app-clone.html"
      }
      ,
    
      "dv-sp-2020-03-22-html-css-kakaotalkclone-html": {
        "title": "KaKaoTalkClone",
        "tags": "side-project, clone-coding, kakaotalk",
        "date": "March 22, 2020",
        "author": "",
        "category": "DV/SP",
        "content": "카카오톡 디자인을 클론 코딩해보았다.카카오톡 클론 코딩",
        
        "url": "/dv/sp/2020/03/22/html-css-kakaotalkClone.html"
      }
      ,
    
      "cs-structure-2020-03-22-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-bit-ec-a7-84-eb-b2-95-eb-b3-80-ed-99-98-html": {
        "title": "02: bit, 진법 변환",
        "tags": "컴퓨터 구조, bit, 진법",
        "date": "March 22, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "bit와 진법 변환에 대해 알아본다.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.bit  1bit는 전기 스위치 1개이고, ON/OFF 두가지 상태를 표시할 수 있다.1bit는 2진수 한자리 숫자를 표현할 수 있다.결국 두가지 상태의 조합으로 우리는 숫자를 표시할 수 있다. 이 조합을 표현하는데 있어 가장 작은 단위를 bit라 한다.4bit  4bit로는 16진수 한자리를 표현할 수 있다.16진수는 0~F(0~15) 까지 한 자리에 쓴다.            2진수(4bit)      16진수                  1010      A(10)              1011      B(11)              1100      C(12)              1101      D(13)              1110      E(14)              1111      F(15)      byte  8bit : 영문자 한 글자를 저장할 수 있는 기억 공간의 최소단위가장 작은 단위가 bit라면, 기억공간을 관리하는데 가장 작은 단위는 1byte이다.연습            16진수      2진수      10진수      용량                  0x73      0111 0011      $16^1\\times7+16^0\\times3=115$      1byte      ",
        
        "url": "/cs/structure/2020/03/22/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-bit-%EC%A7%84%EB%B2%95%EB%B3%80%ED%99%98.html"
      }
      ,
    
      "cs-structure-2020-03-21-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-9a-a9-ec-96-b4-ec-a0-95-eb-a6-ac-html": {
        "title": "01: 용어 정리",
        "tags": "컴퓨터 구조, 용어",
        "date": "March 21, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.PC 조립 과정 보며 구조 이해하기컴퓨터 하드웨어 구성 요약다나와다나와이곳에 가면 컴퓨터 용어에 대한 간단한 설명들을 쉽게 알 수 있다.컴퓨터란?CPU가 가장 중요하다. 컴퓨터의 기본 정체성은 연산을 하는 기계이기 때문에, 이 연산을 담당하는 CPU가 컴퓨터를 거의 대표한다고 볼 수 있다. 요리에 비유한다면 좋은 칼, 좋은 도구 등이 될 수 있겠다.하지만 재료가 없으면 요리를 할 수 없다. 따라서 우리는 CPU가 연산을 수행할 수 있도록 재료에 해당하는 메모리를 주어야 한다. 그 과정에서 보조 기억 장치인 RAM, HDD, SDD 등이 필요하다.Interface  주변기기와 연결되는 지점기본적으로 컴퓨터는 CPU, RAM으로 동작한다. 이 때 추가적인 기억 장치인 HDD, SDD들이 이 컴퓨터에 연결할 때 사용하는 것이 interface이다. 현재는 SATA라는 interface를 사용한다. SATA는 interface 중 하나이며, 어떤 장치를 연결하느냐에 따라 필요한 interface는 달라질 수 있다.운영체제에서 사용하는 용어동시성  여러 일을 여러 사람이 각자 동시에 하는 것행위도 여러개, 주체도 여러개병렬성  같은 일을 여러 사람이 동시에 하는 것군대 삽질 분대가 다같이행위는 하나, 주체는 여러개병렬성은 동시성에 포함된다.원자성  쪼개어 나눌 수 없는 연속된 일어떤 일을 최대한 쪼갰을 때의 가장 작은 단위의 행위원자성은 병렬성을 가지는 상태에서 동기화 라는 작업이 중요하다.의존성  전제조건행위에 대한 의존, 존립에 대한 의존출근(행위)출근 하기 위한 방법이 버스를 타야 가능하다고 생각해보자. 그렇다면 출근이라는 행위는 버스에 의존적이다.자동차 부품(존립)자동차를 구성하는 다양한 부품은 자동차라는 객체가 사라지면 그 부품들의 존재도 사라진다. 그렇다면 부품이라는 존립은 자동차에대해 의존성을 가진다.동기화  원자성을 가지는 행위에 대해 시작과 끝을 알리는 행위화장실 들어갈 때 문잠구는 거규칙 준수의 개념과도 비슷하다.예를 들어, 100개의 인형에 눈을 다는 작업이 있다고 하자. 그렇다면 이 작업은 동시성을 가진다. 그리고 같은 작업을 여럿이 달려들어 수행할 수 있기 때문에 병렬성도 가진다. 이 때, 하나의 인형에 눈을 다는 작업은 원자성을 가진다고 가정하자. 즉, 눈을 다는 작업은 한 사람만이 수행할 수 있고 눈을 다는 작업은 연속적이기 때문에 방해받을 수 없다. 이런 경우에 사람이 1000명이 있더라도 작업에 투입될 수 있는 최대 인원은 100명이다. 그런데 만약 하나의 작업을 수행하고 있는 인원에게 일이 없는 다른 사람이 방해한다면, 해당 작업은 충돌이 발생한다. 이런 과정을 막기 위해서 작업을 수행하는 인원은, 작업을 수행하기 전에 나 작업시작한다! 처럼 알려주는 행위가 필수적으로 요구된다. 이러한 알림을 동기화 라고 한다.교착상태(Deadlock)  이러지도 저러지도 못하는 상태화장실에 휴지 없어서 못나오는 상태원자성을 보장 받는 행위에 대해서 행위가 끝나야 다음 처리가 이루어지는 상황에서 특정 조건 때문에 행위가 끝나지 않아 멈춰버리는 상태를 말한다. 심각한 논리적 오류 때문에 발생한다.예외처리 잘해라하드웨어, 운영체제, 프로세스, 스레드  컴퓨터가 ‘영토’라면 운영체제는 ‘정부조직’스레드는 ‘국민’이고 프로세스는 ‘가족’컴퓨터라는 하드웨어를 가지고 System software인 운영체제와, User software인 프로세스가 돌아가게 된다.Kernel  운영체제의 근간을 이루는 핵심 코드어떠한 방식으로 자원을 나눠주고, 프로세스를 관리하는지, 프로그램이 요구하는 시스템 콜 같은 중요한 작업을 수행하는 코드를 말한다. 그렇기에 어떤 커널을 사용하느냐에 따라 OS의 정체성이 규정된다. 이 부분이 손상될 경우 OS가 사용 불가능해 진다.Virtual Memory가족들은 보통 집에서 생활한다. 이 집은 컴퓨터에 대응해서 생각하면, 메모리 공간이다. 각각의 프로세스는 이러한 전용 공간, 즉 가상 메모리를 갖는다.Thread가족 안에 구성원들이 있고, 이 구성원들은 각자 자유로이 활동하듯이 프로세스 내에서 작동하는 개별 흐름(thread)이다. 해당 스레드는 속한 프로세스에 할당된 자원을 공유한다.스레드는 프로그램의 흐름(연산의 흐름)에 있어서 가장 작은 단위를 뜻한다.",
        
        "url": "/cs/structure/2020/03/21/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC.html"
      }
      ,
    
      "dv-css-2020-03-20-transition-display-none-html": {
        "title": "opacity를 사용하여 display none animation 만들기",
        "tags": "css, transition, opacity",
        "date": "March 20, 2020",
        "author": "",
        "category": "DV/CSS",
        "content": "css를 사용하여 애니메이션 효과를 주는 법을 알아보자.Html&lt;div class=\"chat__write--container\"&gt;  &lt;input    type=\"text\"    class=\"chat__write\"    placeholder=\"Send message\"    class=\"chat__write-input\"  /&gt;  &lt;div class=\"chat__icon-left chat__icon\"&gt;    &lt;i class=\"far fa-plus-square\"&gt;&lt;/i&gt;  &lt;/div&gt;  &lt;div class=\"chat__icon-right chat__icon\"&gt;    &lt;span class=\"chat__write-icon\"&gt;      &lt;i class=\"far fa-smile-wink\"&gt;&lt;/i&gt;    &lt;/span&gt;    &lt;span class=\"chat__write-icon\"&gt;      &lt;i class=\"fas fa-microphone\"&gt;&lt;/i&gt;    &lt;/span&gt;  &lt;/div&gt;&lt;/div&gt;  위의 상황에서 문자를 보내는 것을 클릭했다고 생각해보자. 그 경우, 주변에 있는 아이콘이 사라졌으면 좋겠다. 그런데, 그 아이콘의 속성을 display: none;으로 할 경우, 애니메이션 효과를 넣을 수 없게 된다.그래서 속성의 값중 실수 값을 가질 수 있으면서 같은 효과를 내는 opacity 속성을 사용한다.CSS.chat__write:focus ~ .chat__icon {  opacity: 0;}.chat__icon {  font-size: 23px;  transition: opacity 0.5s ease-in-out;}여기서 ~ 선택자는, 형제 선택자이다.중요여기서, 중요한 것은, 내가 없애고 싶은 아이콘은, input 태그 뒤에 있어야 한다는 점이다. 만약 그렇지 않다면 애니메이션이 적용되지 않는다. 결과적으로 CSS로 어떤 효과를 주고 싶을 때는, 내가 액션을 취할 태그를 html 문서의 앞에 적어주어야 동작한다.",
        
        "url": "/dv/css/2020/03/20/transition-display-none.html"
      }
      ,
    
      "dv-css-2020-03-20-navbar-fixed-html": {
        "title": "navbar, footer 고정하기",
        "tags": "css, position, fixed",
        "date": "March 20, 2020",
        "author": "",
        "category": "DV/CSS",
        "content": "상단 navbar나 footer 같이 고정할 필요성이 있는 html 요소를 어떻게 빠르게 만들지 정리했다.이 부분을 생각할 때 조금 어려웠던 것은, navbar 같은 경우, 어떻게 html 구조를 짜야되는 지 였다. 하지만 조금만 생각해보니, 굳이 떼어내서 구조화할 필요 없이 그냥 필요한 요소들을 만들고, 이를 보여주는 방식, css에서 display만 변화시키면 되는 문제였다.물론, 이 과정에서 class 이름을 바꾸고 body를 해당 nav의 높이 만큼 padding 혹은 margin을 주어야 하지만, html 구조에 있어 navbar는 그대로 두어도 상관없다.",
        
        "url": "/dv/css/2020/03/20/navbar-fixed.html"
      }
      ,
    
      "dv-html-2020-03-19-span-height-is-not-block-html": {
        "title": "span의 height는 block 속성이 아니다.",
        "tags": "css, span, height, block",
        "date": "March 19, 2020",
        "author": "",
        "category": "DV/HTML",
        "content": "text를 쓰는 데 있어 어떤 tag를 써야 하는지, 또 그랬을 때 문제는 무엇인지 알아보자.text는 span 태그에 넣어서 관리한다.div안에 text를 넣으면 좋지 않다.이번에 겪은 문제로는 box-shadow가 먹지 않았다.그렇다고 div에 있던 텍스트를 span으로 교체하면 문제가 생긴다.span 태그는 기본적으로 inline 속성을 강하게 띈다.그렇기 때문에 다음 그림과 같이 margin을 먹였음에도 불구하고 내가 원하는 모양대로 속성이 먹히지 않는다.div와 span의 가장 큰 차이는 display: block, inline따라서 만약에 다 뒤집어 엎고 교체하기 싫다면, display: block 속성을 추가해주면 된다.결론가장 좋은 방법은, text를 쓰는 공간에는 span을 써주고, 이 공간 자체를 box처럼 쓰고 싶다면 display block을 써주자.또는 아예 box와 textbox를 구분해서 만들어주는 것도 좋은 방법이다.",
        
        "url": "/dv/html/2020/03/19/span-height-is-not-block.html"
      }
      ,
    
      "cs-css-2020-03-19-position-fixed-center-ec-a0-95-eb-a0-ac-html": {
        "title": "position fixed에서 중앙 정렬하기",
        "tags": "css, center-arrangement, position, fixed",
        "date": "March 19, 2020",
        "author": "",
        "category": "CS/CSS",
        "content": "position : fixed에서 중앙 정렬하는 방법.class {  position: fixed;  /* fixed를 쓸 때에는 width, height를 명시해줘야 한다. */  width: 80%;  /* left, right는 해당 요소의 위치 시작점을 결정한다. 그런데, 이때, margin의 양 값을 auto로 줌으로써 마진을 주어 해당 요소의 양 끝 위치를 각각 0으로 만들어준다. */  margin: 0 auto;  left: 0;  right: 0;  /* 다른 것들 */  display: flex;  background-color: red;  padding: 20px 50px;  border-radius: 40px;}",
        
        "url": "/cs/css/2020/03/19/position-fixed-center-%EC%A0%95%EB%A0%AC.html"
      }
      ,
    
      "dv-javascripts-2020-03-18-ea-b0-9c-eb-b0-9c-ed-99-98-ea-b2-bd-ec-84-b8-ed-8c-85-html": {
        "title": "개발 환경 초기 세팅",
        "tags": "development, setting",
        "date": "March 18, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "개발을 시작하기 전에 환경 설정해야 하는 것들을 적어둔다.      gitignore        git setting : 이 부분은, terminal에서 clone 후, vscode로 여는 것이 가장 깔끔했다. 그 경우 remote 설정도 안해줘도 순탄하다.  왜 잘 작동을 안하는가ㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹ ㅇㄹ. ㄴㅇㄹㄴㅇㄹ.ㄴㅇㄹㄴㅇㄹ안녕하세요.ㄴㅇㄹㄴㅇ.ㄴㅇ란우라ㅣㄴㅇㄹㄴ앙ㄴㄹㄴㅇㄹ.ㄴ일ㄴㅇㄹㄴㅇ룬ㅇ린ㅇㄴㅇㄹ ㄴㅇ룬ㅇㄴㅇ라ㅣㄴ울ㄴㅇ룬ㅇㄹsdfsdf;sdfsdf",
        
        "url": "/dv/javascripts/2020/03/18/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%B8%ED%8C%85.html"
      }
      ,
    
      "dv-javascripts-2020-02-28-js-html": {
        "title": "개발 시 고려해야 하는 점",
        "tags": "JS, develop",
        "date": "February 28, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "개발 시작하기 전에 플로우를 기록해 둔다.html  그룹을 잘 묶어서 짠다.  하나의 기능이 들어간다고 하더라도 2중으로 그룹화 하는 것이 좋다.  입력 단위는 업데이트 되는 단위로 묶어준다.CSS  reset.css 파일 만들고 복사  내가 사용한 css 파일에 import  기본적으로 항상 css는 body 태그에 대해 설정을 하고 시작하는 것이 좋다. body 태그 안에서 설정해줘야 하는 것은 기본적으로 배경색과 폰트정도가 있다.  집합구조를 잘 생각해서 짠다.  css에서 먹일 때도 명확하게 이 객체의 위치를 명시적으로 적은 후에 걸어준다.JS      여거개의 객체 tag에 대해 같은 이벤트를 얻고 싶을 떄는 id로 js#@%@%이렇게 저장하는 것이아니고 class로 저장한다. 그 이후에 ‘getElementByClassName’으로 불러오면, 자동으로 배열로 모든 class에 해당하는 녀석을 가져온다.        이 때 불러와진 녀석은 배열이 아니다. 유사배열이다. JSON 파일과 같다고 보면 된다. 즉, a[0] 처럼 접근은 가능하나, Array의 메서드를 사용할 수 없다.    for (let i = 0; i &lt; colors.length; i++) {  const element = colors[i];  element.addEventListener(\"click\", handleColorChanging);}        Array.from(colors).forEach(item =&gt; {  console.log(item);  item.addEventListener(\"click\", handleColorChanging);});        따라서 이 두 코드는 같은 작동을 한다.        querySelector 사용처는 다음과 같다. 일반적으로 하나밖에 없는 이름을 갖고 있는 태그라면 querySelector를 쓰는게 좋아보인다.이 경우, 해당 객체에서 다시 querySelector를 사용할 수 있기 때문에, 사용하기 편리하다. 다만 가장 위에 있는 객체하나만을 들고 오기 때문에 여러개가 있을 경우 좋지 않다. 여러개를 들고 올 경우에는 getElementClassName을 사용하는 것이 좋아보인다. 이경우 HTMLCollenction이라는 객체로 들고오며, 이를 Array로 바꿔 사용하면 편리하다. getElementId 는 하나만 빠르게 들고올 떄 사용하면 편리하다.  ",
        
        "url": "/dv/javascripts/2020/02/28/JS.html"
      }
      
    
  };
</script>

<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" charset="utf-8"></script>-->
<script src="./js/lunr.min.js" charset="utf-8"></script>
<script src="/assets/js/search.js" charset="utf-8"></script></section>
</article>
    </div>
    
    


<footer class="site-footer">
	<p class="text">이전 블로그 <a href="https://egg-money.tistory.com">완숙의 에그머니</a>
</p>
</footer>


  </body>
</html>
