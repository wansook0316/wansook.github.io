<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | 완숙의 에그머니🍳</title>
	<meta name="description"
		content="개발, 데이터, 통계, 수학를 좋아하는 반항아의 블로그">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="완숙의 에그머니🍳"
		href="/feed.xml" />

	<!-- Font Awesome -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
		integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Nanum+Gothic|Jua|Nanum+Gothic+Coding|Source+Code+Pro|Nanum+Myeongjo:400|Noto+Sans+KR:100,300" rel="stylesheet"
		type="text/css">
	

	<!-- KaTeX -->
    <!--
	

    -->
	<!-- Google Analytics -->
	
	<script>
		(function (i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date(); a = s.createElement(o),
			m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'UA-156961472-1', 'auto');
		ga('send', 'pageview');
	</script>
	
  
  <!-- Latex -->
<!--
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
-->
  
    
	<script>
console.log(window)

window.addEventListener("resize", changeContent);
window.addEventListener("load", changeContent);

function changeContent(event){
  const width = window.innerWidth;
  console.log(event);
  const cat = document.getElementById("js-cat");
  const cv = document.getElementById("category-cv");
  const math = document.getElementById("category-math");
  const ds = document.getElementById("category-ds");
  const cs = document.getElementById("category-cs");
  const dv = document.getElementById("category-dv");
  const about = document.getElementById("category-about");
  if (width < 710) {
    cv.innerText = "📜"
    math.innerText = "✖"
    ds.innerText = "📈"
    cs.innerText = "💾"
    dv.innerText = "📱"
    about.innerText = "😎"
    cat.style.justifyContent = "space-around"
  } else {
    cv.innerText = "CV"
    math.innerText = "Math"
    ds.innerText = "Data Science"
    cs.innerText = "Computer Science"
    dv.innerText = "Development"
    about.innerText = "About"
    cat.style.justifyContent = "center"
  }
  
}

</script>
</head>
  <body>
    <header class="site-header">
    <div class="site-title-nav">
        <div class="branding">
            
            <a href="/">
                <img class="avatar" src="/assets/img/avatar.png" alt=""/>
            </a>
            
            <h1 class="site-title">
                <a href="/">완숙의 에그머니🍳</a>
            </h1>
        </div>
    </div>
    <nav class="site-nav">
            <ul>
<!--
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                <li>
                    <a class="page-link" href="/about/">
                        About Me
                    </a>
                </li>
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
-->
                <!-- Social icons from Font Awesome, if enabled  -->
<!--                














<li>
	<a href="https://github.com/wansook0316" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>





























-->

                <!-- Search bar -->
                <li>
                














<li>
	<a href="https://github.com/wansook0316" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>






























                </li>
                
                <li>
                <form action="/search.html" method="get">
                    <input type="text" id="search-box" name="query" placeholder="Search" class="">
                    <button type="submit" class="">
                        <i class="fa fa-fw fa-search"></i>
                    </button>
                </form>
                </li>
                
                
            </ul>
        </nav>
  
  
  
  
  

</header>

<div class="site-category">
    <ul class='cat1' id="js-cat">

      
      <li><a id="category-cv"href="/"> </a>
        <ul>
            <li><a href="/CV/Projects">Projects</a></li>
            <li><a href="/CV/Awards">Awards</a></li>
            <li><a href="/CV/Papers">Papers</a></li>
            <li><a href="/CV/ExtraCurricular Act">ExtraCurricular Act</a></li>
            <li><a href="/CV/InternShip">InternShip</a></li>
            <li><a href="/CV/Language">Language</a></li>
            <li><a href="/CV/Education">Education</a></li>
            <li><a href="/CV/Cources">Cources</a></li>
        </ul>
      </li>
      
      <li><a id="category-math"href="/"> </a>
        <ul>
            <li><a href="/Math/Mathematical Statistics">Statistics</a></li>
            <li><a href="/Math/Linear Algebra">Linear Algebra</a></li>
            <li><a href="/Math/Calculus">Calculus</a></li>
        </ul>
      </li>

      <li><a id="category-ds" href="/"> </a>
        <ul>
          <li><a href="/DS/R">R</a></li>
          <li><a href="/DS/ESL">ESL</a></li>
          <li><a href="/DS/ML">Machine Learning</a></li>
        </ul>
      </li>
      
      <li><a id = "category-cs" href="/"> </a>
        <ul>
          <li><a href="/CS/Database">Database</a></li>
          <li><a href="/CS/Algorithm">Algorithm</a></li>
          <li><a href="/CS/Structure">Structure</a></li>
          <li><a href="/CS/OS">OS</a></li>
        </ul>
      </li>


      <li><a id="category-dv" href="/"> </a>
        <ul>
          <li><a href="/DV/Ubuntu">Ubuntu</a></li>
          <li><a href="/DV/Python">Python</a></li>
          <li><a href="/DV/Cpp">C++</a></li>
          <li><a href="/DV/HTML">HTML</a></li>
          <li><a href="/DV/CSS">CSS</a></li>
          <li><a href="/DV/JavaScript">JavaScript</a></li>
          <li><a href="/DV/React">React</a></li>
          <li><a href="/DV/Django">Django</a></li>
          <li><a href="/DV/Git">Git</a></li>
          <li><a href="/DV/Tips">Tips</a></li>
        </ul>
      </li>

      
      <li><a id="category-about" href="/about/"> </a></li>
      
    
  
<!--    <ul class="cat2">-->
      
<!--  </ul>-->
    </ul>
  
  </div>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "cs-os-2020-03-30-test-2-html": {
        "title": "test - 2",
        "tags": "OS",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "test 2",
        "url": "//cs/os/2020/03/30/test-2.html"
      }
      ,
    
      "cs-os-2020-03-30-test-1-html": {
        "title": "test - 1",
        "tags": "OS",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "test 1",
        "url": "//cs/os/2020/03/30/test-1.html"
      }
      ,
    
      "cs-structure-2020-03-29-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ea-b0-80-ed-95-98-eb-8a-94-ec-9d-bc-html": {
        "title": "컴퓨터 구조 - 운영 체제가 하는 일",
        "tags": "컴퓨터 구조, 운영체제, 스케쥴링, 가상메모리",
        "date": "March 29, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "운영 체제가 하는 일을 간단하게 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.운영체제가 하는 일  접근 제어 + 동기화 + 관리전산 자원을 관리한다. 대표적인 전산 자원은 CPU, RAM 등이 있다. 스타판 프로게이머프로그램’들’ 관리하기  Process를 관리한정된 자원으로 많은 프로그램들이 동작해야 한다. 어쩔 수 없이 나눠서 사용해야 한다.아래 단어들의 의미를 모른다면, 용어를 알고 다시 읽자.하드웨어, 운영체제, 프로세스, 스레드 용어 정리Scheduling  멀티 프로세스 운영체제에서 하나의 CPU가 복수의 프로세스를 실행하기 위해 CPU를 사용하는 순서를 정해주는 작업이렇게 다양한 프로세스를 동시에 작업하게 되면, 스레드가 CPU를 사용하고 있을 떄, 사용하고 있다고 알려주는 동기화가 매우 중요하다.Virtual Memory System  RAM과 HDD를 하나의 논리적 메모리로 추상화시킨 메모리 관리 방법프로세스가 운영체제로 부터 메모리를 할당 받는 일은 시간이 많이 걸리는 일이다. 그렇기 때문에 최대한 RAM 공간에 할당 받은 채로 존재하는 것이 속도를 높일 수 있는 방법이다. 또한 여러개의 프로세스를 사용할 경우, RAM 공간을 초과하여 프로세스가 동작하지 않는다. 이런 부분들을 해결하기 위해 HDD 공간을 활용한 것이 가상 메모리 시스템이다.단위이 곳에서 모든 메모리는 Page라는 단위로 관리된다. HDD와 RAM을 왔다갔다 하는 단위이다. 이 중에는 Paged 될 수 있는 페이징 풀 영역과 절대로 Paged 되면 안되는 비 페이징 풀 영역이 있다.Virtual Memory의 구성집의 공간을 가족 구성원들이 나눠쓰듯이 프로세스의 가상 메모리 공간을 thread가 나눠서 사용한다. 이 나눠서 사용하는 공간을 Stack이라 한다. 이 thread에 할당된 메모리 공간이 stack을 사용하여 관리되기 때문에 Stack이라 불린다.프로세스는 Heap과 실행 코드 영역을 갖는다. 추가바람동작 방법  RAM이 꽉찼는 지 확인한다.  꽉찼다면 현재 RAM 공간 중에 사용하지 않는 프로세스가 할당된 공간이 있다면 이것을 HDD 공간에 복사해둔다. Page Out(Swap Out)  RAM 공간이 비게 될 경우 복사해 둔 공간을 다시 RAM으로 복사한다. Page in(Swap in)프로세스 별 가상 메모리의 크기이러한 가상 메모리 시스템이 있기 때문에, 프로세스가 실행 되고 할당 받는 메모리 공간은 4GB로 할당한다. 이 크기는 현실적으로 RAM만 사용한다면 말이 안되는 소리지만, 가상 메모리를 사용하게 되면 문제없다.",
        "url": "//cs/structure/2020/03/29/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C%EA%B0%80-%ED%95%98%EB%8A%94-%EC%9D%BC.html"
      }
      ,
    
      "cs-structure-2020-03-29-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-88-ab-ec-9e-90-eb-a1-9c-eb-aa-a8-eb-93-a0-ea-b2-83-ec-9d-84-eb-8b-a4-eb-a3-a8-eb-8a-94-eb-b0-a9-eb-b2-95-html": {
        "title": "컴퓨터 구조 - 숫자로 모든 것을 다루는 방법",
        "tags": "컴퓨터 구조, 글자, ASCII, Text, binary, rendering, 렌더링, 아스키",
        "date": "March 29, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "컴퓨터가 모든 것을 숫자로 다루는 방식을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.컴퓨터로 글자를 나타내는 방법ASCII Code  숫자와 글자에 대한 함수관계를 정의한다.출처바이너리 코드(binary Code)실제로 담고 있는 정보를 Text 형태로 보여주면 ASCII Code 형태가 되고, 이것을 컴퓨터가 이해하는 방식인 숫자(보통 16진수)로 표현해 놓으면 이것을 바이너리 코드라 한다.결과적으로 사람이 읽을 수 있는 텍스트 파일 이외에 컴퓨터 저장이나 처리 목적을 위해 코드를 숫자로 변경해 놓은(인코딩) 데이터를 말한다.컴퓨터가 사진을 다루는 방법  특정 화소 하나를 숫자로 표시하고 이를 모아 사진으로 그린다.이미지 파일 형식  해당 화소를 표현하는 방식(규칙)에 대한 것.Rendering  숫자로 되어 있는 것을 글자와 사진으로 그려내는 것!이 속도가 중요하다! 렌더링이라는 것이 정확히 무엇인지 몰랐는데… 휴우",
        "url": "//cs/structure/2020/03/29/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%88%AB%EC%9E%90%EB%A1%9C-%EB%AA%A8%EB%93%A0%EA%B2%83%EC%9D%84-%EB%8B%A4%EB%A3%A8%EB%8A%94-%EB%B0%A9%EB%B2%95.html"
      }
      ,
    
      "cs-structure-2020-03-29-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ea-b8-b0-ec-96-b5-ec-9e-a5-ec-b9-98-ec-97-90-eb-8c-80-ed-95-9c-ec-9d-b4-ed-95-b4-html": {
        "title": "컴퓨터 구조 - 기억장치에 대한 이해",
        "tags": "컴퓨터 구조, 기억장치",
        "date": "March 29, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "기억 장치의 동작방법에 대해 이해해보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.Memory Device계층 구조출처 : https://programmer-student.tistory.com쉬운 이해를 위한 도표            기억장치      분류                  캐시      책상              RAM      책꽂이              HDD      도서관      컴퓨터가 관리하는 방법 - 관리 체계  컴퓨터는 모든 것이 숫자이다.그래서 기억 공간도 번호를 붙여 관리한다. 이와 같은 관리 체계는 아파트 단지를 동, 호로 관리하는 것과 비슷하다.  RAM에 있는 n번 번호에 있는 정보를 가져와  그 정보를 CPU에서 사용할 연산 저장 공간에 저장해  연산을 수행해  RAM의 m번 공간에 저장해여기서 CPU에서 저장하는 공간의 명칭이 register이다.레지스터  개별 기억 공간마다 고유 이름을 붙인다.기본적으로 레지스터는 많은 저장 공간을 갖고 있지 않다. 그래서 이 각각에 이름을 붙여 관리한다.주기억장치(RAM)  일련 번호를 붙인다.위에서 언급했던 번호에 해당하는 것이 보통 RAM에 대한 설명이다.  신발장 번호 : 주소신발 : 정보이 신발장을 컴퓨터는 약 43억 개 갖고 있는데, 이 숫자는 $2^32$ 가지에 해당하는 숫자이다. 저 숫자를 표시하기 위해서 32비트가 필요하다.보조 기억장치(HDD, SDD)  트랙 번호와 섹터 번호를 붙여 관리한다.Track중심부로 부터 밖으로 나가는 원들 중 하나를 말한다.Sector원을 균등하게 부채꼴 모양으로 나눈 것들중 하나를 섹터라 말한다.Format 이란?하드디스크의 섹터와 트랙을 구성하는 작업을 말한다. Format을 하면 데이터가 다 날아가는 이유는, 하드디스크에 정보를 저장하는 체계인 트랙과 섹터를 재구성하기 때문이다.파일 시스템하드 디스크에 내가 가진 파일의 위치를 Track, Sector로 나타낸 표            파일이름      Track      Sector                  a.mp3      1      1      이런 파일 시스템은 File Allocation Table (FAT), NTFS.. 등등 엄청 많다. 내가 파일을 삭제하면, 이 파일 시스템의 Delete Field에 True로 체크가 되고, 이 공간은 운영체제에서 쓰기 가능한 공간으로 바뀐다. 그래서 디스크 복구같은 것이 가능한 것.디스크 조각 모음하드디스크는 기본적으로 원의 형태를 띈 모양으로 구성되어 있고, 이것을 Arm을 사용해 읽는다. 그래서 갖는 특징이 있는데, 같은 track에 내가 사용하는 데이터가 모여있는 경우 입출력 속도가 빠르다. 하지만 만약에 데이터가 다른 트랙, 다른 섹터에 분산되어 있다면 이 파일을 읽기 위해서 Arm이 여러번 움직어야 한다. 관성 때문에 Arm의 속도가 느려지고 결과적으로 입출력 속도의 감소가 이루어진다.이렇게 흩어져 있는 파일을 같은 track이나 그 근처로 모으는 작업을 디스크 조각 모음이라 한다.전체 흐름  HDD에 몇번 트랙, 몇번 섹터에서 정보를 읽어와  그걸 RAM의 몇번 주소에 저장해라  그리고 그걸 다시가져와서 CPU에 EAX라는 이름을 가진 레지스터에 저장해라컴퓨터가 연산하는 과정이제 메모리가 어떻게 구성되어 있는 지를 대충 알았다면, 실제 연산과정을 들여다 보자.  캐시 메모리는 CPU 그 자체다.RAM은 CPU의 연산을 돕기위한 연습장이다.맨 위에서 보았듯이 메모리가 정보를 불러오는 데에는 속도가 존재한다. 전체적인 과정은 HDD, RAM, Resister 순으로 입출력이 일어나는데, 이 때 속도차이가 나므로 CPU가 빠르게 연산을 처리하는데 문제가 생긴다.그래서 이 병목구조를 탈피하기 위해서 CPU, RAM 등에 캐시 메모리를 두어 이 부분을 해소한다. 캐시 메모리는 CPU가 연산을 수행하는 동안 다음에 필요한 정보를 RAM에서 미리 가져와 저장하는 역을 한다. 그 결과 CPU는 RAM에서 정보를 가져올 때 걸리는 시간을 캐시에서 가져오므로써 시간적 이득을 가질 수 있다.CPU ALUALU는 가산기를 뜻한다. CPU에 대해서 배울 때, 이는 연산 처리 장치이고 모든 연산은 가산기 하나로 가능하다고 배웠다. 결과적으로 Core 하나에는 ALU하나가 들어있다고 생각하면 된다. 쿼드코어 컴퓨터는 가산기가 4개 존재한다.64bit 컴퓨터CPU가 연산을 처리할 때 발생하는 input, output의 단위가 64bit 만큼의 정보를 단위로 연산을 수행한다는 의미이다.전체 과정  RAM에서 정보를 가져온다  캐시 메모리에서 정보를 읽는다.  레지스터로 해당 값을 옮긴다.  ALU에서 연산을 수행한다.  결과를 레지스터로 복사한다.  그 값을 RAM으로 옮긴다.이런 작업을 코드라 한다. 그런데 CPU(기계)에게 명령하는 코드이므로 기계어 코드라 한다.",
        "url": "//cs/structure/2020/03/29/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4.html"
      }
      ,
    
      "cs-structure-2020-03-29-ec-9e-90-eb-a3-8c-ea-b5-ac-ec-a1-b0-ec-99-80-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "컴퓨터 구조 - 자료구조와 알고리즘",
        "tags": "컴퓨터 구조, 자료구조, 알고리즘",
        "date": "March 29, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "컴퓨터에서 사용하는 자료구조와 알고리즘을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.자료를 정리해야 하는 이유  정리를 잘 해둬야 필요할 때 빨리 꺼내 쓸 수 있다!처음엔 몰랐지만.. 갈 수록 유지 보수를 위해 정리하는 것이 중요함을 느낀다.. ㅠㅠ어떻게 정리할까?  정리 는 상황에 맞는 적절한 규칙이 존재한다.일련번호도 아무런 규칙이 없어보이지만, 그 숫자들에 규칙이 존재한다.자료구조선형 구조배열  물리적으로 순차적인 자료구조장점  단순하다.  한 자료에서 다음 자료 넘어갈 때 생각할 것이 없다. 인덱스가 단순 증가한다.단점  크기를 늘리거나 줄이려면 구조를 변경해야 한다.  중간에 새로운 자료를 넣거나 빼는 경우 문제가 발생한다.Linked List  화살표룰 가지고 원하는 요소를 가리키는 구조장점  순서를 바꾸기 매우 쉽다.  중간에 새로운 자료를 넣거나 뺴기가 쉽다.단점  한 자료 접근 후 다음으로 넘어가기 위해서 위치정보를 활용해 찾아가야한다.  찾아간다는 점에서 배열에 비해 복잡하다.Stack  뚜껑식 김치 냉장고 : 출입구가 하나다!사용처  되돌아 가기 위한 구조한 스텝 전진하고, 전으로 가기 위해서는 pop 한다.  가장 최근 값을 가져온다  대칭 구조Queue  줄을 선다!버스에서 줄을 서는 것이나 은행의 대기열을 생각하면 된다. 이 때 버스는 순차적으로 처리가 진행이 되고, 은행은 병렬적으로 처리된다. 각각을 순차 처리, 병렬 처리라 한다.비선형 구조Binary Tree선형 구조, 정렬이 안된 상황에서 특정 값을 찾는다고 생각해보자. 이런 경우 해당 배열의 크기만큼 탐색을 진행해야 한다. 결과적으로 선형 구조에서 값을 찾는 것은 상대적으로 효과적이지 않다.그래서 새로운 구조가 필요했는데 그 중 가장 효과적으로 사용한 구조가 이진 트리이다.이진 트리에 대한 내용 정리선형 구조, 비선형 구조 비교                   비선형      선형                  구조      복잡      간단              접근효율      좋다      나쁘다      물론 데이터 개수에 따라 판단을 달라질 수 있다. 상황 판단을 잘해야 한다.알고리즘Sort선형 구조에서 정렬하는 방법에 대해 생각해본다. 이 부분은 나열만 해두겠다.정렬에 대한 기초적 내용 정리선형 구조에서의 정렬 알고리즘  Bubble  Quick  Merge  Selection  Insertion  Heap  Radix",
        "url": "//cs/structure/2020/03/29/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "dv-javascripts-2020-03-26-javascript-window-event-html": {
        "title": "javascript - window resize event",
        "tags": "development, javascript, resize",
        "date": "March 26, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "자바스크립트의 window 이벤트를 알아본다.resizewindow.addEventListener(\"resize\", changeContent);function changeContent(event) {  const cat = document.getElementById(\"js-cat\");  const cv = document.getElementById(\"category-cv\");  const math = document.getElementById(\"category-math\");  const ds = document.getElementById(\"category-ds\");  const cs = document.getElementById(\"category-cs\");  const dv = document.getElementById(\"category-dv\");  const about = document.getElementById(\"category-about\");  if (event.target.innerWidth &lt; 710) {    cv.innerText = \"📜\";    math.innerText = \"✖\";    ds.innerText = \"📈\";    cs.innerText = \"💾\";    dv.innerText = \"📱\";    about.innerText = \"😎\";    cat.style.justifyContent = \"space-around\";  } else {    cv.innerText = \"CV\";    math.innerText = \"Math\";    ds.innerText = \"Data Science\";    cs.innerText = \"Computer Science\";    dv.innerText = \"Development\";    about.innerText = \"About\";    cat.style.justifyContent = \"center\";    console.log(cat);  }}이 코드는 내 블로그 카테고리를 수정할 때 만든 코드이다.",
        "url": "//dv/javascripts/2020/03/26/javascript-window-event.html"
      }
      ,
    
      "dv-css-2020-03-26-safari-longline-scroll-html": {
        "title": "Safari - long line scroll 작동 안함",
        "tags": "Browser, Safari, css",
        "date": "March 26, 2020",
        "author": "",
        "category": "DV/CSS",
        "content": "사파리에서 code block을 담당하는 pre 태그에서 long line scroll이 안되는 문제를 해결한다.참고근본적인 문제는 Safari pre태그의 초기값 때문이다.이것을 해결하기 위해서는 다음의 코드를 추가하면 된다..site-content pre {  overflow-wrap: normal;}",
        "url": "//dv/css/2020/03/26/Safari-longline-scroll.html"
      }
      ,
    
      "dv-tips-2020-03-25-latex-align-html": {
        "title": "LaTex - equation 예쁘게 맞추기",
        "tags": "LaTex, equation, align",
        "date": "March 25, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "LaTex 에서 align을 사용하여 방정식을 예쁘게 맞춰보자.수식 전개를 하다보면, 계속해서 등호를 사용하여 수식의 변경요소를 보여줄 필요가 있다.으으 못생겼다이런 경우 Latex 수식을 시작할 떄 align 속성을 걸어주면 예쁘게 사용할 수 있다.\\begin{align}A &amp; = B \\\\&amp; = C \\\\&amp;= \\cdots \\\\&amp;= Z.\\end{align}",
        "url": "//dv/tips/2020/03/25/Latex-align.html"
      }
      ,
    
      "cs-structure-2020-03-25-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-9a-a9-ec-96-b4-ec-a0-95-eb-a6-ac-html": {
        "title": "컴퓨터 구조 - 용어 정리",
        "tags": "컴퓨터 구조, 용어",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.PC 조립 과정 보며 구조 이해하기컴퓨터 하드웨어 구성 요약다나와다나와이곳에 가면 컴퓨터 용어에 대한 간단한 설명들을 쉽게 알 수 있다.컴퓨터란?CPU가 가장 중요하다. 컴퓨터의 기본 정체성은 연산을 하는 기계이기 때문에, 이 연산을 담당하는 CPU가 컴퓨터를 거의 대표한다고 볼 수 있다. 요리에 비유한다면 좋은 칼, 좋은 도구 등이 될 수 있겠다.하지만 재료가 없으면 요리를 할 수 없다. 따라서 우리는 CPU가 연산을 수행할 수 있도록 재료에 해당하는 메모리를 주어야 한다. 그 과정에서 보조 기억 장치인 RAM, HDD, SDD 등이 필요하다.Interface  주변기기와 연결되는 지점기본적으로 컴퓨터는 CPU, RAM으로 동작한다. 이 때 추가적인 기억 장치인 HDD, SDD들이 이 컴퓨터에 연결할 때 사용하는 것이 interface이다. 현재는 SATA라는 interface를 사용한다. SATA는 interface 중 하나이며, 어떤 장치를 연결하느냐에 따라 필요한 interface는 달라질 수 있다.운영체제에서 사용하는 용어동시성  여러 일을 여러 사람이 각자 동시에 하는 것행위도 여러개, 주체도 여러개병렬성  같은 일을 여러 사람이 동시에 하는 것군대 삽질 분대가 다같이행위는 하나, 주체는 여러개병렬성은 동시성에 포함된다.원자성  쪼개어 나눌 수 없는 연속된 일어떤 일을 최대한 쪼갰을 때의 가장 작은 단위의 행위원자성은 병렬성을 가지는 상태에서 동기화 라는 작업이 중요하다.의존성  전제조건행위에 대한 의존, 존립에 대한 의존출근(행위)출근 하기 위한 방법이 버스를 타야 가능하다고 생각해보자. 그렇다면 출근이라는 행위는 버스에 의존적이다.자동차 부품(존립)자동차를 구성하는 다양한 부품은 자동차라는 객체가 사라지면 그 부품들의 존재도 사라진다. 그렇다면 부품이라는 존립은 자동차에대해 의존성을 가진다.동기화  원자성을 가지는 행위에 대해 시작과 끝을 알리는 행위화장실 들어갈 때 문잠구는 거규칙 준수의 개념과도 비슷하다.예를 들어, 100개의 인형에 눈을 다는 작업이 있다고 하자. 그렇다면 이 작업은 동시성을 가진다. 그리고 같은 작업을 여럿이 달려들어 수행할 수 있기 때문에 병렬성도 가진다. 이 때, 하나의 인형에 눈을 다는 작업은 원자성을 가진다고 가정하자. 즉, 눈을 다는 작업은 한 사람만이 수행할 수 있고 눈을 다는 작업은 연속적이기 때문에 방해받을 수 없다. 이런 경우에 사람이 1000명이 있더라도 작업에 투입될 수 있는 최대 인원은 100명이다. 그런데 만약 하나의 작업을 수행하고 있는 인원에게 일이 없는 다른 사람이 방해한다면, 해당 작업은 충돌이 발생한다. 이런 과정을 막기 위해서 작업을 수행하는 인원은, 작업을 수행하기 전에 나 작업시작한다! 처럼 알려주는 행위가 필수적으로 요구된다. 이러한 알림을 동기화 라고 한다.교착상태(Deadlock)  이러지도 저러지도 못하는 상태화장실에 휴지 없어서 못나오는 상태원자성을 보장 받는 행위에 대해서 행위가 끝나야 다음 처리가 이루어지는 상황에서 특정 조건 때문에 행위가 끝나지 않아 멈춰버리는 상태를 말한다. 심각한 논리적 오류 때문에 발생한다.예외처리 잘해라하드웨어, 운영체제, 프로세스, 스레드  컴퓨터가 ‘영토’라면 운영체제는 ‘정부조직’스레드는 ‘국민’이고 프로세스는 ‘가족’컴퓨터라는 하드웨어를 가지고 System software인 운영체제와, User software인 프로세스가 돌아가게 된다.Kernel  운영체제의 근간을 이루는 핵심 코드어떠한 방식으로 자원을 나눠주고, 프로세스를 관리하는지, 프로그램이 요구하는 시스템 콜 같은 중요한 작업을 수행하는 코드를 말한다. 그렇기에 어떤 커널을 사용하느냐에 따라 OS의 정체성이 규정된다. 이 부분이 손상될 경우 OS가 사용 불가능해 진다.Virtual Memory가족들은 보통 집에서 생활한다. 이 집은 컴퓨터에 대응해서 생각하면, 메모리 공간이다. 각각의 프로세스는 이러한 전용 공간, 즉 가상 메모리를 갖는다.Thread가족 안에 구성원들이 있고, 이 구성원들은 각자 자유로이 활동하듯이 프로세스 내에서 작동하는 개별 흐름(thread)이다. 해당 스레드는 속한 프로세스에 할당된 자원을 공유한다.스레드는 프로그램의 흐름(연산의 흐름)에 있어서 가장 작은 단위를 뜻한다.",
        "url": "//cs/structure/2020/03/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC.html"
      }
      ,
    
      "cs-structure-2020-03-25-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-bit-ec-a7-84-eb-b2-95-eb-b3-80-ed-99-98-html": {
        "title": "컴퓨터 구조 - bit, 진법 변환",
        "tags": "컴퓨터 구조, bit, 진법",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "bit와 진법 변환에 대해 알아본다.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.bit  1bit는 전기 스위치 1개이고, ON/OFF 두가지 상태를 표시할 수 있다.1bit는 2진수 한자리 숫자를 표현할 수 있다.결국 두가지 상태의 조합으로 우리는 숫자를 표시할 수 있다. 이 조합을 표현하는데 있어 가장 작은 단위를 bit라 한다.4bit  4bit로는 16진수 한자리를 표현할 수 있다.16진수는 0~F(0~15) 까지 한 자리에 쓴다.            2진수(4bit)      16진수                  1010      A(10)              1011      B(11)              1100      C(12)              1101      D(13)              1110      E(14)              1111      F(15)      byte  8bit : 영문자 한 글자를 저장할 수 있는 기억 공간의 최소단위가장 작은 단위가 bit라면, 기억공간을 관리하는데 가장 작은 단위는 1byte이다.연습            16진수      2진수      10진수      용량                  0x73      0111 0011      $16^1\\times7+16^0\\times3=115$      1byte      ",
        "url": "//cs/structure/2020/03/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-bit-%EC%A7%84%EB%B2%95%EB%B3%80%ED%99%98.html"
      }
      ,
    
      "cs-structure-2020-03-25-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-cpu-html": {
        "title": "컴퓨터 구조 - CPU 작동 원리",
        "tags": "컴퓨터 구조, CPU",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "CPU의 동작방법을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.디지털 회로기본적으로 연산을 수행하도록 가능하게 하는 것은 이 디지털 회로가 있기 때문이다. 이 디지털 회로는 반도체의 특징을 이용하면 가능하다. 반도체는 조건에 따라 도체가 될 수도, 부도체가 될 수도 있다. 이 성격을 이용하여 우리는 연산을 가능하게 만들 수 있다. 출처 : https://www.shutterstock.com연산 방법CPU의 핵심 기능인 연산은 어떻게 구현할까?가산기  2진수를 더하는 방법에 대한 방법이다.기본적으로 우리가 덧셈을 한다고 생각해보자. 그렇다면 우리가 덧셈을 하기 위해서 필요한 파라미터는 3개이다. 각 자리에 표현되는 a, b, 그리고 그 두 수를 더했을 때 자리올림이 발생하는지를 판단해줄 c이다.3개의 input의 결과로 자리올림을 나타내는 변수, 더한 뒤 값을 나타내는 변수 이렇게 두개의 값을 뽑아낸다. 위의 4자리 2진수의 덧셈을 수행하기 위해서는 전가산기 4개가 필요하며, 각 연산을 수행한 결과는 다음 자리수의 input으로 들어가게 된다. $C_0$는 0이다.뺄셈은..?  컴퓨터는 덧셈으로 끝난다.뺄셈은 보수의 덧셈 후 자리버림을 통해 구현이 가능하다.일반 뺄셈보수 덧셈 후 자리버림2진수에서 보수는 $0^c = 1$, $1^c=0$ 이다. 그런데 신기하게도 이 보수는 NOT연산으로 구현이 가능하다.보수란보수는 해당 숫자를 진법의 숫자에서 뺀 것을 말한다. 예를 들어 2의 보수는 $10-2=8$이다.곱셈은..?  곱셈은 더하기의 연속적인 과정이다.계속해서 더하면 곱셈구현이 가능하다. 혹은 비트 연산 중 왼쪽 shift를 사용하면 가능하다.나눗셈은?  나눗셈은 뺄셈의 연속적 과정에서 나오는 결과이다.세번 수행했고, 뺄셈이 불가능할 경우에 정지하면 몫과 나머지를 구할 수 있다.혹은 오른쪽 shifting을 하면 가능하다.0으로 나누기이런 방법이기 때문에 0으로 나누는 경우 무한루프에 진입할 수 밖에 없다. 따라서 CPU가 과열되서 터진다…. 펑!결론  CPU는 연산이 핵심이다. 그리고 그 연산은 더하기만으로 구현이 가능하다.",
        "url": "//cs/structure/2020/03/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-CPU.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-9d-b4-ec-b9-9c-ec-88-98-html": {
        "title": "백준(2193번) - 이친수",
        "tags": "백준, 알고리즘, 동적계획법, 피보나치",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 동적계획법 문제이다.백준(2193번) - 이친수생각이 문제의 핵심은, 최고자리 숫자가 0 또는 1일 때의 상황을 분리해서 생각해보는 것이다. 이유는 나열하면 금방 알아차릴 수 있다.            N=1             N=2             N=3                         0      X      00      X      000      X              1      O      01      X      001      X                            10      O      010      X                            11      X      011      X                                          100      O                                          101      O                                          110      X                                          111      X                     1             1             2      여기서 N이 2 일 때를 생각해보면, 앞자리에 1이 있어야 하고, 그 뒤는 0으로 시작해야 한다. 0으로 시작한 이후에는 이친수가 와야한다. 그럴 경우에 새로운 이친수가 만들어진다. 따라서 N이 증가함에 따라 다음 자리수의 이친수를 만들기 위해서는 최고자리가 0인 상황에서 다음 숫자부터 가지는 이친수를 저장할 필요가 있다.정의  dp[N][0] : N자리수의 최고자리가 0일 경우 이후 자리수에서 가질 수 있는 이친수의 개수  dp[N][1] : N자리수의 최고자리가 1일 경우 가질 수 있는 이친수의 개수점화식  dp[N][0] = dp[N-1][0] + dp[N-1][1];최고자리수가 0일 때, 위의 정의에 맞는 개수를 구하기 위해서는 그 다음 자리의 수가 1인 경우와, 0인 경우가 있다. 따라서 그 두 경우를 모두 더해주어야 내가 원하는 수를 구할 수 있다.  dp[N][1] = dp[N-1][0];1인 경우에는 무조건 다음 자리수가 0으로 시작하는 이친수를 구해야 하므로 위와 같다.Code// 실버3 : 백준 2193번 이친수#include &lt;iostream&gt;using namespace std;int main(){    int N;    long long dp[91][2];    cin &gt;&gt; N;    dp[1][0] = 1;    dp[1][1] = 1;    for (int i = 2; i &lt;= N; i++) {        dp[i][0] = dp[i-1][0] + dp[i-1][1];        dp[i][1] = dp[i-1][0];    }    cout &lt;&lt; dp[N][1] &lt;&lt; '\\n';}피보나치 수열그런데 위의 점화식을 잘 정리하면 우리가 알고있는 피보나치 수열의 형태가 나온다.다이나믹은 끝이 없다.",
        "url": "//cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%9D%B4%EC%B9%9C%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-8b-9c-eb-a6-ac-ec-96-bc-eb-84-98-eb-b2-84-html": {
        "title": "백준(1431번) - 시리얼 넘버",
        "tags": "백준, 알고리즘, 정렬",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 정렬 문제이다.백준(1431번) - 시리얼 넘버생각문제에서 하라는 대로 비교만 하면 된다.Code// 실버3 : 백준 1431번 시리얼 번호#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;string arr[1002];bool compare(string a, string b){    int sizeA = int(a.size()), sizeB = int(b.size());    if (sizeA &gt; sizeB) return false;    else if (sizeA &lt; sizeB) return true;    else {        int sumA = 0, sumB = 0;        for (int i = 0; i &lt; sizeA; i++) {            if (0 &lt;= a[i]-'0' &amp;&amp; a[i]-'0' &lt;= 9) sumA += a[i]-'0';        }        for (int i = 0; i &lt; sizeA; i++) {            if (0 &lt;= b[i]-'0' &amp;&amp; b[i]-'0' &lt;= 9) sumB += b[i]-'0';        }        if (sumA &lt; sumB) return true;        else if (sumA &gt; sumB) return false;        else {            return a &lt; b;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; arr[i];    }    sort(&amp;arr[0], &amp;arr[N], compare);    for (int i = 0; i &lt; N; i++) {        cout &lt;&lt; arr[i] &lt;&lt; '\\n';    }    return 0;}",
        "url": "//cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%8B%9C%EB%A6%AC%EC%96%BC-%EB%84%98%EB%B2%84.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-83-89-ec-a2-85-ec-9d-b4-eb-b6-99-ec-9d-b4-ea-b8-b0-html": {
        "title": "백준(17136번) - 색종이 붙이기",
        "tags": "백준, 알고리즘, 구현, 완전탐색, DFS, 삼성 역량 테스트",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 완전탐색 문제이다. 삼성 A형 기출이다.백준(17136번) - 시리얼 넘버생각시간이 1초라, 제한 시간에 들어올 수 있는지 시간 복잡도 계산부터 진행했다. 최악의 경우 100개의 공간에 모두 1이 차있는 경우 한 개의 공간에서 색종이를 5번 검사해야 한다.백트래킹을 해야 하나 고민했지만, 다행히 이 문제의 경우 한 개의 공간에서 5개의 경우의 수가 무조건적으로 발생하지 않는다는 점을 고려하여 풀이를 진행했다. 구현에 앞서 중요하게 생각한 것들은 다음과 같다.  종이의 수는 5장이다. 이 부분을 업데이트 해준다.  칠했다는 것을 표현하고, 이 부분은 탐색을 하지 않는다.  칠할 수 없는 곳은 칠하지 않고 다음 옵션으로 넘어간다.  끝나는 조건은 모든 1이 색칠이 되었을 때이다.설계main입력을 받는다.    이 때, 입력이 1인 경우 이 위치만 저장한다.1의 개수를 저장해 둔다.탐색한다.탐색 후 값을 출력한다.탐색 함수만약 현재까지 칠한 개수가 1의 개수와 같다면 answer를 업데이트 한다.현재 depth의 1의 위치를 가져온다.이 위치에 색종이가 붙어있지 않다면    5개의 색종이를 순차적으로 비교한다. 이 때 큰 색종이 부터 탐색한다.        만약 현재 색종이가 남아있다면            만약 해당 색종이를 붙일 수 있다면                색종이를 칠한다                색종이의 개수를 하나 감소시킨다                색종이를 붙이고, 다음 위치에서 탐색한다.                색종이의 개수를 하나 증가시킨다                색종이를 뗀다            색종이를 붙일 수 없다면                다음 색종이를 탐색한다        현재 색종이가 남아있지 않다면            다음 색종이를 탐색한다이 위치에 색종이가 붙어있다면    다음 위치에서 탐색한다.Code// 골드3 : 백준 17136번 색종이 붙여넣기#include &lt;iostream&gt;#include &lt;vector&gt;#define INF 2000000000using namespace std;int globalAns = INF, N = 0;int map[10][10] = {0};vector&lt;pair&lt;int, int&gt;&gt; position;pair&lt;int, int&gt; action[5] = {make_pair(5, 5),                            make_pair(4, 5),                            make_pair(3, 5),                            make_pair(2, 5),                            make_pair(1, 5)};void fillSquare(int y, int x, int num, int value){    for (int i = y; i &lt; y+num; i++)        for (int j = x; j &lt; x+num; j++)            map[i][j] = value;}bool isFillPossible(int y, int x, int num){    for (int i = y; i &lt; y+num; i++) {        for (int j = x; j &lt; x+num; j++) {            if (!(0 &lt;= i &amp;&amp; i &lt; 10 &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; 10)) return false;            if (map[i][j] == 0 || map[i][j] == 2) return false;        }    }    return true;}void go(int depth, int localAns, int paint){    if (paint == N) {        globalAns = min(globalAns, localAns);        return;    }    int y = position[depth].first, x = position[depth].second;    if (map[y][x] == 1) {        for (int i = 0; i &lt; 5; i++) {            int squareSize = action[i].first, &amp;squareCount = action[i].second;            if (squareCount != 0) {                if (isFillPossible(y, x, squareSize)) {                    fillSquare(y, x, squareSize, 2);                    squareCount--;                    go(depth+1, localAns+1, paint+(squareSize*squareSize));                    squareCount++;                    fillSquare(y, x, squareSize, 1);                }            } else continue;        }    } else go(depth+1, localAns, paint);}int main(){    for (int i = 0; i &lt; 10; i++) {        for (int j = 0; j &lt; 10; j++) {            cin &gt;&gt; map[i][j];            if (map[i][j] == 1) position.push_back(make_pair(i, j));        }    }    N = int(position.size());    go(0, 0, 0);    if (globalAns == INF) {        if (position.size() == 0) cout &lt;&lt; 0;        else cout &lt;&lt; -1;    }    else cout &lt;&lt; globalAns;    cout &lt;&lt; '\\n';    return 0;}",
        "url": "//cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%83%89%EC%A2%85%EC%9D%B4-%EB%B6%99%EC%9D%B4%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-b2-b4-ec-8a-a4-ed-8c-90-eb-8b-a4-ec-8b-9c-ec-b9-a0-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1018번) - 체스판 다시 칠하기",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현, 완전탐색",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버5 : 완전 탐색 문제이다.백준(1018번) - 체스판 다시 칠하기대표적인 완전 탐색 문제이다.체스판이 될 수 있는 모든 경우에 대해서 몇번의 flip을 해야하는지 세고, 이를 갱신해주면 풀린다.이 때, 체스판의 규칙을 잘 파악하는 것이 중요하다.Example                   1      2      3      4      5      6      7      8                  1      W      B      W      B      W      B      W      B              2      B      W      B      W      B      W      B      W              3      W      B      W      B      W      B      W      B              4      B      W      B      B      B      W      B      W              5      W      B      W      B      W      B      W      B              6      B      W      B      W      B      W      B      W              7      W      B      W      B      W      B      W      B              8      B      W      B      W      B      W      B      W      1행에서, 맨 마지막인 8열은 B이고, 그 다음 행의 첫번째는 B이다. 계속해서 엇갈려서 발생하는 것이 아니고, 행이 끝날 때, 마지막 요소가 다음 요소가 된다. 또한 추가적으로 체스판은 시작 위치의 표식이 어떤 것이냐에 따라 모양이 정해진다. 이 부분에서 생각할 수 있는 것은, 같은 모양이나 시작 위치의 표식만 바뀐다. 라는 것이다.구현이 것을 구현하기 위한 단계를 생각해보자.  우리는 체스판의 크기에 따라 몇 개의 작은 체스판을 조사해야 하는지 정해야 한다.  그 안에 들어갔을 때, 시작 위치의 표식을 설정해 주어야 한다.  체스판을 만들 수 있는 방법을 진행하며 다른 부분을 체크하고 count 해야한다.Code// 실버5 : 백준 1018번 체스판 다시 칠하기#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool map[50][50];int N, M;int ans = 2000000000;void go(int y, int x){    // 각각의 작은 체스판에서 시작 위치의 표식을 W, B으로 설정한다.    // bool으로 잡았기 때문에 0 또는 1로 모델링이 가능하다.    for (int mode = 0; mode &lt;= 1; mode++) {        int localAns = 0;        for (int i = y; i &lt; y+8; i++) {            // 이 부분이 행이 끝났을 떄 표식을            // 다음행에 가져가도록 하는 코드이다.            mode = !mode;            for (int j = x; j &lt; x+8; j++) {                if (mode != map[i][j]) {                    localAns++;                }                mode = !mode;            }        }        // 각각에 대해 ans를 업데이트 해준다.        ans = min(ans, localAns);    }}int main(){    cin &gt;&gt; N &gt;&gt; M;    // 1, 0으로 바꿔서 넣어주었다. W = 1, B = 0    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt; M; j++) {            char temp;            cin &gt;&gt; temp;            if (temp == 'W') map[i][j] = 1;            else map[i][j] = 0;        }    }    // 체스판 모양에 따라 발생할 수 있는    // 작은 체스판의 시작 위치를 결정한다.    for (int i = 0; i &lt;= N-8; i++) {        for (int j = 0; j &lt;= M-8; j++) {            go(i, j);        }    }    cout &lt;&lt; ans &lt;&lt;'\\n';}",
        "url": "//cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%B2%B4%EC%8A%A4%ED%8C%90-%EB%8B%A4%EC%8B%9C-%EC%B9%A0%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-88-a8-eb-b0-94-ea-bc-ad-ec-a7-88-html": {
        "title": "백준(1697번) - 숨바꼭질",
        "tags": "백준, 알고리즘, BFS, 그래프",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 그래프 문제이다.백준(1697번) - 숨바꼭질이 문제의 핵심은, 해당 위치에서 3가지의 선택을 할 수 있다는 점이다. 이 3가지의 선택 각각에 해당하는 위치에서 또 3가지의 선택을 할 수 있다. 그 선택을 연이어한 결과 문제의 답이 있다.하지만 이 문제는 DFS로 접근할 수 없는데, 그 이유는, 각각의 선택을 깊이 기준으로 탐색했을 때, 답에 다다르지 못하는 상황이 있을 수 있기 때문이다. 따라서 무한 루프에 빠지거나, 혹은 이 부분을 거르는 코드를 작성해야 하는데 상당히 번거롭다.이런 경우 오히려 BFS로 생각했을 때, 문제가 확 와닿는 경우가 많다. BFS로 탐색할 경우, 시간의 기준으로 완전 탐색하기 때문에 이 문제의 의도와 정확히 맞아 떨어진다. 최대한 짧은 시간에 답과 일치할 경우 반복문을 빠져나오면 되기 때문이다. 따라서 위치에 따른 시간을 저장할 필요가 있다.이 때, 선택지에 $+1, -1$이 있고 중간중간 $\\times2$ 도 있어 중복되는 위치에 방문할 가능성이 있다. 이 부분의 시간 복잡도를 줄이기 위해 메모리를 사용하여 코드를 짰다.Code// 실버1 : 백준 1697번 숨바꼭질#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int N = 0, K = 0;bool map[100001] = {0};int main(){    cin &gt;&gt; N &gt;&gt; K;    queue&lt;pair&lt;int, int&gt;&gt; q;    int ans = 0;    q.push(make_pair(N, 0));    while (!q.empty()) {        int now = q.front().first, time = q.front().second;        q.pop();        if (map[now] == true) continue;        map[now] = true;        if (now == K) {            ans = time; break;        }        if (now-1 &gt;= 0) q.push(make_pair(now-1, time+1));        if (now+1 &lt;= 100000) q.push(make_pair(now+1, time+1));        if (now*2 &lt;= 100000) q.push(make_pair(now*2, time+1));    }    cout &lt;&lt; ans &lt;&lt; '\\n';}",
        "url": "//cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-86-8c-ec-9a-a9-eb-8f-8c-ec-9d-b4-ec-98-88-ec-81-98-ea-b2-8c-ec-b6-9c-eb-a0-a5-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1022번) - 소용돌이 예쁘게 출력하기",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현, 출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 구현 문제이다.백준(1022번) - 소용돌이 예쁘게 출력하기상당히 갑갑했다. 일단 무한개의 소용돌이가 생길 수 있다는 점에서 기존의 달팽이 문제처럼 생각하면 안된다라는 판단이 들었다. 발생하는 모든 숫자를 저장한다면 메모리 초과가 날 것이 분명했기 때문이다.그래서 이 부분을 꼭 저장해야 하나? 하는 생각이 들었고, 문제에서 제시하는 규칙에 따라 소용돌이 를 만들어가면서 제시하는 좌표 내에 위치했을 때, 이를 저장해주는 방식으로 문제를 해결하기로 했다.이 과정에서 생각해야 하는 중요 문제는 다음과 같았다.  소용돌이를 만드는 규칙  들어왔을 때, 저장하는 배열과의 관계  출력시 공백 처리소용돌이 규칙            num      direction      linecount                  1      ➡      1              2      ⬆      1              3      ⬅      2              4      ⬇      2              5      ➡      3              6      ⬆      3              7      ⬅      4              8      ⬇      4              9      ➡      5      출처 : https://jksk0115.tistory.com/총 4번의 방향전환 속에 고려해야 하는 점은 몇 칸 전진? 이다. 잘 보게 되면, 방향과 방향에 따른 count와 방향과의 관계가 나온다.배열과의 관계  map[y-r1][x-c1] = num;현재 좌표는 음수를 갖고 있는 상태이다. index는 음수일 수 없으므로 우리는 이것을 평행이동 하여 (0,0) 의 상태에 저장해야 한다. 이 때, r1, c1 만큼 평행이동 한다면 정확하게 원하는 위치에 저장할 수 있다.출력시 공백 처리내가 원하는 위치에 있는 것들을 배열에 넣을 때, 가장 긴 숫자가 무엇인지 알아야 한다. 이 때, C++에 integer의 길이는 알아내기 어려우므로 string으로 바꾸어 길이를 알아내는 방법을 사용하도록 하자.이 길이보다 작은 숫자에 대해서는 그 차만큼 공백을 출력하여 문제가 원하는 답을 도출하자.입출력이 많으므로 ios_base::sync_with_stdio(false); 를 사용하자.C++ - 입출력 빠르게 받는 방법Code// 골드4 : 백준 1022번 소용돌이 예쁘게 출력하기#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int r1, r2, c1, c2;int map[50][5] = {0};int y = 0, x = 0, dir_count = 0;int linecount = 1, step = 0, num = 1, dir = 0;int map_count = 0, max_num = -1, maxLength = -1;int dy[4] = {0, -1, 0, 1}, dx[4] = {1, 0, -1, 0};int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2;    while (true) {        // 현재 위치가 원하는 위치인지 확인        if (r1 &lt;= y &amp;&amp; y &lt;= r2 &amp;&amp; c1 &lt;= x &amp;&amp; x &lt;= c2) {            max_num = max(max_num, num);            map[y-r1][x-c1] = num;            map_count++;            if (map_count == (r2-r1+1)*(c2-c1+1)) {                break;            }        }        // 소용돌이 좌표 등 속성 갱신        y += dy[dir];        x += dx[dir];        step++;        num++;        // 방향 갱신        if (step == linecount) {            dir_count++;            step = 0;            dir = (dir+1)%4;            if (dir_count == 2) {                dir_count = 0;                linecount++;            }        }    }    // map 안에서 갖는 최고 길이    maxLength = int(to_string(max_num).size());    for (int i = 0; i &lt; r2-r1+1; i++) {        for (int j = 0; j &lt; c2-c1+1; j++) {            string stringOut = to_string(map[i][j]);            if (stringOut.size() &lt; maxLength) {                for (int i = 0; i &lt; maxLength-stringOut.size(); i++) {                    cout &lt;&lt; \" \";                }            }            cout &lt;&lt; stringOut &lt;&lt; \" \";        }cout &lt;&lt; '\\n';    }}",
        "url": "//cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%9A%A9%EB%8F%8C%EC%9D%B4-%EC%98%88%EC%81%98%EA%B2%8C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-eb-a1-9c-eb-98-90-html": {
        "title": "백준(6603번) - 로또",
        "tags": "백준, 알고리즘, 완전탐색, 재귀, 출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 재귀를 통한 완전탐색 문제이다.백준(6603번) - 로또단순한 문제였다. 재귀를 통해 만들 수 있는 모든 경우를 출력하면 되는 문제였다. 나 같은 경우 재귀를 통해 들어갈 때, 탐색하지 않아도 되는 부분을 거르는 코드를 작성했다. 아마 다른 분들도 작성했을 것이다.이 문제에서 고려해야 되는 점은 다음과 같다.  어떻게 출력하게 만들 것인가?  어느 상황에서 탐색을 하지 않게 가지를 칠 것인가?출력 방법checkbox라는 배열을 만들어 깊이가 6이 되었을 때 모두 출력하였다.백트래킹이 문제는 간단한 백트레킹이지만, 써보면, 현재 위치에서 나머지 공을 선택할 수 있는 가지수와 지금 부터 선택해야 하는 가지수를 비교했다.  현재 위치로 부터 남은 공의 개수 &lt; 앞으로 선택해야 하는 공의 개수이와 같은 경우는 탐색이 불가능 하므로 함수를 콜하지 않았다.Code// 실버2 : 백준 6603번 로또#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int K = 6;int arr[14];bool checkbox[14] = {0};int N = -1;void go(int start, int count){    int restOfBallFromStart = N-(start+1);    if (count == 6) {        for (int i = 0; i &lt; N; i++)            if (checkbox[i]) cout &lt;&lt; arr[i] &lt;&lt; \" \";        cout &lt;&lt; '\\n';        return;    }    for (int i = start+1; i &lt; N; i++) {        if (restOfBallFromStart &lt; K-(count+1)) break;        else {            checkbox[i] = 1;            go(i, count+1);            checkbox[i] = 0;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    while (N != 0) {        fill(&amp;arr[0], &amp;arr[13], 0);        cin &gt;&gt; N;        for (int i = 0; i &lt; N; i++) {            cin &gt;&gt; arr[i];        }        go(-1, 0);        cout &lt;&lt; '\\n';    }    return 0;}",
        "url": "//cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EB%A1%9C%EB%98%90.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-cin-cout-eb-b9-a0-eb-a5-b4-ea-b2-8c-html": {
        "title": "C++ - 입출력 빠르게 받는 방법",
        "tags": "iostream, 입출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "ios_base 라이브러리의 함수를 통해 입출력을 빠르게 받는 방법을 알아본다. 출처 : https://coding-insider.tistory.com확연하게 cin, cout이 느리다는 것을 알 수 있다.적용ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);main 함수안에 위의 코드를 적어주면 빠른 입출력이 가능하다.설명  ios_base::sync_with_stdio(false)C 입출력 함수와 C++ 입출력 스트림의 동기화를 해제하는 것이다. 이걸 쓰면 C, C++ 입출력 함수를 섞어 쓰면 안된다.  cin.tie(NULL); cout.tie(NULL);cin과 cout 의 tie를 해제하는 것이다. 자세한 설명을 모르겠다.  std::endl -&gt; '\\n'endl도 역시 불러오는 것이기 때문에 속도가 매우 느리다.주의 사항하지만 이 방법은 일종의 편법이기 때문에, 사용시 주의가 필요하다.  scanf, printf와 함께 사용하면 안된다.  싱글 쓰레드 환경에서만 사용 가능하다. (알고리즘 문제풀이시에 사용, 실무에서는 사용 X)",
        "url": "//cs/algorithm/2020/03/24/cin-cout-%EB%B9%A0%EB%A5%B4%EA%B2%8C.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ea-b0-80-ec-9e-a5-ed-81-b0-ec-a0-95-ec-82-ac-ea-b0-81-ed-98-95-ec-9d-98-eb-84-93-ec-9d-b4-html": {
        "title": "프로그래머스 - 가장 큰 정사각형 찾기",
        "tags": "백준, 알고리즘, 동적계획법, 구현",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : 구현, 또는 동적 계획법을 사용하는 문제이다.프로그래머스 - 가장 큰 정사각형 찾기처음 풀이로는 빠르게 풀기 위해서 그냥 단순히 구현을 했다. 입력이 1000 x 1000 이라, 완전 탐색을 수행하더라도 로직을 최대한 덜 쓰도록 짜야된다는 생각을 하면서 짰다. 그 결과 나는 최대 넓이를 구하는 것이 목표이므로, board가 가질 수 있는 최대 변의 길이로 부터 하나씩 줄이며 가능한 정사각형을 구했을 때 return 했다.Code1#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool go(int y, int x, int len, vector&lt;vector&lt;int&gt;&gt; board){    for (int i = y; i &lt; len+y; i++){        for (int j = x; j &lt; len+x; j++){            if (board[i][j] == 0) return false;        }    }    return true;}int solution(vector&lt;vector&lt;int&gt;&gt; board){    int now = min(int(board.size()), int(board[0].size()));    int sizeY = int(board.size());    int sizeX = int(board[0].size());    while(now &gt; 0){        for (int i = 0; i &lt;= sizeY-now; i++){            for (int j = 0; j &lt;= sizeX-now; j++){                if (go(i, j, now, board)) return now*now;            }        }        now--;    }    return now;}하지만 근본적으로 최악의 경우 연산 횟수가, n^4 이다. (완전한 n^4는 아니다. 하지만 연산이 중복되는 것이 너무 많다.)  정사각형 판단 (n^2)  가능한 시작 점의 개수 (n^2)연산이 중복된다는 생각과, 또, 정사각형의 모양을 보니 작은 정사각형이 만들어져야 다음 정사각형이 만들어진다는 생각을 했다. 두 생각은 다이나믹 프로그래밍의 핵심적인 발상이기 때문에 해당 문제를 다이나믹으로 다시 구상해보기 시작했다.정의            dp적용전                           dp적용후                                       0      1      1      1      0      1      1      1              1      1      1      1      1      1      2      2              1      1      1      1      1      2      2      3              0      0      1      0      0      0      1      0        dp[y][x] = (y, x)의 위치를 포함하여 만들 수 있는 정사각형의 최대 변의 길이이렇게 정의를 하게 되면, 다음 정사각형의 변의 길이는, 상, 좌, 좌상향 대각 방향의 요소의 최소값+1에 해당하는 변의 길이로 밖에 만들 수 없다.  dp[y][x] = min(dp[y-1][x-1], dp[y][x-1], dp[y-1][x])dp는 항상 초기값을 세팅해주어야 하는데, 이 경우 y = 0일 때, x = 0 일 때 값을 고정한 상태로 점화식을 적용하면 된다. 이 때, 초기값으로 부터 answer가 도출될 수 있다는 점을 주의하자. 예외에 걸릴 수 있다. (내가)Code2#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;vector&lt;int&gt;&gt; board){    int ans = -1;    int sizeY = int(board.size());    int sizeX = int(board[0].size());    for (int i = 0; i &lt; sizeY; i++) ans = max(board[0][i], ans);    for (int i = 0; i &lt; sizeX; i++) ans = max(board[i][0], ans);    for (int i = 1; i &lt; sizeY; i++) {        for (int j = 1; j &lt; sizeX; j++) {            if (board[i][j] == 0) continue;            else {                int minNum = min(board[i-1][j], board[i-1][j-1]);                minNum = min(minNum, board[i][j-1]);                if (minNum != 0) {                    board[i][j] = minNum+1;                    ans = max(ans, board[i][j]);                }            }        }    }    return ans*ans;}",
        "url": "//cs/algorithm/2020/03/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%98-%EB%84%93%EC%9D%B4.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ed-94-bc-eb-b3-b4-eb-82-98-ec-b9-98-ed-95-a8-ec-88-98-html": {
        "title": "[알고리즘] 피보나치 함수",
        "tags": "백준, 알고리즘, 피보나치, 동적계획법",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 동적 계획 법을 사용하는 문제이다.백준(1003번) - 피보나치 함수Code// 백준 1003번 피보나치 함수#include &lt;iostream&gt;using namespace std;int N = 0, T = 0;int dp[50] = {0};// dp[n] = an 까지의 호출되는 1의 개수// dp[n] = dp[n-2] + dp[n-1];// 호출되는 0의 개수는, dp[n-1]과 동일하다.int main(){    dp[0] = 0;    dp[1] = 1;    for (int i = 2; i &lt; 41; i++) {        dp[i] = dp[i-1] + dp[i-2];    }    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; N;        if (N == 0) cout &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; dp[N] &lt;&lt; '\\n';        else        cout &lt;&lt; dp[N-1] &lt;&lt; \" \" &lt;&lt; dp[N] &lt;&lt; '\\n';    }}",
        "url": "//cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ec-9c-a0-ea-b8-b0-eb-86-8d-eb-b0-b0-ec-b6-94-html": {
        "title": "백준(1012번) - 유기농 배추",
        "tags": "백준, 알고리즘, 유기농 배추, 그래프, DFS",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : dfs를 사용하는 기초적인 문제이다.백준(1012번) - 유기농 배추이런 문제를 풀 때, 생각보다 실수를 많이하는 부분은, testcase가 있을 때, 초기화를 하지 않는 것이다. 항상 testcase가 있는 문제는, 이 부분을 유념해야 한다. 또 초기화를 할 때, 연산이 수반되기 때문에, 어떠한 방식으로 초기화하는 것이 좋은지 생각하며 코드를 짜는 것이 바람직하다. 무조건적인 초기화는 안전성을 장담할 수 있지만 자칫하면 불필요한 연산을 수반할 수 있다.인접한 녀석들에 대해 1마리의 지렁이가 있으면 된다.1을 발견하면, dfs를 통해 인접한 것들의 값을 변경하고 globalAns의 값을 1증가시킨다.이 때, 정사각 지형을 다 탐색할 필요는 없다.나는 1이 있는 위치에서 시작해서 탐색만 하면 된다.따라서 입력 받을 때, 해당 위치만을 기억하는 배열을 하나 잡고, 이 것을 모두 확인하면 된다.Code// 백준 1012번 유기농 배추#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; baechuLoc;int T = 0;int N = 0, M = 0, baechuNum = 0, ans = 0;int map[51][51];int dy[4] = {0, 1, 0, -1}, dx[4] = {1, 0, -1, 0};void go(int now_y, int now_x){    map[now_y][now_x] = 2;    for (int i = 0; i &lt; 4; i++) {        int next_y = now_y + dy[i], next_x = now_x + dx[i];        if (map[next_y][next_x] == 1) {            go(next_y, next_x);        }    }}int main(){    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; N &gt;&gt; M &gt;&gt; baechuNum;        fill(&amp;map[0][0], &amp;map[N][M-1], 0);        baechuLoc.clear();        ans = 0;        for (int i = 0; i &lt; baechuNum; i++) {            int tempY, tempX;            cin &gt;&gt; tempY &gt;&gt; tempX;            map[tempY][tempX] = 1;            baechuLoc.push_back(make_pair(tempY, tempX));        }        for (int i = 0; i &lt; baechuNum; i++) {            if (map[baechuLoc[i].first][baechuLoc[i].second] == 1) {                go(baechuLoc[i].first, baechuLoc[i].second);                ans++;            }        }        cout &lt;&lt; ans &lt;&lt; '\\n';    }}",
        "url": "//cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%EC%9C%A0%EA%B8%B0%EB%86%8D%EB%B0%B0%EC%B6%94.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ec-98-a4-eb-a5-b4-eb-a7-89-ec-88-98-html": {
        "title": "백준(11057번) - 오르막 수",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획 법을 사용하는 문제이다.백준(11057번) - 오르막 수대표적인 동적계획법 문제이다.기초적인 동적 계획법 문제를 풀 때에는 펜을 갖고 쓰는 것이 중요해보인다. 기본적으로 점화식을 갖고 해결하는 방식이기 때문에, 수열 문제를 푸는 것도 같은 사고로 접근해야 한다. 수열 문제가 눈에 들어오지 않으면 쓰면서 규칙을 찾아내듯, 이것도 손아프다고 징징대지말고 쓰면서 찬찬히 푸는 것이 문제를 가장 효과적이고 간결하게 풀 수 있는 방법이다.N : 1, N : 2            숫자      오르막 수 개수      숫자      오르막 수 개수                  0      1      공란      공란              1      1      10~19      1~9 : 9              2      1      20~29      2~9 : 8              3      1      30~39      3~9 : 7              4      1      40~49      4~9 : 6              5      1      50~59      5~9 : 5              6      1      60~69      6~9 : 4              7      1      70~79      7~9 : 3              8      1      80~89      8~9 : 2              9      1      90~99      9~9 : 1      규칙을 보게 되면, 최고 자리 수가 어떤 수이냐에 따라 그 다음 자리수는 결정이 되게 된다. 그런데 여기서 잘 보면, N : 2일 때, 최고자리수가 1인 경우, 오르막 수의 개수는 1의 자리 숫자가 1~9까지 오는 경우가 모두 오르막 수가 될 수 있다.추가적으로 최고자리수가 2인 경우는, 일의 자리 숫자가 2인 경우부터 발생하는 모든 오르막 수를 더함으로서 만들어진다.이 규칙을 자세히 보면, 변화하는 파라미터는 총 두개이다.  최고자리의 수  최고자리에 위치하는 숫자이 두가지 특징을 가지고 dp를 정의하고, 점화식을 세워보자.  dp[N][m] = N 자리수를 가지는 수가 M의 숫자를 가질 때 가질 수 있는 오르막 수의 개수  dpdp[N] = N 자리수를 가지는 수가 가질 수 있는 오르막 수의 개수이렇게 정의했을 때, dp 점화식의 정의는 다음과 같다.이걸 가지고 dpdp 점화식을 세우면 다음과 같다.수식도 세웠으니 이제 구현만 하면 된다. 이때, dp를 수행하기 위해서는 초기값을 설정해 줘야 하는데, 이 경우에는 N : 1 인 경우에 해당하는 모든 숫자에 1의 값을 준 뒤에 시작해야 한다.Code// 백준 11057번 오르막 수#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;int dp[1001][10] = {0};int dpdp[1001] = {0};int mod = 10007;int main(){    cin &gt;&gt; N;    // 초기값 세팅    for (int i = 0; i &lt; 10; i++) {        dp[1][i] = 1;    }    dpdp[1] = 10;    for (int i = 2; i &lt;= N ; i++) {        // dp[N][M]을 구하는 코드        for (int j = 1; j &lt; 10; j++) {            for (int k = j; k &lt; 10; k++) {                dp[i][j] += dp[i-1][k];                dp[i][j] %= mod;            }        }        // dpdp[N]을 구하는 코드        for (int j = 0; j &lt; 10; j++) {            dpdp[i] += dp[i][j];        }        dpdp[i] += dpdp[i-1];        dpdp[i] %= mod;    }    // 정답    cout &lt;&lt; dpdp[N] &lt;&lt; '\\n';}",
        "url": "//cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%EC%98%A4%EB%A5%B4%EB%A7%89%EC%88%98.html"
      }
      ,
    
      "dv-react-2020-03-22-movie-app-clone-html": {
        "title": "Project - Movie App Clone",
        "tags": "side-project, clone-coding, movie-app",
        "date": "March 22, 2020",
        "author": "",
        "category": "DV/React",
        "content": "React를 사용하여 동적인 느낌이 나는 movie app을 만들어보았다.React-Movie-App",
        "url": "//dv/react/2020/03/22/movie-app-clone.html"
      }
      ,
    
      "dv-html-2020-03-22-kakaotalkclone-html": {
        "title": "Project - KaKaoTalkClone",
        "tags": "side-project, clone-coding, kakaotalk",
        "date": "March 22, 2020",
        "author": "",
        "category": "DV/HTML",
        "content": "카카오톡 디자인을 클론 코딩해보았다.카카오톡 클론 코딩",
        "url": "//dv/html/2020/03/22/kakaotalkClone.html"
      }
      ,
    
      "dv-css-2020-03-20-transition-display-none-html": {
        "title": "opacity를 사용하여 display none animation 만들기",
        "tags": "css, transition, opacity",
        "date": "March 20, 2020",
        "author": "",
        "category": "DV/CSS",
        "content": "css를 사용하여 애니메이션 효과를 주는 법을 알아보자.Html&lt;div class=\"chat__write--container\"&gt;  &lt;input    type=\"text\"    class=\"chat__write\"    placeholder=\"Send message\"    class=\"chat__write-input\"  /&gt;  &lt;div class=\"chat__icon-left chat__icon\"&gt;    &lt;i class=\"far fa-plus-square\"&gt;&lt;/i&gt;  &lt;/div&gt;  &lt;div class=\"chat__icon-right chat__icon\"&gt;    &lt;span class=\"chat__write-icon\"&gt;      &lt;i class=\"far fa-smile-wink\"&gt;&lt;/i&gt;    &lt;/span&gt;    &lt;span class=\"chat__write-icon\"&gt;      &lt;i class=\"fas fa-microphone\"&gt;&lt;/i&gt;    &lt;/span&gt;  &lt;/div&gt;&lt;/div&gt;  위의 상황에서 문자를 보내는 것을 클릭했다고 생각해보자. 그 경우, 주변에 있는 아이콘이 사라졌으면 좋겠다. 그런데, 그 아이콘의 속성을 display: none;으로 할 경우, 애니메이션 효과를 넣을 수 없게 된다.그래서 속성의 값중 실수 값을 가질 수 있으면서 같은 효과를 내는 opacity 속성을 사용한다.CSS.chat__write:focus ~ .chat__icon {  opacity: 0;}.chat__icon {  font-size: 23px;  transition: opacity 0.5s ease-in-out;}여기서 ~ 선택자는, 형제 선택자이다.중요여기서, 중요한 것은, 내가 없애고 싶은 아이콘은, input 태그 뒤에 있어야 한다는 점이다. 만약 그렇지 않다면 애니메이션이 적용되지 않는다. 결과적으로 CSS로 어떤 효과를 주고 싶을 때는, 내가 액션을 취할 태그를 html 문서의 앞에 적어주어야 동작한다.",
        "url": "//dv/css/2020/03/20/transition-display-none.html"
      }
      ,
    
      "dv-css-2020-03-20-navbar-fixed-html": {
        "title": "navbar, footer 고정하기",
        "tags": "css, position, fixed",
        "date": "March 20, 2020",
        "author": "",
        "category": "DV/CSS",
        "content": "상단 navbar나 footer 같이 고정할 필요성이 있는 html 요소를 어떻게 빠르게 만들지 정리했다.이 부분을 생각할 때 조금 어려웠던 것은, navbar 같은 경우, 어떻게 html 구조를 짜야되는 지 였다. 하지만 조금만 생각해보니, 굳이 떼어내서 구조화할 필요 없이 그냥 필요한 요소들을 만들고, 이를 보여주는 방식, css에서 display만 변화시키면 되는 문제였다.물론, 이 과정에서 class 이름을 바꾸고 body를 해당 nav의 높이 만큼 padding 혹은 margin을 주어야 하지만, html 구조에 있어 navbar는 그대로 두어도 상관없다.",
        "url": "//dv/css/2020/03/20/navbar-fixed.html"
      }
      ,
    
      "dv-html-2020-03-19-span-height-is-not-block-html": {
        "title": "span의 height는 block 속성이 아니다.",
        "tags": "css, span, height, block",
        "date": "March 19, 2020",
        "author": "",
        "category": "DV/HTML",
        "content": "text를 쓰는 데 있어 어떤 tag를 써야 하는지, 또 그랬을 때 문제는 무엇인지 알아보자.text는 span 태그에 넣어서 관리한다.div안에 text를 넣으면 좋지 않다.이번에 겪은 문제로는 box-shadow가 먹지 않았다.그렇다고 div에 있던 텍스트를 span으로 교체하면 문제가 생긴다.span 태그는 기본적으로 inline 속성을 강하게 띈다.그렇기 때문에 다음 그림과 같이 margin을 먹였음에도 불구하고 내가 원하는 모양대로 속성이 먹히지 않는다.div와 span의 가장 큰 차이는 display: block, inline따라서 만약에 다 뒤집어 엎고 교체하기 싫다면, display: block 속성을 추가해주면 된다.결론가장 좋은 방법은, text를 쓰는 공간에는 span을 써주고, 이 공간 자체를 box처럼 쓰고 싶다면 display block을 써주자.또는 아예 box와 textbox를 구분해서 만들어주는 것도 좋은 방법이다.",
        "url": "//dv/html/2020/03/19/span-height-is-not-block.html"
      }
      ,
    
      "cs-algorithm-2020-03-19-position-fixed-center-ec-a0-95-eb-a0-ac-html": {
        "title": "position fixed에서 중앙 정렬하기",
        "tags": "css, center-arrangement, position, fixed",
        "date": "March 19, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "position : fixed에서 중앙 정렬하는 방법.class {  position: fixed;  /* fixed를 쓸 때에는 width, height를 명시해줘야 한다. */  width: 80%;  /* left, right는 해당 요소의 위치 시작점을 결정한다. 그런데, 이때, margin의 양 값을 auto로 줌으로써 마진을 주어 해당 요소의 양 끝 위치를 각각 0으로 만들어준다. */  margin: 0 auto;  left: 0;  right: 0;  /* 다른 것들 */  display: flex;  background-color: red;  padding: 20px 50px;  border-radius: 40px;}",
        "url": "//cs/algorithm/2020/03/19/position-fixed-center-%EC%A0%95%EB%A0%AC.html"
      }
      ,
    
      "dv-javascripts-2020-03-18-ea-b0-9c-eb-b0-9c-ed-99-98-ea-b2-bd-ec-84-b8-ed-8c-85-html": {
        "title": "Web - 개발 환경 초기 세팅",
        "tags": "development, setting",
        "date": "March 18, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "개발을 시작하기 전에 환경 설정해야 하는 것들을 적어둔다.      gitignore        git setting : 이 부분은, terminal에서 clone 후, vscode로 여는 것이 가장 깔끔했다. 그 경우 remote 설정도 안해줘도 순탄하다.  왜 잘 작동을 안하는가ㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹ ㅇㄹ. ㄴㅇㄹㄴㅇㄹ.ㄴㅇㄹㄴㅇㄹ안녕하세요.ㄴㅇㄹㄴㅇ.ㄴㅇ란우라ㅣㄴㅇㄹㄴ앙ㄴㄹㄴㅇㄹ.ㄴ일ㄴㅇㄹㄴㅇ룬ㅇ린ㅇㄴㅇㄹ ㄴㅇ룬ㅇㄴㅇ라ㅣㄴ울ㄴㅇ룬ㅇㄹsdfsdf;sdfsdf",
        "url": "//dv/javascripts/2020/03/18/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%B8%ED%8C%85.html"
      }
      ,
    
      "dv-javascripts-2020-02-28-js-html": {
        "title": "Web - 개발 시 고려해야 하는 점",
        "tags": "JS, develop",
        "date": "February 28, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "개발 시작하기 전에 플로우를 기록해 둔다.html  그룹을 잘 묶어서 짠다.  하나의 기능이 들어간다고 하더라도 2중으로 그룹화 하는 것이 좋다.  입력 단위는 업데이트 되는 단위로 묶어준다.CSS  reset.css 파일 만들고 복사  내가 사용한 css 파일에 import  기본적으로 항상 css는 body 태그에 대해 설정을 하고 시작하는 것이 좋다. body 태그 안에서 설정해줘야 하는 것은 기본적으로 배경색과 폰트정도가 있다.  집합구조를 잘 생각해서 짠다.  css에서 먹일 때도 명확하게 이 객체의 위치를 명시적으로 적은 후에 걸어준다.JS      여거개의 객체 tag에 대해 같은 이벤트를 얻고 싶을 떄는 id로 js#@%@%이렇게 저장하는 것이아니고 class로 저장한다. 그 이후에 ‘getElementByClassName’으로 불러오면, 자동으로 배열로 모든 class에 해당하는 녀석을 가져온다.        이 때 불러와진 녀석은 배열이 아니다. 유사배열이다. JSON 파일과 같다고 보면 된다. 즉, a[0] 처럼 접근은 가능하나, Array의 메서드를 사용할 수 없다.    for (let i = 0; i &lt; colors.length; i++) {  const element = colors[i];  element.addEventListener(\"click\", handleColorChanging);}        Array.from(colors).forEach(item =&gt; {  console.log(item);  item.addEventListener(\"click\", handleColorChanging);});        따라서 이 두 코드는 같은 작동을 한다.        querySelector 사용처는 다음과 같다. 일반적으로 하나밖에 없는 이름을 갖고 있는 태그라면 querySelector를 쓰는게 좋아보인다.이 경우, 해당 객체에서 다시 querySelector를 사용할 수 있기 때문에, 사용하기 편리하다. 다만 가장 위에 있는 객체하나만을 들고 오기 때문에 여러개가 있을 경우 좋지 않다. 여러개를 들고 올 경우에는 getElementClassName을 사용하는 것이 좋아보인다. 이경우 HTMLCollenction이라는 객체로 들고오며, 이를 Array로 바꿔 사용하면 편리하다. getElementId 는 하나만 빠르게 들고올 떄 사용하면 편리하다.  ",
        "url": "//dv/javascripts/2020/02/28/JS.html"
      }
      
    
  };
</script>

<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" charset="utf-8"></script>-->
<script src="./js/lunr.min.js" charset="utf-8"></script>
<script src="/assets/js/search.js" charset="utf-8"></script></section>
</article>
    </div>
    
    


<footer class="site-footer">
	<p class="text">이전 블로그 <a href="https://egg-money.tistory.com">완숙의 에그머니</a>
</p>
</footer>


  </body>
</html>
