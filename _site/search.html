<!DOCTYPE html>
<head>
  
</head>
<html class="no-js">
  <head>
  <meta charset="utf-8" />
  <title>
    Search | 완숙의 에그머니 🍳
  </title>
  <meta
    name="description"
    content="Be On My Wave 🌊 | 뚜렷한 목표, 치밀한 계획, 우직한 실천"
  />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Open Graph -->
  <!--  -->
  <meta
    property="og:title"
    content="Search | 완숙의 에그머니 🍳"
  />
  <meta
    property="og:description"
    content="Be On My Wave 🌊 | 뚜렷한 목표, 치밀한 계획, 우직한 실천"
  />
  <meta property="og:type" content="website" />
  <meta
    property="og:url"
    content="http://localhost:4000/search.html"
  />
  <meta
    property="og:image"
    content="http://localhost:4000/assets/img/search.jpg"
  />

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css">

  <!--Favicon-->
  <link
    rel="shortcut icon"
    href="/assets/favicon.ico"
    type="image/x-icon"
  />

  <!-- Canonical -->
  <link
    rel="canonical"
    href="/search.html"
  />

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="완숙의 에그머니 🍳" href="/feed.xml" />

  <!-- Font Awesome -->
  <link
    rel="stylesheet"
    href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
    integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay"
    crossorigin="anonymous"
  />

  <!-- Google Fonts -->
  
  <link
    href="//fonts.googleapis.com/css?family=Nanum+Gothic|Jua|Nanum+Gothic+Coding|Source+Code+Pro|Nanum+Myeongjo:400,700,800|Noto+Sans+KR:100,300,400,500,700,900|monospace"
    rel="stylesheet"
    type="text/css"
  />
  

  <!-- naver web mater tool -->
  <meta
    name="naver-site-verification"
    content="da86adfc2aa8cdd5f1d573b50497f3e29de44cd5"
  />

  <!-- KaTeX -->
  <!--
	

    -->
  <!-- Google Analytics -->
  
  <script>
    (function (i, s, o, g, r, a, m) {
      i["GoogleAnalyticsObject"] = r;
      (i[r] =
        i[r] ||
        function () {
          (i[r].q = i[r].q || []).push(arguments);
        }),
        (i[r].l = 1 * new Date());
      (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m);
    })(
      window,
      document,
      "script",
      "//www.google-analytics.com/analytics.js",
      "ga"
    );

    ga("create", "UA-156961472-1", "auto");
    ga("send", "pageview");
  </script>
  

  <!-- Latex -->
  <!--
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
-->

   <script>
  console.log(window)

  window.addEventListener("resize", changeContent);
  window.addEventListener("load", changeContent);

  function changeContent(event){
    const width = window.innerWidth;
    console.log(event);
    const cat = document.getElementById("js-cat");
    const cv = document.getElementById("category-cv");
    const book= document.getElementById("category-book");
    const ds = document.getElementById("category-ds");
    const cs = document.getElementById("category-cs");
    const dv = document.getElementById("category-dv");
    const works = document.getElementById("category-works");
    const about = document.getElementById("category-about");
    if (width < 750) {
      cv.innerText = "📜"
      book.innerText = "💡"
      ds.innerText = "📈"
      cs.innerText = "💾"
      dv.innerText = "📱"
      works.innerText = "🎨"
      about.innerText = "😎"
      cat.style.justifyContent = "space-around"
    } else {
      cv.innerText = "CV"
      book.innerText = "Book"
      ds.innerText = "Data Science"
      cs.innerText = "Computer Science"
      dv.innerText = "Development"
      works.innerText = "Works"
      about.innerText = "About"
      cat.style.justifyContent = "space-around"
    }

  }
  
</script>
  <script>
  function handleTocNavShowing() {
    var toc_nav = document.getElementById("js-toc_nav");
    var toc_nav_button_title = document.getElementById("js-toc-btn-content");

    if (toc_nav.style.display == "block") {
      toc_nav.style.display = "none";
      toc_nav_button_title.innerHTML = "▼ 내리기";
    } else {
      toc_nav.style.display = "block";
      toc_nav_button_title.innerHTML = "▲ 숨기기";
    }
  }
</script>
 <script src="//code.jquery.com/jquery-3.3.1.min.js"></script>
<script>
  $(document).ready(function () {
    $(window).scroll(function () {
      if ($(this).scrollTop() > 200) {
        $(".top").fadeIn();
      } else {
        $(".top").fadeOut();
      }
    });

    $(".top").click(function () {
      $(".top").css("background", "#e7eceb");
      $(".top").css("color", "rgba(1, 53, 63, 0.8)");
      $("html, body").animate({ scrollTop: 0 }, 400);
      setTimeout(
        '$(".top").css("background", "rgba(1, 53, 63, 0.8)"); $(".top").css("color", "#e7eceb");',
        1000
      );
      return false;
    });
  });
</script>

</head>

  <body>
    <a href="#" class="top"></a>
 <header class="site-header">
  <div class="site-title-nav">
    <div class="branding">
      
      <a href="/">
        <img
          class="avatar"
          src="/assets/img/avatar.png"
          alt=""
        />
      </a>
      
      <h1 class="site-title">
        <a href="/">완숙의 에그머니 🍳</a>
      </h1>
    </div>
  </div>
  <nav class="site-nav">
    <ul>
      <!--
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                <li>
                    <a class="page-link" href="/about/">
                        About Me
                    </a>
                </li>
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
-->
      <!-- Social icons from Font Awesome, if enabled  -->
      <!--                


<li>
	<a href="mailto:wansook0316@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/wansook0316" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>







<li>
	<a href="https://www.linkedin.com/in/wansik-choi-b065881aa/" title="Follow on LinkedIn">
		<i class="fab fa-fw fa-linkedin"></i>
	</a>
</li>























-->

      <!-- Search bar -->
      <li>


<li>
	<a href="mailto:wansook0316@gmail.com" title="Email">
		<i class="fas fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/wansook0316" title="Follow on GitHub">
		<i class="fab fa-fw fa-github"></i>
	</a>
</li>







<li>
	<a href="https://www.linkedin.com/in/wansik-choi-b065881aa/" title="Follow on LinkedIn">
		<i class="fab fa-fw fa-linkedin"></i>
	</a>
</li>























</li>
      
      <li>
        <form action="/search.html" method="get">
          <input
            type="text"
            id="search-box"
            name="query"
            placeholder="Search"
            class=""
          />
          <button type="submit" class="">
            <i class="fa fa-fw fa-search"></i>
          </button>
        </form>
      </li>
      
    </ul>
  </nav>
</header>

<div class="site-category">
  <ul class="cat1" id="js-cat">
    <li>
      <a id="category-cv" href="/"> </a>
      <ul>
        <li><a href="/CV/Projects">Projects</a></li>
        <li><a href="/CV/Awards">Awards</a></li>
        <li><a href="/CV/Papers">Papers</a></li>
        <li><a href="/CV/ExtraAct">ExtraCurricular Act</a></li>
        <li><a href="/CV/InternShip">Internship</a></li>
        <li><a href="/CV/Language">Language</a></li>
        <li><a href="/CV/Courses">Courses</a></li>
        <li><a href="/CV/Education">Education</a></li>
        <li><a href="/CV/Qualification">Qualification</a></li>
      </ul>
    </li>

    <li>
      <a id="category-book" href="/"> </a>
      <ul>
        <li><a href="/Book/Finance">Finance</a></li>
        <li><a href="/Book/BM">Business/Marketing</a></li>
        <li><a href="/Book/SM">Self Management</a></li>
        <li><a href="/Book/CH">Culture/History</a></li>
        <li><a href="/Book/Leadership">Leadership</a></li>
        <li><a href="/Book/Classics">Classics</a></li>
        <li><a href="/Book/Think">Think</a></li>
      </ul>
    </li>

    <li>
      <a id="category-ds" href="/"> </a>
      <ul>
        <li><a href="/DS/DL">Deep Learning</a></li>
        <li><a href="/DS/ML">Machine Learning</a></li>
        <li><a href="/DS/Visualization">Visualization</a></li>
        <li><a href="/DS/Statistics">Statistics</a></li>
        <li><a href="/DS/LA">Linear Algebra</a></li>
        <li><a href="/DS/Calculus">Calculus</a></li>
      </ul>
    </li>

    <li>
      <a id="category-cs" href="/"> </a>
      <ul class="category-cs-ul">
        <li class="category-cs-li"><a href="/CS/Dynamics">Dynamics</a></li>
        <li class="category-cs-li"><a href="/CS/Network">Network</a></li>
        <li class="category-cs-li"><a href="/CS/Database">Database</a></li>
        <li class="category-cs-li"><a href="/CS/Algorithm">Algorithm</a></li>
        <li class="category-cs-li"><a href="/CS/Structure">Structure</a></li>
        <li class="category-cs-li"><a href="/CS/Parallel">Parallel</a></li>
        <li class="category-cs-li"><a href="/CS/OS">OS</a></li>
      </ul>
    </li>

    <li>
      <a id="category-dv" href="/"> </a>
      <ul class="category-dv-ul">
        <li class="category-dv-li"><a href="/DV/Server">Server</a></li>
        <li class="category-dv-li"><a href="/DV/Linux">Linux</a></li>
        <li class="category-dv-li"><a href="/DV/Python">Python</a></li>
        <li class="category-dv-li"><a href="/DV/C++">C++</a></li>
        <li class="category-dv-li"><a href="/DV/JavaScript">JavaScript</a></li>
        <li class="category-dv-li"><a href="/DV/HTML-CSS">HTML/CSS</a></li>
        <li class="category-dv-li"><a href="/DV/React">React</a></li>
        <li class="category-dv-li"><a href="/DV/Django">Django</a></li>
        <li class="category-dv-li"><a href="/DV/Docker">Docker</a></li>
        <li class="category-dv-li"><a href="/DV/Git">Git</a></li>
        <li class="category-dv-li"><a href="/DV/Tips">Tips</a></li>
        <li class="category-dv-li"><a href="/DV/SP">Side Project</a></li>
      </ul>
    </li>

    <li>
      <a id="category-works" href="/"> </a>
      <ul class="category-works-ul">
        <li class="category-works-li"><a href="/Works/Tags">Tags</a></li>
        <li class="category-works-li"><a href="/Works/Series">Series</a></li>
      </ul>
    </li>

    <li><a id="category-about" href="/about/"> </a></li>

    <!--    <ul class="cat2">-->

    <!--  </ul>-->
  </ul>
</div>

    <div class="content"><article
  class="feature-image main-category-feature"
  
>
  <header
    style="background-image: url('/assets/img/search.jpg')"
  >
    <ul
      class="category-title"
      
    >
      <h1 class="title">Search</h1>
       
    </ul>
  </header>

  <section class="post-content"><div class="search">
  <div id="search-results"></div>
  <p id="not-found" style="display: none">
    No results found.
  </p>
</div>

<script>
  window.store = {
    
      "cv-courses-2020-10-27-deep-learning-specialization-course-html": {
        "title": "Deep Learning Specialization Course",
        "tags": "Courses",
        "date": "October 27, 2020",
        "author": "",
        "category": "CV/Courses",
        "content": "Neural Networks and Deep LearningNeural Networks and Deep LearningImproving Deep Neural Networks: Hyperparameter tuning, Regularization and OptimizationImproving Deep Neural Networks: Hyperparameter tuning, Regularization and OptimizationStructuring Machine Learning ProjectsStructuring Machine Learning ProjectsConvolutional Neural NetworksConvolutional Neural NetworksSequence Models",
        
        "url": "/cv/courses/2020/10/27/Deep_Learning_Specialization_Course.html"
      }
      ,
    
      "cv-projects-2020-10-25-data-augmentation-using-pyqt5-html": {
        "title": "Data Augmentation Using PyQt5",
        "tags": "project, CV",
        "date": "October 25, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "  ImgAug 라이브러리와 PyQt5를 사용하여 Gui 기반 Data Augmentater를 제작하였다.Data Augmentation Using PyQt5",
        
        "url": "/cv/projects/2020/10/25/Data-Augmentation-using-pyqt5.html"
      }
      ,
    
      "dv-tips-2020-10-08-regex-11-greedy-html": {
        "title": "11: Greedy 와 Non-Greedy",
        "tags": "Tips, 정규표현식, greedy",
        "date": "October 8, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "Greedy는 알고리즘 문제를 풀 때 보았던 용어이다. 이 용어는 어떤 의미로 사용이 될까? 무언가 탐욕적으로 한다는 의미일 것이다. 다음과 같은 문자열에서 처음 나오는 tag를 검색하고 싶다 해보자.&gt;&gt;&gt; s = '&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;'&gt;&gt;&gt; len(s)32&gt;&gt;&gt; print(re.match('&lt;.*&gt;', s).span())(0, 32)&gt;&gt;&gt; print(re.match('&lt;.*&gt;', s).group())&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;.*&gt; 정규식의 매치 결과로 &lt;html&gt; 문자열을 돌려주기를 기대했지만 * 메타 문자는 매우 탐욕스러워서 매치할 수 있는 최대한의 문자열인 &lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt; 문자열을 모두 소비해 버렸다. 어떻게 하면 이 탐욕스러움을 제한하고 &lt;html&gt; 문자열까지만 소비하도록 막을 수 있을까?다음과 같이 non-greedy 문자인 ?를 사용하면 *의 탐욕을 제한할 수 있다.&gt;&gt;&gt; print(re.match('&lt;.*?&gt;', s).group())&lt;html&gt;non-greedy 문자인 ?는 *?, +?, ??, {m,n}?와 같이 사용할 수 있다. 가능한 한 가장 최소한의 반복을 수행하도록 도와주는 역할을 한다.Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/08/regex-11-Greedy.html"
      }
      ,
    
      "dv-tips-2020-10-08-regex-10-eb-ac-b8-ec-9e-90-ec-97-b4-eb-b0-94-ea-be-b8-ea-b8-b0-html": {
        "title": "10: 문자열 바꾸기",
        "tags": "Tips, 정규표현식, sub, subn",
        "date": "October 8, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "개요sub 메서드를 사용하면 정규식과 매치되는 부분을 다른 문자로 쉽게 바꿀 수 있다.&gt;&gt;&gt; p = re.compile('(blue|white|red)')&gt;&gt;&gt; p.sub('colour', 'blue socks and red shoes')'colour socks and colour shoes'첫번째 변수는 바꿀 문자열, 두번째 변수는 대상 문자열이다. 그런데 만약 한번만 바꾸고 싶다면 어떻게 해야할까? 세번째 변수로 count를 넘기면 된다.&gt;&gt;&gt; p.sub('colour', 'blue socks and red shoes', count=1)'colour socks and red shoes'처음 일치한 부분만 변경된 것을 확인할 수 있다.subn 역시 sub와 동일한 기능을 하지만 반환 결과를 튜플로 돌려준다는 차이가 있다. 돌려준 튜플의 첫 번째 요소는 변경된 문자열이고, 두 번째 요소는 바꾸기가 발생한 횟수이다.&gt;&gt;&gt; p = re.compile('(blue|white|red)')&gt;&gt;&gt; p.subn( 'colour', 'blue socks and red shoes')('colour socks and colour shoes', 2)참조 구문 사용하기참조 구문은 그루핑에서 검색된 것에 대해 네이밍을 하는 기능을 말했다. 이런 기능을 sub와 함께 사용할 경우 포맷을 변경할 수 있다.&gt;&gt;&gt; p = re.compile(r\"(?P&lt;name&gt;\\w+)\\s+(?P&lt;phone&gt;(\\d+)[-]\\d+[-]\\d+)\")&gt;&gt;&gt; print(p.sub(\"\\g&lt;phone&gt; \\g&lt;name&gt;\", \"park 010-1234-1234\"))010-1234-1234 park위 예는 이름 + 전화번호의 문자열을 전화번호 + 이름으로 바꾸는 예이다. sub의 바꿀 문자열 부분에 \\g&lt;그룹이름&gt;을 사용하면 정규식의 그룹 이름을 참조할 수 있게 된다.다음과 같이 그룹 이름 대신 참조 번호를 사용해도 마찬가지 결과를 돌려준다.&gt;&gt;&gt; p = re.compile(r\"(?P&lt;name&gt;\\w+)\\s+(?P&lt;phone&gt;(\\d+)[-]\\d+[-]\\d+)\")&gt;&gt;&gt; print(p.sub(\"\\g&lt;2&gt; \\g&lt;1&gt;\", \"park 010-1234-1234\"))010-1234-1234 park함수를 넣어 사용하기&gt;&gt;&gt; def hexrepl(match):...     value = int(match.group())...     return hex(value)...&gt;&gt;&gt; p = re.compile(r'\\d+')&gt;&gt;&gt; p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')'Call 0xffd2 for printing, 0xc000 for user code.'hexrepl 함수는 match 객체(위에서 숫자에 매치되는)를 입력으로 받아 16진수로 변환하여 돌려주는 함수이다. sub의 첫 번째 매개변수로 함수를 사용할 경우 해당 함수의 첫 번째 매개변수에는 정규식과 매치된 match 객체가 입력된다. 그리고 매치되는 문자열은 함수의 반환 값으로 바뀌게 된다.Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/08/regex-10-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B0%94%EA%BE%B8%EA%B8%B0.html"
      }
      ,
    
      "dv-tips-2020-10-08-regex-09-ec-a0-84-eb-b0-a9-ed-83-90-ec-83-89-html": {
        "title": "09: 전방 탐색(Lookahead Assertions)",
        "tags": "Tips, 정규표현식, Lookahead Assertions",
        "date": "October 8, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "개요Lookahead Assertions는 이해하기가 어렵다. 하지만 예시와 함께라면 어떤 경우에 이를 사용해야 하는지 알 수 있을 것이다.&gt;&gt;&gt; p = re.compile(\".+:\")&gt;&gt;&gt; m = p.search(\"http://google.com\")&gt;&gt;&gt; print(m.group())http:정규식 .+:과 일치하는 문자열로 http:를 돌려주었다. 만약 http:라는 검색 결과에서 :을 제외하고 출력하려면 어떻게 해야 할까? 위 예는 그나마 간단하지만 훨씬 복잡한 정규식이어서 그루핑은 추가로 할 수 없다는 조건까지 더해진다면 어떻게 해야 할까?이럴 때 사용할 수 있는 것이 바로 전방 탐색이다. 전방 탐색에는 긍정(Positive)과 부정(Negative)의 2종류가 있고 다음과 같이 표현한다.  긍정형 전방 탐색((?=...)) - ... 에 해당되는 정규식과 매치되어야 하며 조건이 통과되어도 문자열이 소비되지 않는다.  부정형 전방 탐색((?!...)) - ...에 해당되는 정규식과 매치되지 않아야 하며 조건이 통과되어도 문자열이 소비되지 않는다.긍정형 전방 탐색긍정형 전방 탐색을 사용하면 http:의 결과를 http로 바꿀 수 있다.&gt;&gt;&gt; p = re.compile(\".+(?=:)\")&gt;&gt;&gt; m = p.search(\"http://google.com\")&gt;&gt;&gt; print(m.group())http정규식 중 :에 해당하는 부분에 긍정형 전방 탐색 기법을 적용하여 (?=:)으로 변경하였다. 이렇게 되면 기존 정규식과 검색에서는 동일한 효과를 발휘하지만 : 에 해당하는 문자열이 정규식 엔진에 의해 소비되지 않아(검색에는 포함되지만 검색 결과에는 제외됨) 검색 결과에서는 :이 제거된 후 돌려주는 효과가 있다.여기서 알 수 있는 사실은, Lookahead Assertions이 zero-width assertion이라는 사실이다. 실제 검색에 적용되기 위해서는 엔진이 이를 가지고 있어야 하는데 그렇지는 않고, 그저 있는지 확인만 해주는 역할이다. 이를 소비된다 라는 표현으로 적었다는 것은 앞 글에서 배웠다.부정적 전방 탐색자, 이번에는 다음 정규식을 보자..*[.].*$이 정규식은 파일 이름 + . + 확장자를 나타내는 정규식이다. 이 정규식은 foo.bar, autoexec.bat, sendmail.cf 같은 형식의 파일과 매치될 것이다.이 정규식에 확장자가 “bat인 파일은 제외해야 한다”는 조건을 추가해 보자. 가장 먼저 생각할 수 있는 정규식은 다음과 같다..*[.][^b].*$            이 정규식은      메타 문자를 사용하여 확장자의 첫 번째 문자가 b가 아니거나 두 번째 문자가 a가 아니거나 세 번째 문자가 t가 아닌 경우를 의미한다. 이 정규식에 의하여 foo.bar는 제외되지 않고 autoexec.bat은 제외되어 만족스러운 결과를 돌려준다. 하지만 이 정규식은 sendmail.cf처럼 확장자의 문자 개수가 2개인 케이스를 포함하지 못하는 오동작을 하기 시작한다.      따라서 다음과 같이 바꾸어야 한다..*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$확장자의 문자 개수가 2개여도 통과되는 정규식이 만들어졌다. 하지만 정규식은 점점 더 복잡해지고 이해하기 어려워진다.그런데 여기에서 bat 파일말고 exe 파일도 제외하라는 조건이 추가로 생긴다면 어떻게 될까? 이 모든 조건을 만족하는 정규식을 구현하려면 패턴은 더욱더 복잡해질 것이다. 이런 상황에서 우리는 부정적 전방 탐색을 사용한다..*[.](?!bat$).*$확장자가 bat가 아닌 경우에만 통과된다는 의미이다. bat 문자열이 있는지 조사하는 과정에서 문자열이 소비되지 않으므로 bat가 아니라고 판단되면 그 이후 정규식 매치가 진행된다.exe 역시 제외하라는 조건이 추가되더라도 다음과 같이 간단히 표현할 수 있다..*[.](?!bat$|exe$).*$Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/08/regex-09-%EC%A0%84%EB%B0%A9%ED%83%90%EC%83%89.html"
      }
      ,
    
      "dv-tips-2020-10-08-regex-08-ea-b7-b8-eb-a3-a8-ed-95-91-html": {
        "title": "08: Grouping(그루핑)",
        "tags": "Tips, 정규표현식, Assertions",
        "date": "October 8, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "특정 문자열이 반복되는지에 대해서 알기 위해서는 어떠한 정규식을 작성해야 할까? 우리가 앞에서 배운 내용으로는 할 수 없다. 이렇게 특정 문자열이 단위로 구성되어 검색을 진행하고 싶을 때 사용하는 것이 그루핑이다.(ABC)+&gt;&gt;&gt; p = re.compile('(ABC)+')&gt;&gt;&gt; m = p.search('ABCABCABC OK?')&gt;&gt;&gt; print(m)&lt;re.Match object; span=(0, 9), match='ABCABCABC'&gt;&gt;&gt;&gt; print(m.group())ABCABCABC()을 사용하여 간단하게 그루핑을 진행할 수 있다.의미론적으로 그루핑하기이렇게 묶어서 무언가를 관리할 수 있다면 추가적으로 이점이 생긴다.&gt;&gt;&gt; p = re.compile(r\"\\w+\\s+\\d+[-]\\d+[-]\\d+\")&gt;&gt;&gt; m = p.search(\"park 010-1234-1234\")이렇게 작성하게 되면, 이름 + \" \" + 전화번호 형태의 문자열을 찾을 수 있다. 그런데 여기서 이름만 뽑아내고 싶다면 어떻게 해야할까? 사실 위의 반복의 목적보다 이런 의미론적으로 묶어서 뽑아내고자 하는 목적인 경우가 더 많다. 이 때 그루핑을 사용해보자.&gt;&gt;&gt; p = re.compile(r\"(\\w+)\\s+\\d+[-]\\d+[-]\\d+\")&gt;&gt;&gt; m = p.search(\"park 010-1234-1234\")&gt;&gt;&gt; print(m.group(1))park이름에 해당하는 \\w+ 부분을 그룹 (\\w+)으로 만들면 match 객체의 group(인덱스) 메서드를 사용하여 그루핑된 부분의 문자열만 뽑아낼 수 있다. group 메서드의 인덱스는 다음과 같은 의미를 갖는다.            group(인덱스)      설명                  group(0)      매치된 전체 문자열              group(1)      첫 번째 그룹에 해당되는 문자열              group(2)      두 번째 그룹에 해당되는 문자열              group(n)      n 번째 그룹에 해당되는 문자열      &gt;&gt;&gt; p = re.compile(r\"(\\w+)\\s+(\\d+[-]\\d+[-]\\d+)\")&gt;&gt;&gt; m = p.search(\"park 010-1234-1234\")&gt;&gt;&gt; print(m.group(2))010-1234-1234이렇게 하면 총 2개의 그룹이 발생하고, 전화번에 해당하는 부분에 접근하고 싶으면 group(2)를 사용하면 된다. 그럼 전화번호에서 통신사 번호를 뽑아내고자 하면 어떻게 할까?&gt;&gt;&gt; p = re.compile(r\"(\\w+)\\s+((\\d+)[-]\\d+[-]\\d+)\")&gt;&gt;&gt; m = p.search(\"park 010-1234-1234\")&gt;&gt;&gt; print(m.group(3))010이 예제에서 알 수 있는 것은 group을 중첩하여 사용하는 것이 가능하다는 것이다. 이런 경우 바깥쪽에서 안쪽으로 들어갈 수록 group의 index가 증가한다. zero-width assertion이기 때문에 이 모든 작업이 가능하다는 것을 염두해두자.그루핑된 문자열 재참조하기그룹의 또 하나 좋은 점은 한 번 그루핑한 문자열을 재참조(Backreferences)할 수 있다는 점이다.&gt;&gt;&gt; p = re.compile(r'(\\b\\w+)\\s+\\1')&gt;&gt;&gt; p.search('Paris in the the spring').group()'the the'정규식 (\\b\\w+)\\s+\\1은 (그룹) + \" \" + 그룹과 동일한 단어와 매치됨을 의미한다. 이렇게 정규식을 만들게 되면 2개의 동일한 단어를 연속적으로 사용해야만 매치된다. 이것을 가능하게 해주는 것이 바로 재참조 메타 문자인 \\1이다. \\1은 정규식의 그룹 중 첫 번째 그룹을 가리킨다. 두 번째 그룹을 참조하려면 \\2를 사용하면 된다.그루핑된 문자열에 이름 붙이기정규식 안에 그룹이 무척 많아진다고 생각해 보자. 예를 들어 정규식 안에 그룹이 10개 이상만 되어도 매우 혼란스러울 것이다. 거기에 더해 정규식이 수정되면서 그룹이 추가, 삭제되면 그 그룹을 인덱스로 참조한 프로그램도 모두 변경해 주어야 하는 위험도 갖게 된다. 만약 그룹을 인덱스가 아닌 이름(Named Groups)으로 참조할 수 있다면 어떨까? 즉 딕셔너리와 같은 형식이다. 그렇다면 이런 문제에서 해방되지 않을까?이러한 이유로 정규식은 그룹을 만들 때 그룹 이름을 지정할 수 있게 했다. 그 방법은 다음과 같다.(?P&lt;name&gt;\\w+)\\s+((\\d+)[-]\\d+[-]\\d+)위 정규식은 앞에서 본 이름과 전화번호를 추출하는 정규식이다. 기존과 달라진 부분은 다음과 같다.(\\w+) --&gt; (?P&lt;name&gt;\\w+)대단히 복잡해진 것처럼 보이지만 (\\w+)라는 그룹에 name이라는 이름을 붙인 것에 불과하다. 여기에서 사용한 (?...) 표현식은 정규 표현식의 확장 구문이다. 이 확장 구문을 사용하기 시작하면 가독성이 상당히 떨어지긴 하지만 반면에 강력함을 갖게 된다. 그룹에 이름을 지어 주려면 다음과 같은 확장 구문을 사용해야 한다.(?P&lt;그룹명&gt;...)그룹에 이름을 지정하고 참조하는 다음 예를 보자.&gt;&gt;&gt; p = re.compile(r\"(?P&lt;name&gt;\\w+)\\s+((\\d+)[-]\\d+[-]\\d+)\")&gt;&gt;&gt; m = p.search(\"park 010-1234-1234\")&gt;&gt;&gt; print(m.group(\"name\"))park위 예에서 볼 수 있듯이 name이라는 그룹 이름으로 참조할 수 있다. 그룹 이름을 사용하면 정규식 안에서 재참조하는 것도 가능하다.&gt;&gt;&gt; p = re.compile(r'(?P&lt;word&gt;\\b\\w+)\\s+(?P=word)')&gt;&gt;&gt; p.search('Paris in the the spring').group()'the the'위 예에서 볼 수 있듯이 재참조할 때에는 (?P=그룹이름)이라는 확장 구문을 사용해야 한다.Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/08/regex-08-%EA%B7%B8%EB%A3%A8%ED%95%91.html"
      }
      ,
    
      "dv-tips-2020-10-08-regex-07-eb-8b-a4-ec-96-91-ed-95-9c-eb-a9-94-ed-83-80-eb-ac-b8-ec-9e-90-html": {
        "title": "07: 다양한 메타문자",
        "tags": "Tips, 정규표현식, Assertions",
        "date": "October 8, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "문자열 소비정규식을 공부하다 보면 Assertion 이라는 단어를 자주 보게된다. Assertion이라는 단어는 검사, 검증, 확인 이라는 의미를 갖고 있다. 결과적으로 어떤 것을 검사하겠다는 의미로 많이 사용한다. 그런데 Zero-width는 무엇인가? 너비가 없다는 의미인데 왜 이런 추상적인 단어를 썼는지는 아직도 모르겠다. 하지만 말을 끼워 맞춰서 연상을 쉽게 해보도록 하자.이 개념을 알기 전에 우리가 알아야 할 것이 있다. 지금 이 글을 앞의 메타 문자와 따로 쓴 이유가 여기에 있다. 앞에서 배운 메타문자를 사용하게 되면 우리는 문자열을 소비한다. 이게 무슨 소리일까.이 굉장히 추상적인 개념은 예시를 들어 한번만 생각하면 굉장히 쉽게 이해가 가능하다. 예를 들어 아버지가방에들어간다 라는 문자열이 있다고 해보자. 내가 궁금한 정보는 가방을 찾고 방에 를 찾고 싶다. 이러한 문제에 대해 [가방] 이렇게 정규식을 작성하고 검색을 진행했을 때, 정규식 엔진이 어떤 방식으로 구동하는지를 따라가 보자.  아버지 부분 까지는 매치가 되지 않으므로 그냥 지나간다.  가방을 확인하고는 매치되었으므로 문자열을 소비해 버린다. 즉 없애 버린다와 같은 개념으로 보는 것이다.  소비된 문자열은 쳐다도 안보고 그 다음 문자열인 에들어간다 라는 문자열에 대해 가방 문자열을 찾는다.  가방을 찾는 정규표현식은 끝난다.  방에를 찾는 정규표현식이 시작되고, 찾지 못한 상태로 끝난다.이 예시를 보다보면, 소비라는 것이 어떤 의미로 사용되었는지 이해할 수 있다. 즉, 매치가 되는 경우 해당 부분이 없어지게 된다. 정말 소비라는 단어에 걸맞는 행동이다.Zero-width Assertion그렇다면, 너비가 없는 확인 이라는 의미의 Zero-width Assertion은 무엇일까. 위에서 가방이라는 단어는 2의 너비를 가진다고 볼 수 있다. 그리고 매칭이 되었을 때, 이 2의 너비에 해당하는 문자열이 소비된다. 이러한 관점에서 보았을 때, 0의 너비를 가진다고 함은, 검증을 진행하는데 있어 소비가 되는 문자열이 없다라는 의미로 와닿는다. 결과적으로 이러한 해석이 맞으며, Zero-width Assertion는 검색을 진행하는데 있어 위에서 알아본 문자열 소비가 없는 방법을 말한다. 이제 이러한 종류의 메타 문자에 대해서 알아보자.  ^ 또는 $ 문자를 메타 문자가 아닌 문자 그 자체로 매치하고 싶은 경우에는 \\^, $ 로 사용하면 된다.            메타문자      설명                                       또는 이라는 의미 (Or)              ^      문자열의 맨 처음과 일치하는가?(옵션에 따라 의미가 다름)                     $      문자열의 맨 끝과 일치하는가?(옵션에 따라 의미가 다름)                     \\A      문자열의 맨 처음과 일치하는가?(옵션에 따라 의미가 다름)                     \\Z      문자열의 맨 끝과 일치하는가?(옵션에 따라 의미가 다름)                     \\b      단어 구분자(whitespace)                     \\B      whitespace가 양쪽에 없는(사실 단어라고 볼수는 없다) 경우에 해당 문자가 있는 경우 매치             |            메타 문자는 or과 동일한 의미로 사용된다. A      B라는 정규식이 있다면 A 또는 B라는 의미가 된다.      &gt;&gt;&gt; p = re.compile('Crow|Servo')&gt;&gt;&gt; m = p.match('CrowHello')&gt;&gt;&gt; print(m)&lt;re.Match object; span=(0, 4), match='Crow'&gt;^메타 문자는 문자열의 맨 처음과 일치함을 의미한다. 앞에서 살펴본 컴파일 옵션 re.MULTILINE을 사용할 경우에는 여러 줄의 문자열일 때 각 줄의 처음과 일치하게 된다.다음 예를 보자.&gt;&gt;&gt; print(re.search('^Life', 'Life is too short'))&lt;re.Match object; span=(0, 4), match='Life'&gt;&gt;&gt;&gt; print(re.search('^Life', 'My Life'))None^Life 정규식은 Life 문자열이 처음에 온 경우에는 매치하지만 처음 위치가 아닌 경우에는 매치되지 않음을 알 수 있다.$$ 메타 문자는 ^ 메타 문자와 반대의 경우이다. 즉 $는 문자열의 끝과 매치함을 의미한다. 다음 예를 보자.&gt;&gt;&gt; print(re.search('short$', 'Life is too short'))&lt;re.Match object; span=(12, 17), match='short'&gt;&gt;&gt;&gt; print(re.search('short$', 'Life is too short, you need python'))Noneshort$ 정규식은 검색할 문자열이 short로 끝난 경우에는 매치되지만 그 이외의 경우에는 매치되지 않음을 알 수 있다.\\A\\A는 문자열의 처음과 매치됨을 의미한다. ^ 메타 문자와 동일한 의미이지만 re.MULTILINE 옵션을 사용할 경우에는 다르게 해석된다. re.MULTILINE 옵션을 사용할 경우 ^은 각 줄의 문자열의 처음과 매치되지만 \\A는 줄과 상관없이 전체 문자열의 처음하고만 매치된다.\\Z\\Z는 문자열의 끝과 매치됨을 의미한다. 이것 역시 \\A와 동일하게 re.MULTILINE 옵션을 사용할 경우 $ 메타 문자와는 달리 전체 문자열의 끝과 매치된다.\\b\\b는 단어 구분자(Word boundary)이다. 보통 단어는 whitespace에 의해 구분된다.&gt;&gt;&gt; p = re.compile(r'\\bclass\\b')&gt;&gt;&gt; print(p.search('no class at all'))&lt;re.Match object; span=(3, 8), match='class'&gt;\\bclass\\b 정규식은 앞뒤가 whitespace로 구분된 class라는 단어와 매치됨을 의미한다. 따라서 no class at all의 class라는 단어와 매치됨을 확인할 수 있다.&gt;&gt;&gt; print(p.search('the declassified algorithm'))None위 예의 the declassified algorithm 문자열 안에도 class 문자열이 포함되어 있긴 하지만 whitespace로 구분된 단어가 아니므로 매치되지 않는다.&gt;&gt;&gt; print(p.search('one subclass is'))Nonesubclass 문자열 역시 class 앞에 sub 문자열이 더해져 있으므로 매치되지 않음을 알 수 있다.\\b 메타 문자를 사용할 때 주의해야 할 점이 있다. \\b는 파이썬 리터럴 규칙에 의하면 백스페이스(BackSpace)를 의미하므로 백스페이스가 아닌 단어 구분자임을 알려 주기 위해 r'\\bclass\\b'처럼 Raw string임을 알려주는 기호 r을 반드시 붙여 주어야 한다.\\B\\B 메타 문자는 \\b 메타 문자와 반대의 경우이다. 즉 whitespace로 구분된 단어가 아닌 경우에만 매치된다.&gt;&gt;&gt; p = re.compile(r'\\Bclass\\B')&gt;&gt;&gt; print(p.search('no class at all'))None&gt;&gt;&gt; print(p.search('the declassified algorithm'))&lt;re.Match object; span=(6, 11), match='class'&gt;&gt;&gt;&gt; print(p.search('one subclass is'))Noneclass 단어의 앞뒤에 whitespace가 하나라도 있는 경우에는 매치가 안 되는 것을 확인할 수 있다.Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/08/regex-07-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A9%94%ED%83%80%EB%AC%B8%EC%9E%90.html"
      }
      ,
    
      "dv-tips-2020-10-08-regex-06-ed-8c-8c-ec-9d-b4-ec-8d-ac-eb-b0-b1-ec-8a-ac-eb-9e-98-ec-8b-9c-eb-ac-b8-ec-a0-9c-html": {
        "title": "06: 파이썬 백슬래시 문제",
        "tags": "Tips, 정규표현식",
        "date": "October 8, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "앞에서 정규식을 표현할 때 우리는 \\ 문자를 사용했다. 하지만 내가 정규식을 작성하는 데 있어서 \\문자 자체를 찾고 싶다면 어떻게 해야할까?\\section이렇게 정규식을 작성하게 되면 문제가 발생한다. \\s 부분이 whitespace로 해석되어 의도한 대로 매치가 이루어지지 않는다.[ \\t\\n\\r\\f\\v]ection즉, 위와 같은 의미로 해석된다. 이러한 문제에 대해서 해결하고 싶다면 아래와 같게 작성해야 한다.\\\\section파이썬의 문제위의 과정까지는 아무런 문제가 없다. 하지만 파이썬에서 정규식을 저렇게 작성하면 문제가 발생한다.&gt;&gt;&gt; p = re.compile('\\\\section')파이썬 정규식 엔진에는 파이썬 문자열 리터럴 규칙에 따라 \\\\이 \\로 변경되어 \\section이 전달된다. 유닉스의 grep, vi 등에서는 이러한 문제가 없다. 파이썬에서 사용할 때만 발생한다(파이썬의 리터럴 규칙) 결국 정규식 엔진에 //문자를 전달하기 위해서는 \\\\\\\\ 이렇게 전달해야 한다.(~~ㅠ~~) 정규식 엔진은 정규식을 해석하고 수행하는 모듈이다.&gt;&gt;&gt; p = re.compile('\\\\\\\\section')정말 번거롭다. 이쁘지도 않고. 이렇게 이해하기 어려운 정규식에 대해서 사람들은 짜증을 표현했다. 이러한 문제로 인해 파이썬 정규식에는 Raw String 규칙이 생겨나게 되었다. 즉 컴파일해야 하는 정규식이 Raw String임을 알려 줄 수 있도록 파이썬 문법을 만든 것이다.&gt;&gt;&gt; p = re.compile(r'\\\\section')위와 같이 정규식 문자열 앞에 r 문자를 삽입하면 이 정규식은 Raw String 규칙에 의하여 백슬래시 2개 대신 1개만 써도 2개를 쓴 것과 동일한 의미를 갖게 된다. 결과적으로 백슬래시를 사용하여 검색을 진행하고자 할때는 raw 표현을 쓰는 것이 좋다.Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/08/regex-06-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%B0%B1%EC%8A%AC%EB%9E%98%EC%8B%9C-%EB%AC%B8%EC%A0%9C.html"
      }
      ,
    
      "dv-tips-2020-10-06-regex-05-compile-option-html": {
        "title": "05: Compile Option(컴파일 옵션)",
        "tags": "Tips, 정규표현식",
        "date": "October 6, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "개요지금까지는 간단한 정규식을 살펴 보았지만, 실제로 존재하는 다양한 문자열에서 정보를 뽑아내기 위해서는 추가적인 옵션이 필요하다. 예를 들어 쇼핑몰의 상품 리뷰를 사용자가 작성했다고 한다. 우리는 여기서 핵심적인 단어를 뽑아내야 한다. 하지만 이런 리뷰는 문자열은 맞지만, 전체적으로 보았을 때 줄바꿈 문자(\\n)가 포함되어 있다. 줄바꿈 문자(\\n)는 이전에 배운 문자열에서 매치되지 않는 경우이다. 이렇게 어떤 문자열이냐에 따라서 우리는 검색 조건을 달리해야 한다. 이런 문제점을 기반으로 정규식을 컴파일할 때 사용할 수 있는 옵션을 소개한다.            option      describtion                  DOTALL(S)      메타문자 . 가 줄바꿈 문자를 포함하여 모든 문자와 매치할 수 있도록 한다.              IGNORECASE(I)      대소문자에 관계없이 매치할 수 있도록 한다.              MULTILINE(M)      여러줄과 매치할 수 있도록 한다. (^, $ 메타문자의 사용과 관계가 있는 옵션이다)              VERBOSE(X)      verbose 모드를 사용할 수 있도록 한다. (정규식을 보기 편하게 만들수 있고 주석등을 사용할 수 있게된다.)      옵션을 사용할 때는 re.DOTALL처럼 전체 옵션 이름을 써도 되고 re.S처럼 약어를 써도 된다.DOTALL(S)  메타문자 . 가 줄바꿈 문자를 포함하여 모든 문자와 매치할 수 있도록 한다.. 메타 문자는 줄바꿈 문자(\\n)를 제외한 모든 문자와 매치되는 규칙이 있다. 만약 \\n 문자도 포함하여 매치하고 싶다면 re.DOTALL 또는 re.S 옵션을 사용해 정규식을 컴파일하면 된다.&gt;&gt;&gt; import re&gt;&gt;&gt; p = re.compile('a.b')&gt;&gt;&gt; m = p.match('a\\nb')&gt;&gt;&gt; print(m)None위의 예를 보면, 컴파일 옵션을 주지 않은 경우 메타문자 .는 줄바꿈 문자(\\n)와 매치되지 않음을 알 수 있다.&gt;&gt;&gt; p = re.compile('a.b', re.DOTALL)&gt;&gt;&gt; m = p.match('a\\nb')&gt;&gt;&gt; print(m)&lt;_sre.SRE_Match object at 0x01FCF3D8&gt;이번에는 옵션을 준 경우이다. 줄바꿈 문자도 포함하여 결과에 반영한 것을 알 수 있다. 보통 re.DOTALL 옵션은 여러 줄로 이루어진 문자열에서 \\n에 상관없이 검색할 때 많이 사용한다.IGNORECASE, I  대소문자에 관계없이 매치할 수 있도록 한다.re.IGNORECASE 또는 re.I 옵션은 대소문자 구별 없이 매치를 수행할 때 사용하는 옵션이다. 다음 예제를 보자.&gt;&gt;&gt; p = re.compile('[a-z]', re.I)&gt;&gt;&gt; p.match('python')&lt;_sre.SRE_Match object at 0x01FCFA30&gt;&gt;&gt;&gt; p.match('Python')&lt;_sre.SRE_Match object at 0x01FCFA68&gt;&gt;&gt;&gt; p.match('PYTHON')&lt;_sre.SRE_Match object at 0x01FCF9F8&gt;[a-z] 정규식은 소문자만을 의미하지만 re.I 옵션으로 대소문자 구별 없이 매치된다.MULTILINE, M  여러줄과 매치할 수 있도록 한다.re.MULTILINE 또는 re.M 옵션은 다음 글에 설명할 메타 문자인 ^, $와 연관된 옵션이다. 이 메타 문자에 대해 간단히 설명하자면 ^는 문자열의 처음을 의미하고, $는 문자열의 마지막을 의미한다. 예를 들어 정규식이 ^python인 경우 문자열의 처음은 항상 python으로 시작해야 매치되고, 만약 정규식이 python$이라면 문자열의 마지막은 항상 python으로 끝나야 매치된다는 의미이다.import rep = re.compile(\"^python\\s\\w+\")data = \"\"\"python onelife is too shortpython twoyou need pythonpython three\"\"\"print(p.findall(data))['python one']정규식 ^python\\s\\w+은 python이라는 문자열로 시작하고 그 뒤에 whitespace, 그 뒤에 단어가 와야 한다는 의미이다. 검색할 문자열 data는 여러 줄로 이루어져 있다.결과를 보면 ^ 메타 문자에 의해 python이라는 문자열을 사용한 첫 번째 줄만 매치된 것을 알 수 있다. 하지만 내가 원하는 결과는 해당 문자열의 처음에 조건이 걸리는 것이 아니고, 라인이 변경될 때 처음인 경우를 뜻하는 것이다. 이럴 때 사용하는 옵션이 re.MULTILINE 또는 re.M이다.import rep = re.compile(\"^python\\s\\w+\", re.MULTILINE)data = \"\"\"python onelife is too shortpython twoyou need pythonpython three\"\"\"print(p.findall(data))['python one', 'python two', 'python three']re.MULTILINE 옵션으로 인해 ^ 메타 문자가 문자열 전체가 아닌 각 줄의 처음이라는 의미를 갖게 되었다. 즉, re.MULTILINE 옵션은 ^, $ 메타 문자를 문자열의 각 줄마다 적용해 주는 것이다.VERBOSE(X)  verbose 모드를 사용할 수 있도록 한다.고마운 옵션이다. 사실 정규식은 사용하기 까다롭다. 정규식은 마치 시와 같이 함축적인 단어들의 집합으로 구성되어 있다. 따라서 전문가들이 만들어 놓은 정규식을 보면 정말 섬세하게 다뤄서 해석해야 한다. 좀 더 좋은 방법이 없을까? 이렇게 이해하기 어려운 정규식을 주석 또는 줄 단위로 구분할 수 있다면 얼마나 보기 좋고 이해하기 쉬울까? 이러한 욕구를 해소해줄 수 있는 것이 바로 re.VERBOSE 또는 re.X 옵션이다.charref = re.compile(r'&amp;[#](0[0-7]+|[0-9]+|x[0-9a-fA-F]+);')charref = re.compile(r\"\"\" &amp;[#]                # Start of a numeric entity reference (     0[0-7]+         # Octal form   | [0-9]+          # Decimal form   | x[0-9a-fA-F]+   # Hexadecimal form ) ;                   # Trailing semicolon\"\"\", re.VERBOSE)첫 번째와 두 번째 예를 비교해 보면 컴파일된 패턴 객체인 charref는 모두 동일한 역할을 한다. 하지만 정규식이 복잡할 경우 두 번째처럼 주석을 적고 여러 줄로 표현하는 것이 훨씬 가독성이 좋다는 것을 알 수 있다.re.VERBOSE 옵션을 사용하면 문자열에 사용된 whitespace는 컴파일할 때 제거된다(단 [ ] 안에 사용한 whitespace는 제외). 그리고 줄 단위로 #기호를 사용하여 주석문을 작성할 수 있다.Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/06/regex-05-compile-option.html"
      }
      ,
    
      "dv-tips-2020-10-06-regex-04-match-ea-b0-9d-ec-b2-b4-ec-9d-98-eb-a9-94-ec-84-9c-eb-93-9c-html": {
        "title": "04: match 객체의 메서드",
        "tags": "Tips, 정규표현식",
        "date": "October 6, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "개요앞의 글에서 우리는 컴파일 된 pattern 객체의 메서드를 공부했다. 이 메서드에는 match, search, findall, finditer가 있었다. 해당 메서드들은 검색이 된 경우 match 객체를 리턴했다.하지만 우리가 원하는 결과는 이 match 객체 자체가 아니다. 우리는 다음과 같은 궁금증을 가지고 검색을 진행했을 것이다.  어떤 문자열이 매치되었는가?  매치된 문자열의 인덱스는 어디서부터 어디까지인가?이러한 것들을 해결하기 위한 메서드를 소개한다.            method      목적                  group()      매치된 문자열을 돌려준다.              start()      매치된 문자열의 시작 위치를 돌려준다.              end()      매치된 문자열의 끝 위치를 돌려준다.              span()      매치된 문자열의 (시작, 끝)에 해당하는 튜플을 돌려준다.      import rep = re.compile('ab*')m = p.match(\"python\")group()  매치된 문자열을 돌려준다.&gt;&gt;&gt; m.group()'python'start()  매치된 문자열의 시작 위치를 돌려준다.&gt;&gt;&gt; m.start()0end()  매치된 문자열의 끝 위치를 돌려준다.&gt;&gt;&gt; m.end()6span()  매치된 문자열의 (시작, 끝)에 해당하는 튜플을 돌려준다.&gt;&gt;&gt; m.span()(0, 6)위 경우는 match를 사용했기 때문에 시작 위치는 항상 0일 것이다. 염두하자.Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/06/regex-04-match-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C.html"
      }
      ,
    
      "dv-tips-2020-10-06-regex-03-re-module-html": {
        "title": "03: re module",
        "tags": "Tips, 정규표현식",
        "date": "October 6, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "정규 표현식은 다양한 언어에서 사용이 가능하다. 이 글에서는 파이썬을 기반으로 정규 표현식을 확인해 보도록 하자.import rep = re.compile('ab*')re.compile을 사용하여 정규 표현식(위 예에서는 ab*)을 컴파일한다. re.compile의 결과로 돌려주는 객체 p(컴파일된 패턴 객체)를 사용하여 그 이후의 작업을 수행할 것이다.  정규식을 컴파일할 때 특정 옵션을 주는 것도 가능한데, 이에 대해서는 뒤에서 자세히 살펴본다.  패턴이란 정규식을 컴파일한 결과이다.Method            Method      목적                  match()      문자열의 처음부터 정규식과 매치되는지 조사한다.              search()      문자열 전체를 검색하여 정규식과 매치되는지 조사한다.              findall()      정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려준다.              finditer()      정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 돌려준다.      match, search는 정규식과 매치될 때는 match 객체를 돌려주고, 매치되지 않을 때는 None을 돌려준다. 각각의 예를 진행하기 전의 아래의 코드를 먼저 수행하자.import rep = re.compile('[a-z]+')Match  문자열의 처음부터 정규식과 매치되는지 조사한다.&gt;&gt;&gt; m = p.match(\"python\")&gt;&gt;&gt; print(m)&lt;_sre.SRE_Match object at 0x01F3F9F8&gt;Z“python” 문자열은 [a-z]+ 정규식에 부합되므로 match 객체를 돌려준다.&gt;&gt;&gt; m = p.match(\"3 python\")&gt;&gt;&gt; print(m)None“3 python” 문자열은 처음에 나오는 문자 3이 정규식 [a-z]+에 부합되지 않으므로 None을 돌려준다. match의 결과로 match 객체 또는 None을 돌려주기 때문에 파이썬 정규식 프로그램은 보통 다음과 같은 흐름으로 작성한다.p = re.compile(정규표현식)m = p.match( 'string goes here' )if m:    print('Match found: ', m.group())else:    print('No match')검색되지 않은 경우 작업을 수행하지 않는다.search  문자열 전체를 검색하여 정규식과 매치되는지 조사한다.&gt;&gt;&gt; m = p.search(\"python\")&gt;&gt;&gt; print(m)&lt;_sre.SRE_Match object at 0x01F3FA68&gt;match와 동일한 결과이다. 하지만 아래의 예는 결과가 다르다.&gt;&gt;&gt; m = p.search(\"3 python\")&gt;&gt;&gt; print(m)&lt;_sre.SRE_Match object at 0x01F3FA30&gt;“3 python” 문자열의 첫 번째 문자는 “3”이지만 search는 문자열의 처음부터 검색하는 것이 아니라 문자열 전체를 검색하기 때문에 “3 “ 이후의 “python” 문자열과 매치된다. 이렇듯 match 메서드와 search 메서드는 문자열의 처음부터 검색할지의 여부에 따라 다르게 사용해야 한다.findall  정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려준다.&gt;&gt;&gt; result = p.findall(\"life is too short\")&gt;&gt;&gt; print(result)['life', 'is', 'too', 'short']“life is too short” 문자열의 ‘life’, ‘is’, ‘too’, ‘short’ 단어를 각각 [a-z]+ 정규식과 매치해서 리스트로 돌려준다.finditer  정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 돌려준다.findall과 마찬가지로 문자열에 해당하는 단어를 돌려준다. 하지만 우리가 이 정규 표현식을 사용하는 경우 중에서, 하나의 문자열에 존재하는 다양한 단어들에 대해 다시한번 검색을 진행하고 싶을 수 있다. 이런 경우 findall은 리스트를 결과값으로 뱉기 때문에 이러한 작업을 진행하기 어렵다. 이러한 필요성에서 finditer method는 굉장히 유용하다.&gt;&gt;&gt; result = p.finditer(\"life is too short\")&gt;&gt;&gt; print(result)&lt;callable_iterator object at 0x01F5E390&gt;&gt;&gt;&gt; for r in result: print(r)...&lt;_sre.SRE_Match object at 0x01F3F9F8&gt;&lt;_sre.SRE_Match object at 0x01F3FAD8&gt;&lt;_sre.SRE_Match object at 0x01F3FAA0&gt;&lt;_sre.SRE_Match object at 0x01F3F9F8&gt;match 객체를 리턴하기 때문에 우리는 이를 기반으로 다른 검색을 진행할 수 있다.Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/06/regex-03-re-module.html"
      }
      ,
    
      "dv-tips-2020-10-06-regex-02-ea-b0-84-eb-8b-a8-ed-95-9c-eb-a9-94-ed-83-80-eb-ac-b8-ec-9e-90-html": {
        "title": "02: 간단한 메타문자",
        "tags": "Tips, 정규표현식",
        "date": "October 6, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "  원래 그 문자가 가진 뜻이 아닌 특별한 용도로 사용하는 문자문자 클래스 []  [ ] 사이에 있는 각각의 문자들에 대해 적어도 하나가 매치가 되는가?즉, 정규 표현식이 [abc]라면 이 표현식의 의미는 “a, b, c 중 한 개의 문자와 매치”를 뜻한다.  “a”는 정규식과 일치하는 문자인 “a”가 있으므로 매치  “before”는 정규식과 일치하는 문자인 “b”가 있으므로 매치  “dude”는 정규식과 일치하는 문자인 a, b, c 중 어느 하나도 포함하고 있지 않으므로 매치되지 않음[ ] 안의 두 문자 사이에 하이픈(-)을 사용하면 두 문자 사이의 범위(From - To)를 의미한다. 예를 들어 [a-c]라는 정규 표현식은 [abc]와 동일하고 [0-5]는 [012345]와 동일하다.  [a-zA-Z] : 알파벳 모두  [0-9] : 숫자문자 클래스([ ]) 안에는 어떤 문자나 메타 문자도 사용할 수 있다. 하지만..주의사항주의해야 할 메타 문자가 1가지 있다. 그것은 바로 ^인데, 문자 클래스 안에 ^ 메타 문자를 사용할 경우에는 반대(not)라는 의미를 갖는다. 예를 들어 [^0-9]라는 정규 표현식은 숫자가 아닌 문자만 매치된다.자주 사용하는 문자 클래스            메타문자      동일 표현식      설명                  \\d      [0-9]      숫자와 매치              \\D      [^0-9]      숫자가 아닌 것과 매치              \\s      [ \\t\\n\\r\\f\\v]      whitespace 문자(스페이스, 공백, tab)와 매치(맨 앞의 빈 칸은 공백문자(space)를 의미한다.)              \\S      [^ \\t\\n\\r\\f\\v]      whitespace 문자가 아닌 것과 매치              \\w      [a-zA-Z0-9_]      문자+숫자(alphanumeric)와 매치              \\W      [^a-za-z0-9_]      문자+숫자(alphanumeric)가 아닌 문자와 매치      대문자 사용은 소문자의 반대이다.Dot(.)  줄바꿈 문자인 \\n을 제외한 모든 문자와 매치됨을 의미, 단 하나라도 있어야 한다.사실, re.DOTALL 옵션을 주면 \\n 문자와도 매치된다. 일단 예제를 보며 이해해보자.            정규식      의미                  a.b      “a + 모든문자 + b”      즉, a와 b라는 문자 사이에 어떤 문자가 들어가도 모두 매치된다는 의미이다. 문자열 “aab”, “a0b”, “abc”가 정규식 a.b와 어떻게 매치되는지 살펴보자.  “aab”는 가운데 문자 “a”가 모든 문자를 의미하는 .과 일치하므로 정규식과 매치된다.  “a0b”는 가운데 문자 “0”가 모든 문자를 의미하는 .과 일치하므로 정규식과 매치된다.  “abc”는 “a”문자와 “b”문자 사이에 어떤 문자라도 하나는 있어야 하는 이 정규식과 일치하지 않으므로 매치되지 않는다.마지막이 헷갈린다. 조심하도록 하자. 그런데 만약 “.” 문자 자체와 매칭이 되길 원한다면 어떻게 해야할까?            정규식      의미                  a[.]b      “a + Dot(.)문자 + b”      정규식 a[.]b는 “a.b” 문자열과 매치되고, “a0b” 문자열과는 매치되지 않는다. 혼동하지 말자.반복(*)  특정 문자가 0부터 무한대까지의 반복을 매칭한다.            정규식      문자열      Match 여부      설명                  ca*t      ct      Yes      “a”가 0번 반복되어 매치              ca*t      cat      Yes      “a”가 0번 이상 반복되어 매치 (1번 반복)              ca*t      caaat      Yes      “a”가 0번 이상 반복되어 매치 (3번 반복)      반복(+)  특정 문자가 1부터 무한대까지의 반복을 매칭한다.            정규식      문자열      Match 여부      설명                  ca+t      ct      No      “a”가 0번 반복되어 매치되지 않음              ca+t      cat      Yes      “a”가 0번 이상 반복되어 매치 (1번 반복)              ca+t      caaat      Yes      “a”가 0번 이상 반복되어 매치 (3번 반복)      반복({n,m})  특정 문자가 n이상 m이하 반복 횟수인 경우 매칭한다.{ } 메타 문자를 사용하면 반복 횟수를 고정할 수 있다. {m, n} 정규식을 사용하면 반복 횟수가 m부터 n까지 매치할 수 있다. 또한 m 또는 n을 생략할 수도 있다. 만약 {3,}처럼 사용하면 반복 횟수가 3 이상인 경우이고 {,3}처럼 사용하면 반복 횟수가 3 이하를 의미한다. 생략된 m은 0과 동일하며, 생략된 n은 무한대(2억 개 미만)의 의미를 갖는다.{1,}은 +와 동일하고, {0,}은 *와 동일하다. 이 부분을 언급하는 이유는, 굳이 저런 표현보다는 +, *을 사용하는 것이 직관적이기 때문이다.{n}  반드시 n번 반복.            정규식      문자열      Match 여부      설명                  ca{2}t      cat      No      “a”가 1번만 반복되어 매치되지 않음              ca{2}t      caat      Yes      “a”가 2번 반복되어 매치      {n, m}  n~m 번 반복.            정규식      문자열      Match 여부      설명                  ca{2,5}t      cat      No      “a”가 1번만 반복되어 매치되지 않음              ca{2,5}t      caat      Yes      “a”가 2번 반복되어 매치              ca{2,5}t      caaaaat      Yes      “a”가 5번 반복되어 매치      ?  있어도 되고 없어도 된다.            정규식      문자열      Match 여부      설명                  ab?c      abc      Yes      “b”가 1번 사용되어 매치              ab?c      ac      Yes      “b”가 0번 사용되어 매치      Reference07-2 정규 표현식 시작하기",
        
        "url": "/dv/tips/2020/10/06/regex-02-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%A9%94%ED%83%80%EB%AC%B8%EC%9E%90.html"
      }
      ,
    
      "dv-tips-2020-10-06-regex-01-ea-b0-9c-eb-85-90-ec-9e-a1-ea-b8-b0-html": {
        "title": "01: 개념잡기",
        "tags": "Tips, 정규표현식",
        "date": "October 6, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "개념  특정한 규칙을 가진 문자열의 집합을 표현하기 위해 쓰이는 형식언어프로그래밍을 다루다 보면 가장 많이 만나게 되는 것이 문자열이다. 모든 것이 문자열로 나타나 있고, 이것을 기반으로 한 규칙으로 프로그램이 구동되기 때문이다. 또한 특정한 정보를 다루기 위해서라도 우리는 이 문자열을 다루고 추출해야 한다. 이러한 수요는 끊임없이 계속되어 왔다.역사와 종류  개발 새발이다. 너무 다양해.정규 표현식은 다양한 분야에서 쓰였다. 그리고 각각의 분야에서 발생한 정규식은 서로에게 영향을 주었다. 보통 이러면 하나의 통일된 표준이 나올법도 한데, 그렇지 않다.유닉스 명령줄 도구들에서 사용하던 정규 표현식은 후에 POSIX 표준에 편입되었다. 그러면서 이 시기의 표준으로 받아들여진 형식을 POSIX 정규식이라고 한다. 그리고 이후에 다시 POSIX 정규식은 POSIX BRE (POSIX 기본 정규식)와 POSIX ERE (POSIX 확장 정규식)으로 다른 버전이 나뉘게 된다. (grep에서 -e 스위치를 써서 확장 정규식을 쓰던 옵션이 바로 ERE를 쓴다는 의미이다.) 그 외에 BRE를 기본 골격으로 한 vim 정규식이 있다. 이 vim 정규식은 vim 편집기 내에서 찾기/바꾸기 등의 동작에서 범위를 지정하는데 사용된다. 하지만 오랜 역사를 따라 개선과 확장을 거듭하면서 이 vim 정규식 역시 POSIX 표준과는 좀 다른 규격으로 취급될 정도이다. (심지어 vim 내에서도 magic 모드, very magic 모드라는 것이 있어서 이후의 확장 정규식의 일부 기능을 사용하거나, 일부 punctuation 문자를 매칭하는 방법이 다시 갈리게 되는 지경이다.)그리고 문자열을 다루는데 특화된 스크립트 언어인 펄(perl)이 등장했다. 펄의 정규식 체계는 역시나 기본은 POSIX와 비슷한 골격에서 디자인되어 있다. 그런데 엄청나게 많은 확장이 들어갔다. 펄의 정규식은 PCRE라는 규격으로 정리되었으며, 이후 많은 프로그래밍 언어들이 이 규격을 차용하거나 계승한다. 여기서 중요한 것은 “일부 차용”이다. 이 규격은 워낙 방대해서 PCRE를 그대로 가져다 쓰지 않는 이상, 구현할 게 너무 많기 때문이다.Reference정규표현식의 개념과 기초 문법",
        
        "url": "/dv/tips/2020/10/06/regex-01-%EA%B0%9C%EB%85%90%EC%9E%A1%EA%B8%B0.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-14-function-in-complex-numbers-html": {
        "title": "14: 함수의 복소적 표현 (Function in Complex Numbers)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-14-Function-in-Complex-Numbers.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-13-cauchy-riemann-equation-html": {
        "title": "13: 코시-리만 방정식 (Cauchy-Riemann Equation)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-13-Cauchy-Riemann-Equation.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-12-eb-b3-b5-ec-86-8c-ed-95-b4-ec-84-9d-ed-95-a8-ec-88-98-ec-9d-98-eb-8f-84-ed-95-a8-ec-88-98-html": {
        "title": "12: 복소 해석 함수의 도함수 (Derivative of Complex Analytic Function)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-12-%EB%B3%B5%EC%86%8C-%ED%95%B4%EC%84%9D-%ED%95%A8%EC%88%98%EC%9D%98-%EB%8F%84%ED%95%A8%EC%88%98.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-11-demoivre-s-fomula-html": {
        "title": "11: 드무아브르의 공식 (De Moivre's Fomula)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-11-DeMoivre's-Fomula.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-10-polar-form-of-complex-numbers-html": {
        "title": "10: 복소수의 극좌표 표현(Polar Form of Complex Numbers)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-10-Polar-Form-Of-Complex-Numbers.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-09-complex-number-complex-plane-html": {
        "title": "09: 복소수 &amp; 복소평면 (Complex Number &amp; Complex Plane)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-09-Complex-Number-Complex-Plane.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-08-wave-equation-in-polar-coordinates-html": {
        "title": "08: 극좌표에서 파동방정식 (Wave Equation in Polar Coordinates)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-08-Wave-Equation-In-Polar-Coordinates.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-07-two-dimentional-wave-equation-html": {
        "title": "07: 2차원 파동 방정식 (Two Dimentional Wave Equation)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-07-Two-Dimentional-Wave-Equation.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-06-laplace-equation-html": {
        "title": "06: 라플라스 방정식 (Laplace Equation)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-06-Laplace-Equation.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-05-solution-of-heat-equation-html": {
        "title": "05: 열 방정식의 해",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-05-Solution-Of-Heat-Equation.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-04-heat-equation-html": {
        "title": "04: 열 방정식 (Heat Equation)",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-04-Heat-Equation.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-03-wave-equation-2-html": {
        "title": "03: 파동방정식 (Wave Equation) #2",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-03-Wave-Equation-2.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-02-wave-equation-1-html": {
        "title": "02: 파동방정식 (Wave Equation) #1",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-02-Wave-Equation-1.html"
      }
      ,
    
      "ds-calculus-2020-10-02-partial-differential-equations-01-ed-8e-b8-eb-af-b8-eb-b6-84-eb-b0-a9-ec-a0-95-ec-8b-9d-ea-b0-9c-eb-a1-a0-html": {
        "title": "01: 편미분 방정식 개론",
        "tags": "Math, Differential Equation",
        "date": "October 2, 2020",
        "author": "",
        "category": "DS/Calculus",
        "content": "",
        
        "url": "/ds/calculus/2020/10/02/Partial-Differential-Equations-01-%ED%8E%B8%EB%AF%B8%EB%B6%84-%EB%B0%A9%EC%A0%95%EC%8B%9D-%EA%B0%9C%EB%A1%A0.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-thermodynamics-08-eb-8b-a8-ec-97-b4-ed-8f-ac-ed-99-94-ec-98-a8-eb-8f-84-html": {
        "title": "08: 단열 포화 온도(Adiabatic Saturation) &amp; Psychrometric Chart",
        "tags": "Dynamics, Thermodynamics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Adiabatic Saturation다음과 같은 단열 Chamber를 보자.왼쪽은 포화되지 않은 공기가 들어오고 Chamber를 통과한 후 포화공기가 되서 나간다. 그렇게 될만큼 긴 챔버라고 가정하자. Dew point Temperature와는 다르다. 제 3의 inlet에서 물이 들어와 있기 때문이다. 1에서 2로 가는동안 (T1 &gt; T2) 물에서 증기를 발생시키고, 그 증기를 가져갈 것이다. 따라서 이 과정은 등압이 아니고 압력이 높아지는 과정이다.우리가 가진 정보가 T1, T2, w2라 했을 때, 단열 Chamber에서 w1을 구하는 식을 만들어 보자.첨자 a는 air를 의미한다고 약속하자. 첨자 f는 물를 의미한다고 약속하자.inlet과 outlet에서 질량이 같다고 가정하고, inlet의 vapor와 물의 질량의 합이 outlet에서의 vapor의 질량이다. 윗 식을 아래식에 대입해서 정리하면,1번식 ; 더해지는 증기의 양은 나중 습도에서 현재 습도를 뺀 뒤 질량을 곱해준다.이 전체 시스템에 대해 에너지 보존 법칙을 쓰게 되면,2번식에 1번식을 넣어 정리하면,양변을 Ma로 나누면,공기의 엔탈피는 다음의 식으로 구할 수 있으므로,w2는 상대습도가 1인 곳의 절대 습도이므로, 관계식에 의해, 다음과 같다.그런데 항상 w1을 구할 때 이런 단열 Chamber를 만들 수 없기 때문에 (실현도 불가능) 그래서 T2, T1을 구하는데 있어 좀더 실용적인 방법을 택해야 한다. 이 때, 다음과 같은 온도계를 사용한다.Wet bulb란 아래쪽에 물에 흠뻑 적신 솜을 달아놓은 것을 의미한다. 이렇게 한 상태로 불어오는 바람에 대해 온도를 측정하면, 공기는 지나가면서 적신 솜에서 열을 빼앗아 갈것이다. 이 때의 온도를 측정하는 것을 Wet bulb Temperature라 하고, 솜을 달지 않은 상태에서 측정하는 것을 Dry bulb Temperature라 한다.Psychrometric Chart사실 어떤 물질의 Property는 state postulate에 의해 두가지 이상만 알게 되면 결정된다. 하지만 혼합기체에서 그 값을 구하는게 너무 귀찮아서 만든 표이다.하지만 굉장히 끔찍하게 생겼다.보는 방법은 생각보다 간단한데, 그냥 2개의 property에 맞게 선을 그어서 만나는 부분의 값을 읽으면 된다. 제일 왼쪽 바깥에 그려져있는 상대습도가 100%인 곳은,상대습도가 100%니까 그 점에서 Sat T, Tdp, Twb, Tdr 온도가 모두 같을 것이다.",
        
        "url": "/cs/dynamics/2020/10/02/Thermodynamics-08-%EB%8B%A8%EC%97%B4-%ED%8F%AC%ED%99%94-%EC%98%A8%EB%8F%84.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-thermodynamics-07-reciprocating-engines-html": {
        "title": "07: 왕복 사이클 (Reciprocating Engines)",
        "tags": "Dynamics, Thermodynamics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "왕복엔진이라 함은, 가솔린 엔진과 디젤 엔진으로 나뉜다. 기본적으로 피스톤의 왕복운동을 기반으로 Shaft work을 생산하기 때문에 그렇다.종류  Spark-ignition (Gasolin)  compression-ignition (Diesel)기본적으로 알아야 하는 것  MEP (Mean Effective Pressure)          피스톤이 움직이는 최대 부피대비 일 생산량 (kPa)      왕복엔진의 성능을 판단하는 척도가 된다.      $W_{net} = MEP * (V_{max} - V_{min})$        Compression Ratio          r = Vmax/Vmin        Actual : 4 stroke, open system  Ideal : 2 stroke, closed system  ISENTROPIC RELATIONOTTO Cycle  Ideal Cycle for Spark - ignition Engine​  Process : 등엔트로피 수축 -&gt; 등적 Heat in -&gt; 등엔트로피 팽창 -&gt; 등적 Heat out  Efficiency : r (압축비) 의 함수, 높을 수록 증가한다.  Problem : 압축비가 높을 때 효율이 좋지만 자연발화의 가능성이 있다.Diesel Cycle  Ideal Cycle for Compression - ignition Engine​  Difference : OTTO에는 혼합기체가 압축된다. Diesel은 공기만 압축된다.​ _ 자연발화의 가능성을 제거​ _ 높은 압축비에서 운행 가능  Process : 등엔트로피 수축 -&gt; 등압 Heat in -&gt; 등엔트로피 팽창 -&gt; 등적 Heat out  Efficiency : r (압축비)와 rc(부피비) 의 함수  Problem : 질소산화물 배출, r (압축비) 가 같을 경우 OTTO보다 효율이 낮다.",
        
        "url": "/cs/dynamics/2020/10/02/Thermodynamics-07-Reciprocating-Engines.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-thermodynamics-06-properties-of-gas-vapor-mixtures-html": {
        "title": "06: 증기 혼합 기체에서의 물성치 (Properties of Gas-Vapor Mixtures)",
        "tags": "Dynamics, Thermodynamics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Gas Vapor Mixture우리는 가동유체를 보통 대기에 있는 기체로 사용한다. 그 기체는 건조한 공기 + 증기로 볼 수 있을 것이다.가정  건조 공기 비열을 1.005의 고정값을 갖는다고 가정  증기 상온에서, 저압의 증기의 엔탈피는 온도만의 함수이다.즉, Tsat이 정해지면 그 때의 엔탈피를 상수로 보아도 문제가 없다.절대 습도, 상대 습도  절대 습도 증기의 질량 / 전체 질량 = 0.622 * (증기압 / 전체 압력)  포화 공기 공기와 습기의 혼합기체에서 이 기체가 머금을 수 있는 최대 증기를 가진 공기  m_g 혼합공기가 최대로 머금을 수 있는 증기의 질량  상대 습도 증기의 질량 / m_g = 증기압 / 최대 증기압절대 습도를 통한 혼합기체의 엔탈피 표현이 때 ma로 나누는 것에 주의한다.Dew point Temperature  등압으로 온도가 떨어질 때, 혼합 공기가 액화하기 시작하는 온도.여기서,이므로,이다. 그리고 아래에 정리할 상대습도의 개념을 가지고,다음과 같은 관계가 성립한다. 상대습도는 (0~1)의 값이므로 포화증기의 절대습도는 $\\phi = 1$ 일 때 성립한다.",
        
        "url": "/cs/dynamics/2020/10/02/Thermodynamics-06-Properties-of-Gas-Vapor-Mixtures.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-thermodynamics-05-gas-mixture-pressure-html": {
        "title": "05: 혼합기체에서 압력, 부피, 온도 양상 (PVT Behavior of Gas Mixture)",
        "tags": "Dynamics, Thermodynamics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "가정  실제 기체는 저압, 고온(임계온도) 상황에서 이상기체로 간주할 수 있다.  두 기체가 서로 반응하지 않는 이상 기체 인 경우, 두 기체의 합도 역시 이상기체로 행동한다.이 두가지 가정은 이상기체의 행동을 예측하는데 쓰인다.Two Law of Gas Mixture  Dalton’s Law of Additive Pressures          두 기체가 같은 부피를 가지고 있고, 더했을 때도 같은 부피라면, 혼합기체의 압력은 두 기체의 압력을 더한 것과 같다.        Amagat’s Law of additive Volumes          두 기체가 같은 압력를 가지고 있고, 더했을 때도 같은 압력이라면, 혼합기체의 부피은 두 기체의 부피을 더한 것과 같다.      사실 V = f(P, T), P = f(V, T) 로 이상기체의 경우 같은 식을 의미한다.혼합 기체를 다루고 있기 때문에 우리는 그 둘을 구분하기 위해서 Mol의 개념을 가지고 오는 것이 편리하다. 사용의 편리를 위해 이상기체 방정식을 Mol에 대해 정리한 후 위의 혼합기체에서의 두 법칙을 적용해보면, (아래첨자 m은 total을 의미한다.) i번째 기체의 분압은, 분적과 같으며, 몰수 비와 같아진다.이 특징을 이용하여 기존 Property를 몰수 비를 활용하여 나타낼 수 있다.",
        
        "url": "/cs/dynamics/2020/10/02/Thermodynamics-05-Gas-Mixture-Pressure.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-thermodynamics-04-gas-mixture-property-html": {
        "title": "04: 혼합기체 물성치 (Gas Mixture Property)",
        "tags": "Dynamics, Thermodynamics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Gas Mixture Property이 다음에 사용할 혼합기체의 property를 정의하기 위한 방법이 정의되어 있는 포스팅이다. 혼합하기 전 두 기체의 Property와 혼합한 기체간의 property의 관계를 알아보자.",
        
        "url": "/cs/dynamics/2020/10/02/Thermodynamics-04-Gas-Mixture-Property.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-thermodynamics-03-maxwell-relations-html": {
        "title": "03: 맥스웰 관계식 &amp; 클라페이롱 식 (Maxwell Relations &amp; Clapeyron Equation)",
        "tags": "Dynamics, Thermodynamics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Maxwell RelationsTotal Derivative 의 성질을 사용한다. 4가지 Equation에서 이 성질을 사용하는데, 그 종류는 다음과 같다.  내부에너지 U(T,V)  엔탈피(Enthalpy) H(T, P)  헬름홀츠 방정식 (Helmholtz) A(T, V)  깁스 방정식 (Gibbs Equation) G(T, P)The Clapeyron Equation상변화할 때 압력과 온도를 가지고 h_fg 나 v_fg를 추정할 수 있다. Vapor일 때, 몇가지 가정을 추가해서 온도와 압력으로 h_fg를 구할 수 있다. 이 방정식을 The Clausius-Clapeyron Equation이라 한다.",
        
        "url": "/cs/dynamics/2020/10/02/Thermodynamics-03-Maxwell-Relations.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-thermodynamics-02-heat-engine-html": {
        "title": "02: 열기관과 냉동 사이클 (Heat Engine &amp; Refrigerator Cycles)",
        "tags": "Dynamics, Thermodynamics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Power Cycle(Engine) vs Refrigeration Cycle  방향이 반대다!  Engine (시계 방향) : 일을 생산          액체 압력 높힘 (Pump) -&gt; 액체에서 기체로(고압) (Boiler) -&gt; 기체 압력 낮춤 (Turbine) -&gt; 기체에서 액체로 (Condenser)        Refrigeration Cycle (반시계 방향) : 열을 제거, 공급 (Refrigerator, Heat Pump)          액체에서 기체로(저압) (Evaporator) -&gt; 기체 압력 높힘 (Compressor) -&gt; 기체에서 액체로(고압) (Condenser) -&gt; 액체 압력 낮춤 (Turbine or Throttling Valve)      Vapor-compression Refrigeneration Cycle  반대 방향으로 진행되는 수정된 Rankine Cycle(Vapor Power Cycle)기존의 Rankine Cycle을 반대로 운행시키면 된다. 그런데 여기서, 터빈을 사용하지 않고 Throttling Valve를 사용한다. Sat.liquid 상태에서 터빈을 돌리고 나면 Mixture상태가 된다. 즉 터빈이 운행하는 동안에 한가지 phase가 아니게 되어 효율이 감소한다. 일을 생산할 수는 있겠지만 전체적으로 보았을 때 이득이 아니다. 단가문제도 있다.  Problem          원래 Turbine을 사용할 때는 Internally reversible 이었지만, 밸브로 변경하는 바람에 내적으로 비가역인 과정이다.      근본적으로 Heat Pump와 Refrigerator는 목적이 다를 뿐 원리는 동일하기 때문에, 중간에 밸브를 끼워넣어 모드를 변경할 수 있다.Exergy Transfer엑서지란 특정 계의 상태가 환경의 상태까지 갔을 때 할 수 있는 잠재일 양이다.그 System이 Closed, Open 일 때 엑서지는 다음과 같이 나타낼 수 있다.그렇다면 이 계의 엑서지의 변화를 만들어내는 요인은 무엇이 있을까. 내가 특정 계를 잡았을 때, 이 시스템에 작용할 수 있는 에너지의 형태는, 열, 일, 질량이동 이 세가지 이다. 그런데 System에 이 세가지 형태의 엑서지가 전달이 곧 시스템의 엑서지 변화로 변하지 않는다. 열에 의한 엑서지 이동은 엔트로피 Term과 관련이 있는데, 엔트로피 증가의 원리 (특정 System의 엔트로피 변화량은 Sin와 Sout 이외에 생성되는 엔트로피 항을 더해야 함)에 의해, 생성되는 엔트로피항에 대응되는 엑서지 파괴량을 빼주어야 한다.2nd Law Efficiency2법칙 효율은 쉽게 말해 System에서 할 수 있는 최대에너지 (엑서지 양) 대비 실제로 한 나온 에너지양이다.이 설명은 엑서지 소비양 대비 엑서지 회복 양과도 같다.Compressor1-&gt;2 과정, 압축기는 이상적으로 등엔트로피 과정이다. 이 때 1점과 2점을 비교하면, 질량변화(열전달 X, 환경에 해주는 일 말고 유용일 X) 밖에 없다. 즉, 1,2 점의 변화로 부터 얻어낼 수 있는 에너지 양은, 엔탈피만 변화했으므로 h2 - h1 이다. 실제로 이 과정에서 생기는 에너지 양은 엔트로피 생성으로 인한 항을 빼주어야 한다. 1,2지점에서 계의 엔트로피 변화는 없으므로, 2점에서 1점의 엔트로피를 빼준 것이 Sgen이 될 것이다.Condenser2-&gt;3 과정, 콘덴서를 System으로 잡았을 때, 이 계의 엑서지 변화량은 X2 - X3로 나타낼 수 있다. 이 과정에서 들어온 에너지의 형태는 열이다. 환경의 온도와 계에 들어온 온도와의 관계만큼의 열이 들어오므로 카르노 사이클 효율을 곱하여 나타 낸다. 이 과정동안 변화하는 계의 엔트로피양은 Qh/Th 이다. 이 계의 엔트로피 양은, 2에서의 엔트로피에서 3에서의 엔트로피를 뺀것에 Sgen을 더해주면 된다. 따라서 Sgen은 아래와 같이 표현될 것이다.Expansion Valve3-&gt;4 과정 계의 엑서지 변화는 X3-X4로 나타내어 질 것이다. 계의 속도변화와 위치차가 없고 valve는 h3 = h4이므로 엔트로피항만 살아남을 것이다. 그 과정 이후 실제로 회복된 에너지는 없다. 따라서 2법칙 효율은 0이다.Evaporator4-&gt;1과정 엑서지 변화는 X4-X1로 나타낼 수 있다. 이 과정에서 실제로 회복된 에너지는 열의 형태이다. Sgen으로도 동일하게 엔트로피 증가의 법칙을 사용해서 구할 수 있다.결과적으로 총합을 구해서 정리하게 되면 결국 사이클 전체에 대해 2법칙 효율은, 가역적 과정에서의 사이클 COP대비 실제 COP비율이다.",
        
        "url": "/cs/dynamics/2020/10/02/Thermodynamics-02-Heat-engine.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-thermodynamics-01-vapor-power-cycle-html": {
        "title": "01: 증기 원동 사이클 (Vapor Power Cycle)",
        "tags": "Dynamics, Thermodynamics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Vapor Power Cycle열역학에서 가장 먼저 다루는 사이클은 카르노 사이클이다. 이 사이클 내에서 효율이 극대화 되기 때문에 가장 이상적인 사이클이기 때문이다. (가역과정일때) 하지만 이것을 현실화하기는 매우 어렵다.가정Turbine과 Compressor 안에는 2개 이상의 phase인 유체가 들어가는 것은 좋지 않다. 부식 발생, 효율적이지 못하기 때문이다.Power Cycle의 주 사용이유는 많은 일을 생산하기 위함이다. 그러기 위해서는 Tmax가 높아야하는데, 카르노 사이클은 근본적으로 그러기 힘들다.Rankin Cycle  Ideal cycle for capor power cycles카르노 사이클의 단점을 보안한 이상적인 사이클  Process          등엔트로피 압축(Compressor) -&gt; 등압 팽창(Boiler) -&gt; 등엔트로피 수축(Turbine) -&gt; 등압 수축(Condenser)        Efficiency          카르노 사이클 보다 낮은 효율 (내적 가역과정이라 하더라도 외적 비가역성이 생김)      Ideal cycle vs Acutal cycle  Irreversiblility  마찰로 인한 압력 강하  열 손실로 인한 온도 저하The way of making cycle more Efficient  Condensor의 압력을 낮춘다.          Problem : Turbine에 습기가 많아져 부식이 생길 수 있다.        Tmax를 높힌다. 열을 더 추가한다.          Problem : 무한정 높힐 수 있는게 아니다. 터빈이 견딜 수 있는 온도까지만 높힐 수 있다.        높은 압력에서 Heating한다.          Problem : Turbine에 습기가 많아져 부식이 생길 수 있다.        REHEATING          터빈을 두개를 달고 온도를 높히는 장치를 하나 더 달아버린다.                  Open Feed Water Heating                          기존에 데우는 유체와 다시 데우려는 유체를 섞어서 운행.                          Closed Feed Water Heating                                기존에 데우는 유체와 다시 데우려는 유체가 서로 열교환만 한다.                    ",
        
        "url": "/cs/dynamics/2020/10/02/Thermodynamics-01-Vapor-Power-Cycle.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-14-eb-b6-88-ec-99-84-ec-a0-84-ec-83-81-ec-82-ac-html": {
        "title": "14: 불완전 상사 (Incomplete Similarity)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "앞에서 완전상사가 되기 위해서는 3가지 조건을 만족해야 한다고 했다. 이 중 한가지 조건이라도 맞지 않을 경우 불완전상사라고 한다. 너무 작은 스케일에서 실험을 하려고 할 때 보통 발생한다.",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-14-%EB%B6%88%EC%99%84%EC%A0%84%EC%83%81%EC%82%AC.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-13-eb-b3-80-ec-88-98-eb-b0-98-eb-b3-b5-eb-b2-95-html": {
        "title": "13: 변수반복법 (Dimension Analysis - Method of Repeating Variables)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "본격적으로 차원해석에 대해 알아보자. 차원해석은 변수반복법 이라는 것을 사용하는데, 반복법인 이유는 과정중에 변수를 선택하게 되는데, 이 변수로 차원을 재정렬하고 난 뒤의 변수를 반복해서 쓰기 때문이다. (이라는 뇌피셜이다. 정확하게 설명이 안나와있다 어디에도,,)사실 책에는 어떤 물리현상을 기술하는 식을 모르는 상태에서 매개변수를 정하고 차원해석을 사용하면 지배방정식을 구할 수 있다. 이런 입장이지만 사실 물리학적 직관이 없다면 변수선정에 있어 이미 지고들어가는 선택이다..",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-13-%EB%B3%80%EC%88%98%EB%B0%98%EB%B3%B5%EB%B2%95.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-12-ec-b0-a8-ec-9b-90-ed-95-b4-ec-84-9d-html": {
        "title": "12: 차원해석 개론 (Introduction of Dimensional Analysis)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "차원해석은 무차원수에 대한 내용이다.왜 무차원화를 하는가?  실험을 할 때에 여러가지 변수에 연관된 식을 소수의 변수를 이용한 식으로 변환하여 진행할 수 있기 때문  또 차원해석을 함으로써 나오는 무차원수는 시스템에 대한 직관적인 통찰을 갖게 해준다.  그리고 결정적으로 이 무차원화를 한 식은 스케일링이 된 식이기 때문에 우리가 프로토타입으로 실험을 하지 않고 이를 축소한 사이즈나, 다른 공간을 사용한 곳에서 실험을 진행하여 원래 값을 도출할 수 있다.그런데 이 축소(상사 similarity)를 하기 위해서는 몇가지 조건이 필요하다.상식적인 내용이지만 이 3가지의 원칙이 적용되지 않을 때 근사를 하든, 다른 방법을 모색해야 되기 때문에 완전상사인지 꼭 확인해야한다.  기하학적 상사          길이비가 모두 일정한 비율을 가져야 한다.        운동학적 상사          프로토타입에서 특정 포인트의 속도는 모형에서 속도와 비례관계가 있어야 한다.        역학적 상사          대응되는 힘에서도 비례관계가 있어야 한다.      이 세가지 조건을 만족했을 때, 완전상사 (Complete Similarity) 라 한다.",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-12-%EC%B0%A8%EC%9B%90%ED%95%B4%EC%84%9D.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-11-ec-9c-a0-eb-9f-89-ec-b8-a1-ec-a0-95-eb-b2-95-html": {
        "title": "11: 유량 측정법 (Flow Rate Velocity Measurement)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "유량을 측정하는 방법에 대한 얘기다. 지금까지 배운내용을 바탕으로 적용하는 것이므로 긴설명은 생략하도록 하겠다.",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-11-%EC%9C%A0%EB%9F%89%EC%B8%A1%EC%A0%95%EB%B2%95.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-10-ed-8c-8c-ec-9d-b4-ed-94-84-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-ed-8e-8c-ed-94-84-ec-84-a0-ed-83-9d-html": {
        "title": "10: 파이프 연결망(네트워크) &amp; 펌프선택 (Piping Network &amp;Pump Selection)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "우리가 관을 매개로 한 시스템을 구성했을 때, 두 가지의 손실이 발생한다고 배웠다. 주손실과 부손실이 그것인데, 우리는 여기서 회로도와 관 네트워크의 유사성을 알 수 있다. 유동을 일으키는 압력은 전압과, 그에 따르는 유량은 전류와, 이를 방해하는 손실을 저항과 대응할 수 있을 것이다.그렇다면 총 옴의 법칙과 같이 이 값도 대응이 될 것이다. 또한 회로에서 직렬, 병렬 개념도 같게 대응이 될 것이다.자, 그런데 유체는 일정한 압력차가 있어야 고정된 유량으로 계속 흐를 수 있다. 하지만 현실을 유체가 흐름에 따라 해당위치에서 압력(수두)는 감소한다. 초기부터 엄청나게 큰 P를 파이프 입구에서 주면 되겠지만 현실적으로 힘들다. 따라서 중간에 압력을 추가적으로 가해 유량을 증가시키는 행위가 필요하다. 이것이 펌프! 먼저 펌프의 원리와, 각각의 펌프가 갖는 효율을 구해보자.결과적으로 펌프의 효율은 전기에너지가 축에너지로 바뀔때, 축에너지가 펌프로 전해지면 유체를 가속시킬 때의 효율과 연관이 있다.그렇다면 시스템과 펌프사이에서 어떤 펌프를 고르는 것이 가장 효율적일까? 첫번째로 펌프자체가 갖는 압력과 유량의 관계가 있을 것이다. 예를 들어 h만큼의 수두를 제공할 수 있는 펌프가 있다고 하자. 그런데 펌프의 양쪽의 inlet, outlet이 막혀있다. 그렇다면 펌프가 하는 일은 모두 해당 포인트에서 압력을 높히는데 사용될 것이다. 만약 적당량의 유체가 흐르면, h만큼의 수두에서 유체를 흐르게 하는 양만큼의 수두가 감소하고 나머지는 여전히 압력을 증가시킬 것이다. 즉, 펌프의 입장에서 봤을 때, 수두와 압력간에는 일종의 -정비례 관계가 있다. 엄밀하게 알아보기 위해 간단한 유도를 해보자.다음과 같이 빨간 실선이 펌프의 압력손실, 즉, 유량을 생기게 한 양이다. 자, 그러면 펌프가 정해졌을 때, 수두와 유량간의 관계는 알았다. 그럼 이 펌프의 수두량은 어떻게 구해질까? (죄송합니다. 샤프트 일은 아래 식이 맞습니다.)내부에너지 항과 열항을 한데 묶어 역학적 손실항이라 한다. 아까 전체 식을 질량속도로 나누었으므로 여기서 W항은 w로 단위질량당 일이 된다. (이는 곧 압력이다! 밑에 유도식을 보자) w_pump를 구해보자.아! 펌프의 수두량은 로스항과 높이차로 구할 수 있다. 이렇게 펌프 수두를 구할 수 있다. 펌프 수두를 계산할 때 높이차를 감안하고 생각하면 쉽다는 얘기이다. 시스템에서 원하는 압력차는 기존에 배웠던 주손실 식을 사용하면 구할 수 있다. 이 두그래프의 교점이 최적의 펌프를 선택하는 방법이다.",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-10-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%8E%8C%ED%94%84%EC%84%A0%ED%83%9D.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-09-eb-b6-80-ec-86-90-ec-8b-a4-ec-9c-a0-eb-8f-99-eb-b0-95-eb-a6-ac-html": {
        "title": "09: 부손실 &amp; 유동 박리 (Minor Loss &amp; Flow Separation)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "주손실은 이미 공부했고, 이번에는 부손실에 대해 공부해보자. 부손실은 입구영역에서 발생하는 것도 포함하지만 더 주가 되는 유동박리에 의해서 일어난다. 유동이 관을 타고 지나갈 때, 관의 형태 때문에 부차적으로 생기는 손실을 의미한다. 낮은 속도에서 유체가 장애물을 지나갈 때는 만나는 면에서 유체의 초기속도가 작기 때문에벽면에서 속도 = 0, 그 바로위에서 속도가 작으므로 변화율도 작다점성응력(마찰이다 사실) 이 작다. 그래서 끝면 까지 갈 수 있다. 그런데 빠른속도 일 경우 점성응력이 매우커진다. 그렇게 되면 끝점까지 가기전에 속도가 0이 되는 지점이 생기고 유체가 떨어져 나간다. 이 때, 역방향으로 작용하는 압력차를 역압력 구배(adverse pressure gradient) 라 한다.여기서 골프공이 움푹파인 이유를 알 수 있다. 움푹파이게 되면 표면적이 넓어져 점성효과가 커져 더 빨리 박리가 일어날 것 같지만 구멍은 거칠기 역할을 한다!! 거칠기가 커지게 되면 유체는 더 난류유동으로 운동하며 난류유동의 특징인 높은 관성효과, 즉 난류유동을 일으켜 압력 회복이 좋기 때문에 더 멀리 날아간다. 주손실과 부손실을 합친 항을 전체 손실이라 한다",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-09-%EB%B6%80%EC%86%90%EC%8B%A4-%EC%9C%A0%EB%8F%99%EB%B0%95%EB%A6%AC.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-08-eb-ac-b4-eb-94-94-ec-b0-a8-ed-8a-b8-html": {
        "title": "08: 무디 차트 (Moddy Chart &amp; Colebrook Equation)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "무디 차트는 압력강하식에서 사용되는 f의 정체이다. 파이프에서 이 식은로 정의되었었지만 사실 그렇게 만만하지 않다. 왜냐하면 레이놀즈 수에서 배웠지만 이 레이놀즈 수는 정해진 수가 아니기 때문이다. 유체가 운동하는 방향에 따라 변한다. 저 수는 유체가 측류라 가정했을 때 도출되는 식이다. 그렇다면 어떻게 해야되는가? 파이프를 예로 들었을 때, 벽면으로부터 중심부로 갈수록 유체의 레이놀즈 수는 커진다.에서 속도가 빨라지기 때문이다. 속도가 빨라지면 어떤 문제가 생기냐 난류유동이 생긴다.(후…) 그렇기 때문에 이건 간단한 문제가 아니다. 따라서 우리는 유동이 흐를때 어디까지를 층류로 보고 난류로 볼건지 또, 어떤 특징 때문에 그렇게 되는지를 분명하게 알 필요가 있다. 즉, 측류와 난류를 간단하게 구분해보면,  유체의 특징상 Re의 태생은 정해져 있기 때문에 이놈이 더 난류처럼 움직일지, 층류처럼 움직일지는 알 수 있다.  하지만 추가적으로 운동하게 되면 난류효과는 어떤 유체든 커질 수 밖에 없다.  이 복잡한 것을 하나로 만들어 놓은 것이 무디 차트이다.  벽면에서는 파이프의 매끄러움, 즉 거칠기의 영향을 받는다.  유체가 파이프를 운동할 때 벽면에서는 층류처럼 행동하는 경향이 있는데, 레이놀즈 수가 작은 층류는 이 층의 두께가 두껍고 레이놀즈 수가 큰 난류는 이 층의 두께가 얇다.  층류가 벽면에 작용할 때는 이 거칠기가 유동에 영향을 끼치지 않는다. 하지만 층류의 두께가 얇게 되면 이 거칠기를 무시하지 못한다.  즉 두께가 상대적으로 얇은 난류에서는 이 거칠기에 따라 유동이 변화한다.  따라서 그 때 f는 Re, 거칠기의 함수이다.  f값에 따라 압력강하가 달라진다.Colebrook Equation는 f를 수식적으로 구할 수 있는 식이다. 자, 그러면 여러개의 property가 주어졌을 때, 압력강하를 어떻게 구할 수 있는지 3가지 유형을 정리했다. 2번째, 3번째 방법은, 반복계산법을 통해서 해를 유추하는 방법으로 구한다.",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-08-%EB%AC%B4%EB%94%94%EC%B0%A8%ED%8A%B8.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-07-eb-82-9c-eb-a5-98-ec-9c-a0-eb-8f-99-html": {
        "title": "07: 난류 유동 (Tubulent Flow)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-07-%EB%82%9C%EB%A5%98%EC%9C%A0%EB%8F%99.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-06-ec-9e-85-ea-b5-ac-ec-98-81-ec-97-ad-html": {
        "title": "06: 입구영역, 입구유동 (Entrance Region or Entrance Flow)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "지금까지는 유동 양상에 대해 공부한 것은 외력의 합이 0이 되는 상황에서만 공부했다. 그렇다면 실제로 처음 유동이 이동할 때는 어떤 모습으로 생기는지 알아보자. 이 유동이 생기는 부분을 입구영역이라고 한다.입구영역에서는 직관적으로 알 수 있듯이 같은 속도를 유지하며 유동을 주기 위해서 Fully developed 상황보다 더 많은 압력차를 가해야한다. 그래서 이 추가적인 압력 손실 때문에 이 부분은 부손실과 많은 관련이 있다.입구영역의 가장 핵심은 유체가 갑작스럽게 관에 들어오게 되면서 벽면효과 때문에 벽에서 속도가 0이 된다는 점이다. 처음 들어올 때, 속도 변화가 가장 크게 발생하기 때문에 이 부분에서 점성력 타우가 가장 클 것이다.자. 그렇다면 입구영역에서 압력강하가 얼마나 일어날 지 수식적으로 간단하게 증명해보자.먼저, 입구영역에서의 전단응력이 크기 때문에 더 많은 압력차가 필요할 것이다.그런데 이 압력강하 외에도 추가적인 압력차가 필요하다.유체 흐름에서 중앙에서는 점성효과를 받지 않으므로 베르누이 정리를 사용할 수 있다. 밑의 상황에서는 높이차가 없는 상황이지만 1점과 2점의 속도차가 발생하고 있는 상황이기에 필연적으로 1지점과 2지점의 압력은 달라야 한다. 이 속도차까지도 만들어야 되기 때문에 위에 서술한 커진 타우의 영향보다 더 큰 압력차가 필요하다.",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-06-%EC%9E%85%EA%B5%AC%EC%98%81%EC%97%AD.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-05-eb-a0-88-ec-9d-b4-eb-86-80-ec-a6-88-ec-88-98-html": {
        "title": "05: 레이놀즈 수 유도  (Derive Reynolds Number)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "이번에는 레이놀즈 수를 유도하는 방법을 알아볼 것이다. 레이놀즈 수는 유체의 특징을 알려주는 무차원 수이다. 유체가 압력항에 영향을 크게 받는지, 점성항에 크게 받지를 직관적으로 알 수 있게 만든 수이다. 이 개념을 알기 위해서는 무차원 수를 알아야 하지만 난류의 이해를 위해서는 레이놀즈 수부터 알고 가는 것이 좋기에 먼저 설명하려고 한다.레이놀즈 수는 점성계수처럼 딱 정해진 숫자라고 보기 힘들다. 밀도, 속도, 길이, 점성 이 4가지의 조합으로 이루어져 있기에 상황에 따라 변한다.밑의 예시로 든 담배연기같은 경우도 그렇다. 처음에는 고르게 올라가다가 어느순간부터 연기는 퍼진다.퍼지는 이유는 여러가지 요인이 있지만 유체가 난류의 형태로 변화했기 때문이다. 무차원수에 대해는 나중에 배우고 이번에는 그냥 받아들이면서 유도과정을 보자.여기서 왼쪽항은 ma, 즉 관성에 의해 운동하는 항을 의미한다.이 앞의 계수는 이 관성효과를 대변하는 수가 된다.반대로 점성항 앞에 있는 계수항은 점성효과를 대변한다.이 두 항의 비율이 곧 레이놀즈 수이다.무차원화 하는 이유에 관해서는 다음 포스팅에서 설명하도록 하겠다.이 무차원 식을 기반으로 저번 포스팅에서 유도했던 Polar system에서 파이프 속도 양상을 구해보자.각각 다른 파이프지만 이렇게 Scaling을 한 뒤 일반화를 해놓게 되면, 특정 파이프의 특징에 따라 대입만하게 되면 값이 바로 도출 된다.그럼 이번에는 파이프에서 압력강하를 구해보자. 파이프에서 평균속도와 압력과의 관계로 부터 레이놀즈 수를 사용하여 압력차를 식으로 유도해보자.이렇게 도출한 식은 내가 특정한 파이프에 압력차를 주었을 때, 이 압력차에 해당하는 동압이 얼마나 생길지 알게 해준다. 거기서 영향을 주는 변수는 f, L,D 이다. (마지막은 잘못 적었다.)앞에서 본 파이프에서 압력강하는 fully developed 상황에서 이루어 진다. 만약 이 파이프에서 일정한 속도로 유체를 이동시켜야 한다고 하면 그만큼의 정압을 줘야한다는 의미가 된다. 반대로 말하면 그정도의 압력이 손실된다. 그래서 이 부분은 주손실과 관련이 있다.",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-05-%EB%A0%88%EC%9D%B4%EB%86%80%EC%A6%88-%EC%88%98.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-04-eb-a0-88-ec-9d-b4-eb-86-80-ec-a6-88-ec-88-98-ec-86-a1-ec-a0-95-eb-a6-ac-html": {
        "title": "04: 레이놀즈 수송정리와 나비에 스톡스 방정식 관계 (The Relation of Reynolds Transform Theorem &amp; Navier-Stokes Equation)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "이번에는 B = mV일 때의 RTT와 나비에 스톡스 방정식이 어떻게 연결되는지 알아보려고 한다! 벡터 표기법이 난무하고 텐서의 개념이 등장하지만 잘 따라온다면 이해할 수 있다!",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-04-%EB%A0%88%EC%9D%B4%EB%86%80%EC%A6%88-%EC%88%98%EC%86%A1%EC%A0%95%EB%A6%AC.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-03-pipe-flow-html": {
        "title": "03: 파이프 유동 &amp; 내부유동 (Pipe Flow &amp; Internal Flow)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "파이프란 단면적이 원형인 유로를 의미한다. 왜 굳이 원형을 가지고 파이프라고 명명했을까?  고루 퍼진 원의 특성상 응력집중이 생기지 않는다.  단면적 대비 둘레가 가장 작은 도형이라 점성력 효과를 최소로 줄일 수 있다,  또한 단가도 최대로 줄일 수 있다.덕트란 단면적이 사각형인 유로를 말한다. 보통 점성효과의 영향이 작을 때, 설치의 간편함 때문에 사용하는 경우가 많다.이전 글에서는 Couette flow와 duct에서의 유동 양상을 공부했다. 이번에는 파이프에서 유동의 양상을 알아볼 것이다. 그전에 단면이 원이기 때문에 Cartesian 좌표계보다 polar 좌표계를 사용하는 것이 더 효율적일 것이다. duct에서와 마찬가지로 Fully developed 상황을 가정하고 알아보자.Cartesian 좌표계에서는 위와 같다. 이 상태에서 Polar로 바꾸는 것은 힘드므로, Fully Developed에서는 위에서와 같이 외력이 0인 특징을 이용해서 파이프에서 속도 양상을 알아보자.으로 부터, 타우에 대해 정리 할 수 있다.다음과 같이 구해진다.덕트와 파이프의 양상을 비교해보면, 전체유량을 구할 떄, 속도에 대한 함수 외에도 r항이 곱해져 있기 때문에 벽면 근처로 갈수록 유량이 흐르는 폭이 증가한다. 그렇기 때문에 벽면효과를 더 많이 받는다. 결과적으로 벽면에 흐르는 유량이 많이 못 흐르는 결과를 가져오기 때문에 중앙부분에서 이 유량을 커버해야 한다.위에서 보듯 중앙에서 흘러야 하는 유량의 크기가 1.5에서 2로 증가했다. 앞에서 배운 Couette flow와 Duct, pipe의 속도 양상에 대한 식을 정리하면 다음과 같다.",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-03-pipe-flow.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-02-velocity-profile-html": {
        "title": "02: 완전발달유동에서 속도 윤곽 (Velocity Profile in Fully Developed Flow)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "완전 발달 유동이란 위치 변화에 따라 유동의 모양이 변화하지 않는 유동을 의미한다. 즉 x에 대한 편미분 값이 0이라는 의미이다. 이 경우 속도의 모양이 어떻게 이루어져 있는지 유도해보도록 하자.가정  2D  incompressible  μ is constant  steady  No gravity압력과 전단력에 의한 힘 이외에 외력이 없으므로 나비에 스톡스 방정식에서 시작한다. 가정에 따라 없어지는 항들을 체크한다.우리는 완전발달 유동 상황에서 속도 함수를 구하기 위함이므로, 완전 발단 유동의 특징을 식에 추가해준다.신기하게도 이 가정을 연속 방정식에 넣게되면이 만들어 진다.다 정리하면 x축에 대해서 미분방정식이 하나,y축으로도 미분방정식이 하나가 나온다. 이 때 y축에 대한 미분방정식으로 부터 완전발달유동일 때, y축으로의 압력변화는 없다는 것을 알 수 있다. 이제 경우를 나눠서 속도 윤곽을 알아보자.  Couette Flow (with no pressure difference)  Couette Flow (with pressure difference)  Square area Pipe",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-02-Velocity-Profile.html"
      }
      ,
    
      "cs-dynamics-2020-10-02-fluid-mechanics-01-ec-97-b0-ec-86-8d-eb-b0-a9-ec-a0-95-ec-8b-9d-html": {
        "title": "01: 연속 방정식 &amp; 나비에-스톡스 방정식 (Continuity Equation &amp; Navier-Stokes Equation)",
        "tags": "Dynamics, Fluid Mechanics",
        "date": "October 2, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Continuity Equation연속 방정식은 질량보존법칙을 오일러 표현으로 나타내 었을 때 어떤 모양이 되는지를 설명해주는 식이다. 라그랑지언 표현을 오일러 표현으로 바꾸어주는 RTT를 사용해 미소 면적을 표현해보자. 미소면적의 중앙에서 모든 Property의 값을 갖는다고 가정했을 때, 상하좌우에서 Property의 값은 테일러 급수를 통해 값을 근사해서 나타낼 수 있다. (1계 미분까지만 표현한 것은 2계미분 항부터는 너무 크기가 작아 무시할 수 있기 때문에)이렇게 나온 식을 연속 방정식이라 부른다. 그런데 여기서 이 항을 조금더 풀게 되면 물질도함수의 모양으로 정리가 가능하다.다시 연속방정식을 이 모양으로 해석하게 되면, 특정 점에서 밀도의 시간에 따른 변화는 경계면에서의 속도의 발산(다이버전스)값에 밀도를 곱해준 것과 같다.로 해석할 수 있다. 여기서 만약 시간에 따라 밀도가 일정하다면, 즉, 특정점에서 밀도 변화가 없다면, (밀도 = 상수, 비압축성 유체)속도의 발산 값이 0, 즉 경계면에서 나가고 들어오는 양의 총합이 0, 우리가 생각하는 결과와 일치한다.Navier-Stokes Equation나비에 스톡스 방정식은 그럼 무엇인가. 뉴턴 법칙을 오일러 관점에서 서술한 식이다. net_F = m*a에서 RHS의 서술이 오일러 관점에서 어떻게 서술될 수 있는지 알 수 있다. 이를 바꿔주는 RTT에서 B = V를 대입해서 정리해보자. 마찬가지로 미소면적에 대해 정리하면,여기서 비압축성 유체(밀도 = 상수)일 경우, 첫번째 항에서 밀도가 상수로 빠져나올 수 있게 된다. 그리고 비압축성 유체의 연속방정식으로 부터, 결론적으로 미소 부피의 Total F는 밀도 * 속도에 대한 물질도함수로 나타낼 수 있다.그런데, 이 건 외력의 총합이 시스템에서 어떻게 작용하는 지에 대한, m*a에 대한 정리이고, 실제로 특정 시스템을 잡았을 때, 그 곳에 작용 할 수 있는 외력의 종류가 무엇이 있는지 정리할 필요가 있다. 우리가 가하는 힘을 제외했을 때, 자연적으로 발생하는 힘은 Body force와 Surface force로 나눌 수 있다. 그중 Body force는 쉽게 구할 수 있다.표면힘이 조금 까다로운데, 미소면적의 중앙에서 작용하는 응력을 기준으로 잡았을 때, 테일러 급수에 의해 각 면에 해당하는 응력을 구할 수 있다. 이 때, 응력에 의해 이 미소면적에 작용하는 알짜 힘은 각면에서의 응력차에 해당하는 힘이 그 역할을 하므로, 다음과 같이 구할 수 있을 것이다.만약 3차원이라면 각포인트에서 3개의 응력항이 나오고, 이것을 행렬형태로 만든것을 응력 텐서라 한다. 이것에 대해서는 다른 포스팅에서 좀더 자세하게 다루도록 하겠다.이것들을 한번에 나타내면, 외력은 라그랑지언 관점과, 오일러 관점에서 서술할 수 있다. 라그랑지언 관점은 기존의 생각하는 방식과 동일하게 작용하는 외력항을 다 더해준 형태를 말한다. 오일러 관점에서는 조금 변화되서 생각하는 것이 좋은데, 다른 구조물에 의한 외력을 제외했을 때, body force와 surface force로 생각한다. 이는 유체내에서 해석하기 좋게 하기 위해 식을 풀어 쓰는 것이다. ma항도 역시 라그랑지언 관점과, 오일러 관점에서 서술할 수 있다. 라그랑지언 관점은 ma로 해석하면 된다. 오일러 관점 은 물질도함수를 사용하여 나타내는데, 전역가속항과 국소가속항으로 나누어서 표현한다. 유체역학에서 ma항은 보통 오일러 관점으로 서술한다.뉴튼 유체, 즉 incompressible(밀도 상수)인 유체에서 나비에 스톡스 방정식을 정리해보자. 밑 부분은 사실 벡터 형태로 정리할 경우 더 직관적인 사실을 알 수 있다. 지금은 그냥 넘어가고 다음 포스팅에서 이를 알아보자.마지막으로 이 나비에 스톡스 방정식에서 베르누이 방정식을 도출할 수 있는지 알아보자. 베르누이 정리를 쓰기위한 4가지 가정을 이 식에 적용시켜야 한다.  Steady  No friction  Incompressible  Along the Streamline",
        
        "url": "/cs/dynamics/2020/10/02/Fluid-Mechanics-01-%EC%97%B0%EC%86%8D%EB%B0%A9%EC%A0%95%EC%8B%9D.html"
      }
      ,
    
      "cs-dynamics-2020-09-30-system-dynamics-08-newton-euler-algorithm-html": {
        "title": "08: Newton-Euler Equations, D'Alembert's Principle",
        "tags": "Math, Dynamics, Linear Algebra",
        "date": "September 30, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Newton Euler Equations강체를 위치를 나타낸 그림Reference point(O^i) 가 강체 i 의 질량중심에 위치해 있다고 생각하자.M은 net Moment, J는 강체의 관성모멘트, F는 net force 이다. 따라서 2차원 공간에서 작용할 수 있는 3가지 자유도에 대한 힘과 모멘트는, 질량 중심에 작용하는 3가지 Term 으로 정리된다.D’Alembert’s Principle여기서 delta r 벡터는 Virtual displacement 라 한다.Virtual Displacement  이 항은 시스템의 무한히 작은 변화를 가정했을 때 변위를 의미한다.  즉, 시간이 constant 일 때, 계의 변위를 측정한 것이다.  우리는 이것을 가상 변위라 부르는데, 실제로 시간이 상수일 때, 변위는 없기 때문이다.식을 정리하면, 다음과 같이 정리된다.D’Alembert’s Equation여기서 q_j 는 다음과 같은 것들이 될 수 있다.",
        
        "url": "/cs/dynamics/2020/09/30/System-Dynamics-08-Newton-Euler-Algorithm.html"
      }
      ,
    
      "cs-dynamics-2020-09-30-system-dynamics-07-computational-algorithm-html": {
        "title": "07: Computational Algorithm",
        "tags": "Math, Dynamics, Linear Algebra",
        "date": "September 30, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Computational AlgorithmStep 1특정 시간에 대해서 C 벡터 함수의 해를 추정한다. 즉, 초기값을 설정한다. 이 추정치는 발산하지 않도록 잘 선택해야 한다.Step 2이 추정치를 기반으로 자코비안 행렬 과 C 벡터함수의 해를 구한다.Step 3를 계산한다.Step 4를 계산한다.Step 5Step 2 ~ Step 5 를 사용자가 지정한 임계치보다 작을 때 까지 반복한다.Step 6속도 벡터를 구한다.Step 7가속도 벡터 구하기Step 8Step 1 ~ Step 7 까지 다른 t를 설정한 뒤 반복한다.",
        
        "url": "/cs/dynamics/2020/09/30/System-Dynamics-07-Computational-Algorithm.html"
      }
      ,
    
      "cs-dynamics-2020-09-30-system-dynamics-06-newton-raphson-method-html": {
        "title": "06: Newton Raphson Method",
        "tags": "Math, Dynamics, Linear Algebra",
        "date": "September 30, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Tayler Series테일러 급수는, 임의의 함수를 무한개의 다항식을 더하여 근사하는 방법이다.보통 테일러 급수는 1차 함수로 근사할 때 많이 사용한다.Newton-Rahpson method뉴턴 랍슨 메서드의 핵심은, iterative 접근이다.1변수 함수에서 Newton-Rahpson method다음과 같은 함수가 있다고 하자. 우리가 하고 싶은 것은 이 함수의 근 을 찾는 것이다. 그러기 위해서 테일러 시리즈를 사용해보자. 이 함수 f는 1차까지만 근사하면 다음과 같다.이 때, 이 근사를 시작하는 점, a를 x_i로 주면,그렇다면 이 xi로 시작해서 이 함수를 근사했으므로, 근사한 식을 0으로 만드는 것이 답이다. **이 근사된 함수로 나온 solution을 x(i+1) 이라 하자.**우리는 x_(i+1)을 찾고 싶으므로, 위의 가정들을 식에 다 집어넣으면,따라서, 우리가 원하는 x_(i+1) 은 다음과 같다.나온 x_(i+1)을 다시 a로 넣고, 이 작업을 반복하게 되면, 해 근처에 갔을 때, 델타 x가 매우 작아진다. 이 때, 우리는 해를 찾았다고 return 해준다.일반화된 Newton-Rahpson method그렇다면, 식이 2개, 변수가 2개인 벡터 함수에서는 어떻게 근사할 수 있을까?각각을 테일러 시리즈로 전개하자. 1차항 까지.우변이 0인 이유는 위에서 설명한 것과 같은 의미 이다. 우리는 0이 되는 x, y를 찾고 싶은 것이기에 근사한 식에서 함수값이 0이 될 때, x*(i+1), y*(i+1) 이 필요하다. 편미분 후 x_i, y_i를 넣는 것을 생략해서 표현하면,여기서,J를 자코비안 행렬 이라 한다.이므로 업데이트가 가능하다. 역시나 초기값 설정이 필요하다!Position Analysis이전 글에서 우리는 제약식들이 모인 벡터함수 C를 정의했다. 우리는 결국 벡터함수 C = 0 이되는 해, 즉 q 벡터를 찾는 것이 목적이다. 따라서 우리는 이 벡터 함수 C를 테일러 시리즈로 근사한 뒤 Newton-Rahpson method 를 사용해서 해를 구하자! 그러기 위해서는 벡터함수 C를 근사화 해야 한다. 테일러 시리즈를 적용하면,C 행렬은 자코비안 행렬이다. 따라서,로 q벡터를 구할 수 있다. 이를 반복하다가 특정 조건일 때, 우리는 반복을 멈추고 return 하면되는데,두 식의 의미는, 하나는 다가가는 step size이고, 두번째는 함수값의 size 차이이다.해답을 찾아가는 과정에는 다음과 같이 두가지의 기준을 세울 수 있으므로, 두 기준에 대해서 iteration을 멈춘다.Notice우리는 t가 변수가 아닌 것에 주목해야 한다. 우리는 해를 수치적으로 구할 것이기 때문이다. t가 0일 때, q벡터의 초기값을 임의로 잡고, Newton 메서드, q 구함. t가 0.01 일 때, q벡터의 초기값을 임의로 잡고, newton 메서드 , q 구함. 따라서 t는 상수로 생각하고 우리는 문제를 푼다.Velocity Analysis같은 방법으로 제약식이 주어졌을 때, 우리가 궁금한 것은 q_dot 벡터이다.이므로,Ct 벡터는 t에 대해 미분한 벡터이므로, Driving constraint 식 이외 항은 0이다. 따라서 결론적으로,이다.Acceleration Analysis제약식을 두번 미분해서, q_twodot 을 구하면 된다.결과적으로,",
        
        "url": "/cs/dynamics/2020/09/30/System-Dynamics-06-Newton-Raphson-Method.html"
      }
      ,
    
      "cs-dynamics-2020-09-30-system-dynamics-05-ea-b8-b0-ea-b5-ac-ed-95-99-ec-a0-81-ec-a0-9c-ec-95-bd-html": {
        "title": "05: 기구학적 제약",
        "tags": "Math, Dynamics, Linear Algebra",
        "date": "September 30, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "기구학적인 joint 들은 각자가 가지는 특징 때문에, 기구학적으로 제약을 갖는다. 이 제약은 결국 시스템의 자유도를 구속하게 된다.Ground2차원 공간에서 기본적으로 가지는 자유도는 3이다. 이때, 특정 포인트를 내가 지면으로 잡는다면,이렇게 3개의 제약이 걸리게 된다.Revolute joint특정 포인트에 Revolute joint가 달리게 될 경우, 회전만 가능하고, 두 body 사이에 연결된 revolute joint는 하나만을 가리켜야 한다.Global coordinate 에서 표현한다고 했을 때, 따라서 body 1에서 가리키는 revolute joint의 벡터와 body 2에서 가리키는 revolute joint의 벡터는 같아야 한다.따라서 2개의 제약이 걸리게 된다.Prismatic jointPrismatic joint는 한방향의 병진운동만 가능하게 하는 joint이다. 따라서 2개의 제약식이 만들어질 것임을 예상할 수 있다.두 body 사이에 prismatic joint가 연결되어 있다면, global coordinate에서 봤을 때 정의된 두 body coordinate 의 초기 상대각도는 constant 로 유지된다.또한 prismatic 의 경우, 두 바디 사이의 각이 항상 수직이다. 따라서 움직이는 방향 벡터와 수직으로 연결된 body의 벡터를 내적하면 항상 0이다. 따라서 2개의 제약이 걸리게 된다.Moblility Criteria역학 시스템을 분석하기 위한 가장 기본적인 단계는, 계의 자유도를 구하는 것이다.2D 에서 구하는 방법은 다음과 같다.3D 에서 구하는 방법은 다음과 같다.Driving Constraint시스템의 자유도가 0 인 경우 우리는 추가적인 제약식을 만들 필요가 없다. 하지만 자유도가 0이 아닌 정수인 경우. 우리는 추가적인 제약식이 있어야 연립방정식을 풀 수 있다. 이 때 주어지는 제약식을 Driving Constraint 라 한다.예제DOF 구하기BODY  Ground  bar1  bar23 x 3 = 9Constraint  Ground : 3  Revoulte joint 1 : 2  Revolute joint 2 : 23 + 2 + 2 = 7ResultSystem DOF = 9 - 7 = 2결과적으로 우리는 theta2, theta3 에 관해 자유롭다. 따라서 이 시스템의 기구학적 특성을 살펴보기 위해서는 이 두 요소에 대한 Driving Constraint 가 필요하다.위 두가지 제약으로 부터,O로 표현된 각은 초기 각이다.제약식 나타내기각 constraint condition 으로 부터 도출되는 식은, system body에서 결정되는 coordinate 변수의 종류 안에서 결정된다.총 9개의 식이 나오고, 이 각각을 C_1, C_2.. 스칼라 함수라고 한다면, 총 9개의 스칼라 함수를 가지는 벡터함수 C는,위와 같다. 그런데 각각의 스칼라 함수 안에 들어가는 함수는, 삼각함수로 표현되기 일쑤기 때문에 Non-linear 하다. 따라서 우리는 저 행렬식을 푸는데 있어 다른 방법을 생각해야 한다.To solve nonlinear function  Bisection method  Golden Section method  Newton-Raphson method  secant method우리는 여기서 Newton-Rahpson Method를 사용해 보겠다.",
        
        "url": "/cs/dynamics/2020/09/30/System-Dynamics-05-%EA%B8%B0%EA%B5%AC%ED%95%99%EC%A0%81-%EC%A0%9C%EC%95%BD.html"
      }
      ,
    
      "cs-dynamics-2020-09-30-system-dynamics-04-ed-8f-89-eb-a9-b4-ec-97-90-ec-84-9c-ec-9d-98-ea-b8-b0-ea-b5-ac-ed-95-99-html": {
        "title": "04: 평면에서의 기구학",
        "tags": "Math, Dynamics, Linear Algebra",
        "date": "September 30, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "좌표계의 회전 변환i번째에서 정의된 좌표계는, 내가 원하는 global 좌표계에서 좌표로 다음과 같은 관계를 갖는다.이 행렬을 A라 정의하자.위치 벡터의 표현다음과 같이 global 좌표계가 있고, 특정 body에서 정의된 좌표계가 있을 때, 우리는 이 두 좌표계를 변환할 필요가 있다. global 좌표계에서 body의 움직임을 알고 싶다. 강체라 가정하고, body의 좌표계에서 중심점이 되는 곳을 우리는 reference point 라 부른다. 또 그곳에서 정의되는 좌표계를 body frame, local coordinate 라 한다. 그리고 global 좌표계의 중심이 되는 곳을 reference frame 이라 부를 것이다. 이 두좌표계를 변환하는 관계식은 다음과 같다.이 표기법을 말로 정의해보면, global 좌표계에서 표현된 p점의 벡터 는, reference point까지의 벡터 와 reference point로 부터 global 좌표계에서 표현된 특정 위치의 벡터 를 더한 것이다. 라는 의미이다. 이 때, reference point로 부터 global 좌표계에서 표현된 특정 위치의 벡터는 local coordinate 로 부터 global coordinate 로 회전 변환 한 것이므로,여기서 맨 오른쪽에 표현된 term은, local coordinate에서 표현된 특정 좌표이다.속도 벡터의 표현위치벡터를 미분하면, 얻을 수 있다.여기서 의미를 파악해보면, 시간에 흐름에 따라, Rigid body assumption 에 의해 local coordinate 안에서 p점의 속도는 0이다. 따라서 마지막 항은 0이다.여기서 행렬 미분을 생각해보면, A는 theta 만의 함수이므로 이녀석을 시간 t에 대해 미분하면, chain rule 에 의해,이렇게 표현되고, A를 theta에 대해 미분한 행렬은,Transform to Cross product form결과적으로, 강체에서 속도 벡터는,2D에서 각속도 벡터는,이 때,로 정리될 수 있다. 여기서 Up 벡터는 다음과 같이 표현 될 수 있다.각속도 백터와 Up 벡터를 내적하면,이 식을 행렬식으로 표현하면,따라서,Summary결론적으로 속도 벡터는 다음과 같이 표현된다.가속도 벡터의 표현정리하면,여기서 alpha는,이다.",
        
        "url": "/cs/dynamics/2020/09/30/System-Dynamics-04-%ED%8F%89%EB%A9%B4%EC%97%90%EC%84%9C%EC%9D%98-%EA%B8%B0%EA%B5%AC%ED%95%99.html"
      }
      ,
    
      "cs-dynamics-2020-09-30-system-dynamics-03-ec-a7-81-ea-b5-90-ec-84-b1-eb-b2-a1-ed-84-b0-eb-af-b8-eb-b6-84-ec-9e-90-ec-bd-94-eb-b9-84-ec-9d-b4-eb-a1-a0-html": {
        "title": "03: Orthogonality, Vector Differentiation, Jacobi's Theorem",
        "tags": "Math, Dynamics, Linear Algebra",
        "date": "September 30, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "행렬의 종류에 대해서는 링크로 대체한다!Types of MatrixOrthogonality두 벡터를 곱했을 때 수직! 자기 자신이 나온다.자기 자신을 곱한다면 자기자신의 크기의 제곱이 나와야 한다.Orthonomality여기서는 두 벡터가 단위 벡터이다! 따라서 자기 자신을 곱했을 때, 1이 나와야 한다.사실 Orthogonal Matrix는 각 열(혹은 행) 벡터가 모두 단위 벡터일 때 정의를 만족한다!Vector DifferentiationScalar Function by Scalar이때 t에 대해 미분하면,이를 벡터 형식으로 나타내면,여기서 벡터로 표현된 녀석을 다음과 같이 표현하자.그렇다면 위의 식은 다음과 같이 정리된다.Vector Function by Scalar벡터함수 f는 각각의 요소에 변수 (q1~qn, t) 를 갖는 스칼라 함수를 m개 갖는다고 하자.그렇다면 이 함수를 스칼라 변수 t로 미분하면,각각의 요소는,그렇다면, 벡터 함수를 t로 미분한 최종 결과는,여기서 행렬이 만들어진다는 것을 잊으면 안된다! 각각의 크기만 적어보면,Scalar Function by Vector스칼라 함수를 스칼라로 미분하는 가장 위의 예에서, 함수 f를 벡터 q로 미분하면, 다음과 같다.Vector Function by Scalar벡터 함수를 스칼라로 미분하는 두번째 예에서, 벡터 함수 f를 q1으로 미분한다면,정리  스칼라 함수를 스칼라로 미분하면 스칼라함수다.  스칼라 함수를 벡터 함수로 미분하면 1xn 벡터가 나온다.  벡터 함수를 스칼라로 미분하면 1xm 벡터가 나온다.  벡터 함수를 벡터로 미분하면 nxm 행렬이 나온다.Skew-Symmetric Matrix RepresentationSkew-Symmetric Matrix는 벡터의 외적을 사용해서 다르게 표현이 가능한데, 간단한 예를 들어 생각해보자.이 두 벡터를 내적하면,외적 식을 b벡터를 활용해서 나타내면 다음과 같이 나타낼 수 있다. 이때 중간에 skew-symmetric matrix 가 나오고, a 벡터가 왼쪽에 놓인 외적을 수행했을 때 발생하는 행렬을 위와 같이 표현했다. 마찬가지로, b벡터에 대해 하면,이와 같다.Propertya 의 단위벡터와 a 벡터를 외적하면, 0이다.이 표현을 Skew-symmetric Matrix를 써서 표현하면,Skew-Symmetric Matrix 의 특징을 사용하면,역학에서 사용예시스템 내에서 역학적 Joint 에서 위치 벡터와의 관계는 다음과 같이 빈번하게 묘사된다.즉, a 벡터와 x 벡터가 수직임을 나타낸다. 수직인 벡터는 무수하게 많이 나온다는 점을 기억한 상태로 다음을 보자. Skew-symmetric Matrix를 사용해서 나타내면,a 행렬에 대해 Determinant를 구해보면, 0이다. 즉, a 행렬은 특이 행렬이다. 즉, Rank가 matrix size보다 작다. 즉, x 벡터는 하나로 결정되지 못한다.Jacobi’s TheoremDeterminant 의 성질에 의해서,이 때 n이 짝수이게 되면, 양쪽 식의 값이 동치가 되어 det(a)의 값은 부정이다.따라서 n의 값은 홀수여야 한다. 즉, Skew-symmetric Matrix의 행렬식의 값이 0이 되려면, 행렬의 size가 홀수 차원이어야 한다.",
        
        "url": "/cs/dynamics/2020/09/30/System-Dynamics-03-%EC%A7%81%EA%B5%90%EC%84%B1-%EB%B2%A1%ED%84%B0%EB%AF%B8%EB%B6%84-%EC%9E%90%EC%BD%94%EB%B9%84%EC%9D%B4%EB%A1%A0.html"
      }
      ,
    
      "cs-dynamics-2020-09-30-system-dynamics-02-ed-8f-89-eb-a9-b4-ec-97-90-ec-84-9c-eb-8b-a4-eb-ac-bc-ec-b2-b4-ea-b3-84-ec-9d-98-ec-9a-b4-eb-8f-99-ed-95-99-html": {
        "title": "02: 평면에서 다물체계의 운동학",
        "tags": "Math, Dynamics, Linear Algebra",
        "date": "September 30, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Kinematics of Planer Multibody Systems평면에 놓인 특정 물체를 나타내려면 어떻게 해야할까? 그 물체를 나타내기 위해 우리는 기준을 잡아서 설명해야 할 것이다. 즉 절대좌표 가 필요하다.먼저 물체의 질량 중심을 가리키는 좌표가 존재할 것이고, (x, y) 그리고 그 물체의 형상을 나타낼 때에 기준으로 잡은 상대좌표 가 필요하다. 이유는 물체는 위치정보 이외에도 회전에 대한 정보도 있기 때문에 이것을 표현하기 위해서는 물체기준으로 만들어진 기준이 필요하다. 즉, 절대좌표와 상대좌표가 얼마나 회전했는지에 대한 지표가 필요하다.  2D          Rx, Ry, T : 3개        3D          Rx, Ry, Rz, Tx, Ty, Tz : 6개      Degree Of Freedom계의 운동을 정확히 표현하기 위해 필요한 최소한의 좌표 수 를 자유도라 한다.좌표계의 총 개수여기서 n coordinates는 해당 시스템의 좌표의 총 개수를 의미한다. coordinates의 개수 n은, 해당 시스템의 물체수와 관련이 있다.이와 같은 시스템이 있을 때, 이 시스템을 나타내기 위해서는, 절대좌표, 또 각각의 물체에서 사용해야하는 좌표계까지 12개이다.우리는 보통 Ground를 절대좌표로 잡으며, 그렇기 때문에 이 시스템을 볼때, Ground, 크랭크, 커플러, 종동절 총 4개의 물체가 있다고 생각하고 각각의 물체가 2D에서 정의되어 있기 때문에 각각의 좌표계는 Rx, Ry, T 3개씩의 좌표가 필요하다. 따라서 12개가 총 필요한 좌표계의 수이다.구속식의 개수그런데 저 시스템의 자유도는 1이었다. 그렇다면, 1개의 좌표만이 저 시스템의 운동학적 형상을 결정짓는데 영향을 준다는 얘기인데, 다른말로 하면 제약 조건이 11개라는 소리다.그 제약조건은 어떤 것 때문에 발생할까? 각각의 물체에 연결되어 있는 Joint 때문이다. 이 시스템에서 각각의 Joint는 연결되어 있는 물체가 길이방향, 길이에 수직인 방향으로 움직이는 것을 제한하고 있다.8개의 제약이 Joint에서 발생한다. 또한, Ground는 이 시스템 전체에서 기준점 역할을 하고 있다. 위에서 3개의 좌표를 가질 수 있다고 계산은 했지만, Rx, Ry, T 각각이 상수값을 가져야 하므로, 제약 역시 세 좌표에 대해서 가지고 있다.따라서 Ground 에 대한 제약은 3이다. 결론적으로 전체 제약 조건은,11이다.DOF calculation그래서 DOF는 다음과 같이 계산할 수 있다.Types of Mechanical Joints  Prismatic Joint (Translational joint)          한 방향으로만 움직일 수 있게 만든 joint      따라서 2D 인 경우 제약 조건은 2이다.      3D 인 경우 제약 조건은 5이다.        Revolute Joint (Pin joint)          한 방향으로 회전할 수 있게 만든 joint      따라서 2D 인 경우 제약 조건은 2이다.      3D 인 경우 제약 조건은 5이다.        Cylindrical Joint          회전과 한 방향으로 움직일 수 있게 만든 joint      이 joint 경우 2D에서는 사용할 수 없다.      3D 인 경우 제약 조건은 4이다.        Spherical Joint (ball Joint)          세 방향으로 회전만 가능하게 만든 joint      따라서 2D 인 경우는 정의되지 않는다.      3D 인 경우 제약 조건은 4이다.      ",
        
        "url": "/cs/dynamics/2020/09/30/System-Dynamics-02-%ED%8F%89%EB%A9%B4%EC%97%90%EC%84%9C-%EB%8B%A4%EB%AC%BC%EC%B2%B4%EA%B3%84%EC%9D%98-%EC%9A%B4%EB%8F%99%ED%95%99.html"
      }
      ,
    
      "cs-dynamics-2020-09-30-system-dynamics-01-eb-8b-a4-eb-ac-bc-ec-b2-b4-eb-8f-99-ec-97-ad-ed-95-99-ea-b0-9c-eb-a1-a0-html": {
        "title": "01: 다물체 동역학 개론",
        "tags": "Math, Dynamics, Linear Algebra",
        "date": "September 30, 2020",
        "author": "",
        "category": "CS/Dynamics",
        "content": "Classification of Dynamics  동역학          정역학 (Statics)평형 (Equilibirium) 조건으로부터 반력을 구함 (Material Mechanics)      동역학(Dynamics)                  운동학 (kinematics)                          운동방정식 없이 가속도와 속도, 초기 위치등으로 현상을 기술하는 것을 말한다.              힘이 주어지지 않았을 때, 물체의 기하적인 특징을 분석한다.              질량에 관계 없다.              운동 방정식을 사용하지 않고 기술한다.                                운동 역학 (kinetics)                          운동 방정식을 통한 해석 방법을 말한다.              질량에 관계 있다.                                          Forward, Inverse Dynamics우리는 보통, 주어진 힘에 대한 운동을 해석하는 방법으로 동역학을 이용해 왔다. 기존의 익숙한 방법을 Forward Dynamics 라 한다. 그런데, 로보틱스 같은 분야에서는 내가 원하는 궤적 (Path)를 따라가도록 하기 위해서 가해야 하는 힘이 얼마인지를 찾는 경우가 있다. 이런 경우 사용되는 동역학의 방법을 Inverse Dynamics 라 한다.Straight, Curve운동은 직선 운동과 곡선운동으로 나눌 수 있다. 단 방향으로의 운동만 발생한다면 스칼라 로 표현가능하지만, 그렇지 않을 경우 우리는 해당 위치의 특성값을 벡터 로 표현해야 한다.Translation, Rotation일반적인 운동은 병진운동과 회전운동, 두 가지의 형태의 결합으로 발생한다. 병진운동이라 함은, 물체의 자세가 바뀌지 않는 운동을 말한다. 위에서 배운 직선운동과 곡선 운동이 이 병진운동의 카테고리 안에 들어간다. 회전운동은 물체의 자세를 변화시키는 운동을 의미한다. 우리가 실제 물체의 운동을 관찰할 경우 이 두가지의 운동의 형태의 결합으로 모든 운동을 기술할 수 있다. (강체)  병진 운동          직선 운동      곡선 운동        회전 운동Degree of Freedom (DOF)자유도(DOF)란 어떠한 물체가 움직이는 형상 (configuration)을 표현하는데 필요한 최소한의 좌표 수를 의미한다.자유도는 시간에 대해 독립적으로 계산한다. 그런데 만약에 특정 시간에 대해 시스템의 위치와 모양이 결정된다면 이 때 DOF는 0이다. 왜냐하면 시간에 대해 독립적이라 했으므로 DOF가 0이 아니라면, 어떤 시간을 잡던지 시스템의 위치와 모양은 결정될 수 없다. 그런데 특정시간에 결정된다면 DOF는 0이다.다루는 시스템의 크기가 커져, Body의 갯수가 많아지면, 각각의 body에 대한 좌표(Coordinates) 갯수는 많아지지만 이에 비례하여 DOF가 증가하지는 않는다. 그 이유는 Body들이 서로 연관되어 있기 때문인데, 자세한 것은 다음에 설명하도록 하고, 지금은 간단한 그림을 통해 직관적으로 이해하는 것을 우선으로 하자.Example system이런 시스템이 주어졌을 때, 크랭크의 각위치만 알면, 다른 링크의 형상도 계산할 수 있으므로, 자유도는 1이다. 즉, 특정 형상을 결정하기 위해 필요한 좌표의 갯수가 자유도 이다.Point mass, particle질량은 있으나 크기를 무시할 만큼 작은 물체를 질점이라고 한다. 크기가 점만큼 작기 때문에 회전운동을 고민할 필요가 없다.Rigid Body강체(rigid body)는 여러개의 질점들이 모여져 있고, 질점들 사이의 거리가 변하지 않는 물체이다. 이에 비해 탄성체는 변형에 의해 질점 사이의 거리가 변하는 물체이다. 우리는 보통 강체로 모든 물체를 가정하고 문제를 푼다. (Rigid body Assumption)",
        
        "url": "/cs/dynamics/2020/09/30/System-Dynamics-01-%EB%8B%A4%EB%AC%BC%EC%B2%B4-%EB%8F%99%EC%97%AD%ED%95%99-%EA%B0%9C%EB%A1%A0.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-13-class-html": {
        "title": "13: Class",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "클래스는 c++에서 자세히 다뤘으므로, 해당 내용에 대해 파이썬 문법만 알아보도록 하자.init, constructorclass Student:    def __init__(self, givenID, givenName):        self.id = givenID        self.name = givenName    def setId(self, givenID):        self.id = givenID    def getId(self):        return self.id    def setName(self, givenName):        self.name = givenName    def getName(self):        return self.namestudent1 = Student(20190001, \"Harry Potter\")student2 = Student(20190002, \"Hermione Granger\")print(student1.getId())print(student1.getName())print(student2.getId())print(student2.getName())20190001Harry Potter20190002Hermione Grangerstr()기본적으로 내가 만든 클래스의 모든 내용을 알아볼 수 있게 관용적으로 만들어주는 함수이다.class Student:    def __init__(self, givenID, givenName):        self.id = givenID        self.name = givenName    def setId(self, givenID):        self.id = givenID    def getId(self):        return self.id    def setName(self, givenName):        self.name = givenName    def getName(self):        return self.name    def __str__(self):        msg = \"id:{}, name:{}\".format(self.id, self.name)        return msgstudent1 = Student(20190001, \"Harry Potter\")student2 = Student(20190002, \"Hermione Granger\")print(student1.getId())print(student1.getName())print(student2.getId())print(student2.getName())20190001Harry Potter20190002Hermione Grangerid:20190002, name:Hermione Granger클래스 변수class Student:    # Class variables    countStudent = 0    def __init__(self, givenID, givenName):        # Instance (or Object) variables        self.id = givenID        self.name = givenName        Student.countStudent = Student.countStudent + 1    def setId(self, givenID):        self.id = givenID    def getId(self):        return self.id    def setName(self, givenName):        self.name = givenName    def getName(self):        return self.name    def __str__(self):        msg = \"id:{}, name:{}\".format(self.id, self.name)        return msg    def getNumOfStudent():        return Student.countStudentprint(Student.getNumOfStudent())student1 = Student(20190001, \"Harry Potter\")student2 = Student(20190002, \"Hermione Granger\")print(student1)print(student2)print(Student.getNumOfStudent())20190001Harry Potter20190002Hermione Grangerid:20190002, name:Hermione Granger22Private Attribute클래스를 설계할 때, 사람이 변수에 접근하는데 있어서 직접적인 접근을 막고 싶다! 이 때 c++ 에서는 private 를 사용했는데, 여기서는 좀더 직관적으로 변수에 __ 를 추가해주면 된다.class Student:    # Class variables    __countStudent = 0    def __init__(self, givenID, givenName):        # Instance (or Object) variables        self.__id = givenID        self.__name = givenName        Student.__countStudent = Student.__countStudent + 1    def setId(self, givenID):        self.__id = givenID    def getId(self):        return self.__id    def setName(self, givenName):        self.__name = givenName    def getName(self):        return self.__name    def __str__(self):        msg = \"id:{}, name:{}\".format(self.__id, self.__name)        return msg    def getNumOfStudent():        return Student.__countStudentstudent1 = Student(20190001, \"Harry Potter\")student2 = Student(20190002, \"Hermione Granger\")print(student1.getId())print(student1.getName())print(student2.getId())print(student2.getName())print(student2.__str__())print(Student.getNumOfStudent())print(Student.getNumOfStudent())print(Student.__countStudent)---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-15-949f5d70643a&gt; in &lt;module&gt;     43 print(Student.getNumOfStudent())     44---&gt; 45 print(Student.__countStudent)AttributeError: type object 'Student' has no attribute '__countStudent'내가 직접적으로 __countStudent 에 접근했기 때문에 에러가 뜬다.상속상속받는 방법을 알아보자!class GraduatedStudent(Student):    def __init__(self, givenId, givenName, givenYear):        self.__graduatedYear = givenYear        super().__init__(givenId, givenName)    def __str__(self):        msg = super().__str__() + \", graduation:{}\".format(self.__graduatedYear)        return msgstudent1 = GraduatedStudent(20190001, \"Harry Potter\", 2023)print(student1)id:20190001, name:Harry Potter, graduation:2023super() 함수가 굉장히 신기한데, 바로 상속받은 클래스에 접근할 수 있는 메서드이다.has-a Relationship특정 클래스를 포함하는 클래스가 있을 수 있다. 부모자식 관계처럼 피를 나누지는 않아도 묶어놓을 수는 있다.class Department:    def __init__(self):        memberStudent = Student()memberStudent 를 __init__ 함수안에 변수로 선언해주면 된다.Exerciseinputdata1.csv 와 inputdata2.csv 를 입력으로 받아서 sample.csv와 같은 형태로 결과를 만드는 프로그램을 작성해라.myFile 클래스를 만들어서 풀이해라.inputdata1.csvID,Name20190001,Apple20190003,Pear20190002,Orangeinputdata2.csvID,Class1,Class2,Class320190003,90,90,9820190002,45,12,3720190009,10,10,1020190001,89,92,35sample.csvID,Name,Course 1,Course 2,Course 3,Average20190001,Apple,89,92,35,7220190002,Orange,45,12,37,3120190003,Pear,90,90,98,92풀이# ANSWER : STARTimport csvclass myFile:    def __init__(self, fileName = None, fileMode = None):        self.__fileName = fileName        self.__fileMode = fileMode        self.__fileList = []        if self.__fileMode == \"r\" and self.__fileName != None:            self.file = open(self.__fileName, self.__fileMode)            read_file = csv.reader(self.file)            for line in read_file:                self.__fileList.append(line)            self.__fileList[1:] = sorted(self.__fileList[1:])        elif self.__fileMode == \"w\" and self.__fileName != \"\":            self.file = open(self.__fileName, self.__fileMode)    def getStatus(self):        if self.__fileList != [] or self.__fileMode == \"w\":            return True        else:            print(\"파일이 열리지 않았음 status = false\")            return False    def getBody(self):        if self.getStatus() == True:            return self.__fileList[1:]        else:            print(\"파일이 열리지 않아 body 출력이 불가합니다.\")            return False    def setContentHead(self,fileHeader = None):        if self.getStatus() == True and fileHeader != None:            self.__fileHeader = fileHeader            return True        else:            print(\"fileHeader 가 주어지지 않았거나, 파일이 열리지 않았습니다.\")            return False    def setContentBody(self, fileContent = None):        if self.getStatus() == True and fileContent != None:            self.__fileContent = fileContent            return True        else:            print(\"fileContent 가 주어지지 않았거나, 파일이 열리지 않았습니다.\")            return False    def writeFile(self):        if self.getStatus() == True:            myWriter = csv.writer(self.file)            myWriter.writerow(self.__fileHeader)            for i in range(len(self.__fileContent)):                myWriter.writerow(self.__fileContent[i])            return True        else:            print(\"파일이 열리지 않았습니다.\")            return False    def closeFile(self):        if self.getStatus() == True:            self.file.close()            return True        else:            print(\"파일이 열리지 않았습니다.\")            return Falsedef mergeList(li1, li2):    result = []    temp = []    for i in range(len(li1)):        for j in range(len(li2)):            if li1[i][0] == li2[j][0]:                temp = []                temp.append(li1[i][0])                temp.append(li1[i][1])                temp.append(li2[j][1])                temp.append(li2[j][2])                temp.append(li2[j][3])                sum = 0                for k in range(1,4):                    sum = sum + int(li2[j][k])                temp.append(str(int(sum/3)))                result.append(temp)    result = sorted(result)    return result# ANSWER : ENDfile1 = myFile(\"inputdata1.csv\", 'r')file2 = myFile(\"inputdata2.csv\", 'r')if (file1.getStatus() != False) and (file2.getStatus() != False):    newList = mergeList(file1.getBody(), file2.getBody())    file3 = myFile(\"output.csv\", 'w')    file3.setContentHead([\"ID\", \"Name\", \"Course 1\", \"Course 2\", \"Course 3\", \"Average\"])    file3.setContentBody(newList)    file3.writeFile()    file3.closeFile()else:    print(\"input file error\")file1.closeFile()file2.closeFile()",
        
        "url": "/dv/python/2020/09/29/python-basic-13-Class.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-12-other-data-types-html": {
        "title": "12: Other Data Types",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "지금까지 배운 데이터 타입은 정수, 실수, boolean, 문자열, list 였다. 그런데 정수, 실수는 단순한 데이터 타입이므로, 결국 여러 정보를 넣을 수 있는 것은 String, List이다. 그런데 String은 입력할 때에 숫자와 문자를 섞어 넣을 수 있지만, 요소에 접근해 수정할 수 없으므로 우리가 여러 정보를 넣어 처리할 수 있는 것은 리스트가 전부다. 파이썬은 이런 목적에 맞는 다양한 데이터 타입을 제공한다.Summary            Collection      Mutable      Ordered      Duplication      Notation      Description      Empty Collection                  string      no      yes      yes      [ ]      “simple string”      s = ‘’ or s = “”              list      yes      yes      yes      [ ]      [ [“item0_0”, 12 ], [“item1_0”, 22 ] ]      l = []              tuple      no      yes      yes      ( )      ( [“item0_0”, 12 ], [“item1_0”, 22 ] )      t = ()              set      yes      no      no      { }      { 1, 2, 3, 4, 5 }      S = set()              dictionary      yes      no      no      { }      { ‘one’ : 1, ‘two’ : 2, ‘three’ : 3 }      d = {}      Setset은 정렬되지 않은 수학의 집합과 동일한 개념의 데이터 타입으로서, 중복된 값을 가질 수 없다. 아래의 예제에서 exSet1은 set의 규칙에 제대로 부합하는 경우 이지만, exSet2는 중복된 아이템(‘p’)이 섞여 있는 것을 볼 수 있다. 따라서 실제 아래의 코드를 실행해 보면, exSet2에는 Python이 알아서 중복된 값을 하나 제거한 것을 알 수 있다.Example 1exSet1 = { 1, 2, 3, 4, 5 }print(exSet1)exSet2 = { 'a', 'p', 'p', 'l', 'e' }print(exSet2){1, 2, 3, 4, 5}{'l', 'p', 'a', 'e'}Example 2# 빈 집합 만들기aSet = set()print(\"(a)\", aSet)# List를 input으로 넣었을 때bSet = set([1,2,3,4,5])print(\"(b)\", bSet)# 집합을 input으로 넣었을 때cSet = set({1,3,5,7,9})print(\"(c)\", cSet)# range 함수를 넣었을 때dSet = set(range(5))print(\"(d)\", dSet)# tuple을 넣었을 때eSet = set((2,4,6,8,10))print(\"(e)\", eSet)(a) set()(b) {1, 2, 3, 4, 5}(c) {1, 3, 5, 7, 9}(d) {1, 2, 3, 4, 5}(e) {2, 4, 6, 8, 10}집합 연산집합을 정의했다면 당연히 연산도 가능할 것이다.            연산자      수학 기호      Python 문법                         합집합(union)      $A \\cup B$      A.union(B) 혹은 A $      $ B              교집합(intersection)      $A \\cap B$      A.intersection(B) 혹은 A &amp; B                     차집합(difference)      $A - B$      A.difference(B) 혹은 A - B                     상위집합(superset)      $A \\supseteq B$      A.issuperset(B) 혹은 A &gt;= B                     부분집합(subset)      $A \\subseteq B$      A.issubset(B) 혹은 A &lt;= B             aSet = {1,2,3,4,5}bSet = {1,2,4,8,16}# 원소 추가aSet.add(6)print(aSet)# 원소 제거aSet.remove(6)print(aSet)# 합, 교, 차print(aSet | bSet)print(aSet &amp; bSet)print(aSet - bSet)print(aSet.union(bSet))print(aSet.intersection(bSet))print(aSet.difference(bSet))# 상위, 하위print(aSet &gt;= bSet)print(aSet &lt;= bSet)print(aSet &gt;= (aSet - bSet)){1, 2, 3, 4, 5, 6}{1, 2, 3, 4, 5}{1, 2, 3, 4, 5, 8, 16}{1, 2, 4}{3, 5}{1, 2, 3, 4, 5, 8, 16}{1, 2, 4}{3, 5}FalseFalseTrueTupletuple는 여러 부분 리스트와 매우 유사한데, 가장 큰 차이점은 tuple의 아이템은 변경이 불가(immutable)하다는 점이다.tempTuple = (1,2,3,4,5)print(tempTuple)type(tempTuple)(1, 2, 3, 4, 5)tuple인덱싱과 슬라이싱은 리스트와 비슷하다. 다만 주의해야 하는 점이 있다.요소가 하나 있는 튜플 만들기튜플에 선언에 있어 ()를 사용하고 있기 때문에 (8)과 같이 선언을 할경우 파이썬은 괄호를 연산자 라 판단한다. 따라서 우리가 하나의 튜플 요소를 선언할 경우 (8,) 다음과 같이 명확히 알려주는 문법을 사용해야 한다.notTuple = (8)print(\"[notTuple]\", notTuple, type(notTuple))minTuple = (8,)print(\"[minTuple]\", minTuple, type(minTuple))[notTuple] 8 &lt;class 'int'&gt;[minTuple] (8,) &lt;class 'tuple'&gt;튜플 안에 리스트튜플은 기본적으로 수정이 불가하다고 생각하지만, 만약 튜플 안에 리스트 가 있다면 리스트 내의 요소를 바꿀 수 있다.sampleList = ([\"Python\", 'B'], [\"C++\", 'B'])# 튜플 안 리스트의 요소를 바꾸고 있으므로 가능하다.sampleList[0][1] = 'A'# 튜플의 요소를 바꾸고 있으므로 불가능 하다.sampleList[0] = [\"Python\", 'B'] # Erron in this statementDictionaryKey - Value 의 형태로 저장되어 있는 자료형이다.  Key 는 변할 수 없다.  Value는 변할 수 있다.선언 방법 / Value 접근# 선언author = {\"python\" : \"person1\", \"c++\" : \"person2\"}# 접근author[\"python\"]# 삭제del author[\"python\"]# 추가author[\"python\"] = \"person1\"for item in author:    print(item, \"is designed by \", author[item])c++ is designed by  person2python is designed by  person1실습Example 1(a) 다음과 같이 list 하나는 프로그래밍 언어를, 다른 list는 언어의 개발자 이름을 갖도록 선언합니다.language = [\"python\", \"c++\", \"javascript\", \"go\"]author = [\"Guido van Rossum\", \"Bjarne Stroustrup\", \"Brendan Eich\", \"Robert Griesemer\"](b) 함수 matingPairs()를 만드는데, 입력 파라메타로 위의 두 리스트를 받아서, 결과롤 set 타입을 돌려줍니다.(c) 함수 matingPairs()는 두 리스트에서 각각 하나의 값을 꺼내서 언어 이름별 저자의 tuple을 만든 후,(d) 함수 matingPairs() 안의 내부 변수인 set 타입 데이터 타입에 (c)에서 만든 tuple을 아이템으로 추가해 줍니다.(e) 모든 언어에 대한 저자 매핑과, 이를 set에 넣는 과정을 마치면, 함수 matingPairs()은 결과값으로 set를 돌려줍니다.(f) 함수 matingPairs()의 결과값을 화면에 출력합니다.language = [\"python\", \"c++\", \"javascript\", \"go\"]author = [\"Guido van Rossum\", \"Bjarne Stroustrup\", \"Brendan Eich\", \"Robert Griesemer\"]def matingPairs(array1, array2):    result_set = set()    for i in range(len(array1)):        temp_tuple = (array1[i], array2[i])        result_set.add(temp_tuple)    return result_setmatingPairs(language, author){('c++', 'Bjarne Stroustrup'), ('go', 'Robert Griesemer'), ('javascript', 'Brendan Eich'), ('python', 'Guido van Rossum')}Example 2다음의 요구 사항에 맞는 프로그램을 개발하여 아래의 입력창을 통해서 실행합니다.(a) dictionary의 key는 유일해야 하지만 value는 유일하지 않아도 됩니다.(b) count_values() 라는 이름의 함수를 구현합니다.(c) count_values() 함수는 하나의 dictionary를 입력 파라메타로 받아서, 이 dictionary가 포함한 서로 다른 value의 개수를 반환합니다.(d) 예를 들어, {'red': 1, 'green': 1, 'blue': 2}가 입력 파라메타로 전달되면, 2를 반환합니다.def count_values(dic):    set_dic = set()    for item in dic:        set_dic.add(dic[item])    return len(set_dic)dic = {'red' : 1, 'green' : 1, 'blue' : 2}count_values(dic)2",
        
        "url": "/dv/python/2020/09/29/python-basic-12-Other-Data-Types.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-11-file-html": {
        "title": "11: File",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "컴퓨터를 통한 문제 해결을 위해서 우리는 정수, 실수, 문자열 등을 프로그램 실행중에 만들어서 사용하였다. 하지만 실제 큰 프로그램들은 수시간 수년동안 쌓여진 데이터를 취급하는 목적으로 사용하며, 이 경우 컴퓨터의 전원이 꺼져도 유지되는 디스크의 화일 사용은 필수적이다.파일 열기, 닫기Python과 같은 프로그래밍 언어에서는 화일을 열고 닫는 문법을 제공하는데, 연 화일은 반드시 닫아야 한다. 열기만 하고 닫지 않은 화일은 프로그램의 동작시에 작업한 내용이 제대로 반영이 안되거나, 최악의 경우는 화일에 오류가 생겨서 사용이 불가할 수도 있다. Python에서 화일을 여는 문법은 open() 함수이다. 반대로 닫는 문법은 close() 함수이다.file = open('filename.csv', 'r')file.close()두번째 파라미터는, 파일을 여는 용도를 의미한다. 'r'은 read-only를 의미하여, 읽기만 하고 수정은 불가능하게 하겠다는 의미이다. 자세한 사용법은, Input and Output 여기에 가보자.파일 통째로 읽기file = open('filename.csv', 'r')contents = file.read()file.close()read() 함수를 사용하면 연 파일에 대한 모든 내용을 받아올 수 있다.with 문으로 파일 열기, 닫기close() 를 까먹는 경우가 있기 때문에 with문을 사용해서 파일을 열고 닫을 수 있다.with open('filename.csv', 'r') as file:    contents = file.read()ID,Python,C++,Javascript,Go20190001,A,A,A,A20190002,A,B,A,C20190003,C,B,C,A파일 한 줄씩 읽기화일 안의 데이터를 의미있게 사용하려면, 화일의 내용을 한줄씩 읽어서 프로그래밍을 하기 용이한 형태도 바꾸는 것이 일반적이다.filename.csv도 자세히 살펴보면, 2차원 테이블 형태로, 한줄을 여러 5개의 아이템이 있는 리스트 모양으로 볼 수 있다.따라서 Python 안에서 아이템을 5개 갖는 리스트들의 집합(List in Lists)으로 보면 의미있게 처리가 가능하다.with 문 이용fileMatrix = []with open('filename.csv', 'r') as file:    for lineContent in file: # Point.1        fileMatrix.append(lineContent.strip('\\n').split(',')) # Point.2print(fileMatrix)[['ID', 'Python', 'C++', 'Javascript', 'Go'], ['20190001', 'A', 'A', 'A', 'A'], ['20190002', 'A', 'B', 'A', 'C'], ['20190003', 'C', 'B', 'C', 'A']]Point.1로 명시한 부분은 앞서 for 반복문에서 사용한 문법와 유사한 의미를 갖는데, file에서 한줄씩 읽어서 lineContent 문자열에 넣는다는 의미이다. 기본적으로 이 문법을 사용하면, \\n 을 기준으로 한줄 씩 가져온다. Point.2 를 보면,lineContent.strip('\\n')은 화일에서 읽은 한줄에서 '\\n'를 제거하겠다는 의미이다. 이는 텍스트 파일에서 줄이 바뀌는 부분에서 줄 바꿈 특수 기호인 '\\n'이 삽입되는데, 이는 데이터의 원래 의미와 상관 없으니 제거한다는 의미이다..split(',')은 '\\n'이 제거된 줄에서, 다시 , 기호를 기준으로 나눈뒤 리스트에 넣어 반환하라는 코드이다. 이렇게 함으로써 화일의 20190001,A,A,A,A는 결국 다섯개의 아이템을 갖는 리스트로 변합니다.이렇게 만들어진 리스트를 다시 fileMatrix 리스트의 요소로 하나씩 넣는다.Default open(), close() 이용위의 코드를 open, close를 이용하면 다음과 같다.fileMatrix = []file = open('filename.csv', 'r')lineContent = file.readline()while lineContent != '':    fileMatrix.append(lineContent.strip('\\n').split(','))    lineContent = file.readline()print(fileMatrix)file.close()[['ID', 'Python', 'C++', 'Javascript', 'Go'], ['20190001', 'A', 'A', 'A', 'A'], ['20190002', 'A', 'B', 'A', 'C'], ['20190003', 'C', 'B', 'C', 'A']]여기서 알 수 있는 점은,  아무것도 없는 줄을 가져오면 빈 string 이다.  이 값을 기준으로 제어해야 한다.  또 readline() 함수를 호출하면 그 다음줄을 읽어 온다.기존 파일에 추가하기기존 파일에 추가하기 위해서는 open 할 때, 두번째 입력 파라미터에 a 를 줘야한다. append 의 약자이다.이 때, 파일을 쓰는 것이니 w 를 쓰면 큰일 난다. 컴퓨터는 단순하기 때문에 파일 이름에 해당 하는 파일을 그냥 써버린다 이 얘기가 뭐냐면 덮어쓴다 는 이야기이다. 어떠한 경고도 없이 덮어써 버린다. 따라서 우리는 주의할 필요가 있다.with open('filename.csv', 'r') as file:    contents = file.read()print(\"[Before append]\")print(contents)with open('filename.csv', 'a') as file: # Point.1    file.write(\"20190004,B,B,B,B\\n\") # Point.2with open('filename.csv', 'r') as file:    contents = file.read()print(\"[After append]\")print(contents)[Before append]ID,Python,C++,Javascript,Go20190001,A,A,A,A20190002,A,B,A,C20190003,C,B,C,A[After append]ID,Python,C++,Javascript,Go20190001,A,A,A,A20190002,A,B,A,C20190003,C,B,C,A20190004,B,B,B,B파일 쓰기위의 예에서 본 파일은 사실 잘 보게 되면, 학번, 그리고 언어에 대한 성적을 의미하고 있다. 여기서 우리가 HTML, CSS 에 대한 추가적인 성적역시 나타내고 싶다. 아직 시험을 치르지 않았으므로 공란으로 두고 싶다면, 우리는 지금까지 배운 것으로 해결 할 수 없다. 왜냐면 우리는 추가하는 방법에 있어 마지막에 추가하는 것만 배웠기 때문이다. 따라서 우리는 기존 파일을 읽어와 추가적인 작업을 하고, 다시 이녀석을 파일에 넣어줄 필요가 있다. 이 때 필요한 것이 파일 쓰기 이다.import csv# 위의 예에서 파일을 string으로 부터 list로 만들어 다룰 수 있게 했다.# 그런데 파일을 내가 쓰려면, 다시 list로 부터 string으로 만든뒤 넣어줘야 한다.# 그 작업이 너무 귀찮다.. 그래서 이 라이브러리를 import하고 함수를 가져다 쓰자.fileMatrix = []# 파일을 리스트로 정리해줄 큰 녀석을 만들자.with open('filename', 'r') as fileRead:    for lineContent in fileRead:        fileMatrix.append(lineContent.strip('\\n').split(','))# fileMatrix에 내가 원하는 파일을 리스트 형태로 정리해 두자.# 이렇게 csv 라이브러리를 사용해서 나타낼 수 도 있다.#with open('Step_13_SampleFile_score.csv', 'r') as fileRead:#    fileReader = csv.reader(fileRead)#    for line in fileReader:#        fileMatrix.append(line)print(\"[Before]\")print(fileMatrix)fileMatrix[0].extend([\"HTML5\", \"CSS3\"])# Array 원소자체를 추가한다.# Array상태로 추가하는 것이 아님lenFileMatrix = len(fileMatrix)# fileMatrix Array의 크기를 가져온다.for i in range(lenFileMatrix - 1):    i = i + 1    fileMatrix[i].extend([\"_\", \"_\"])# 아직 성적이 입력이 안되어 있으므로, 다 초기화 해준다.print(\"[After]\")print(fileMatrix)with open('Step_13_SampleFile_newScore.csv', 'w') as fileWrite:    myWriter = csv.writer(fileWrite)    for i in range(lenFileMatrix):        myWriter.writerow(fileMatrix[i])    # 여기서 csv 라이브러리를 가져온 이유가 나온다.    # 먼저, 내가 쓸 파일을 'w' 로 연다.    # 그리고 그 객체를 csv.writer 라는 객체의 input으로 주고,    # 해당 객체를 mywriter라는 이름으로 받는다.    # 이제 내가 만들었던, fileMatrix array의 요소요소들을 써줘야 한다.    # for 문을 돌면서, 아까 만들었던 myWriter 객체의 writerow 객체의 input으로    # 배열을 넣어준다.['ID', 'Python', 'C++', 'Javascript', 'Go']['20190001', 'A', 'A', 'A', 'A']['20190002', 'A', 'B', 'A', 'C']['20190003', 'C', 'B', 'C', 'A']['20190004', 'B', 'B', 'B', 'B'][Before][['ID', 'Python', 'C++', 'Javascript', 'Go'], ['20190001', 'A', 'A', 'A', 'A'], ['20190002', 'A', 'B', 'A', 'C'], ['20190003', 'C', 'B', 'C', 'A'], ['20190004', 'B', 'B', 'B', 'B']][After][['ID', 'Python', 'C++', 'Javascript', 'Go', 'HTML5', 'CSS3'], ['20190001', 'A', 'A', 'A', 'A', '_', '_'], ['20190002', 'A', 'B', 'A', 'C', '_', '_'], ['20190003', 'C', 'B', 'C', 'A', '_', '_'], ['20190004', 'B', 'B', 'B', 'B',  '_', '_']]주석 없는 소스코드import csvfileMatrix = []with open('SampleFile.csv', 'r') as myfile:    read_file = csv.reader(myfile)    for line in read_file:        fileMatrix.append(line)print(\"[Before]\")print(fileMatrix)lenfileMatrix = len(fileMatrix)for i in (1, lenfileMatrix-1):    fileMatrix[i].extend([\"_\", \"_\"])print(\"[After]\")print(fileMatrix)with open('SampleFile_new.csv', 'w') as newfile:    write_file = csv.writer(newfile)    for i in range(lenfileMatrix):        write_file.writerow(fileMatrix[i])",
        
        "url": "/dv/python/2020/09/29/python-basic-11-File.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-10-loop-html": {
        "title": "10: Loop",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "컴퓨터를 통하여 문제를 해결하는 가장 중요한 이유 중에는 계속적으로 반복하는 작업을 컴퓨터가 대신 처리하여 주는 것이다. 이런 기능을 반복문이라고 하며, 대부분의 프로그래밍 언어는 다양한 반복문을 제공한다.forfor i in [1,2,3,4,5,6,7,8,9]:    print(i, end = \"  \")&gt;&gt; 1  2  3  4  5  6  7  8  9range()  range(limit): 0에서 limit - 1까지를, 1씩 증가하는 형태의 값으로 돌려 준다.  range(start, end): start에서 end까지를, 1씩 증가하는 형태의 값으로 돌려 준다.  range(start, end, step): start에서 end까지의 값을 돌려 주는데, 숫자의 증가폭을 step만큼으로 한다.Exampleprint(\"Case.1\")for i in range(3) :    print(i, end = \"  \")print(\"\")print(\"Case.2\")for i in range(1,3) :    print(i, end = \"  \")print(\"\")print(\"Case.3\")for i in range(0,10,2) :    print(i, end = \"  \")print(\"\")print(\"Case.4\")for i in range(10,0,-2) :    print(i, end = \"  \")OutputCase.10  1  2Case.21  2Case.30  2  4  6  8Case.410  8  6  4  2Whilefor 와 while의 차이점# for statementfor i in [1,2,3,4,5,6,7,8,9] :    print(i)# while statementi = 1while i &lt;= 9 :    print(i)    i = i + 1두 구문은 같은 명령을 수행한다.무한 루프왜 만들죠? 무한 반복하여 작업을 수행하다가, 특정 조건이 발생하는 경우에 반복문을 멈추거나, 아니면 사용자가 특정입력을 주는 경우 반복을 멈추기 위해서 사용한다.무한루프는 다음과 같이 만들 수 있다.i = 0while True:    i = i + 1    print(i end = \" \")그렇다면 특정 조건이 나왔을 때 탈출하는 문법은 무엇일까?break특정 조건에서 무한 루프를 탈출 시키기 위해 위의 코드를 바꿔주자.i = 0while True :    i = i + 1    print(i, end = \" \")    if(i == 10):        breakContinue반복문을 수행하는 경우 특정 조건은 pass하고 나머지 조건에 대해서는 기존 작업을 계속하도록 하는 것이다. 이때 continue 라는 문법을 사용한다. 사용하게 되면 반복문의 처음으로 돌아가서 수행을 계속하게 된다. i 가 짝수인 경우 출력을 하지만 그렇지 않은 경우 넘기는 코드를 보자.i = 0while True :    i = i + 1    if i % 2 == 0:        print(i, end = \" \")        if(i == 100): #NEW.1            break #NEW.2    else:        continue2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100Lab제대로 된 구구단 프로그램 완성하기이제 우리는 다양한 방법으로 제대로된 구구단 프로그램을 완성할 수 있는 단계로 왔다. calcGugudan() 함수를 사용하지 않고 다음 처럼 List in Lists의 형태로 구구단의 결과를 저장하고 출력 할 수 있는 프로그램을 만들어 보자.출력 예시Output['  1  ', '  2  ', '  3  ', '  4  ', '  5  ', '  6  ', '  7  ', '  8  ', '  9  ']['  2  ', '  4  ', '  6  ', '  8  ', '  10 ', '  12 ', '  14 ', '  16 ', '  18 ']['  3  ', '  6  ', '  9  ', '  12 ', '  15 ', '  18 ', '  21 ', '  24 ', '  27 ']['  4  ', '  8  ', '  12 ', '  16 ', '  20 ', '  24 ', '  28 ', '  32 ', '  36 ']['  5  ', '  10 ', '  15 ', '  20 ', '  25 ', '  30 ', '  35 ', '  40 ', '  45 ']['  6  ', '  12 ', '  18 ', '  24 ', '  30 ', '  36 ', '  42 ', '  48 ', '  54 ']['  7  ', '  14 ', '  21 ', '  28 ', '  35 ', '  42 ', '  49 ', '  56 ', '  63 ']['  8  ', '  16 ', '  24 ', '  32 ', '  40 ', '  48 ', '  56 ', '  64 ', '  72 ']['  9  ', '  18 ', '  27 ', '  36 ', '  45 ', '  54 ', '  63 ', '  72 ', '  81 ']Gugudan = []for i in range(1,10):    temp = []    for j in range(1,10):        temp.append(' {} '.format(i*j))    Gugudan.append(temp)    temp = []Gugudan사용자가 입력한 숫자보다 작은 숫자로 리스트 만들기다음의 요구 사항에 맞는 프로그램을 개발하여 아래의 입력창을 통해서 실행합니다.  리스트 a가 [1,2,1,8,9,4,2,5,1,3]로 초기화 되어 있습니다.  사용자로부터 정수 하나를 입력받습니다.  리스트 a의 아이템 중 사용자가 입력한 숫자보다 작은 숫자를 모두 출력하는 프로그램을 구현합니다.  이때, 출력할 숫자를 하나씩 출력하지 말고, 해당되는 숫자들을 모아 새로운 list를 만들어서 그 list를 출력하게 합니다.a = [1,2,1,8,9,4,2,5,1,3]int_input =  int(input(\"입력해!! : \"))low_num_a = []for i in range(len(a)):    if (a[i] &lt;= int_input):        low_num_a.append(a[i])print(low_num_a)Output입력해!! : 3[1, 2, 1, 2, 1, 3]두 개의 리스트 병합하여 중복된 아이템이 없는 새로운 리스트 만들기다음의 요구 사항에 맞는 프로그램을 개발하여 아래의 입력창을 통해서 실행합니다.(a) 두 개의 list a와 b를 다음과 같이 정의합니다.(b) a = [1,1,2,3,5,8,13,24,34,55](c) b = [1,1,2,3,4,5,6,7,8,9,10,11,12](d) 두 list에 모두 포함되는 요소(element)를 모아서, 중복되는 요소가 없는 새로운 리스트 c를 만든 후, 결과를 출력합니다.a = [1,1,2,3,5,8,13,24,34,55]b = [1,1,2,3,4,5,6,7,8,9,10,11,12]checker = []for i in range(len(a)):    if(a[i] not in checker):        checker.append(a[i])for k in range(len(b)):    if(b[k] not in checker):        checker.append(b[k])checker.sort()checkerOutput[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 24, 34, 55]숫자 추측 게임 개발하기 (1)다음의 요구 사항에 맞는 프로그램을 개발하여 아래의 입력창을 통해서 실행합니다.  1에서 9 사이의 숫자(1과 9 포함) 중 하나를 랜덤하게 생성합니다.  사용자에게 숫자를 추측하여 입력하게 하고, 입력한 수가 생성된 수보다 큰지, 작은지, 같은지를 알립니다.  사용자가 생성된 수와 같은 수를 입력할 때까지 프로그램은 끝나지 않고 반복됩니다.import random as rdcom_num = rd.randrange(1,10)while(1):    my_num = int(input(\"맞춰봐! : \"))    if (com_num &gt; my_num):        print(\"up\")    elif (com_num &lt; my_num):        print(\"down\")    else:        print(\"맞추다니.......! 내가 졌다.\")        breakOutput맞춰봐! : 3up맞춰봐! : 5down맞춰봐! : 4맞추다니.......! 내가 졌다.숫자 추측 게임 개발하기 (2)  앞서 숫자 추측 게임 개발하기 (1) 문제와 반대되는 문제입니다.  이번에는 사용자(당신)가 0에서 100 사이 숫자 중 하나를 골라 머리 속에 기억합니다.  프로그램이 그 숫자가 무엇인지 맞히도록 합니다.  프로그램이 숫자를 guess할때마다 사용자는 그 숫자가 자신이 생각한 수 보다 큰지(2), 작은지(0), 혹은 똑같은지(1) 입력합니다.  프로그램이 숫자를 맞히면 종료됩니다.from random import *start = 0end = 100while(1):    com_num = randrange(start,end)    print(\"너의 숫자는 {} 거야\".format(com_num))    updown = int(input(\"up : 2, same : 1, down : 0 = \"))    if (updown == 2):        print(\"더 큰숫자야!\")        start = com_num + 1    if (updown == 0):        print(\"더 작은 숫자야!\")        end = com_num    if (updown == 1):        print(\"잘했어!\")        breakOutput너의 숫자는 56 일거야up : 2, same : 1, down : 0 = 0더 작은 숫자야!너의 숫자는 19 일거야up : 2, same : 1, down : 0 = 2더 큰숫자야!너의 숫자는 50 일거야up : 2, same : 1, down : 0 = 1잘했어!",
        
        "url": "/dv/python/2020/09/29/python-basic-10-Loop.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-09-list-html": {
        "title": "09: List",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "지금까지, 정수, 실수 문자열을 다루는 법을 배웠다. 그런데 하나의 값 말고, 여러개를 다룰 필요가 있다면 어떡해야할까? 이런 용도를 위해 python은 리스트를 제공하고 있다. 그리고 특히 서로 다른 타입의 값과 변수 를 함께 다루면서 읽고/쓸 수 있다는 장점을 제공한다.course = [\"python\", \"javascript\", \"C++\", \"__reserved__\"]print(type(course))print(type(course[0]))&gt;&gt;&gt; &lt;class 'list'&gt;&gt;&gt;&gt; &lt;class 'str'&gt;리스트를 이렇게 선언하고 나서, 리스트 자체의 타입을 출력하면, 리스트로 요소에 접근해서 타입을 출력하면, 스트링이라고 뜬다.리스트 아이템 이해하기course = [ \"Python\", \"Javascript\", \"C++\", \"__reserved__\" ]course[3] = \"Go\"이러면 리스트 요소를 바꿀 수 있다.course[1].upper()&gt;&gt;&gt; JAVASCRIPT각 리스트 요소의 타입에 따른 메소드를 활용할 수 있다.newStr = course[1] + \" language\"&gt;&gt;&gt; Javascript language1번 요소가 str 이기 때문에 더해서 새로운 string 을 만들 수 있다.print(len(course))print(max(course))print(min(course))print(sorted(course))print(sorted(course, reverse = True))&gt;&gt;&gt; 4&gt;&gt;&gt; python&gt;&gt;&gt; C++&gt;&gt;&gt; ['C++', 'Go', 'Javascript', 'python']&gt;&gt;&gt; ['python', 'Javascript', 'Go', 'C++']&gt;&gt;&gt; ['python', 'Javascript', 'C++', 'Go', 'HTML', 'CSS3']in 연산자print(\"C\" in course)print(1 in [0,1,2,3])&gt;&gt;&gt; False&gt;&gt;&gt; True리스트 안에 해당 요소가 있는지 검사하는 연산자 이다. 매우 유용하다!List Slicing기존에 String 에서 Slicing 을 배웠는데, 비슷한 방식으로 작동한다.print(course[0:4:2])print(course[1:4:2])&gt;&gt;&gt; ['Javascript', 'C++']&gt;&gt;&gt; ['Python', 'C++']이 때 뒤에서 부터 거꾸로 불러올 수도 있는데, 이 부분을 기억해 두는 것이 중요하다.print(course[::-1])print(course[4:0:-2])&gt;&gt;&gt; ['__reserved__', 'C++', 'Javascript', 'Python']&gt;&gt;&gt; ['__reserved__', 'Javascript']시작점을 끝으로, 종료지점을 앞에 있는 인덱스로 선택하고, 맨뒤의 파라미터를 부호를 거꾸로 해서 주면 위와 같이 출력된다. 즉. 맨뒤의 파라미터는 등차수열의 공차라 생각하면 좋다.List copy, aliasing파이썬은 C++ 처럼 선언을 할 때, 계속해서 메모리 공간에 값이 저장되는 형식이 아닌, 만약 같은 값을 선언한다면 해당 변수 안에는 값이 저장되어 있는 주소를 가리키는 방식으로 작동한다. 즉, 기본적으로 Shallow copy를 기반으로 작동한다. 따라서 내가 특정 변수를 다른 변수이름으로 가져온다면 C++의 참조변수와 같은 개념으로 작동한다.course = [ \"Python\", \"Javascript\", \"C++\", \"__reserved__\" ]courseAliasing = course # Alisingprint(courseAliasing)&gt;&gt;&gt; [ \"Python\", \"Javascript\", \"C++\", \"__reserved__\" ]이 때 courseAliasing 변수는 course 변수가 작동하는 방식과 똑같이 각각의 요소를 가리키는 주소들이 묶여있는 녀석이 된다. 그런데 만약 메모리 공간에 course 안에 들어간 요소들을 메모리 공간에 똑같이 복사한 녀석이 갖고 싶다면 어떻게 해야할까? 딥카피를 하고 싶다면?courseCopy = course[:]print(courseCopy)&gt;&gt;&gt; [ \"Python\", \"Javascript\", \"C++\", \"__reserved__\" ]이렇게 써주면 된다. 즉, 슬라이싱을 하게 되면 DeepCopy 방식으로 작동 한다. 위의 두 리스트 요소의 값을 바꿔보며 차이를 확인해보자.print(\"[Before]\")print(\"course: \", course)print(\"courseAliasing: \",courseAliasing)print(\"courseCopy: \", courseCopy)courseAliasing[3] = \"CSS3\"courseCopy[3] = \"HTML5\"print(\"[After]\")print(\"course: \", course)print(\"courseAliasing: \",courseAliasing)print(\"courseCopy: \", courseCopy)courseAliasing 리스트의 값을 바꾼후, 원래 course 리스트를 출력해 보고, courseCopy 리스트의 값을 바꾼후 출력해보자.[Before]course:  ['Python', 'Javascript', 'C++', '__reserved__']courseAliasing:  ['Python', 'Javascript', 'C++', '__reserved__']courseCopy:  ['Python', 'Javascript', 'C++', '__reserved__'][After]course:  ['Python', 'Javascript', 'C++', 'CSS3']courseAliasing:  ['Python', 'Javascript', 'C++', 'CSS3']courseCopy:  ['Python', 'Javascript', 'C++', 'HTML5']courseAliasing 변수를 변화시키니 course 요소의 값도 변화했다. 그리고 courseCopy 값은 course 와 별개로 작동하는 것을 알 수 있다.입력 파라미터로의 리스트C++ 에서는 입력파라미터로 값을 넘기면, 이 값을 함수내에서 정의된 변수에 딥카피를 해서 가져온 다음 처리를 거친 후 리턴하고, 안의 지역변수들은 사라진다.하지만 파이썬은 기본적으로 c++ 에서의 참조변수로 모든 것이 돌아가기 때문에, 내가 함수의 입력변수로 리스트를 전달한 후, 함수내에서 리스트 내부를 수정/변경할 경우 함수가 끝난 후에도 여전히 리스트는 수정된 상태로 유지된다.def removeTailItem(givenList):    del givenList[-1]    print(\"[in removeTailItem] \", givenList)다음과 같이 리스트의 가장 끝값을 지우는 함수를 만들었다.course = [ \"Python\", \"Javascript\", \"C++\", \"__reserved__\" ]print(\"[Before function call] \", course)removeTailItem(course)print(\"[After function call] \", course)그리고 리스트를 만들고, 함수실행 이전과 이후의 course 리스트 변경이 되었는 지 확인해보자.[Before function call]  ['Python', 'Javascript', 'C++', '__reserved__'][in removeTailItem]  ['Python', 'Javascript', 'C++'][After function call]  ['Python', 'Javascript', 'C++']course 의 요소가 변경된 것을 알 수 있다.중첩된 리스트C++과 같이 리스트안에 요소로 리스트를 줄 수 있다. 접근하는 방법은 같으므로 생략하도록 하겠다.Method of List역시 리스트로 클래스로 구성되어 있으며, 기본적으로 제공되는 method가 있다. 꼭 필요한 것만 정리 해보면,  append() : 리스트에 아이템을 마지막에 추가함  extend() : 리스트에 주어진 리스트의 아이템을 마지막에 추가함  insert() : 리스트의 주어진 위치에 주어진 아이템을 삽입하고, 삽입된 위치의 기존 아이템은 뒤에 위치하도록 함  remove() : 리스트내에서 주어진 아이템과 동일한 아이템을 모두 제거함  count() : 리스트에서 주어진 아이템과 동일한 아이템의 갯수를 카운트함  sort() : 리스트내의 아이템을 순서대로 정렬함  reverse() : 리스트내의 아이템을 역순으로 정렬함  pop() : 리스트의 마지막 아이템을 돌려주면서, 해당 아이템을 리스트에서 제거함pop 하기course = [ \"Python\", \"Javascript\", \"C++\", \"__reserved__\" ]print(course)print(course.pop())print(course)&gt;&gt;&gt; ['Python', 'Javascript', 'C++', '__reserved__']&gt;&gt;&gt; __reserved__&gt;&gt;&gt; ['Python', 'Javascript', 'C++']정렬하기course.sort()print(course)&gt;&gt;&gt; ['C++', 'Javascript', 'Python']거꾸로 정렬하기course.sort(reverse = TRUE)print(course)&gt;&gt;&gt; ['Python', 'Javascript', 'C++']뒤에 요소 추가하기course.append(\"Go\")course.append([\"HTML5\", \"CSS3\"])print(course)&gt;&gt;&gt; ['C++', 'Javascript', 'Python']&gt;&gt;&gt; ['C++', 'Javascript', 'Python', 'Go', ['HTML5', 'CSS3']]거꾸로 출력하기course.reverse()print(course)&gt;&gt;&gt; [['HTML5', 'CSS3'], 'Go', 'Python', 'Javascript', 'C++']해당 요소 개수 출력하기print(course.count(\"C++\"))&gt;&gt;&gt; 1리스트 풀어서 추가하기course.extend([\"what\", 3, \"question\"])print(course)&gt;&gt;&gt; [['HTML5', 'CSS3'], 'Go', 'Python', 'Javascript', 'C++', 'what', 3, 'question']요소 지우기del course[0]print(course)&gt;&gt;&gt; ['Go', 'Python', 'Javascript', 'C++', 'what', 3, 'question']해당 요소의 인덱스 값 가져오기index_C = course.index('C++')print(index_C)&gt;&gt;&gt; 3삽입하기course.insert(4, love)print(course)&gt;&gt;&gt; ['Go', 'Python', 'Javascript', 'C++', 'love', 'what', 3, 'question']4번 인덱스 위치에 삽입했다.",
        
        "url": "/dv/python/2020/09/29/python-basic-09-List.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-08-class-method-html": {
        "title": "08: Class &amp; Method",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "프로그램을 개발하다 보면, Python에서 제공하는 연관된 데이터와 함수들을 묶어서 사용하면 좋겠다는 생각을 하게 된다. 모듈처럼 단순하게 하나의 화일에 물리적으로 모아 놓는 개념을 넘어서서, 데이터 값과 함수가 상호 의미적으로 연관되어 있는 의미있는 묶음을 의미한다. 이럴 경우 우리는 Class 라는 개념을 사용하게 된다.Method와 Class 개념 이해하기지금까지 배운 함수의 형태를 정리해보자.  Built-in functions : 파이썬 언어에서 기본 제공하는 함수  Functions inside modules : 모듈에 포함되어 모듈을 import 한후 사용하는 함수 (예: 모듈명.함수명())  Programmer defined functions : 프로그래머가 본인의 프로그램안에서 직접 만들어서 사용하는 함수  Method1~3 까지의 함수들은 우리가 앞에서 이미 배웠던 것들이지만 4번의 개념은 처음 들어본다.그런데, String을 배우면서 이미 이것을 활용해보았는데,sentence = 'Mary had a little lamb'sentence.count('a')&gt;&gt;&gt; 4이것이 바로 그것이다. 이 함수는 1~3의 어디도 들어가지 않는데, 이런 함수를 Method 라 부른다.위의 sentence 는 string 타입이다. 그런데 이 string 타입인 sentence 안에는 Mary had a little lamb 이라는 데이터가 있으며, 이 데이터 안에 글자를 세는 count() 와 같은 함수도 묶여있다.이렇게 데이터와 함수가 묶여있는 타입을 Class 라 부르며, Class 안의 함수들을 Method 라 한다. 이 Class 타입으로 부터 만들어진 녀석을 Object 라 한다.문자열 Class Methods 알아두기tempString = \"String..Method\"print(tempString.capitalize())print(tempString.upper())print(tempString.lower())print(tempString.center(30))print(tempString.count('.'))&gt;&gt;&gt; String..method&gt;&gt;&gt; STRING..METHOD&gt;&gt;&gt; string..method&gt;&gt;&gt;        String..Method&gt;&gt;&gt; 2format()print('{0} ate {1} apples {2}'.format('I', '3', 'yesterday'))print('{0} ate {1} apples {2}'.format('You', '5', 'at 2 pm'))print('{1} ate {0} apples {2}'.format('5', 'You', 'at 2 pm'))print('{} ate {} apples {}'.format('I', '3', 'yesterday'))import mathmyPi = math.piprint('{0} {1:.4f} '.format(2,myPi) )print('Pi rounded to {0} decimal places is {1:.5f}.'.format(4, myPi))&gt;&gt;&gt; I ate 3 apples yesterday&gt;&gt;&gt; You ate 5 apples at 2 pm&gt;&gt;&gt; You ate 5 apples at 2 pm&gt;&gt;&gt; I ate 3 apples yesterday&gt;&gt;&gt; 2 3.1416&gt;&gt;&gt; Pi rounded to 4 decimal places is 3.14159.문자열.format() 을 사용하면, 결과값의 형태를 규격화 할 수 있다.실습문자열에서 해당 문자 찾기  string method인 find()를 사용하여 ‘tomato’단어 안에 첫번째 ‘o’ 의 위치(인덱스)를 찾아내어 출력하시오.  string method인 find()를 사용하여 ‘tomato’단어 안에 두번째 ‘o’ 의 위치(인덱스)를 찾아내어 출력하시오.print(\"tomato\".find('o'))print(\"tomato\".find('o', \"tomato\".find('o')+1))print(\"tomato\".find('z'))&gt;&gt;&gt; 1&gt;&gt;&gt; 5&gt;&gt;&gt; -1find 함수의 입력 파라미터로 어디서 부터 조사할지 값을 주어주면 그 부분부터 조사한다. 만약에 없는 문자열을 찾는다면 -1 을 출력한다.",
        
        "url": "/dv/python/2020/09/29/python-basic-08-class-method.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-07-module-html": {
        "title": "07: Module",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "Python은 언어이기에 내장하는 기능들이 대부분의 프로그래머에게 필요한 필수적인 것들을 제공하고 있다. 따라서 특정 분야에서 필수적으로 필요로 하는 기능은, 분야에 제한적이기에 Python 언어에서 기본 내장하기가 어렵다. 이러한 이유로 수많은 프로그래머들은 본인이 풀고자 하는 문제에서 주요한 기능을 직접 만들고 서로 공유하는 접근을 하게 된다. 이렇게 모듈은 프로그래머들이 직접 유용한 함수 등을 작성하여, 다른 사람 혹은 본인의 프로그램 개발시 활용하고자 하는 일종의 별도 파일이다. 모듈의 타입을 쳐보면, module이라고 뜬다.import mathtype(math)&gt;&gt;&gt; module모듈안의 함수 호출하기math.factorial(3)&gt;&gt;&gt; 6이렇게 어떤 모듈을 사용하는지, 쓰고 함수명을 같이 써준다. 모듈전체를 불러오지 않고, 모듈안의 해당 함수만을 불러오고 싶을 때는,from math import factorialfactorial(3)&gt;&gt;&gt; 6이렇게 써주면 된다.모듈을 불러오는 방법같은 디렉토리에 이런 파일을 작성했다고 하자.#filename : SampleModule.pydef convert_to_celsius(fahrenheit):    return (fahrenheit - 32) * 5/9다른 python 파일에 이 파일을 가져다가 쓰고 싶으면,import SampleModuleSampleModule.convert_to_celsius(212)앞에 모듈이름을 쓰기 싫으면,from SampleModule import convert_to_celsiusconvert_to_celsius(212)혹은 모듈안에 있는 모든 함수를 모듈이름 없이 사용하고 싶으면,from SampleModule import *convert_to_celsius(212)너무 모듈이름이 길면, 줄여서 사용하자.import SampleModule as SMSM.convert_to_celsius(212)",
        
        "url": "/dv/python/2020/09/29/python-basic-07-Module.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-06-conditional-statement-html": {
        "title": "06: Conditional Statement",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "C++과 약간의 차이를 기억해야 하는데, 가장 핵심적인 것은 OR, AND 를 그대로 갖다 쓴다는 것이다. C++에서는 각각 &amp;&amp; , || 로 사용했는데, 이것을 AND, OR 로 사용하면 된다.문자열에서 특정 문자 갯수 세는 프로그램 개발하기def calcCharacterFromString(sentence, inputChar):    numChs = sentence.count(inputChar)    return numChssentence = 'Mary had a little lamb'inputChar = input(\"Enter the Char : \")calcCharacterFromString(sentence, inputChar)",
        
        "url": "/dv/python/2020/09/29/python-basic-06-Conditional-Statement.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-05-string-html": {
        "title": "05: String",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "문자열 할당nameVar1 = 'Issac'nameVar1 = \"Issac\"문자열 기본 연산자, 내장 함수  len()입력 파라미터로 문자열을 전달 받는다.길이를 결과값으로 돌려준다.  +두 문자열을 하나로 연결하여 결과값을 돌려준다.  *문자열을 뒤에 곱한 수만큼 반복한 형태의 문자열로 돌려준다.  int()입력 파라미터로 전달받은 문자열이 숫자로만 이루어진 경우 정수타입으로 변경하여 돌려준다.  float()실수 타입으로 바꿔서 돌려준다.문자열 할당 시 ‘ 을 사용해야 하는 경우  \"\" 으로 감싼다.  \\' 을 사용한다.Print() 함수print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)  value,...입력 파라미터를 여러개 줄 수 있다.  sep=' '각각의 입력 파라미터를 출력할 때에 구분하는 문자열은 공백이다.  end='\\n'모든 입력 파라미터를 출력한 이후에 마지막에는 개행을 하고 마친다.  file, flush 추후 설명input() 함수input() 함수의 리턴값은 기본이 문자 이다.string = input(\"문자열을 입력하세요 : \")\t\t# charnum_string = input(\"숫자를 입력하세요 : \")\t# charnum = int(input(\"숫자를 입력하세요 : \"))\t# int문자열 주의 사항문자열은 한번 입력하면 수정이 불가하다!실습문자열 뒤집기 프로그램 만들기문자열이 들어오면 앞뒤를 뒤집어서 화면에 출력한다.def reverseString(string):    result = \"\"    for i in range(len(string)-1, -1, -1):        result += string[i]    return result나이 계산 프로그램 만들기name = input(\"이름 입력해!!! : \")old = int(input(\"몇 살이니??? : \"))now_year = int(input(\"올 해 몇년??? :\"))future_year = int(input(\"궁금한 년수 : \"))def calcAge(old, now_year, future_year):    result = old + (future_year - now_year)    return resultprint(calcAge(old, now_year, future_year), \"살 입니다.\")나이 출력 프로그램 만들기  입력 : 주민등록번호 앞자리를 받는다.  출력 : 당신의 생일은 OOOO년 OO월 OO일 입니다.number = input(\"주민등록번호 앞자리 6자리를 입력해주세요 : \")def makeBirthdayString(number):    #print(\"당신의 생일은 \", \"19\"+number[:1]+\"년\", int(number[2:3],\"월\", int(number[4:5]),\"일 입니다.\")    print(\"당신의 생일은 \", \"19\" , number[:2], \"년 \", int(number[2:4]), \"월 \", int(number[4:]), \"일 입니다.\", sep = \"\")makeBirthdayString(number)쇼핑 총액 계산 프로그램 만들기apple = int(input(\"how many apple?\"))banana = int(input(\"how many apple?\"))melon = int(input(\"how many apple?\"))peach = int(input(\"how many apple?\"))grape = int(input(\"how many apple?\"))def calcProductSum(apple, banana, melon, peach, grape):    a = 3000    b = 2500    c = 10000    d = 5000    e = 4000    result = apple * a +banana * b + melon * c + peach * d + grape * e    return result",
        
        "url": "/dv/python/2020/09/29/python-basic-05-String.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-04-function-design-recipe-html": {
        "title": "04: Function Design Recipe (FDR)",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "Function Design Recipe (FDR)우리는 파이썬에서 제공하는 다양한 내장 함수들에 대한 설명을 보고싶을때, help() 함수를 통해 정보를 확인할 수 있었다. 마찬가지로 내가 정의한 함수를 help() 를 통해 설명을 볼 수 있게 하는 것이 좋은 개발자의 방향이다.def convert_to_celsius(fahrenheit):    \"\"\" (int) -&gt; int #1    Return the celcius number from the given fahrenheit number. #2    &gt;&gt;&gt; Return the celsius(212) #3    100 #4    \"\"\" #5    return (fahrenheit - 32) * 5/9함수를 선언하고 \"\"\" 을 써준뒤 주석을 달아준다. 이 때,  입력파라미터와 리턴값을 써준다.  함수의 설명을 써준다.  예제를 써준다.이 세가지를 두루한다면 가장 완벽한 주석이 될 거다!",
        
        "url": "/dv/python/2020/09/29/python-basic-04-Function-Design-Recipe.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-03-variables-html": {
        "title": "03: Variables",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "모든 변수는 객체이다.파이썬에서 사용하는 변수는 객체를 가리킨다. 여기서 객체란 파이썬에서 사용되는 모든 것 을 의미하는 말이다. 이게 무슨말일까? 이 개념에 대한 직관적인 설명을 잘해둔 페이지가 있어 여기 소개한다. 객체란?신기하게도, C 에서 변수를 선언하면 각각 다른 메모리 공간에 상수로 들어갔던 것과 달리 파이썬에서는 같은 객체를 가리킨다. 예제로 직관적 이해를 해보도록 하자.a = 3먼저 이렇게 선언했을 때, 변수 a는 객체가 저장된 메모리 위치를 가리킨다. 또 오른쪽 3은, 정수 자료형 객체가 자동으로 메모리에 생성된다. 이렇게 보면 변수 a는 객체가 저장된 메모리의 위치를 가리키는 레퍼런스 라고 생각할 수 있다. 그리고 만약 내가 같은 객체를 다른 변수를 통해 가리킨다면, 같다고 뜬다.&gt;&gt;&gt; a = 3&gt;&gt;&gt; b = 3&gt;&gt;&gt; a is bTruea가 3을 가리키고 b도 3을 가리킨다. 즉 a=3 을 입력하는 순간 3이라는 정수형 객체가 생성되고 변수 a는 3이라는 객체의 메모리 주소를 가리킨다. 다음에 변수 b가 동일한 객체인 3을 가리킨다. 이제 3이라는 정수형 객체를 가리키는 변수가 2개가 됐다. 이 두 변수는 가리키고 있는 대상이 동일하다. 따라서 동일한 객체를 가리키고 있는지 아닌지에 대해서 판단하는 파이썬 내장 함수인 is 함수를 a is b처럼 실행했을 때 참(True)을 리턴하게 된다. 이렇게 하나의 객체를 가리키는 변수의 개수를 레퍼런스 카운트 (참조 개수) 라 한다. 여기서는 2가 되겠다.",
        
        "url": "/dv/python/2020/09/29/python-basic-03-Variables.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-02-string-array-list-datatype-html": {
        "title": "02: String Array, List, Data Type",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "자료형파이썬은 알아서 처리해주니까 이부분을 무시하고 작성하는 경향이 있을 수 있다. 하지만 여전히 연산을 할때, 해당 변수의 자료형을 인지한 상태로 수행해야 한다. 명시적 형변환을 하는 것을 잊지 말자.String문자열 나누기Pithon -&gt; Python 으로 바꾸는 작업을 진행해보자.# 잘못된 예a = \"Pithon\"a[1] = 'y'불가능하다. 문자열의 요소값은 바꿀 수 있는 값이 아니다.# 옳은 예a = \"Pithon\"a[:1] + 'y' +a[2:]슬라이싱을 사용하여 새로운 문자열을 만들 수 있다. 또한, 슬라이싱을 할때 마지막 값은 미만으로 인식한다. 이런 방법을 사용하지말고, 기본 메서드를 사용하면 더 쉽게 가능하다.문자열 관련 함수들# 문자 개수 세기a.count('b')# 위치 알려주기 1a.find('b')\t\t\t# 있으면 처음으로 나온 위치 반환, 없으면 -1# 위치 알려주기 2a.index('t')\t\t# 있으면 처음으로 나온 위치 반환, 없으면 에러# 문자열 삽입a = \",\"a.join('abcd')\t\t# 'a,b,c,d'# 소문자를 대문자로a = \"hi\"a.upper()\t\t\t# 'HI'# 문자열 바꾸기a = \"Life is too short\"a.replace(\"Life\", \"Your leg\")\t\t# ’Your leg is too short’# 문자열 나누기a = \"Life is too short\"a.split()\t\t\t\t\t\t# [’Life’, ’is’, ’too’, ’short’]a = \"a:b:c:d\"a.split(’:’) \t\t\t\t# [’a’, ’b’, ’c’, ’d’]List수정&gt;&gt;&gt; a[1:2] [2]&gt;&gt;&gt; a[1:2] = [’a’, ’b’, ’c’]&gt;&gt;&gt; a[1, ’a’, ’b’, ’c’, 4]&gt;&gt;&gt; a[1] = [’a’, ’b’, ’c’]&gt;&gt;&gt; a[1, [’a’, ’b’, ’c’], 4]2번 예제에서 리스트를 a[1:2] = [‘a’, ‘b’, ‘c’]로 수정하는 것과 a[1] = [‘a’, ‘b’, ‘c’]로 수정하는 것은 전혀 다른 결과값을 갖게 되므로 주의해야 한다. a[1] = [‘a’, ‘b’, ‘c’]는 리스트 a의 두 번째 요소를 [‘a’, ‘b’,‘c’]로 바꾼다는 말이고a[1:2]는 a[1]에서 a[2] 사이의 리스트를 [‘a’, ‘b’, ‘c’]로 바꾼다는 말이다. 따라서 a[1] = [‘a’, ‘b’, ‘c’]로 수정하게 되면 위와는 달리 리스트 a가 [1, [‘a’, ‘b’,‘c’], 4]라는 값으로 변하게 된다.삭제[ ] 사용해 리스트 요소 삭제하기&gt;&gt;&gt; a[1:3] = [ ]&gt;&gt;&gt; a[1, ’c’, 4]del 함수 사용해 리스트 요소 삭제하기&gt;&gt;&gt; a[1, ’c’, 4]&gt;&gt;&gt; del a[1]&gt;&gt;&gt; a[1, 4]리스트 관련 함수append&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a.append(4)&gt;&gt;&gt; a[1, 2, 3, 4]sort&gt;&gt;&gt; a = [1, 4, 3, 2]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 4]&gt;&gt;&gt; a = [’a’, ’c’, ’b’]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[’a’, ’b’, ’c’]insert&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a.insert(0, 4)[4, 1, 2, 3]remove&gt;&gt;&gt; a = [1, 2, 3, 1, 2, 3]&gt;&gt;&gt; a.remove(3)[1, 2, 1, 2, 3]첫번째로 나오는 녀석을 삭제한다.poppop( )은 리스트의 맨 마지막 요소를 돌려 주고 그 요소는 삭제하는 함수이다.&gt;&gt;&gt; a = [1,2,3] &gt;&gt;&gt; a.pop()3&gt;&gt;&gt; a[1, 2]Tuple튜플(tuple)은 몇 가지 점을 제외하곤 리스트와 거의 비슷하다. 리스트와 다른 점은 다음과 같다.  리스트는 []으로 둘러싸지만 튜플은 ()으로 둘러싼다.  리스트는 그 값의 생성, 삭제, 수정이 가능하지만 튜플은 그 값을 바꿀 수 없다.딕셔너리 자료형사람은 누구든지 “이름” = “홍길동”, “생일” = “몇 월 몇 일” 등으로 구분 할 수 있다. 파이썬은 영리하게도 이러한 대응 관계를 나타낼 수 있는 자료형을 가지고 있다. 요즘 사용하는 대부분의 언어들도 이러한 대응 관계를 나타내는 자료형을 갖고 있는데, 이를 연관 배열(Associative array) 또는 해시(Hash)라고 한다.파이썬에는 이 자료형을 딕셔너리라고 하는데, 기본적으로 Key, Value 라는 것을 한 쌍으로 갖는 자료형이다. 딕셔너리가 튜플이나 리스트와 가장 다른 점이라면, 순차적으로 해당 요소값을 구하지 않고 Key 를 통해 Value를 얻는다는 점이다. 처음부터 다 뒤져보는 것이 아니고, Key가 있는 곳만 탐색한다는 것이다.Key list&gt;&gt;&gt; a = {’name’: ’pey’, ’phone’: ’0119993323’, ’birth’: ’1118’}&gt;&gt;&gt; a.keys()dict_keys([’name’, ’phone’, ’birth’])Items&gt;&gt;&gt; a.items()dict_items([(’name’, ’pey’), (’phone’, ’0119993323’), (’birth’, ’1118’)])items 함수는 key와 value의 쌍을 튜플로 묶은 값을 dict items 객체로 돌려준다.GetKey 로 Value 를 얻어보자.&gt;&gt;&gt; a = {’name’:’pey’, ’phone’:’0119993323’, ’birth’: ’1118’}&gt;&gt;&gt; a.get(’name’)’pey’&gt;&gt;&gt; a.get(’phone’)’0119993323’",
        
        "url": "/dv/python/2020/09/29/python-basic-02-String-Array-List-DataType.html"
      }
      ,
    
      "dv-python-2020-09-29-python-basic-01-introduction-html": {
        "title": "01: Introduction",
        "tags": "python",
        "date": "September 29, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "기본 정보발표년도 : 1991설계자 : Guido van Rossum, 네덜란드패러다임 : 절차적 프로그래밍, 함수형 프로그래밍, 객체 지향 프로그래밍  초보자부터 전문가까지 사용자층이 넓다.  다양한 플랫폼에서 쓸 수 있다.  라이브러리(모듈)이 풍부하다.  들여쓰기를 사용해서 블록을 구분한다.  C/C++ 에 비해 수행 속도가 느리다.철학  “아름다운게 추한 것보다 낫다.” (Beautiful is better than ugly)  “명시적인 것이 암시적인 것 보다 낫다.” (Explicit is better than implicit)  “단순함이 복잡함보다 낫다.” (Simple is better than complex)  “복잡함이 난해한 것보다 낫다.” (Complex is better than complicated)  “가독성은 중요하다.” (Readability counts)",
        
        "url": "/dv/python/2020/09/29/python-basic-01-Introduction.html"
      }
      ,
    
      "ds-la-2020-09-29-linear-algebra-basic-06-qr-decomposition-html": {
        "title": "06: QR Decomposition (QR 분해)",
        "tags": "Math, Linear Algebra",
        "date": "September 29, 2020",
        "author": "",
        "category": "DS/LA",
        "content": "QR DecompositionQR 분해의 근본적인 이유는 무엇일까? 기존의 선형대수에 대한 글에서, 행렬은 하나의 공간을 매핑한다고 했다. 그리고 행렬 size가 정사각행렬이고, full rank일 때 n차원 공간을 매핑한다. 그런데 공간을 매핑하는데 있어, 굳이 orthogonal 할 필요는 없다. 즉, 직교하는 축으로 공간이 매핑될 필요는 없다. 하지만, 우리는 직교축에 익숙하다! 또한 다루기도 매우 쉽다!Vector따라서 우리는 특정 행렬이 Orthogonal 한 행렬로 나타내어 진다면 다루기 굉장히 수월할 것이다! 필요성이 생겼으니 만들어보자.AssumptionA 행렬의 모든 벡터는 선형 독립 이다.Idea2 차원 공간에서 먼저 생각해보자. 우리가 하고 싶은 것은, A 벡터를 Orthogonal 한 벡터로 변환시키는 것이다. 그전에, 어떤 직교행렬로 만들지에 대한 고민이 필요한데, 그러기 위해서는 기준이 필요하다. 그래서 우리는 직교행렬로 만들 첫번째 축(b1)을 a1 벡터로 선택할 것이다.그렇다면, 우리는 b1에 직교하는 축, b2를 만들어야 하는데, 이녀석은 어떻게 정의할 수 있을까? a2 벡터의 방향으로 부터, a1 벡터의 성분을 제거 해준다면 그 남은 벡터가 b2 벡터라 할 수 있을 것이다.Orthogonal Vector그 다음 3차원 벡터는, a3 벡터에서, b1벡터의 성분을 빼고, b2벡터의 성분을 빼면 된다!Process이 과정을 수식화해보면, 첫번째 요소는,두번째 요소는,세번째 요소는,i 번째 요소는,Transform to Matrix form행렬 A에 대해 정리하기 위해, a벡터에 대해 정리해보자.여기서,이므로,이 식을 A 식이라 하자. 여기서 양쪽에 b의 단위 벡터를 곱하자.이 때, Orthogonal vector의 특징으로 부터,시그마로 표시된 우측항은 0 이다. 또한, 그 왼쪽항도 1이 되어 b벡터의 크기만 남는다.여기서 왼쪽항을 전치행렬의 특징을 사용해서 뒤바꾸면,이 결과를 A 식에 대입하면,여기서 괄호안을 전치행렬의 특징을 사용해서 뒤바꾸면,이제 행렬모양으로 바꿔보자.A가 정사각행렬일 때,orthogonal matrix의 특성에 따라 전치행렬을 곱하면 identity matrix가 나온다. 그리고 R 행렬은 upper triangle matrix 이다.",
        
        "url": "/ds/la/2020/09/29/Linear-Algebra-Basic-06-QR-Decomposition.html"
      }
      ,
    
      "ds-la-2020-09-29-linear-algebra-basic-05-aspects-of-matrix-multiplication-html": {
        "title": "05: Aspects of Matrix Multiplication (행렬 곱셈의 여러 측면)",
        "tags": "Math, Linear Algebra",
        "date": "September 29, 2020",
        "author": "",
        "category": "DS/LA",
        "content": "원소의 측면R이 결과 행렬이라고 한다면,행의 측면행의 측면에서 행렬의 곱을 바라본다면, 내가 변환된 행렬이 오른쪽에 있다고 가정했을 때 판단하면 유용하다. A가 내가 관심을 두는 행렬이고, E가 변환을 하는 행렬이라 생각하자.따라서 내가 원하는 행렬이 오른쪽에 있다면 그 행렬을 행벡터의 모임 으로 생각하고 왼쪽의 변환 행렬은 행방향 순서대로 상수배를 해주고 더한다는 개념으로 이해한다. 결과는 행벡터이다. 따라서,열의 측면이번에는 내가 관심이 있는 행렬이 왼쪽에 있다고 생각하자. 그렇다면,따라서,정리  기본 요소로 보았을 때 계산은 식으로 나타냈을 때 굉장히 심플하다!  내가 원하는 행렬이 오른쪽에 있을 때는 행으로 본다!  내가 원하는 행렬이 왼쪽에 있을 때는 열로 본다!",
        
        "url": "/ds/la/2020/09/29/Linear-Algebra-Basic-05-Aspects-of-Matrix-Multiplication.html"
      }
      ,
    
      "ds-la-2020-09-29-linear-algebra-basic-04-lu-decomposition-html": {
        "title": "04: LU Decomposition (LU 분해)",
        "tags": "Math, Linear Algebra",
        "date": "September 29, 2020",
        "author": "",
        "category": "DS/LA",
        "content": "LU 분해는 근본적으로 가우스 소거법의 방법을 차용한다. 가우스 소거법은 행의 조작을 통해, Upper Triangle Matrix 를 만드는 것이 핵심이다. 이 과정에서 우리는 행의 조작을 하는데, 윗삼각행렬을 만들기 위해 상수배와 더하기 빼기를 하는데, 이 과정을 행렬을 곱하는 것으로 대치하는 것이 전부이다. 먼저 가우스 소거법을 대치하는 행렬을 어떻게 만들지 부터 생각해보자.E 행렬1행 * (1/2) + 2행의 결과를 2행에 넣어야 한다. 이 때, A 행렬을 다음과 같이 바라보자.각각의 벡터는 행을 의미한다. 우리는 1, 3행은 그대로, 2행을 위의 연산을 수행한 뒤 넣어줘야 하므로,다음과 같다. 이 행렬을 다음과 같이 사용하겠다.그렇다면,이 수행된 결과에 대해 다음 단계를 이와 같이 나타내면,따라서 가우스 소거법은 다음과 같이 나타낼 수 있다.이 때,결론적으로,여기서 EA의 결과 행렬은 Upper Triangle Matrix 이다.이제 다시 LU 분해자, 이렇게 가우스 소거법이 행렬로 분해가 될 수 있다는 사실 까지 알았다. 그렇다면 항등식으로 부터 A행렬을 L과 U로 분해해보자.여기서, 양쪽에 위에서 배운 E1, E2, E3 행렬을 곱해보자.오른쪽 은 세 행렬이 곱해졌을 때 Upper triangle 행렬이 된 것을 의미한다. 이 식은 다음과 같이 요약되고,여기서 Lower triangle matrix의 inverse matrix는, Lower Triangle Matrix 이다.따라서,다음과 같이 분해가 완료 되었다.LU 분해의 특별한 경우 (Cholesky’s factorization)  A가 대칭행렬 이다.  행렬식의 값이 Positive 이다.이런 경우 LU 분해의 결과는,대부분의 다물체 동역학 시스템은 위의 두 가정을 만족한다.Numerical Solution Process먼저 Factorization 을 진행한다.그리고, 식을 재정의한 뒤, iterative method를 사용한다.두번의 back-subsitution process를 걸치면 원하는 결과가 나온다.",
        
        "url": "/ds/la/2020/09/29/Linear-Algebra-Basic-04-LU-Decomposition.html"
      }
      ,
    
      "ds-la-2020-09-29-linear-algebra-basic-03-linear-independant-gauss-jordan-method-html": {
        "title": "03: Linear Independent, Guass-Jordan Method, Pivoting (선형 독립, 가우스-조르당 방법, 피보팅)",
        "tags": "Math, Linear Algebra",
        "date": "September 29, 2020",
        "author": "",
        "category": "DS/LA",
        "content": "Linear Independence하나의 행렬은 공간을 나타낸다고 볼 수 있다.다음과 같은 행렬이 있다면, column 벡터를 보면, i, j, k를 나타냄을 알 수 있다.그런데 만약에 각각의 벡터가 서로의 상수배를 한 관계를 가지고 있다면, 이 공간은 행렬 사이즈에 해당하는 공간을 매핑하지 못한다. 이 경우 우리는 행렬이 선형 종속 이라 말한다. 반대로 공간을 매핑할 수 있다면 선형 독립 이라 말한다. 이것을 수식으로 판단해보면,위 식을 만족하는 e 벡터가 0 벡터인 경우 a .. 벡터들은 선형 독립 이라 한다. 선형 독립이 되기 위해서는 위의 행렬식에서, Determinant 가 존재해야만 한다. 즉, 비특이행렬 이어야 하고, 위 식의 해인 e 벡터는 0 벡터로 유일 해야 한다.Rank행렬은 하나의 공간을 매핑한다고 했다. 방금은 3 x 3 의 행렬에 대해 봤기 때문에, 열벡터 공간과 행벡터 공간이 동일하게 3차원 공간을 매핑하고 있었다. 하지만 행렬이 꼭 정사각행렬이라는 법은 없다. 따라서 우리는 행벡터와 열벡터에 대한 선형 독립성을 판단할 지표가 필요한데, 이 때 등장하는 개념이 Rank 이다.A 행렬이 다음과 같이 있을 때, 첫번째가 열벡터로 묶은 행렬, 두번째가 행벡터로 묶은 행렬이다. A 행렬의 모든 벡터들이 선형 독립이라 가정 할때, 열벡터들의 개수가 Column Rank(Nc) , 행벡터들의 개수가 Row Rank(Nr) 이다. 만약 정사각 행렬이라면, 아래와 같다.Rank와 행렬식과의 관계정사각 행렬에서 Full Rank 인 경우, 동치인 말이 여러개 존재한다.  Full Rank  det(A) != 0  역행렬이 존재한다.  non-singular Matrix  non-trivuial solutionGauss Elimination가우스 소거법은, 연립방정식의 해를 행렬을 이용해 쉽게 구하는 방법이다. 기본적으로 행벡터의 계수를 조작하여 구하는 방법으로, Upper Triangle Matrix, Lower Triangle Matrix 를 만들어 구하는 방법이다. 역행렬을 구하여 답을 찾는 방식은 Cost가 많이 들어, 해를 구하는데는 적합하지 않다. 자세한 방법은 생략한다.Gauss - Jordan Method가우스- 조르당 방법의 가장 큰 이점은, 역행렬 을 구하는데에 있다. 기존의 Cramer’s rule을 사용하는 것은 computing cost가 많이 들기 때문에, 이 방법이 매우 유용하다. 역행렬을 구하는데 있어 Gauss Elimination에서 한 행벡터를 조작해서 하는 방법은 동일하다.PivotingMotivation of Pivoting가우스 소거법과, 가우스-조르당 방법에서 대각행렬을 기준으로 수행한다는 것은 명백하다. 우리는 그래서 이 대각 행렬의 요소를 Pivot 이라 부른다. Pivoting 이란, 행렬이 있을때, 이 Pivot을 기준으로 행을 판단해서 두 행을 바꿔 계산하는 방법을 말한다. 그렇다면 이 Pivoting은 왜 필요한 것일까? 우리는 행렬을 계산하는데 있어 Computing Method를 사용하는데,현실의 값을 근사해서 매핑하는 컴퓨터의 한계 때문에, 우리는 Round Off Error 를 필연적으로 가질 수 밖에 없다. 이 에러를 줄이기 위해 우리는 Pivoting을 한다. 예제를 살펴보자.이 식의 정확한 값은,가우스 소거법을 사용해서 위 식을 계산해보자. 우리는 대각 요소를 1로 만드는 것에 관심이 있기 때문에, 1행 1열의 값을, 2행 1열의 값과 같게 만든뒤 빼줘야 한다. 그러기 위해서이 값을 1행에 곱하고 2행을 더한 행을 2행과 바꿔주자. 결과 식은,이 때 계산된 해는,다음과 같이 현저히 다른 해가 도출된다. 결국 우리는 대각 요소의 값과 밑의 행이 비율이 큰 것을 피하면 된다!j는 행의 번호를 말하고, k는 대각 요소의 행번호를 의미한다. 우리는 이 값이 1보다 클경우 Round Off 에러가 발생한다는 것을 알았으므로 이것을 막으면 된다.Remedy  Partial Pivoting  Scaled PivotingPartial Pivoting가장 간단한 방법은, 저 값이 1보다 훨씬 클 경우 아래 행과 위의 행을 바꾸는 것이다!k는 현재 있는 행을 의미한다. n은 마지막 행을 의미한다. 그 사이에 있는 i 라는 값을 가지면서 각 행의 요소들을 조사하면서 가장 큰 값을 리턴한다. 이때, 행의 index를 저장하고, 만약 해당 행의 대각 요소의 값이 가장 크다면 p = k 가 될 것이다. 만약 그렇지 않다면 p != k 일 것이다. 이 경우 p 행과 k 행을 Pivoting 한다. 그렇게 되면 필연적으로 m_jk 값은 1보다 작아지므로 Round Off Error 를 피할 수 있다.적용Scaled Pivoting만약 m 값이 1에서 크게 차이가 없다면 이 방법은 사실의미가 없다. 따라서 이 경우에는 각 행에 특정 같은 값을 곱한뒤, 답을 구하는 방법을 사용해야 한다. 가우스 소거법의 특성상, 밑의 값부터 올라오기 때문에, 특정 행의 계수들의 크기가 균등하다면 값의 변화가 크다. 따라서 우리는 행의 계수들의 비율이 큰 행을 아래로 피보팅 해야한다.따라서 1행과 2행을 피보팅한다.",
        
        "url": "/ds/la/2020/09/29/Linear-Algebra-Basic-03-Linear-Independant-Gauss-jordan-method.html"
      }
      ,
    
      "ds-la-2020-09-29-linear-algebra-basic-02-determinant-inver-html": {
        "title": "02: Determinant, Inverse Matrix, Orthogonal Matrix (행렬식, 역행렬, 직교행렬)",
        "tags": "Math, Linear Algebra",
        "date": "September 29, 2020",
        "author": "",
        "category": "DS/LA",
        "content": "DeterminantInverse MatrixDefinition정사각행렬에서 정의된다.Determinant 에 따른 구분, 그리고 의미  Determinant 가 존재한다.          역행렬이 존재한다.                  비특이행렬 (Non-Singular Matrix)          이 행렬이 다른 벡터에 곱해졌을 때, 차원의 크기가 유지된다.          방정식의 해가 하나로 정해진다.                      Determinant 가 존재하지 않는다.          역행렬이 존재하지 않는다.                  특이행렬 (Singular Matrix)          이 행렬이 다른 벡터에 곱해졌을 때, 차원의 크기가 축소된다.          방정식의 해가 무수히 많다.                    성질Orthogonal Matrix",
        
        "url": "/ds/la/2020/09/29/Linear-Algebra-Basic-02-Determinant-Inver.html"
      }
      ,
    
      "ds-la-2020-09-29-linear-algebra-basic-01-types-of-matrix-html": {
        "title": "01: Types of Matrix (행렬의 종류)",
        "tags": "Math, Linear Algebra",
        "date": "September 29, 2020",
        "author": "",
        "category": "DS/LA",
        "content": "Types of MatrixSquare MatrixRectangular MatrixZero MatrixSymmetric MatrixUpper-Triangle MatrixLower-Triangle MatrixDiagonal MatrixIdentity MatrixSkew-Symmetric MatrixMatrix Transformation전치 행렬은 정사각행렬에서, 행과 열의 숫자가 같은 요소들을 기준으로 하는 선으로 행렬을 대칭 시킨 것을 말한다.Before TransformationAfter Transformation성질",
        
        "url": "/ds/la/2020/09/29/Linear-Algebra-Basic-01-Types-Of-Matrix.html"
      }
      ,
    
      "dv-tips-2020-09-28-naming-rules-03-eb-93-a4-ec-97-ac-ec-93-b0-ea-b8-b0-html": {
        "title": "03: 들여쓰기",
        "tags": "Tips, Naming",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "1. 들여쓰기 기본  TAB 을 사용한다.  SPACE를 사용하지 않는다.  Tab 사이즈는 4로 정의한다.2. 주석은 코드와 같은 레벨에 있어야 한다.  들여쓰기의 레벨을 같이 사용한다.좋은 예// Format a message and displaystring fullMessage = \"Hello \" + name;DateTime currentTime = DateTime.Now;string message = fullMessage + \", the time is : \" + currentTime.ToShortTimeString();MessageBox.Show ( message );좋지 않은 예// Format a message and displaystring fullMessage = \"Hello \" + name;DateTime currentTime = DateTime.Now;string message = fullMessage + \", the time is : \" + currentTime.ToShortTimeString();MessageBox.Show ( message );3. 중괄호는 중괄호 밖에 있는 코드와 같은 레벨에 있어야 한다.4. 논리적인 코드 그룹은 빈 줄 하나로 구분해야 한다.좋은 예bool SayHello ( string name ){        string fullMessage = \"Hello \" + name;        DateTime currentTime = DateTime.Now;        string message = fullMessage + \", the time is : \" + currentTime.ToShortTimeString();        MessageBox.Show ( message );        if ( ... )        {                // Do something                // ...                return false;        }        return true;}좋지 않은 예bool SayHello (string name){        string fullMessage = \"Hello \" + name;        DateTime currentTime = DateTime.Now;        string message = fullMessage + \", the time is : \" + currentTime.ToShortTimeString();        MessageBox.Show ( message );        if ( ... )        {                // Do something                // ...                return false;        }        return true;}5. 클래스 내부의 각 메서드 사이에는 단 하나의 빈 줄만 있어야 한다.6. 중괄호는 다른 라인과 분리되어 있어야하며 라인을 같이 쓰면 안된다.좋은 예if ( ... ){        // Do something}좋지 않은 예if ( ... )     {        // Do something}7. 지시자(operator)와 괄호 앞뒤로는 한 칸의 공간을 남긴다.좋은 예if ( showResult == true ){    for ( int i = 0; i &lt; 10; i++ )    {            //    }}좋지 않은 예if(showResult==true){        for(int    i= 0;i&lt;10;i++)        {                //        }}8. 연관된 코드를 묶을때는 #region을 사용해라.확장하거나 축소할 수 있는 코드 블록을 지정하자. #region을 사용해서 묶는다면 그 페이지는 훨씬 간략해질 것이다.9. private 멤버 변수, 속성, 그리고 메소드는 파일의 하단에 그리고 public 멤버들을 파일의 하단에 위치하도록 하라.  switch 문은 다음 형식이어야 한다.switch (condition) {    case ABC :        statements;        // 지나감    case DEF :        statements;        break;    case XYZ :        statements;        break;    default :        statements;        break;}각 case 키워드를 전체 switch 문에 대해 들여쓰기한다는 점에 주의한다. 이를 통해 전체 switch 문을 두드러지게 한다. 또한 “:” 문자 앞에 있는 여분의 빈칸에 주의한다. case 문에 break 문이 없으면 항상 명시적으로 ‘지나감’이라고 주석을 달아야 한다. break 문이 없는 것은 일반적인 오류이므로, 사용하지 않을 때는 의도적이라는 것을 명확히 해야 한다.  do-while 문은 다음 형식이어야 한다.do {    statements;} while (condition);이 형식은 위에서 제시한 일반 구역 규칙을 따른다.  while 문은 다음 형식이어야 한다.while (condition) {    statements;}이 형식은 위에서 제시한 일반 구역 규칙을 따른다.  부동소수점 상수는 항상 소수점과 함께 써야 한다.double total = 0.0;          // 아님: double total = 0;double speed = 3.0e8;    // 아님: double speed = 3e8;double sum;    :sum = (a + b) * 10.0;이는 정수와 부동소수점 수의 본질적인 차이를 강조한다. 수학적으로 두 모델은 완전히 다르며 호환되지 않는 개념이다. 또한 위의 마지막 예제처럼 코드의 어떤 지점에서 명확하지 않을 수 있는 대입되는 변수(sum)의 타입을 강조한다.  부동소수점 상수는 항상 소수점 앞에 숫자를 써야 한다.double total = 0.5;    // 아님: double total = .5;C++ 에서 숫자와 표현식 시스템은 수학에서 빌려왔으므로 가능한 구문에 대한 수학적 관례를 따라야 한다. 또한 .5보다 0.5가 휠씬 읽기 쉬우며 정수 5와 헷갈리지 않는다.  루프 변수는 해당 루프 바로 앞에서 초기화해야 한다.isDone = false;        // 아님: bool isDone = false;while ( !isDone ) {     ...}10. do-while 루프는 피한다.do-while 루프는 해당 루프의 가장 아래에 조건이 있기 때문에 일반적인 while 루프와 for 루프보다 가독성이 떨어진다. 해당 루프의 사용 범위를 이해하려면 반드시 전체 루프를 살펴봐야 한다. 게다가 do-while 루프는 while 루프나 for 루프로 쉽게 바꿔 쓸 수 있으므로 필요하지 않다. 이 구조의 사용을 줄여 가독성을 향상시킨다.11. 루프에서 break와 continue 사용을 피해야 한다.이 문장은 구조적인 대체 코드보다 가독성을 더 높일 수 있을 때만 사용해야 한다.12. 무한 루프는 “while (true)” 형식을 사용한다.while (true) {    :}for (;;) {       // 좋지 않음    :}while (1) {    // 좋지 않음    :}1에 대해 시험하는 것은 필요하지도 의미적이지도 않다. for (;;) 형식은 가독성이 매우 나쁘며 실제 무한 루프인지 명확하지 않다.13. 파일 내용은 반드시 80 열(column) 내로 유지해야 한다.80 열은 편집기, 터미널 에뮬레이터, 프린터와 디버거의 공통적인 치수이며 여러 사람이 공유하는 파일은 이런 제한을 지켜야 한다. 이를 통해 프로그래머 사이에 파일을 전달할 때 의도하지 않은 줄바꿈을 피할 수 있어 가독성을 향상시킨다.14. 객체 이름이 암시되어 있으면 메서드 이름에서 반복 사용하지 말아야 한다.            O      X                  line.getLength();      line.getLineLength();      클래스 선언에서 두 번째가 자연스러운 것처럼 보이지만 불필요하게 사용한 예이다.Reference프로그램 코딩 시 네이밍 규칙과 들여쓰기",
        
        "url": "/dv/tips/2020/09/28/Naming-Rules-03-%EB%93%A4%EC%97%AC%EC%93%B0%EA%B8%B0.html"
      }
      ,
    
      "dv-tips-2020-09-28-naming-rules-02-ed-8a-b9-ec-a0-95-eb-aa-85-eb-aa-85-ea-b7-9c-ec-b9-99-html": {
        "title": "02: 특정한 명명 규칙",
        "tags": "Tips, Naming",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "1. get/set은 반드시 속성(attribute)에 직접 접근할 때 사용한다.C++ 개발 커뮤니티에서 일반적인 용례이며, 자바에서는 거의 표준이 되었다.employee.getName();employee.setName(name);matrix.getElement(2, 4);matrix.setElement(2, 4, value);2. compute는 무언가 계산하는 메서드에서 사용한다.valueSet-&gt;computeAverage();matrix-&gt;computeInverse();이 것은 시간을 소비할 수 있는 연산이라는 것을 즉시 알아챌 수 있는 단서를 제공해 반복해서 사용한다면 결과를 따로 저장해 두는 것을 고려하도록 할 수 있다. 이처럼 용어를 일관되게 사용하면 가독성을 향상시키게 된다.3. find는 무언가를 찾는 메서드에서 사용한다.vertex.findNearestVertex();matrix.findMinElement();최소한의 계산이 포함된, 간단한 검색 메서드라는 것을 즉시 알아챌 수 있는 단서를 다른 개발자에게 제공한다.4. initialize는 객체 또는 개념을 만들 때 사용한다.printer.initializeFontSet();영국어 initialise보다 미국어 initialize를 사용해야 하며, 약어 init 는 피하도록 한다.5. GUI 요소(component)를 나타내는 변수는 해당 요소 타입 이름을 접미어로 사용한다.mainWindow, propertiesDialog, widthScale, loginText, leftScrollbar, mainForm, fileMenu, minLabel, exitButton, yesToggle, 등…해당 변수 타입을 통해 리소스 객체를 즉시 알아챌 수 있는 단서를 사용자에게 제공하므로 가독성을 향상시킨다.6. 복수형은 객체 모음(collection)을 나타내는 이름에 사용해야 한다.vector &lt;Point&gt;  point;int  values[];변수 타입과 더불어 해당 요소에 수행할 수 있는 연산을 즉시 알아챌 수 있는 단서를 사용자에게 제공하므로 가독성을 향상시킨다.7. 접두어 n 은 객체 수를 나타내는 변수에 사용한다.  nPoints  nLines객체 수를 나타내는 이 관례적인 표기법은 수학에서 가져왔다.8. 접미어 “No”는 독자적인(Entity) 번호를 나타내는 변수에 사용한다.  tableNo  employeeNoEntity 번호를 나타내는 이 관례적인 표기법은 수학에서 가져왔다.세련된 다른 방법은 iTable, iEmployee 처럼 접두어 i 를 붙이는 것이며, 이를 통해 효과적으로 그런 변수를 명명된 반복자로 만들 수 있다.9. 반복자 변수는 i, j, k 등으로 호출한다.for ( int i = 0 ; i &lt; nTables ; i++ ){...}for ( vector&lt;MyClass&gt;::iterator i = list.begin() ; i != list.end() ; i++ ){Element element = *i;...}반복자를 나타내는 이 관례적인 표기법은 수학에서 가져왔다. 변수 이름으로 i 를 제외한 j, k 등은 중첩 루프에서만 사용한다. (옮긴이 주: 이 표기법은 되도록 간단한 루프에서만 사용하고 복잡하거나 긴 루프에서는 의미있는 이름을 사용하는 게 좋다.)10. 접두어 is는 Boolean 변수와 메서드에서 사용한다.  isSet  isVisible  isFinished  isFound  isOpenC++ 개발 커뮤니티에서 일반적이며, 자바에서는 일부분에서 강제하는 용례이다. 접두어 is를 사용하면 status나 flag처럼 좋지 못한 불리언 이름을 선택하는 흔한 문제를 해결할 수 있다. 사실 isStatus나 isFlag는 적절하지 못하므로 더 의미있는 이름을 선택해야 한다.다음은 상황에 따라 접두어 is 보다 더 나은 방법 몇 가지로 has, can 그리고 should 접두어를 사용한다.bool hasLicense();bool canEvaluate();bool shouldSort();11. 반의어는 반드시 대응하는 연산에 대해 사용해야 한다.            A      B      A      B                  get      set      add      remove              create      destroy      start      stop              insert      delete      increment      decrement              old      new      begin      end              first      last      up      down              min      max      next      previous              open      close      show      hide              suspend      resume      -      -      대칭 관계를 통해 복잡성을 낮출 수 있다.12. 이름에 약어는 피해야 한다.약어는 되도록이면 피하고, 명시적으로 작성한다.            좋은 예      나쁜 예                  computeAverage();      compAvg();      12.1 사용하면 안되는 약어문제가 될 만한 단어들은 약어를 사용하지 않는다.            O      X                  command      cmd              copy      cp              point      pt              compute      comp              initialize      init      12.1 약어를 사용하는 것이 좋은 경우그에 반해 약어/두문자어가 더 자연스런 특정 분야의 관용구는 약어 형태를 유지해야 하며, 절대 다음처럼 쓰지 않는다.            O      X                  html      HypertextMarkupLanguage              cpu      CentralProcessingUnit              per      PriceEarningRatio      13. 포인터를 이름에 사용하는 것은 특히 피해야 한다.            O      X                  Line* line;      Line* pLine;              -      Line* linePtr;      C/C++ 환경에서 많은 변수가 포인터이므로 이와 같은 관례는 따르기가 거의 불가능하다. 또한 C++ 에서 객체는 흔히, 프로그래머가 특정 구현 내용을 무시할 수 있는 간접 타입이다.포인터를 이름에 사용할 때는 객체의 실제 타입이 특별히 중요할 때에 한해 해당 타입을 강조하기 위해서이다.14. 부정적인(negated) Boolean 변수 이름은 반드시 피해야 한다.            O      X                  bool isError;      isNoError              bool isFound;      isNotFound      문제는 이런 이름을 논리 부정 연산자와 함께 사용할 때 이중 부정을 통해 결과가 만들어지므로 생긴다.!isNotFound 의 의미를 즉시 명확하게 알아차릴 수 없다.15. 열거 상수는 공통 타입 이름을 접두어로 붙인다.enum Color {COLOR_RED,COLOR_GREEN,COLOR_BLUE,};이러한 것은 해당 선언을 어디에서 찾을 수 있는지, 어느 상수가 함께 속한 것인지, 그리고 그 상수가 어떤 개념을 나타내는지 등 추가 정보를 제공한다. 다른 방법은 Color: : RED, Airline: : AIR_FRANCE 등과 같이 항상 공통 타입을 통해 해당 상수를 참조하는 것이다.16. 예외 클래스는 Exception 접미어를 붙인다.class AccessException{...}예외 클래스는 실제 해당 프로그램의 주된 설계 부분이 아니며(옮긴이 주: 프로그램에서 주된 처리 로직이 아니라는 뜻), 이와 같이 이름을 붙이면 다른 클래스와 상대적으로 구별된다.Reference프로그램 코딩 시 네이밍 규칙과 들여쓰기",
        
        "url": "/dv/tips/2020/09/28/Naming-Rules-02-%ED%8A%B9%EC%A0%95-%EB%AA%85%EB%AA%85-%EA%B7%9C%EC%B9%99.html"
      }
      ,
    
      "dv-tips-2020-09-28-naming-rules-01-eb-84-a4-ec-9d-b4-eb-b0-8d-ea-b4-80-eb-a1-80-ec-99-80-ed-91-9c-ec-a4-80-html": {
        "title": "01: 네이밍 관례와 표준",
        "tags": "Tips, Naming",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "가장 중요한 두 가지의 표기법을 알고 읽으면 수월하다.  파스칼 표기법          모든 단어에서 첫번째 문자가 대문자이며 나머지는 소문자이다      BackColor        카멜 표기법          최초에 사용된 단어를 제외한 첫번째 문자가 대문자이며 나머지는 소문자이다      backColor      1. 클래스 명에는 파스칼 표기법을 사용한다.public class HelloWorld{...}2. 함수(Method) 명에는 파스칼 표기법을 사용한다.void SayHello(string name){...}3. 변수와 함수 파라미터에는 카멜 표기법을 사용한다.int totalCount = 0;void SayHello(string name){string fullMessage = \"Hello \" + name;...}4. 인터페이스에는 접두사 “I”가 포함된 파스칼 표기법을 따른다.  IEntity5. 변수명에 헝가리안 표기법을 사용하지 않는다.이전에는 많은 프로그래머들이 변수명에 데이터 타입에 해당하는 접두사를 첨가하였다. 즉, 멤버변수에는 아래와 같이 m_ 을 접두사로 사용하는 것과 같은 헝가리안 표기법을 사용했었다.string m_sName;int nAge;그러나 닷넷 코딩 표준에서 헝가리안 표기법은 추천하지 않는다. 데이터 타입을 사용하는 것과 멤버 변수를 표현하기 위한 m* 은 사용해서는 안된다. 모든 변수는 카멜 표기법을 사용해야 한다. 몇몇 프로그래머들은 아직 m* 을 붙이거나 데이터 타입을 표시하는 것을 더 좋아하겠지만, 이제 이것들은 멤버 변수를 확인하기 위한 쉬운 방법이 아니다.6. 변수에 모든 의미를 충분히 담아라(약어를 사용하지 말 것).            좋은 예      나쁜 예                  string address      tring addr              int salary      int sal      7. 한 글자로 된 이름을 사용하지 말 것.i, n, s 보다는 index, temp 와 같은 이름을 사용한다.한 가지 예외가 있다면 루프에서 반복을 의미하는 변수를 하용하는 경우이다.for ( int i = 0; i &lt; count; i++ ){...}만일 변수가 단지 반복을 위한 카운터로만 사용 된다면, 그리고 그것이 루프 안에 있는 다른 어떤 곳에서도 사용되지 않는다면, 많은 사람들은 아직까지 다른 적합한 단어를 만들어서 사용하는 것보다 i 를 사용하는 것을 선호한다.8. 지역변수와 멤버변수는 변수명 앞에 밑줄(_)을 사용하여 구별한다.지역변수에는 변수명 앞에 밑줄을 사용하지 않는다.멤버변수에는 m_ 과 같은 헝가리안 표기법을 사용하는 대신 밑줄을 사용하여 지역변수와 구별한다.9. 키워드와 비슷한 이름을 하용하지 말것.10. boolean 이 들어가는 변수, 속성, 함수(method)등은 “is” 또는 유사한 접두사를 사용한다.  private bool _isFinished11. 네임스페이스 명은 표준 패턴을 따라야 한다.      ...    org.apache.common.lang.StringUtils;12. UI 구성요소를 위해 적당한 접두사를 사용한다.UI 구성요소를 적당한 접두사를 사용하여 다른 변수들과 구분할 수 있어야 한다.여기서 추천하는 서로 다른 두 가지 방식이 있다.12.1. 모든 UI 구성요소를 위하여 공통적인 접두사(ui_)를 사용한다.이것은 모든 UI 구성요소를 묶는데 도움을 줄 것이고, 쉽게 이해하고 접근할 수 있도록 도와 줄 것이다.12.2. 각각의 UI 구성요소마다 접두사를 적용한다.간단한 목록이 아래에 있다. 닷넷은 다양한 컨트롤들이 제공되므로 더 많은 컨트롤(써드파티 컨트롤을 포함한)에 대한 표준을 정의해야 한다.            Control      Prefix      Control      Prefix                  Label      lbl      ListBox      lst              TextBox      txt      DataList      dtl              DataGrid      dtg      Repeater      rep              Button      btn      CheckBox      chk              ImageButton      imb      CheckBoxList      cbl              Hyperlink      hlk      RadioButton      rdo              DropDownList      ddl      RadioButtonList      rbl              Image      img      PlaceHolder      phd              Panel      pnl      Table      tbl              Validators      val      -      -      13. 파일 명은 클래스 명과 같아야 한다.예를 들어, 클래스 명이 “HelloWorld” 라면 파일명은 “HelloWorld.cs” 이어야 한다.14. 파일 명은 파스칼 표기법을 사용한다.메서드나 함수 이름은 반드시 동사이면서 소문자로 시작해 대소문자를 섞어 써야 한다.  getName()  computeTotalWidth()C++ 개발 커뮤니티에서 일반적인 용례이다. 이 형식은 변수 이름과 같지만 C++ 에서 함수는 형식상 변수와 이미 구별된다. 약어와 동의어를 이름으로 사용할 때는 반드시 대문자가 아니어야 한다.            좋은 예      나쁜 예                  exportHtmlSource();      exportHTMLSource();              openDvdPlayer();      openDVDPlayer();      기본 이름에 대해 모두 대문자를 사용하면 위에서 제시한 명명 규칙과 충돌한다. 이런 종류의 변수는 dVD, hTML 등으로 이름 지어야 하나 분명 가독성이 매우 나쁘다. 위의 예에서 보여준 다른 문제는 이런 이름을 다른 것과 붙여 사용할 때 가독성이 심각하게 나빠진다는 점이다. 즉, 약어 다음에 오는 단어가 원하는 만큼 돋보이지 않게 된다.Reference프로그램 코딩 시 네이밍 규칙과 들여쓰기",
        
        "url": "/dv/tips/2020/09/28/Naming-Rules-01-%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B4%80%EB%A1%80%EC%99%80-%ED%91%9C%EC%A4%80.html"
      }
      ,
    
      "dv-python-2020-09-28-jupyter-notebook-eb-8b-a8-ec-b6-95-ed-82-a4-ec-b6-94-ea-b0-80-html": {
        "title": "sublime text처럼 단축키 추가하기",
        "tags": "python",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "ReferenceSublime-style multiple cursors in Jupyter",
        
        "url": "/dv/python/2020/09/28/jupyter-notebook-%EB%8B%A8%EC%B6%95%ED%82%A4-%EC%B6%94%EA%B0%80.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-23-exception-handling-html": {
        "title": "22: Exception handling",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "예외 처리예외 처리를 사용하므로써 알고리즘이 마주할 수 있는 예외 상황에 대해 코드를 분리할 수 있다. 이 결과 알고리즘에 보다 집중할 수 있다.에러 만들기int main(){    vector&lt;int&gt; v{1, 2, 3, 4}    int num;    cin &gt;&gt; num;    cout &lt;&lt; v.at(num) &lt;&lt; endl;    return 0;}Output10=&gt; Errorvector size보다 큰 index를 넣을 경우, 프로그램이 멈춰버린다. 이렇게 될 경우 만드는 사람 입장에서는 어느 부분 때문에 에러가 났는지 찾기 어렵다.Try/catch그래서 우리는 예외를 처리하는 다음과 같은 구문을 활용한다.int main(){    vector&lt;int&gt; v{1, 2, 3, 4};    int num;    cin &gt;&gt; num;    try{        cout &lt;&lt; v.at(num) &lt;&lt; endl;    }    catch(exception&amp; e){        cout &lt;&lt; e.what() &lt;&lt; endl;        cout &lt;&lt; \"인덱스 오류가 발생!\" &lt;&lt; endl;    }    cout &lt;&lt; \"[program is still running!]\" &lt;&lt; endl;    return 0;}Output1알고 싶은 인덱스를 입력해주세요 :34[program is still running!]Program ended with exit code: 0Output2알고 싶은 인덱스를 입력해주세요 :10vector인덱스 오류가 발생![program is still running!]Program ended with exit code: 0인덱스를 넘어가는 값을 입력했을 때, 이 오류를 캐치해서 예외를 처리해 주었다. 또한, 예외처리 구문을 통해서, 프로그램이 제대로 마무리 되었다는 사실을 알 수 있다! 그렇기 때문에 예외를 통과했기 때문에 문제가 없음을 판단할 수 있다.사용법  예외를 throw 할 것 같은 곳에 try block으로 싼다.  예외가 발생 했을 경우에만 발생할 코드를 catch block 으로 싼다.  exception&amp; e 는 프로그램이 던지는 에러를 받아주는 객체이다.  try/catch 구문은 if 문 처럼 state가 한줄이더라도 꼭 {} 로 감싸줘야 한다.std::exception class  Standard exception class예외를 담당하는 기본 c++제공 클래스이다. 모든 예외 처리 클래스는 이 클래스를 상속받아서 작성된다. 따라서 다형성의 원리에 의해 어떤 에러를 던지더라도, 추상클래스인 exception class 로 받을 수 있다.Member functionsexception 클래스 멤버함수이 중에서 what() 이라는 함수가 중요하게 사용되는데, 어떤 예외이냐에 따라 이 what() 함수가 다르게 구성된다. 즉, override 를 통해 재정의해서 사용한다! 여기서는 사실 다른구문을 쓰지만 그건 밑에서 알아보자.vector container 함수를 사용하는 이유위의 예에서, vector의 index로 접근하는 부분을 바꿔보자.int main(){    vector&lt;int&gt; v{1, 2, 3, 4};    int num;    cin &gt;&gt; num;    try{        // 이 부분!        cout &lt;&lt; v[num] &lt;&lt; endl;    }    catch(exception&amp; e){        cout &lt;&lt; e.what() &lt;&lt; endl;        cout &lt;&lt; \"인덱스 오류가 발생!\" &lt;&lt; endl;    }    cout &lt;&lt; \"[program is still running!]\" &lt;&lt; endl;    return 0;}Output알고 싶은 인덱스를 입력해주세요 :34[program is still running!]Program ended with exit code: 0알고 싶은 인덱스를 입력해주세요 :101[program is still running!]Program ended with exit code: 0기존 에는 10을 넣었을 경우 에러를 출력했는데, 이번에는 에러가 뜨지 않는다 왜 그럴까? 이건 클래스 내부에서 에러를 발생하는 exception 객체를 throw 해주지 않아서 그렇다.클래스에서 예외 처리 구문 만들기예외 처리가 필요한 함수 만들기위에서는 try/catch 구문을 사용해 vector container 에서 발생하는 예외처리를 어떻게 받아서 표현하는지 알아보았다. 그렇다면 내가 함수나 클래스를 만들 때, 어떤 부분에서 에러가 날지를 규명해주는 것이 필요하다. 여기서는, file을 읽어, 벡터로 넣어주는 함수를 만들어 보았다. 이 때 만약 파일을 읽지 못할 경우 에러를 throw 하도록 만들었다.throw 구문vector&lt;int&gt; load_vector(string filename){    ifstream fin(filename);    if(!fin){        // 예외 처리 throw        throw FileNotFoundException(filename);    }    int num, value;    vector&lt;int&gt; result;    fin &gt;&gt; num;    for(int i = 0; i &lt; num; i++){        fin &gt;&gt; value;        result.push_back(value);    }    return result;}구문해석  예외 처리 throw특정 상황에 에러가 날 경우 우리는 에러를 던져줘야 한다. 이때 사용하는 것이 throw 구문이다.예외 처리 클래스 만들기그렇다면 FileNotFoundException 은 예외처리를 담당하는 클래스이므로, 위에서 말했듯, 예외 처리 클래스는 std::exception 클래스를 상속해서 만든다.class FileNotFoundException : public exception {    string message;public:    // 1.    FileNotFoundException(string _m): message(\"File not Found : \" + _m){}    // 2.    virtual const char* what() const throw() {        // 3.        return message.c_str();    }};구문 해석  생성자(constructor)member variable 로 갖고 있는, message에 담아준다.  what() override 하기.          virtual                  이 FileNotFoundException 클래스를 상속받는 다른 클래스가 있을 수 있기 때문에 써주었다.                    const                  what() 함수의 return type은 const char* 이다.          즉, 문자열을 리턴 값으로 갖는다는 것인데,이 리턴 값은 변할 수 없으므로 const 를 적어 명시적으로 써준다.                    what()                  override를 수행할 함수의 이름이다.                    const                  외부 함수에서 만든 객체를 불러올 때, callbyreference 로 가져올 경우 값을 변화 시킬 수 있다.          그래서 우리는 void print(const 클래스이름&amp; p) 이런식으로 가져오는데,          이 때 입력 파라미터의 값을 변화시키지 않으면서 reference 하겠다는 의도에서 const를 적게되면,          내가 만든 class 에서도 const를 적은 함수만 사용이 가능하다.          즉, 외부에서 const 상태로 사용하는 함수를 의미한다.          추가 정보는,14: this, operator overloading를 참고하자.                    throw()                  위에서 설명한 이 부분이 다른데 exception 클래스를 상속받을 때, what() 함수를 override 할때는, throw() 를 사용한다.          이는, 에러를 던진다는 의미에서 유래된 듯하다.                      string 인 message 를 char 로 만들어주자.main 에서 try/catch 구문이제 함수도 만들고, 예외처리 클래스도 정의했으니, try/catch 구문을 사용해서 나타내보자.int main(){    try{        vector&lt;int&gt; v = load_vector(\"values.dat\");    }// 1.   catch(FileNotFoundException&amp; e)    catch(exception&amp; e){        // 2.        cout &lt;&lt; e.what() &lt;&lt; endl;    }    return 0;}구문해석  주석처리한 부분을 보면, 원래 catch 구문에서는 예외 처리 객체를 받아줘야 한다.          즉, catch(FileNotFoundException&amp; e) 이런식으로 써줘야 하는데, ` catch(exception&amp; e)` 이렇게만 써줬다.      이 이유는 위에서 설명한 것과 같이 다형성 때문이다.        에러가 발생했을 때, 이 에러가 어떤 에러인지 what() 메서드로 보여준다.전체 코드#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;class FileNotFoundException : public exception {    string message;public:    FileNotFoundException(string _m): message(\"File not Found : \" + _m){}    const char * what() const throw() {        return message.c_str();    }};vector&lt;int&gt; load_vector(string filename){    ifstream fin(filename);    if(!fin){        throw FileNotFoundException(filename);    }    int num, value;    vector&lt;int&gt; result;    fin &gt;&gt; num;    for(int i = 0; i &lt; num; i++){        fin &gt;&gt; value;        result.push_back(value);    }    return result;}int main(){    try{        vector&lt;int&gt; v = load_vector(\"values.dat\");    }    catch(exception&amp; e){        cout &lt;&lt; e.what() &lt;&lt; endl;    }    return 0;}try/catch 구문의 작동 방식Findint Nearest catch Statementcatch의 동작 방식여러 개의 함수에 exception 과 try/catch 구문을 걸어놓을 경우, 가장 근접한 catch 구문을 찾아가서 실행한다.예제#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;// double throwvoid filter(vector&lt;int&gt;&amp; v, int i){    v.at(i)++;}void compute(vector&lt;int&gt;&amp; a){    for(int i = 0; i &lt; 6; i++){        try{            filter(a, i);        }        catch(exception&amp; ex){            cout &lt;&lt; \"******1번 catch********\" &lt;&lt; endl;            cout &lt;&lt; \"반복문이 중간에 멈췄습니다.\" &lt;&lt; endl;            cout &lt;&lt; \"when i =\" &lt;&lt; i &lt;&lt; endl;            cout &lt;&lt; \"**********************\" &lt;&lt; endl;//            throw ex;        }    }}int main(){    vector&lt;int&gt; list {10,20,30,40,50};    try{        compute(list);    }    catch(exception&amp; e){        cout &lt;&lt; \"******2번 catch******\" &lt;&lt; endl;        cout &lt;&lt; \"에러가 발생했습니다.\" &lt;&lt; endl;        cout &lt;&lt; e.what() &lt;&lt; endl;        cout &lt;&lt; \"**********************\" &lt;&lt; endl;    }    cout &lt;&lt; \"프로그램 종료\" &lt;&lt; endl;}Output******1번 catch********반복문이 중간에 멈췄습니다.when i =5**********************프로그램 종료Program ended with exit code: 0구문 해석  main 함수main 함수를 보게 되면, compute 함수를 호출하게 된다.  compute 함수compute 함수는 filter 함수를 호출한다.  filter 함수filter 함수를 수행하는 도중, i의 값이 size를 넘는 순간이 오고,exception 객체를 throw 한다.  프로그램은 왔던 길을 되돌아가며 가장 근접한 catch 문을 찾는다.이 경우 compute 함수에 있기 때문에, 이 catch 문을 실행한다.  main 함수로 돌아올 때는 throw가 다 해소됐고, 돌아오는 throw가 없으므로 catch 함수는 실행되지 않는다.double throw(Re-thorwing)그러면, main으로 돌아올 때도, 객체를 던져주면, 여러번의 catch 구문을 실행 시킬 수 있지 않을까?예제#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;// double throwvoid filter(vector&lt;int&gt;&amp; v, int i){    v.at(i)++;}void compute(vector&lt;int&gt;&amp; a){    for(int i = 0; i &lt; 6; i++){        try{            filter(a, i);        }        catch(exception&amp; ex){            cout &lt;&lt; \"******1번 catch********\" &lt;&lt; endl;            cout &lt;&lt; \"반복문이 중간에 멈췄습니다.\" &lt;&lt; endl;            cout &lt;&lt; \"when i =\" &lt;&lt; i &lt;&lt; endl;            cout &lt;&lt; \"**********************\" &lt;&lt; endl;            throw ex;        }    }}int main(){    vector&lt;int&gt; list {10,20,30,40,50};    try{        compute(list);    }    catch(exception&amp; e){        cout &lt;&lt; \"******2번 catch******\" &lt;&lt; endl;        cout &lt;&lt; \"에러가 발생했습니다.\" &lt;&lt; endl;        cout &lt;&lt; e.what() &lt;&lt; endl;        cout &lt;&lt; \"**********************\" &lt;&lt; endl;    }    cout &lt;&lt; \"프로그램 종료\" &lt;&lt; endl;}Output******1번 catch********반복문이 중간에 멈췄습니다.when i =5****************************2번 catch******에러가 발생했습니다.std::exception**********************프로그램 종료Program ended with exit code: 0잘 작동한다!",
        
        "url": "/dv/c++/2020/09/28/OOP-23-Exception-handling.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-22-algorithm-library-html": {
        "title": "21: algorithm Library",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "for_each()algorithm 라이브러리에는 다양한 함수가 있지만, 그 중에서 for_each() 함수에 대해서 알아보자.#include &lt;algorithm&gt;vector&lt;int&gt; v{1, 2, 3, 4, 5, 6, 7};다음과 같은 벡터가 선언되어 있을 때, 각 요소의 값을 실제로 1 증가시키기 위해서는 어떻게 해야할까? 각각의 요소를 reference 해서 불러온 뒤, 증가시켜주면 될 것이다.for(auto&amp; elem : v){    elem++;}그런데, 만약 다른 자료형이라면, 이 것을 일일히 다 쳐줘야 한다. 그래서 for_each() 함수가 존재한다.사용법for_each(시작 주소값, 끝 주소값, 함수);이 때 특정 객체의 시작주소값, 끝주소값을 받아오는 것을 begin() end() 함수로 배웠다. 그리고, 이 객체에 대해 순간적으로 우리가 어떤 작업을 한다면, 굳이 함수를 정의해놓지 않고, 람다함수로 집어넣을 수도 있을 것이다. 따라서 위에 구현한 코드는 다음과 같다.for_each(begin(v), end(v), [](int&amp; elem){elem++;});출력해보는 함수도 비슷하게 짤 수 있을 것이다.for_each(begin(v), end(v), [](int elem){cout &lt;&lt; elem &lt;&lt; \"\\t\";});transform()그런데 만약에 내가 어떤 작업을 한 뒤에, 다른 컨테이너에 넣어야 할 수 있다. 위에 있는 건 각 요소에 대해 reference 해서 값을 변화시켰다.바꾼 내용을 다른 객체에 반환해야 할수도 있다. 우리는 이럴 때, transform() 함수를 사용한다.사용법transform(소스_시작주소, 소스_끝주소, 목적지_시작주소, 함수);for_each() 와 비슷하게 사용하면 된다.vector&lt;int&gt; v2(v.size());transform(begin(v), end(v), begin(v2), [](int elem){return elem*elem;});copy()특정 주소에서 주소까지 값을 복사해서 올 수 있다. [시작 주소, 끝주소) 끝 주소에 해당하는 값은 복사하지 않는다.사용법copy(소스_시작주소, 소스_끝주소, 목적지 시작주소);vector&lt;int&gt; v3(3);copy(begin(v)+1, begin(v)+4, begin(v3));for_each(begin(v3), end(v3), [](int elem)-&gt;int{cout &lt;&lt; elem &lt;&lt; \"\\t\";});2 3 4",
        
        "url": "/dv/c++/2020/09/28/OOP-22-algorithm-library.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-21-functional-lambda-html": {
        "title": "21: functional, lambda function",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "functional libraryLambda function함수 안에서 부를 수 있는 Local function! 사실 정체는 객체이지만, 우리는 함수의 개념으로 갖다 쓴다!Usage[closure](입력 매개변수)-&gt;출력 type{내용}Local function 이기 때문에 만들어졌다가 리턴 후 사라진다.Example#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;functional&gt;using namespace std;int evaluate(int(*func)(int, int), int x, int y){    return func(x, y);}int main(){    // sum: [](int x, int y)-&gt;int{return x + y;}    cout &lt;&lt; evaluate([](int x, int y)-&gt;int{return x + y;}, 2, 3) &lt;&lt; endl;    // mult: [](int x, int y)-&gt;int{return x*y;}    // mult: [](int x, int y){return x*y;} 굳이 안적어도돼 너무 명확해서    cout &lt;&lt; evaluate([](int x, int y){return x * y;}, 2, 3) &lt;&lt; endl;    // lambda 함수를 바로 생성해서 호출    [](int x, int y){cout &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; endl;}(2,3);    auto f  = [](int x, int y)-&gt;int{return x - y;};    cout &lt;&lt; f(3, 5) &lt;&lt; endl;}evaluate 함수는 함수 포인터와, 인자 두개를 받아, 해당하는 함수를 리턴해주는 함수이다. main 함수 내에서 즉석으로 내가 원하는 함수를 만들고, evaluate 함수를 사용하고 싶다면, Lambda function 을 사용하면 된다!closure우리가 기존에 함수를 만들 때, 람다 함수를 사용할 때 우리는 이걸 함수처럼 사용한다. 즉, 입력 파라미터를 제외하고는 함수의 구현부에서 다른 변수를 사용할 수 없었다.하지만 람다함수의 경우, 입력 파라미터이외의 변수를 읽어올 수 있다. 람다 함수가 특정 함수의 지역 함수 처럼 사용되기 때문인데, 람다함수가 속해있는 함수의 변수를 가져와 사용할 수 있다. 이 점 때문에, 글의 도입부에서 람다함수의 정체는 객체라고 했던 것이다! 함수의 모양을 하고 있지만, 클래스 구성이 객체처럼 되어 있다.(뇌피셜) 사용예는 다음과 같다.int evaluate(int(*func)(int, int), int x, int y){    return func(x, y);}int main(){    int a;    cin &gt;&gt; a;    // [](int x, int y){return x*y;}    // [closure]: capturing variables    // [] 안에 변수를 넣으면 이 람다 함수내에서 사용할 수 있다.    // 원래는 인풋파라미터만 사용가능했는데 , 외부 변수를 가져올 수 있다는 것    // [a] : 변수 a를 call by value 로 함수에 전달    // [&amp;a] : 변수 a를 call by reference로 함수에 전달    // [=]: 모든 주위 변수를 call by value로 함수에 전달    // [&amp;]: 모든 주우 변수를 call by reference로 함수에 전달    cout &lt;&lt; evaluate([a](int x, int y){return a*x*y;}, 2, 3) &lt;&lt; endl;    return 0;}Function Object우리가 위에서 구현한 evaluate 함수에서, 함수 포인터로 첫번째 인자를 주었다. 그런데, 포인터를 사용해서 나타내는 것은 위험하므로, 우리는 이것을 표현할 수 있는 객체를 만들어 관리하는 것이 보다 안전하다. 이 것을 가능하게 하는 객체가 function 이다.사용방법function&lt;출력자료형&lt;입력자료형1, 입력자료형2...&gt;함수 이름int evaluate2(function&lt;int(int, int)&gt;func , int x, int y){    return func(x, y);}",
        
        "url": "/dv/c++/2020/09/28/OOP-21-functional-lambda.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-20-iterator-html": {
        "title": "20: Iterator (반복자)",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "Iterator반복자는 generic 함수이다. 즉, 일반적인 프로그래밍을 가능하게 하기위해 만들어진 전역함수이다. 우리는 배열을 다루기 위해 vector, array, list와 같은 것들을 사용했다.그런데, 이녀석들을 다루기 위해서는 이 세가지 객체에 어떤 method가 있는지 알아야 한다. 또한, 어떤 인풋이 들어오든간에, 클래스나 함수를 돌아가기 위해서는 특정 객체에 접근할 수 있는 일반적인 함수가 존재하는 것이 보다 편리하다. 그래서 Iterator 클래스를 만들고, 가장 많이 사용하는 몇개의 함수를 구현해놓았다.MethodIterator 객체에서 사용할 수 있는 메서드는 다음과 같이 7개이다.  *iter  iter++  iter--  iter1 == iter2  iter1 != iter2  begin(객체)  end(객체)이것들은 실제로 우리가 사용하는 연산자 가 아니다! 클래스 내부에서 함수 오버로딩을 통해 구현해 놓은 녀석들이다. 그러니 iter1 + iter2 와 같은 것은 불가능하다. begin , end 는 객체를 집어넣게될 경우, 처음 주소와 끝 주소를 가지는 iterator 객체를 리턴하는 함수이다. 포인터와 비슷하게 사용할 수 있다.Exampleiterator를 사용하지 않았을 때,#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    int ary[] = {1,2,3,4};    int *pBegin, *pEnd;    pBegin = ary;    pEnd = ary + 4;    for (int* pIter = pBegin; pIter != pEnd; pIter++){        cout &lt;&lt; *pIter &lt;&lt; endl;    }    cout &lt;&lt; endl;    return 0;}iterator를 사용할 때#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    vector&lt;int&gt; v{10, 20, 30, 40};    for(auto iter = begin(v); iter != end(v); iter++){        cout &lt;&lt; *iter &lt;&lt; '\\t';    }    cout &lt;&lt; endl;    return 0;}여기서 auto를 선언해준게 중요한데, begin 함수에 인풋에 따라 반환하는 iterator의 객체 자료형이 다르기 때문에, 자동으로 이 자료형을 인지할 수 있는 auto를 선언해준다. 아마 iterator 클래스는 template 를 사용하여 만들어져 있을 것이다. 따라서 iter 인스턴스가 end(v) 이기 전까지 증가시키며, 해당 주소의 요소를 출력하게 할 수 있다.Example2#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;template&lt;class T&gt;void print(const T&amp; iter_begin,const T&amp; iter_end){    for(auto iter = iter_begin; iter != iter_end; iter++)        cout &lt;&lt; *iter &lt;&lt; '\\t';    cout &lt;&lt; endl;}template&lt;class T&gt;void print_reverse1(const T&amp; iter_begin, const T&amp; iter_end){    auto iter = iter_end;    while(iter != iter_begin){        iter--;        cout &lt;&lt; *iter &lt;&lt; '\\t';    }    cout &lt;&lt; endl;}int main(){    vector&lt;int&gt; v1{1, 2,3,4};    list&lt;double&gt; l1{10.1, 10.2, 10.3};    int ary[] = {100, 200, 300, 400};    print(begin(v1), end(v1));    print(begin(l1), end(l1));    print(begin(ary), end(ary));    cout &lt;&lt; endl;    print_reverse1(begin(v1), end(v1));    print_reverse1(begin(l1), end(l1));    print_reverse1(begin(ary), end(ary));    cout &lt;&lt; endl;    return 0;}거꾸로 출력할 때, iter_end를 하나 줄여준 이유는, end() 함수가 해당객체의 다음 주소를 리턴하기 때문이다. 따라서 이 값부터 출력을 시도하게 되면, 쓰레기값이 출력되고 객체의 처음 요소는 출력되지 않는다. for문을 사용해서 reverse로 출력하기 위한 예제는 다음과 같다.template&lt;class T&gt;void print_reverse2(T iter_begin,T iter_end){    iter_end--;    iter_begin--;    for(auto iter = iter_end; iter != iter_begin; iter--){        cout &lt;&lt; *iter &lt;&lt; '\\t';    }    cout &lt;&lt;  endl;}이렇게 될 경우 레퍼런스로 인자를 가지고 올 수 없게 된다. 함수 안에서 iterator 객체의 주소를 줄인 후에 for문을 돌려야 하기 때문에, 우리는 deep copy를 한 이후 이 함수를 돌릴 수 있게 되는 한계를 가진다.",
        
        "url": "/dv/c++/2020/09/28/OOP-20-Iterator.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-19-list-container-html": {
        "title": "19: List Container",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "List이제껏 vector container 에 대해서 집중적으로 사용했는데, list container 역시 vector와 마찬가지로 많이 사용된다.Vector  장점 : search가 빠르다.  단점 : pop/ push 가 느리다.  요소의 내용이 바뀔일이 많이 없으면 Vector 사용List  장점 : search가 느리다.  단점 : pop/ push 가 빠르다.  요소의 내용이 바뀔일이 많으면 List 사용기본적으로 가지는 method는 같기 때문에, 쉽게 사용가능하다.#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main(){    list&lt;int&gt; myList{1,2,3,4};    char command;    int inputVal;    bool finished = false;    while(!finished){        cout &lt;&lt; \"I)nput, P)rint, L)ength, E)mpty, Q)uit : \";        cin &gt;&gt; command;        switch (command) {            case 'I':            case 'i':                cin &gt;&gt; inputVal;                myList.push_back(inputVal);                break;            case 'P':            case 'p':                for(auto elem:myList)                    cout &lt;&lt; elem &lt;&lt; '\\t';                cout &lt;&lt; endl;                break;            case 'L':            case 'l':                cout &lt;&lt; \"Number of items : \" &lt;&lt; myList.size() &lt;&lt; endl;                break;            case 'E':            case 'e':                myList.clear();                break;            case 'Q':            case 'q':                finished = true;                cout &lt;&lt; \"Exit the program\" &lt;&lt; endl;                break;            default:                cout &lt;&lt; \"Wrong command\" &lt;&lt; endl;                break;        }    }    return 0;}I)nput, P)rint, L)ength, E)mpty, Q)uit : I1I)nput, P)rint, L)ength, E)mpty, Q)uit : P1\t2\t3\t4\t1I)nput, P)rint, L)ength, E)mpty, Q)uit : LNumber of items : 5I)nput, P)rint, L)ength, E)mpty, Q)uit : EI)nput, P)rint, L)ength, E)mpty, Q)uit : PI)nput, P)rint, L)ength, E)mpty, Q)uit : QExit the programProgram ended with exit code: 0",
        
        "url": "/dv/c++/2020/09/28/OOP-19-List-container.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-18-generic-programming-html": {
        "title": "18: Generic Programming, Template",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "Generic Programmingvector 컨테이너를 보게되면, 다음과 같이 선언하게 되는데,vector&lt;int&gt; v(3, 0);vector&lt;double&gt; v(3, 10.3);자료형을 추가적으로 정해서 벡터 컨테이너를 만들 수 있게 되어있다. 벡터 역시 클래스로 구현이 되어 있을 텐데 이 때, 벡터라는 녀석을 생각해보면 여러개의 자료형에 대해 결국 같은 행위, 즉, 동적 배열을 할당 하는 역할을 담당하고 있다는 것을 알 수 있다. 그렇다면 결국은 함수 오버로딩 으로 구현이 되어 있다는 소리이다.bool less_than(int a, int b){return a &lt; b;}bool less_than(double a, double b){return a &lt; b;}위와 같이, less_than 함수는, 다른 자료형에 대해 같은 역할을 하는 함수이다. 그렇기 때문에 내가 클래스를 구현할 때, 다른 자료형이 들어오더라도 같은 역할을 하기 위해서는 이렇게 여러개의 자료형에 대해 정의를 일일히 해줘야하는 번거로움이 존재한다. 이렇게 귀찮은 것을 하지 않기 위해 우리가 사용할 수 있는 것이 template 이다.templatetemplate&lt;class T&gt;어떤 클래스를 구현하거나, 또는 함수를 사용하기 이전에 내가 자료형들이 묶여있는 template을 다음과 같이 선언해줄 경우, 우리는 각각의 다른 자료형을 구현할 필요 없이 T 클래스의 인자를 선언하므로써 쉽게 함수 오버로딩을 가능케 할 수 있다.T - &gt; int, double, object...따라서 위에 구현된 함수는 다음과 같이 쓸 수 있다. 만약 들어오는 자료형이 다르다면, 두개의 Template class도 사용할 수 있다.template &lt;class T, class V&gt;bool less_than(const T&amp; a, const T&amp; b){return a &lt; b;}a, b 변수에 들어올 수 있는 것은 간단한 int 자료형 부터, 클래스 객체까지 들어올 수 있기 때문에 우리는 reference 를 달아 참조로 가지고 오며, 또한 이 함수 안에서 각각의 변수는 변경하지 않을 것이므로 const를 달아 명시적으로 표현하자.또, 입력파라미터로 저렇게 템플릿 클래스를 사용해서 적어줬을 경우,. 함수를 호출했을 때, T클래스는 고정된다. 따라서 만약에 T 클래스의 value를 찾고 싶다면, auto 자료형을 써야한다. 밑의 예제에서 보도록 하자.Example 1int, double, float등 수를 다루는 자료형 전반에 대해 Sum 함수를 구현해 보자.#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;T sum(vector&lt;T&gt; v){    T result = 0;    for(auto elem : v){        result += elem;    }    return result;}Example 2이전에 구현했던 Point 클래스를 각 자료형을 인자로 받을 수 있도록 template 를 사용해서 구현해보자.#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class Point {private:    T x;    T y;public:    Point(T _x, T _y);    void setXY(T _x, T _y);    T getX();    T getY();    void print();};template&lt;class T&gt;Point&lt;T&gt;::Point(T _x, T _y) : x(_x), y(_y){}template&lt;class T&gt;void Point&lt;T&gt;::setXY(T _x, T _y){    x = _x;    y = _y;}template&lt;class T&gt;T Point&lt;T&gt;::getX(){return x;}template&lt;class T&gt;T Point&lt;T&gt;::getY(){return y;}template&lt;class T&gt;void Point&lt;T&gt;::print(){ cout &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; endl;}int main(){    Point&lt;int&gt; pt(1,2);    Point&lt;double&gt; pt2(1.1, 2.2);    pt.print();    pt2.print();    return 0;}Output1, 21.1, 2.2Program ended with exit code: 0Example 3#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;template &lt;class Iter&gt;int find_max(const Iter&amp; iter_begin,const Iter&amp; iter_end){    int max_idx = 0;    int idx = 0;    auto max = *iter_begin;    for_each(iter_begin, iter_end,             [&amp;](int elem){                 if(elem &gt; max){                     max = elem;                     max_idx = idx;                 }                 idx++;             }             );    return max_idx;}int main(){    vector&lt;int&gt; v1{1, 3, 5, 4, 7, 6};    vector&lt;double&gt; v2{1.1, 4.4, 3.3, 5.5, 2.2};    cout &lt;&lt; \"argmax(v1) : \" &lt;&lt; find_max(begin(v1), end(v1)) &lt;&lt; endl;    cout &lt;&lt; \"argmax(v2) : \" &lt;&lt; find_max(begin(v2), end(v2)) &lt;&lt; endl;    return 0;}",
        
        "url": "/dv/c++/2020/09/28/OOP-18-Generic-Programming.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-17-static-binding-dynamic-binding-header-file-html": {
        "title": "17: Static Binding, Dynamic Binding, Header File",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "Static Binding (정적 바인딩)#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Base{public:    void f(){cout &lt;&lt; \"Base::f()\" &lt;&lt; endl;}    virtual void vf() {cout &lt;&lt; \"Base::vf()\" &lt;&lt; endl;}};class Derived:public Base{public:    void f(){ cout &lt;&lt; \"Derived::f()\" &lt;&lt; endl;}    void vf() override { cout &lt;&lt; \"Derived::vf()\" &lt;&lt; endl;}};int main(){    Base base;    Derived derived;    base.f();    base.vf();    derived.f();    derived.vf();    return 0;}Base::f()Base::vf()Derived::f()Derived::vf()Program ended with exit code: 0우리가 여태껏 배웠던 상속에서 override , virtual 은 단지 상속을 받았다는 것을 명시하는 역할이라고 생각했다. 이렇게 우리가 알았던 상속을 단순하게 사용하는 방법을 정적 바인딩 이라 한다.코드를 보면, 내가 생성한 객체에 대해 엮여있는 함수를 정해주는데 있어 내가 선언해준대로 되었다. base 객체에 대해 base 클래스에서 정의된 멤버함수들만 사용가능하고, derived 객체에 대해서는 Derived 클래스에서 정의된 멤버함수들만 사용가능하다.Dynamic Binding (동적 바인딩)그런데, 우리가 두 클래스가 상속관계에 있다는 것을 안다면, 이 멤버함수를 자동으로 묶어줄 수는 없을까? 이제 override , virtual 의 강력한 기능을 알 수 있다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Base{public:    void f(){cout &lt;&lt; \"Base::f()\" &lt;&lt; endl;}    virtual void vf() {cout &lt;&lt; \"Base::vf()\" &lt;&lt; endl;}};class Derived:public Base{public:    void f(){ cout &lt;&lt; \"Derived::f()\" &lt;&lt; endl;}    void vf() override { cout &lt;&lt; \"Derived::vf()\" &lt;&lt; endl;}};int main(){    Base base;    Derived derived;    Base* pBase;    pBase = &amp;base;    pBase-&gt;f();    pBase-&gt;vf();    pBase = &amp;derived;    pBase-&gt;f();    pBase-&gt;vf();    return 0;}Base::f()Base::vf()Base::f()Derived::vf()Program ended with exit code: 0Base 클래스의 주소를 담는 포인터 변수 pBase 를 선언하고, 이 주소에 base 객체의 주소를 담고서, 두 멤버함수를 호출하니 당연히 Base 클래스의 함수들이 호출되는 것을 알 수 있다.그런데, derived 객체의 주소를 담으면, (부모 클래스에 자식 클래스를 넣을 수는 있다고 앞글에서 설명했다.) 이 때, 멤버함수는 Base의 f(), Derived 의 vf() 가 호출되었음을 알 수 있다.즉, 해당 객체의 멤버함수를 기본적으로는 Base 에서 가져온다. 하지만 Virtual 선언이 되어 있다면, 어떤 객체인지 파악후 그 객체의 멤버함수를 가져온다 이런 작업은, 프로그램이 실행되면서 묶일 수 밖에 없으므로, 동적 바인딩 이라 불린다.동적 바인딩의 의미우리는 이 기술을 사용해서, 서로 다른 자료형들을 하나의 벡터안에 넣어서 관리할 수 있다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Base{public:    void f(){cout &lt;&lt; \"Base::f()\" &lt;&lt; endl;}    virtual void vf() {cout &lt;&lt; \"Base::vf()\" &lt;&lt; endl;}};class Derived:public Base{public:    void f(){ cout &lt;&lt; \"Derived::f()\" &lt;&lt; endl;}    void vf() override { cout &lt;&lt; \"Derived::vf()\" &lt;&lt; endl;}};int main(){    Base* pBase;    vector&lt;Base*&gt; v{ new Base, new Derived, new Base};    pBase = new Derived;    v.push_back(pBase);    pBase = new Base;    v.push_back(pBase);    for (auto elem: v)        elem-&gt;vf();    return 0;}Base::vf()Derived::vf()Base::vf()Derived::vf()Base::vf()Program ended with exit code: 0Base 클래스의 주소를 담는 자료형을 기반으로 벡터를 만들고, 그 안에, 내가 원하는 클래스를 담으면, virtual override 구조에 따라서 자동으로 멤버함수가 결정된다!Pure virtual function (순수 가상 함수)virtual 을 선언할 때, 특별히 기본 Base 클래스에서는 기능을 정의하지 않고 파생 클래스에서 이 함수를 정의해서 사용할 때가 있는데 이때 선언하는 것이 순수 가상함수 이다.virtual print() = 0;순수 가상함수를 선언할 때는, base 클래스에서 이 함수의 작동이 없다는 것을 명시하기 위해서 뒤에 =0 을 추가로 달아준다. 이 표시가 있을 경우 우리는 파생 클래스로부터 이 함수를 필수적으로 정의해야한다. 또한 Base 클래스에서 위와 같이 선언했을 경우 main 함수에서 우리는 저 함수를 사용할 수 없다.abstract Class(추상 클래스)내가 파생클래스들로 무언가를 만들어 사용하고 싶을 때, 그 윗단계에서 이 함수들에 대한 개략적인 것들을 적어둔 상위 집합의 클래스를 만들 수 있을 것이다.이 때, 순수 가상함수들로 구성된 하나의 클래스를 추상클래스 라 부른다. 이렇게 관리할 경우 우리는 어떤 클래스들의 공통된 특징을 묶어서 관리할 수 있으므로 용이하다.Header File왜 사용하는가?C++ 코드를 작성하다가 보면, Class 내의 멤버변수, 멤버함수, 또 내가 만들어서 사용하는 사용자 정의 함수, main 함수등 결국 어떤 프로그램을 동작하고 싶은 건지 전체적 구조를 알기 어렵다는 점이 있다. 따라서 우리는 class를 정의하는 것은 hpp 확장자에, 그리고 그 클래스에 해당되는 멤버함수들은 cpp 확장자에, 프로그램이 동작하는 main 에는 지저분한 것을 없애고 큰틀만 두는 것이다. 이 때, 내가 만들어 놓은 hpp 를 #include 하고 사용하는 것이다.여태껏 &lt;&gt; 안에 적었던 것은, 기본적으로 c++에서 제공하는 라이브러리 이며, 이제부터 내가 만들어 사용하는 녀석들은 \"\" 안에 적어서 사용한다.main()////  main.cpp//  last_example////  Created by 최완식 on 13/05/2019.//  Copyright © 2019 최완식. All rights reserved.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include \"CText.hpp\"#include \"CFancyText.hpp\"#include \"CFixedText.hpp\"using namespace std;int main() {    vector&lt;Text*&gt; v{ new Text(\"Plain\"),        new FancyText(\"Fancy1\", \"&lt;\", \"&gt;\", \"-\"),        new FixedText };    Text* pText;    pText = new FancyText(\"Fancy2\", \"[\", \"]\", \"*\");    v.push_back(pText);    pText = new Text(\"Plain2\");    v.push_back(pText);    for (auto elem : v)        elem-&gt;append(\"A\");    for (unsigned i = 0; i &lt; v.size(); i++)        cout &lt;&lt; i &lt;&lt; \" : \" &lt;&lt; v.at(i)-&gt;get() &lt;&lt; endl;    return 0;}우리는, v라는 벡터안에 Text 객체, FanctText 객체, FixedText 객체를 넣을 것이다. FancyText 클래스는 Text를 상속받아 추가적인 텍스트를 추가한다. FixedText 클래스는 Text를 상속받지만 일관된 출력을 한다. 마지막으로 모든 객체는 Text 클래스로 부터 append 라는 멤버함수를 상속받으니, for문을 돌면서 A라는 문자를 다 추가한다.CText.hpp#pragma once#include &lt;string&gt;using namespace std;// Text.hclass Text {private:    string text;public:    Text(string _t);    virtual string get();    virtual void append(string _extra);};pragma once는 한 번 #include 된 파일은 다시 열지 않도록 하는 명령어 이다.CText.cpp#include \"CText.hpp\"// Text.cppText::Text(string _t) : text(_t) {}string Text::get() { return text; }void Text::append(string _extra) { text += _extra; }같은 이름을 가진 헤더파일을 cpp에서 include 하고 멤버함수를 작성한다.CFancyText.hpp#pragma once#include &lt;string&gt;#include \"CText.hpp\"using namespace std;class FancyText : public Text {private:    string left_brac;    string right_brac;    string connector;public:    FancyText(string _t, string _lb, string _rb, string _con);    string get() override;    void append(string _extra) override;};CFancyText.cpp#include \"CFancyText.hpp\"FancyText::FancyText(string _t, string _lb, string _rb, string _con) :Text::Text(_t), left_brac(_lb), right_brac(_rb), connector(_con) {}string FancyText::get() { return left_brac + Text::get() + right_brac; }void FancyText::append(string _extra) {    Text::append(connector + _extra);}CFixedText.hpp#include \"CText.hpp\"using namespace std;class FixedText : public Text {public:    FixedText();    void append(string _extra) override;};CFixedText.cpp#include \"CFixedText.hpp\"FixedText::FixedText() : Text::Text(\"FIXED\") {}void FixedText::append(string _extra) {    //NOOP}다시 main()#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include \"CText.hpp\"#include \"CFancyText.hpp\"#include \"CFixedText.hpp\"using namespace std;int main() {    vector&lt;Text*&gt; v{ new Text(\"Plain\"),        new FancyText(\"Fancy1\", \"&lt;\", \"&gt;\", \"-\"),        new FixedText };    Text* pText;    pText = new FancyText(\"Fancy2\", \"[\", \"]\", \"*\");    v.push_back(pText);    pText = new Text(\"Plain2\");    v.push_back(pText);    for (auto elem : v)        elem-&gt;append(\"A\");    for (unsigned i = 0; i &lt; v.size(); i++)        cout &lt;&lt; i &lt;&lt; \" : \" &lt;&lt; v.at(i)-&gt;get() &lt;&lt; endl;    return 0;}Output0 : PlainA1 : &lt;Fancy1-A&gt;2 : FIXED3 : [Fancy2*A]4 : Plain2AProgram ended with exit code: 0Binding 의 시각화vtable 이란 멤버함수를 동적으로 할당하는 변수이다. 어떤 객체를 넣느냐에 따라 다른 멤버함수가 할당되는 것을 볼 수 있다.Binding의 시각화",
        
        "url": "/dv/c++/2020/09/28/OOP-17-Static-binding-Dynamic-Binding-Header-file.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-16-inherence-html": {
        "title": "16: Inherence (상속)",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "전체적인 구조한번에 이해하기상속이 필요한 이유상속은 매우 유용하다. 이전에 클래스를 다뤘던 글을 다시 기억해보자. 13: class, object우리가 클래스를 사용하는 이유는, 쉽게 말해, 어떤 물체를 정의해서 사용하는 것이 더 합리적이라는 판단이 들어서이다. 함수만 가지고서 무언가를 만들기 보다는, 내가 물건을 정의하고 그 물건들을 실제로 만든뒤, 물건들로 다른 활동을 하는 것이 보다 쉽기 때문이다.이전에 사용했던 사진을 다시 사용해보면,class, object, instance간단하게 이렇게 정의할 수 있다. 물체를 정의하기 위해 만들어진 것이 클래스, 그 클래스를 기반으로 만들어질 대상이 객체, 실제로 만들어져 구체화 된 물체를 인스턴스라 부른다.그럼, 상속의 개념은 왜 필요할까? 위의 클래스 예시에서 리모컨 설계도는 굉장히 다양할 수 있다. TV 리모컨, 차 리모컨, 에어컨 리모컨,, 이렇게 다양한 리모컨이 있지만, 이녀석을 세상에 존재하는 하나의 물건(인스턴스)로 구현하기 위해서는, 각자에 맞는 설계도(Class)가 따로 필요하다. 하지만 이녀석들이 가지는 근본적인 특성은 모두 동일하다.이 설계도(Class)를 만들 때 있어서 보다 큰 집합 개념을 도입하면 어떨까? 더 큰 클래스에서 가지는 특성을 변형해서 다른 클래스를 만들면 어떨까? 이것이 바로 상속 이다.상속의 필요성이렇게 부모 클래스로 부터 파생된 다른 녀석들을 만들어 가져다 쓸 수 있다. 따라서 부모클래스는 자식클래스의 내용을 반드시 가질 수 밖에 없다. 그렇기 때문에 부모 클래스가 (A) 이고, 부모클래스로 부터 만들어진 파생 클래스가 (A’) 라 했을 때, 각각의 클래스로 부터 만들어진 객체가 (a, a’)이라 하면, 할당이 가능한 방법은 하나뿐이다.a = a';\t\t// 가능a' = a;\t\t// 불가능이렇게 부모는 자식의 내용을 일부 가지고 있기 때문에 없는 변수나, 함수에 관해서는 무시하고 있는 값만 할당 받으면 되지만, 자식 객체에 부모 객체를 할당 할 수 없다. 자식 객체가 가지는 변수는 부모객체가 가지고 있지 않기 때문에 어떤 값을 할당 받아야하는지 모호해지기 때문이다.Base 와 Derived 간 상속관계상속 Type과 속성Summary  Base : Private -&gt; 사용 불가  Base : Protected -&gt; Private  Base : Public -&gt; 상속 타입에 따라 변화!Example 1#include &lt;iostream&gt;using namespace std;class Base {public:    void print_base() { cout &lt;&lt; \"Base\" &lt;&lt; endl; }};class Derived : private Base{ // Base를 Private으로 받으니,    \t\t\t\t\t\t  // 이 클래스 내에서는 모두 Private으로 받는다.// 따라서 지금은 적혀 있지 않지만, 이 클래스의 private는 Base 클래스가// 가지는 public내의 변수와 함수를 갖는다.public:    void print_derived() {        Base::print_base();\t// 그렇기 때문에 여기서 Base 클래스의 함수를 사용할 수 있다.        \t\t\t\t\t// private이니까!        cout &lt;&lt; \"Derived\" &lt;&lt; endl; }};int main(){    Base base;    Derived derived;    base.print_base();    //derived.print_base();  이 부분은 에러가 뜬다.    \t\t\t\t\t //\tDerived 클래스에서는 print_base 함수가 Private 이다.    derived.print_derived();    return 0;}OutputBaseBaseDerivedProgram ended with exit code: 0Initialize List의 중요성지금까지 위에서 클래스를 상속하는데 있어, 기존 클래스에서 정의된 속성과, 파생 클래스에서 어떤 방식으로 상속을 받는지에 따라 사용할 수 있는 범위가 제한됨을 배웠다.그런데 보통 우리는 클래스를 작성할 때, Private에 이 클래스가 가지는 변수들을 정의하여 사용한다. 그렇기 때문에 내가 파생클래스를 작성 할때, 상속 속성을 Public 으로 준다고 하더라도, Private에 작성된 녀석은 사용할 수가 없다. 따라서 내가 만든 파생 변수가 기존의 클래스를 따와서 같은 변수들을 넣어줘야 함에도 그 변수에 접근할 수가 없다 는 문제가 발생한다.이 때, Initialize List가 중요한 이유가 나온다. 예제를 통해 알아보자.Example#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 부모 클래스의 생성자를 Public에 정의했다.class Text{private:    string text;public:    Text(string _t) : text(_t) {}};// 파생 클래스에서는 부모 클래스를 받아, 추가적인 기능을 구현하도록 한다.// 이 때 부모클래스의 Private는 파생클래스에서 직접적으로 사용할 수 없다.class FancyText: public Text{private:    // string text; 이 변수는 파생클래스에서 직접적으로 사용할 수는 없다.    // 하지만 상속 받았기 때문에 이 변수는 파생 클래스에서도 중요한 역할을 할 것이다.    // 그렇다면 파생 클래스를 선언할 때, 이 변수를 어떻게 받을 수 있을까?    string left_brac;    string right_brac;    string connector;public:    // 정답은 파생 클래스에서 생성자를 호출할 때, Initialize list를 사용하면 되는데,    // 사용자로 부터 초기값을 받을때, 그 값을 initialize list의 인자로 넘겨준다.    // 위의 부모 클래스의 생성자를 보게되면, Public으로 선언되었기 때문에,    // 파생 클래스에서 이 생성자를 가져다가 사용할 수 있다!!    FancyText(string _t, string _lb, string _rb, string _con):    Text::Text(_t), left_brac(_lb), right_brac(_rb), connector(_con){    }    // Text::Text(_t) 이 부분이 부모클래스의 생성자를 호출한 부분이다.    // 따라서 우리는 private로 선언되어 있는 부모클래스의 속성 부분을    // 간접적으로 생성자를 호출함으로써 초기화에 성공했다.};class FixedText : public Text{public:    FixedText() : Text::Text(\"FIXED\"){}    // 생성자를 호출할 수 있게 해준다는 것이 initialize list의 엄청난 장점!!!!};function overloading이름만 같은 함수를 의미한다. 입력 파라미터의 자료형, 입력 파라미터의 갯수, 출력파라미터의 자료형 등, 아무 상관이 없다. 하지만 함수 이름을 동일하게 작성했기 때문에 아마도 본질적으로 수행하는 내용은 동일 할 것이다. 따라서, 함수 오버로딩은, 하는 행동, 본질(A)이 동일한 녀석 이라고 생각하면 된다. 결국 같은 이름의 다른 함수들이 쌓이 고 있기 때문에 우리는 function overloading 이라 한다.int    sum(int x, int y),double sum(double x, double y)float  sum(float x, float y, float z)function overriding함수 오버라이딩은 상속의 특수한 경우에 해당되는데, base 클래스의 함수로 부터 상속받아 구체적이거나, 혹은 이 클래스에 맞는 방식으로 함수를 재정의 할 때 사용한다.즉, 같은 이름, 또 같은 입력파라미터를 받으나, 함수내의 작동에 있어서 함수 오버로딩 처럼 (A)의 본질을 따르기 보다는, A’ 혹은 B 와 같이 변경이 있을 수 있다. 상속을 받아 이녀석의 내용을 변경하고 있으므로, 원래 클래스의 함수에 내가 원하는 내용을 추가 혹은 올라타 고 있다. 따라서 function overloading 이다.Virtual, override우리는 함수 오버로딩을 할때, 부모 클래스로 부터 자식 클래스로 갈때, 변경될 수 있다는 것을 명시해주기 위해 Virtual 이라는 단어를 명시해주고, 또 자식클래스에서는 부모클래스로 부터 받았다는 것을 알려주기 위해 override 라는 단어를 사용한다.사실 프로그램을 구동하는데는 문제가 없지만,  유지보수  Polymorphism (다형성)을 위해 필수적이니 명시적으로 작성해주는 것을 습관들이자.소스코드 총 정리#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Text{private:    string text;public:    Text(string _t) : text(_t) {}    // 이 함수는 가상이며, 파생클래스에서 구체화 될것을 명시한다.    virtual string get(){ return text;}    virtual void append(string _extra) {text += _extra; }};class FancyText: public Text{private:    string left_brac;    string right_brac;    string connector;public:    FancyText(string _t, string _lb, string _rb, string _con):    Text::Text(_t), left_brac(_lb), right_brac(_rb), connector(_con){    }    // 부모 클래스로 부터 override 된 함수임을 명시해준다.    string get() override { return left_brac + Text::get() + right_brac; }    void append(string _extra) override{            Text::append(connector + _extra);        // 이 함수내용을 작성하는데 있어, text = text + connector + _extra;        // 이렇게 쓸 수 없다. 부모클래스의 text는 private로 선언되어 있기 때문이다.        // 그렇기 때문에 우리는 부모클래스에 정의된 public 특성의 함수로 접근해서 작성해야 한다.        }};class FixedText : public Text{public:    FixedText() : Text::Text(\"FIXED\"){}    void append(string _extra) override{        // no operation    }};int main(){    Text t1(\"Plain\");    t1.append(\"A\");    cout &lt;&lt; t1.get() &lt;&lt; endl;    FancyText t2(\"Fancy\", \"&lt;&lt;\", \"&gt;&gt;\", \"***\");    t2.append(\"A\");    cout &lt;&lt; t2.get() &lt;&lt; endl;    FixedText t3;    t3.append(\"A\");    cout &lt;&lt; t3.get() &lt;&lt; endl;//    t1 = t2; // 자식 클래스 내용은 부모에 넣을 수 잇음//    t2 = t1;    // 반대는 안댐//    return 0;//}OutputPlainA&lt;&lt;Fancy***A&gt;&gt;FIXEDProgram ended with exit code: 0",
        
        "url": "/dv/c++/2020/09/28/OOP-16-Inherence.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-15-friend-static-destructor-html": {
        "title": "15: friend, static, destructor",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "friend두 개의 클래스가 있을 때, 서로 만들어진 모든 멤버변수, 멤버함수를 공유하기 위해서 우리는 friend 라는 키워드를 사용할 수 있다.a 객체가 b 객체를 친구로 선언한다면 b객체는 a객체의 모든 변수와 함수값을 갖다가 사용할 수 있다. Private 까지 사용가능하다.#include &lt;iostream&gt;using namespace std;class Point{private:    int x;    int y;public:    Point(): x(0), y(0){}    Point(int _x, int _y): x(_x), y(_y) {}    void setXY(int _x, int _y){        this-&gt;x = _x;        this-&gt;y = _y;    }    int getX() const { return this-&gt;x; }    int getY() const { return this-&gt;y; }    Point operator + (Point&amp; pt){        Point result(this-&gt;x + pt.x, this-&gt;y + pt.y);        return result;    }    Point operator - (Point&amp; pt){        Point result(this-&gt;x - pt.x, this-&gt;y - pt.y);        return result;    }    Point operator = (Point&amp; pt){        this-&gt;x = pt.x;        this-&gt;y = pt.y;        return (*this);    }    // SpyPoint에 Point 클래스의 모든 정보를 넘겨준다.    friend class SpyPoint;};class SpyPoint{public:    void print_all_point_info(Point&amp; pt){        cout &lt;&lt; \"SpyPoint에 의해 출력됩니다.\" &lt;&lt; endl;        cout &lt;&lt; \"x : \" &lt;&lt; pt.x &lt;&lt; endl;        cout &lt;&lt; \"y : \" &lt;&lt; pt.y &lt;&lt; endl;        cout &lt;&lt; \"numCreatedObjects: \" &lt;&lt; pt.getNumCreatedObject() &lt;&lt; endl;    }};int main(){    Point pt1(1, 2), pt2(3, 4);    SpyPoint spyPt;    spyPt.print_all_point_info(pt1);    spyPt.print_all_point_info(pt2);    return 0;}OutputSpyPoint에 의해 출력됩니다.x : 1y : 2numCreatedObjects: 2SpyPoint에 의해 출력됩니다.x : 3y : 4numCreatedObjects: 2Program ended with exit code: 0static Members때때로는, 클래스의 객체들이 모두 공유하는 변수를 가지는 것이 용이하다. 전역변수와는 조금 다른 점이 있는데,  공통점 : 특정 함수나 클래스가 끝나고 나서 변수가 사라지지 않는다.  차이점 : 특정 클래스에 구속되어 있다.이것을 구현하고 싶으면 Static 키워드를 붙여주면 된다. 특이한 점은, 이 변수를 사용하기 전에 초기화는, 클래스 내부에서 하지 않고, 전역변수처럼 main 함수 밖에서 한다.#include &lt;iostream&gt;using namespace std;class Point{private:    int x;    int y;    // 선언!!    static int numCreatedObjects;public:    // 초기화시 개수를 하나씩 늘려줌    Point(): x(0), y(0){        numCreatedObjects++;    }    Point(int _x, int _y): x(_x), y(_y) {        numCreatedObjects++;    }    // public에서 이 숫자를 접근 할 수 있게 함수를 만들어줌.    static int getNumCreatedObject(){ return numCreatedObjects; }};// 여기서 초기화를 해준다!int Point::numCreatedObjects = 0;int main(){    Point pt1(1, 2);    cout &lt;&lt; pt1.getNumCreatedObject() &lt;&lt; endl;    Point pt2(3, 3);    cout &lt;&lt; pt1.getNumCreatedObject() &lt;&lt; endl;    cout &lt;&lt; pt2.getNumCreatedObject() &lt;&lt; endl;    return 0;}122pt1 과 pt2에 관련없이 생성된 객체의 개수만큼 반환되는 것을 알 수 있다.Class vs Structure구조체는 클래스와 비슷하다! 하지만 구조체는 Public 이 기본값이다! 하지만 요즘에는 많은 부분이 차이가 없어졌다. 여전히 그래도 class를 많이 사용한다.Destructor소멸자는 특별한 멤버함수이다. 객체가 생성되고, 소멸될 때 호출된다. 소멸자의 목적은, 컴퓨팅 자원의 절약에 있다. 객체가 생성되고 계속 남아있다면 메모리 자원을 많이 소모하게 된다.생성자와 마찬가지로 굳이 적어주지 않는다면, 기본적으로 소멸자는 호출되며 만약 내가 적어준다면 객체가 생성되고 소멸할 때마다 호출되어 내가 원하는 작업을 수행한다.내가 소멸자를 명시적으로 적어준다면 기본적으로 호출된 소멸자는 작동하지 않고, 내가 적어준 녀석만 작동한다.Example  생성자 : new, file open  소멸자 : delete, file closeclass Point{private:    int x;    int y;public:    Point(): x(0), y(0){}    Point(int _x, int _y): x(_x), y(_y) {}    ~Point(){        cout &lt;&lt; \"소멸되었습니다.\" &lt;&lt; endl;    }};int main(){    Point pt1(1,2);    return 0;}Output소멸되었습니다.지금까지 짠 소스코드 정리#include &lt;iostream&gt;using namespace std;class Point{private:    int x;    int y;    static int numCreatedObjects;public:    Point() : x(0), y(0) {        cout &lt;&lt; \"Point 객체 생성\" &lt;&lt; endl;        cout &lt;&lt; \"numCreatedObjects 1 증가\" &lt;&lt; endl;        numCreatedObjects++;    }    Point(int _x, int _y) : x(_x), y(_y) {        cout &lt;&lt; \"Point 객체 생성\" &lt;&lt; endl;        cout &lt;&lt; \"numCreatedObjects 1 증가\" &lt;&lt; endl;        numCreatedObjects++;    }    static int getNumCreatedObjects() {return numCreatedObjects;}    ~Point(){ cout &lt;&lt; \"소멸되었습니다.\" &lt;&lt; endl; }    void setXY(int _x, int _y){        this-&gt;x = _x;        this-&gt;y = _y;    }    int getX() const { return x;}    int getY() const { return y;}    Point operator + (Point&amp; pt){        Point result(this-&gt;x + pt.x, this-&gt;y + pt.y);        return result;    }    Point operator - (Point&amp; pt){        Point result(this-&gt;x - pt.x, this-&gt;y - pt.y);        return result;    }    Point operator = (Point&amp; pt){        this-&gt;x = pt.x;        this-&gt;y = pt.y;        return (*this);    }    friend class SpyPoint;};class SpyPoint{public:    void print_all_point_info(Point&amp; pt){        cout &lt;&lt; \"SpyPoint 클래스에 의해 해킹됨\" &lt;&lt; endl;        cout &lt;&lt; \"x : \" &lt;&lt; pt.x &lt;&lt; endl;        cout &lt;&lt; \"y : \" &lt;&lt; pt.y &lt;&lt; endl;        cout &lt;&lt; \"numCreatedObjects: \" &lt;&lt; pt.getNumCreatedObjects() &lt;&lt; endl &lt;&lt; endl;;    }};int Point::numCreatedObjects = 0;void print(const Point&amp; pt){    cout &lt;&lt; pt.getX() &lt;&lt; \", \" &lt;&lt; pt.getY() &lt;&lt; endl;}ostream&amp; operator &lt;&lt; (ostream&amp; cout, Point&amp; pt){    cout &lt;&lt; pt.getX() &lt;&lt; \", \" &lt;&lt; pt.getY();    return cout;}int main(){    cout &lt;&lt; \"%%%%%%%% OUTPUT %%%%%%%%%\" &lt;&lt; endl&lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; \"생성자 확인하기\" &lt;&lt; endl;    Point pt1(1, 2);    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; \"print 함수 확인하기\" &lt;&lt; endl;    print(pt1);    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; \"setXY 확인하기\" &lt;&lt; endl;    pt1.setXY(3, 3);    print(pt1);    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; \"new, delete, destructor 확인하기\" &lt;&lt; endl;    Point* pPt1 = new Point[5];    delete[] pPt1;    cout &lt;&lt; \"동적할당 이후 delete 를 사용하면 중간에 객체를 삭제할 수 있다.\" &lt;&lt; endl;    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; \"연산자 오버로드\" &lt;&lt; endl;    Point pt2(2, 3), pt3(3, 4);    Point pt4 = pt2 + pt3;    print(pt4);    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; \"Static 변수 확인\" &lt;&lt; endl;    cout &lt;&lt; pt1.getNumCreatedObjects() &lt;&lt; endl;    cout &lt;&lt; pt2.getNumCreatedObjects() &lt;&lt; endl;    cout &lt;&lt; pt3.getNumCreatedObjects() &lt;&lt; endl;    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; \"SpyPoint friend 확인\" &lt;&lt; endl;    SpyPoint spyPt;    spyPt.print_all_point_info(pt1);    spyPt.print_all_point_info(pt2);    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; \"객체가 모두 사용이 끝났으므로 소멸자가 호출됨\" &lt;&lt; endl;    return 0;}%%%%%%%% OUTPUT %%%%%%%%%생성자 확인하기Point 객체 생성numCreatedObjects 1 증가print 함수 확인하기1, 2setXY 확인하기3, 3new, delete, destructor 확인하기Point 객체 생성numCreatedObjects 1 증가Point 객체 생성numCreatedObjects 1 증가Point 객체 생성numCreatedObjects 1 증가Point 객체 생성numCreatedObjects 1 증가Point 객체 생성numCreatedObjects 1 증가소멸되었습니다.소멸되었습니다.소멸되었습니다.소멸되었습니다.소멸되었습니다.동적할당 이후 delete 를 사용하면 중간에 객체를 삭제할 수 있다.연산자 오버로드Point 객체 생성numCreatedObjects 1 증가Point 객체 생성numCreatedObjects 1 증가Point 객체 생성numCreatedObjects 1 증가5, 7Static 변수 확인999SpyPoint friend 확인SpyPoint 클래스에 의해 해킹됨x : 3y : 3numCreatedObjects: 9SpyPoint 클래스에 의해 해킹됨x : 2y : 3numCreatedObjects: 9객체가 모두 사용이 끝났으므로 소멸자가 호출됨소멸되었습니다.소멸되었습니다.소멸되었습니다.소멸되었습니다.Program ended with exit code: 0",
        
        "url": "/dv/c++/2020/09/28/OOP-15-friend-static-destructor.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-14-this-pointer-operator-overloading-html": {
        "title": "14: this, operator overloading",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "Pass by Reference내가 클래스를 만들고, 그 클래스를 바탕으로 객체를 만들었다. 이 때, 이 클래스에 연결되어 있는, 함수를 메서드라 했다. 그렇다면 이 만들어진 객체를 클래스 밖의 함수에서 input으로 받는다면 어떻게 해야할까?보통 클래스를 함수의 input parameter로 받을 때, reference로 받는다. 그 이유는 클래스가 저장되어 있는 메모리공간의 절약을 위해서이다.const외부 함수에서 내가 만든 객체를 부를 때, callbyreference로 값을 가져왔다면, 함수 내에서 값이 변경될 수 있다. 그렇기 때문에 함수를 만들 때, input 파라미터 앞에 const 를 달아준다.void print(const Point&amp; pt){    // 함수내용}그런데, 이 함수내에서 함수의 메서드를 사용한다면, 클래스를 정의하는데 있어서 추가적인 작업이 필요한데, const로 이 객체가 사용된다면 const라는 표시가 있는 method만 사용할 수 있다.// class 정의class Point {private:    int x;    int y;public:    Point(): x(0), y(0) {}    Point(int _x, int _y): x(_x), y(_y) {}    // 외부함수에 객체를 const로 넘겼을 때 사용할 수 있는 함수    int getX() const {return this-&gt;x;}    int getY() const {return this-&gt;y;}// 외부 함수 정의void print(const Point&amp; pt){    cout &lt;&lt; pt.getX() &lt;&lt; \", \" &lt;&lt; pt.getY() &lt;&lt; endl &lt;&lt; endl;}Pointer to Object클래스의 객체를 가리킬 때도 역시 포인터 변수를 선언했던 것과 똑같다.*우리가 예전에 포인터에 대해서 배울때, 해당 주소의 있는 값으로 점프 하라고 했을 때, * 를 사용하기로 했었다. 클래스 변수에 대해 이 것을 취하게 되면 클래스 객체 자체를 말하게 되고, 그제서야 우리는 멤버변수에 접근 할 수 있다.#include &lt;iostream&gt;using namespace std;class Point{public:    int x;    int y;};int main(){    Point pt1;    Point* ppt1;    pt1.x = 1;    pt1.y = 2;    ppt1 = &amp;pt1;    cout &lt;&lt; (*ppt1).x &lt;&lt; \", \" &lt;&lt; (*ppt1).y &lt;&lt; endl;    return 0;}1, 2-&gt;이번에는 포인터에서 멤버변수로 접근하는 다른 방법을 배워보자.#include &lt;iostream&gt;using namespace std;class Point{public:    int x;    int y;};int main(){    Point pt1;    Point* ppt1;    pt1.x = 1;    pt1.y = 2;    ppt1 = &amp;pt1;\tcout &lt;&lt; ppt1-&gt;x &lt;&lt; \", \" &lt;&lt; ppt1-&gt;y &lt;&lt; endl;    return 0;}1, 2포인터 변수(주소가 담긴) -&gt; 변수 이런식으로 적어주게 되면, “해당 포인터 주소로 가서, 변수 x의 값을 읽어!” 라는 뜻이 된다.동적할당 new, delete동적할당도 역시 할 수 있다. 동적할당은, 한 함수내에서 함수가 종료되기 전에도 값을 메모리 공간에 넣었다가 삭제할 수 있어 효율성을 높일 수 있는 방법이었다.#include &lt;iostream&gt;using namespace std;class Point{public:    int x;    int y;};int main(){    Point* pt1, pt2;    pt1 = new Point;    pt2 = new Point[5];    pt1.x = 1;    pt1.y = 2;    cout &lt;&lt; ppt1-&gt;x &lt;&lt; \", \" &lt;&lt; ppt1-&gt;y &lt;&lt; endl;    delete pt1;    delete pt2;    return 0;}주의사항동적할당을 해제하지 않으면, 함수가 종료된 이후에도 남아있으므로! stream 객체를 사용했을 때와 마찬가지로 꼭! delete로 할당을 해제 해주어야 한다!this Pointer  자기 자신의 주소값을 가져온다.우리가 class를 만들다보면, 특정 메서드를 사용했을 때, 자기자신을 내뱉어야 하는 경우가 발생한다. 이 것을 위해서 우리는 매서드 안에서 this 라는 포인터를 가지고 사용한다.#include &lt;iostream&gt;using namespace std;class Point{public:    int x;    int y;    // 메서드를 호출하면 자신의 멤버변수에 값을 할당한다.    void setXY(int _x, int _y){        this-&gt;x = _x;        this-&gt;y = _y;    }    // const 는 다른 함수에서 썼을 때 const로 받는 경우에 사용가능한 함수    //    int getX() const {return this-&gt;x;}    int getY() const {return this-&gt;y;}};Overloading같은 함수이름, 혹은 연산자를 사용하면서, 하나 이상의 정의가 가능한 방법이다.Function Overloading연산자 오버로딩과 방식이 동일하다. 밑에서 예를 든것을 보고 이해해보자.Operator OverloadingPoint operator +(Point&amp; pt){        Point result(this-&gt;x + pt.x, this-&gt;y + pt.y);        return result;    }pt1(1, 2);pt2(3, 4);pt1 + pt2;// 여기서 pt1은 + 연산자를 호출했을 때, 기본적으로 들어가는 input parameter가 된다.// 이녀석이 호출했다고 컴파일러는 처리한다.// 따라서 이녀석이 호출했기 때문에 + 연산자에 안에서// 호출한 녀석의 멤버변수를 가지고 쓰기 위해서는 this 포인터로 접근하면 된다.4, 6이 연산자는, Point 객체를 리턴하고 ‘+’ operator 에 대해서, 오른쪽에 Point 변수를 reference로 받는다. 받은 Point 객체에 대해, result 라는 Point 객체를 만들고, 초기값에 pt1의 멤버변수 x와 나중에 나온 pt2의 x를 더한값을 result의 멤버변수 x로 할당한다. 같은 원리로 result의 멤버변수 y도 할당한다. 그리고 Point 객체 result를 반환한다.Point operator = (Point&amp; pt){        this-&gt;x = pt.x;        this-&gt;y = pt.y;        return (*this);    }// 연산자의 왼쪽에 있는 객체가 호출했다고 생각한다.// 그때의 그 객체를 나타내는 게 여기서 this 포인터.// 그래서 호출한 객체의 x에 받은 input의 x를 할당한다.// 같은 방식으로 y도 수행한다.pt1(1, 2);pt2(3, 4);pt3 = pt1 + pt2;// 오른쪽에 계산된 값을 왼쪽에 할당한다.외부에서 정의한 operator overloading클래스 내부에서 모든 연산자 오버로딩을 하기 힘들 수 있다. 왜냐하면, 다른 객체를 클래스 내부에서 정의하게 되기 때문이다. 이렇게 될 경우 코드가 지저분해지고, 의존성이 생길 수 있다. 따라서 우리는 클래스 외부에서 함수를 정의하고 이것이 클래스와 연관 되어 있다고 알려주는 방식을 사용한다. 이것은 friend 에서 배워보기로 하고 일단은 외부에서 정의하는 방법을 알아보자.ostream&amp; operator &lt;&lt;(ostream&amp; cout, Point&amp; pt){    cout &lt;&lt; pt.getX() &lt;&lt; \", \" &lt;&lt; pt.getY();    return cout;}기본적으로 operator는 왼쪽과 오른쪽 두개의 파라미터를 받는다. 첫번째 파라미터는, 연산자 왼쪽에 놓인 객체, 두번째 파라미터는, 연산자 오른쪽에 놓인 객체를 말한다. 이 연산자 오버로딩을 말로 설명해보면,  이 연산자는 ostream의 객체를 reference 로 리턴한다.  &lt;&lt; 연산자를 사용하며,  이 왼쪽에는 ostream 의 객체를 cout이란 이름으로 callbyreference한다.  오른쪽에는 Point 객체를 pt라는 이름으로 callbyreference 한다.  그렇게 했을 때, cout으로 각각을 출력하고,  cout 객체를 리턴한다.여기서, 우리가 cout 객체로 여러번 출력이 가능한 이유는, cout 객체를 반환 하기 때문이라는 것을 알 수 있다. 같은 원리로, int, double과 같은 모든 자료형에 대해 연산자 오버로딩 의 방식으로 위와 같이 선언되어 있다. 함수 오버로딩도 위와 같은 방식으로 구현되어 있다.여기까지 구현한 전체 코드#include &lt;iostream&gt;using namespace std;class Point{private:    int x;    int y;public:    Point(): x(0), y(0){}    Point(int _x, int _y): x(_x), y(_y) {}    void setXY(int _x, int _y){        this-&gt;x = _x;        this-&gt;y = _y;    }    int getX() const { return this-&gt;x; }    int getY() const { return this-&gt;y; }    Point operator + (Point&amp; pt){        Point result(this-&gt;x + pt.x, this-&gt;y + pt.y);        return result;    }    Point operator - (Point&amp; pt){        Point result(this-&gt;x - pt.x, this-&gt;y - pt.y);        return result;    }    Point operator = (Point&amp; pt){        this-&gt;x = pt.x;        this-&gt;y = pt.y;        return (*this);    }};void print(const Point&amp; pt){    cout &lt;&lt; pt.getX() &lt;&lt; \", \" &lt;&lt; pt.getY() &lt;&lt; endl &lt;&lt; endl;    // 만약 x, y를 public 으로 선언했다면 다음도 같은 코드    // cout &lt;&lt; pt.x &lt;&lt; \", \" &lt;&lt; pt.y &lt;&lt; endl &lt;&lt; endl;}ostream&amp; operator &lt;&lt; (ostream&amp; cout, Point&amp; pt){    cout &lt;&lt; pt.getX() &lt;&lt; \", \" &lt;&lt; pt.getY();    return cout;}int main(){    // print 사용, const    Point pt1(1, 2);    print(pt1);    // 동적할당, 해제, new, delete    Point* pPt2 = new Point(10,20);    print(*pPt2);        // -&gt; 사용        cout &lt;&lt; pPt2-&gt;getX() &lt;&lt; \", \" &lt;&lt; pPt2-&gt;getY() &lt;&lt; endl &lt;&lt; endl;    delete pPt2;    // 연산자 오버로딩    Point pt3(5, 6), pt4(7, 8);    Point pt5 = pt3 + pt4;    cout &lt;&lt; pt3 &lt;&lt; endl;    cout &lt;&lt; pt4 &lt;&lt; endl;    cout &lt;&lt; pt5 &lt;&lt; endl;    return 0;}",
        
        "url": "/dv/c++/2020/09/28/OOP-14-this-pointer-operator-overloading.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-13-class-object-html": {
        "title": "13: class, object",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "What is Class?  설계도.우리는 클래스라는 개념을 왜 도입했을까? C++에서 함수가 태어나게 된 이유도 분리해서 관리하기 위함이었다.그런데 함수로 계속해서 나눠서 하는데 한계가 찾아온 것! 함수에 들어가는 입출 파라미터가 특정 데이터 타입에 연관되어 필요하다는 사실을 알아냈다.실제로 우리가 어떤 물건을 생각해 보면, 해당 물건(객체)는 물건의 용도에 따라 할 수 있는 행동(method)가 정해져 있다. 따라서 우리는 어떤 객체인지를 밝히고, 그 객체가 할 수 있는 함수를 정의해 놓는 것이 보다 실제적인 접근이다. 이 때 클래스 의 개념은 신이 무언가를 만들때 어떻게 만들지 생각해놓은 설계도 라 생각하면 된다.Class, object, instanceClass 생성 방법Member data실제 세상에 비유하면 물체를 만드는 행위에 해당한다. 해당 클래스를 선언할 때, 기본으로 어떤 값을 가지고서 동작을 할 것인지 정의한다.Member function물체에 대한 행동을 정의하는 부분이다. 함수를 선언하듯 적어주면 된다.Private, public클래스를 만드는 행위는, 특정 물체에 대해 설계도를 만드는 것과 동일하므로, 사용자 지향적이어야 한다.예를 들어 리모컨을 설계한다고 했을 때, 사용자는 입력 신호와 출력 결과물만 알면 되지, 그 중간에 작용하는 다른 변수에 대해 제어할 필요가 없다.따라서 클래스를 만드는 설계자 입장에서 클래스 내에서만 작동하는 private 구간과 클래스 밖에서 접근가능한 public 구간으로 나눠관리할 필요가 있다.Constructor우리가 물건을 떠올리면, 다른 물건들이 세상에는 존재하지만 공통점을 가진다. 예를 들어 리모컨이라 한다면, 보통 10개 정도의 숫자버튼과, 전원버튼 정도가 기본적으로 달려있는 모습을 떠올릴 것이다. 이와 마찬가지로, 사용자가 특정 객체를 사용할 때, 기본적으로 가져야 하는 값이 존재한다. 그래서 우리는 이걸 설정할 수 있게, 혹은 기본값을 가질 수 있게 만들어 주어야 한다. 이것을 생성자 라 한다.Public 밑에 선언을 하고 사용하는데, 이 때 일반적인 함수의 모양과 다르게 Output 이 없다. 또한, 사용하는 문법이 조금 다르다. 기억해 둘 필요가 있다.ExampleExample 1#include &lt;iostream&gt;using namespace std;class Point {// 클래스를 구성하고 있는 변수를 Member variable 이라 한다.private:    // x, y 변수는 내부에서만 사용되고, 함수로 이 변수를 제어하는 방향으로 코딩하는 것이 좋음.    int x;  // 클래스 내부에서만 사용가능    int y;// 클래스를 구성하고 있는 함수를 Member Function(Method) 이라 한다.public:     // 클래스 외부에서도 사용가능    void setXY(int _x, int _y) {        x = _x;        y = _y;    }\t\t\t\t\t\t\t// pt1.x = 1 과 같이 직접적으로 접근하기보다는 함수로 변경시킨다.    \t\t\t\t\t\t\t// 이렇게 함수를 실행해서 값을 할당해준다.    int getX() {return x;}\t\t// 값을 가져올 때도 이렇게 함수를 만들어서 가져온다.    int getY() {return y;}    \t\t\t\t\t\t\t// 출력하는 함수도 새로 만들어준다.    void print(){        cout &lt;&lt; \"(\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; endl;    }};int main(){    Point pt1, pt2;\t\t\t\t// Point라는 클래스로 부터 객체 2개를 만든다.//    pt1.x = 1;\t\t\t\t// x, y를 public 에서 선언했다면 실행가능한 코드이다.//    pt1.y = 2;    pt1.setXY(1, 2);\t\t\t// 생성된 객체 pt1의 값을 할당한다.    cout &lt;&lt;  pt1.getX() &lt;&lt; endl;\t\t// pt1의 x값을 가져와서 출력한다.//    cout &lt;&lt; pt1.x &lt;&lt; \", \" &lt;&lt; pt1.y &lt;&lt;endl;\t\t// public 으로 선언했다면 가능한 코드    pt1.print();\t\t\t\t\t\t// pt1 값을 출력해라    pt2.print();    int temp = pt1.getX();\t\t\t\t// 값을 할당하는 방법    cout &lt;&lt; temp &lt;&lt; endl;    return 0;}Example 2#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Account {private:    string name;    string id;    double balance;public:    // constructor    // 생성자의 이름은 class의 이름과 같다.    // output이 없다.    // 초기화를 담당하는 함수 (생성자)    // 아무 것도 입력이 안되었을 때 초기값    Account():    \tname(\"초기값이름\"), id(0000), balance(0){    }    // 사용자가 하고 싶은 초기값을 설정하고 싶을 때,    Account(string _name, string _id, double _bal):        name(_name), id(_id), balance(_bal){            // 초기화가 진행될 때 동작되는 함수가 들어가는 공간            // 마이너스 통장하는 게 아니므로 잔고가 음수면 오류를 발생시킨다.            if (balance &lt; 0){                cout &lt;&lt; \"Error, negatice balance\" &lt;&lt; endl;                balance = 0;            }        }    // Method    // 예금할 때,    void deposit(int _amt){        balance += _amt;    }    // 출금할 때, 잔고보다 출금금액이 많으면 false를 반환    bool withdraw(int _amt){        if( balance - _amt &lt; 0)            return false;        // 출금이 가능하면 잔고에서 값을 빼고 true 반환        else{            balance -= _amt;            return true;        }    }    void print(){        cout &lt;&lt; setw(10) &lt;&lt; name &lt;&lt; setw(10) &lt;&lt; id &lt;&lt;  setw(10) &lt;&lt; balance &lt;&lt; endl;    }};int main(){    Account ac1(\"최완식\", \"0316\", 5000);    ac1.print();    ac1.deposit(2000);    ac1.print();//    ac1.withdraw(3000);//    ac1.print();    if(!ac1.withdraw(10000))        cout &lt;&lt; \"잔액 부족\" &lt;&lt; endl;    ac1.print();    ac1.withdraw(5000);    ac1.print();    return 0;}Example 3사용자의 계좌정보를 기억하고, 이름별, 아이디별, 잔고별 정렬을 해서 출력해주는 프로그램을 만들어보자. 먼저 설명이 적힌 코드부터 보고 가자.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Account{public:    std::string name;    int id;    double balance;};void add_account(std::vector&lt;Account&gt;&amp; accts){    std::string name;    int number;    double amount;    cout &lt;&lt; \"Enter name, account number, and account balance: \";    cin &gt;&gt; name &gt;&gt; number &gt;&gt; amount;    Account acct;    acct.name = name;    acct.id = number;    acct.balance = amount;    accts.push_back(acct);}void print_accounts(const std::vector&lt;Account&gt;&amp; accts){    int n = (unsigned int)accts.size();    for (int i = 0; i &lt; n; i++)        cout &lt;&lt; accts[i].name &lt;&lt; \", \" &lt;&lt; accts[i].id &lt;&lt; \", \" &lt;&lt; accts[i].balance &lt;&lt; endl;}void swap(Account&amp; er1, Account&amp; er2){    Account temp = er1;    er1 = er2;    er2 = temp;}bool less_than_by_name(const Account&amp; e1, const Account&amp; e2){    return e1.name &lt; e2.name;}bool less_than_by_id(const Account&amp; e1, const Account&amp; e2){    return e1.id &lt; e2.id;}bool less_than_by_balance(const Account&amp; e1, const Account&amp; e2){    return e1.balance &lt; e2.balance;}void sort(std::vector&lt;Account&gt;&amp; db, bool (*comp)(const Account&amp;, const Account&amp;)){    // 참조변수 db로 vector를 가져오고,    // comp라고 부를 특정 함수의 시작주소를 bool 포인터 변수에 담는다.    // 그리고 그 시작주소에 있는 함수는    // Account 자료형을 가지는 변수를 참조해서 가져온 녀석 두개를 입력 파라미터로 받는다.    // db의 총 사이즈를 담아 둔다. 벡터이므로 unsigned int로 받아주어야 한다.    int size = (unsigned int)db.size();    // 10 크기인 배열이라면, 0~8까지 i는 움직인다.    for(int i = 0; i &lt; size - 1; i++){        // 그리고 해당 인덱스가 가장 작은 값이라 가정한다.        int smallest = i;        // i의 다음 번째부터 끝까지 하나씩 비교한다.        for (int j = i + 1; j &lt; size; j++)            if(comp(db[j], db[smallest]))                // 비교는 사용자가 어떤 파라미터를 기준으로 비교함에 따라서 달라져야 한다.                // 여기서 함수포인터를 입력 파라미터로 받은 것이 효과를 발휘한다.                // 특정 함수에 대해서 가장 작을 것이라고 생각했던 smallest 인덱스의 값과                // 현재 j인덱스의 값을 비교한다.                // comp의 후보가 될 수 있는 함수들                // (less_than_by_name, less_than_by_id, less_than_by_balance)                // 의 리턴 값은 모두 boolian 이다.                // 그리고 두번째 파라미터 값이 클 때, True 이다.                // 따라서 이 if 문이 실행되기 위해서는 내가 작다고 가정한 smallest 인덱스가                // j 인덱스 보다 클 때 실행되며, 우리는 smallest 인덱스가 j가 되어야 함을 알 수 있다.                smallest = j;        \t// 나머지 경우는 smallest 인덱스가 여전히 가장 작은 값을 가지므로 내비두면 된다.        // 만약에 위의 조건문이 실행되었다면        // smallest가 이전의 인덱스와 달라졌을 것이다.        // 이때 우리는 실제 i 인텍스에서와 smallest 인덱스의 값을 바꿔줘야 한다.        if (smallest != i)            swap(db[i], db[smallest]);    }}int main(){    // 자료형이 Account 클래스인 벡터를 선언하고 이것의 이름을 customers라 하자.    std::vector&lt;Account&gt; customers;    char cmd;    bool done = false;    do{        cout &lt;&lt; \"[A]dd [N]ame [I]D [B]alanc [Q]uit ==&gt; \";        cin &gt;&gt; cmd;        switch(cmd){            case 'A':            case 'a':                add_account(customers);                break;            case 'P':            case 'p':                print_accounts(customers);                break;            // 함수이름이 포인터이므로 함수이름자체를 넘겨준다.            case 'N':            case 'n':                sort(customers, less_than_by_name);                print_accounts(customers);                break;            case 'I':            case 'i':                sort(customers, less_than_by_id);                print_accounts(customers);                break;            case 'B':            case 'b':                sort(customers, less_than_by_balance);                print_accounts(customers);                break;            case 'Q':            case 'q':                done = true;                break;        }    }while(!done);}이제 설명이 없는 코드이다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Account{public:    std::string name;    int id;    double balance;};void add_account(std::vector&lt;Account&gt;&amp; accts){    std::string name;    int number;    double amount;    cout &lt;&lt; \"Enter name, account number, and account balance: \";    cin &gt;&gt; name &gt;&gt; number &gt;&gt; amount;    Account acct;    acct.name = name;    acct.id = number;    acct.balance = amount;    accts.push_back(acct);}void print_accounts(const std::vector&lt;Account&gt;&amp; accts){    int n = (uint32_t)accts.size();    for (int i = 0; i &lt; n; i++)        cout &lt;&lt; accts[i].name &lt;&lt; \", \" &lt;&lt; accts[i].id &lt;&lt; \", \" &lt;&lt; accts[i].balance &lt;&lt; endl;}void swap(Account&amp; er1, Account&amp; er2){    Account temp = er1;    er1 = er2;    er2 = temp;}bool less_than_by_name(const Account&amp; e1, const Account&amp; e2){    return e1.name &lt; e2.name;}bool less_than_by_id(const Account&amp; e1, const Account&amp; e2){    return e1.id &lt; e2.id;}bool less_than_by_balance(const Account&amp; e1, const Account&amp; e2){    return e1.balance &lt; e2.balance;}void sort(std::vector&lt;Account&gt;&amp; db, bool (*comp)(const Account&amp;, const Account&amp;)){    int size = (uint32_t)db.size();    for(int i = 0; i &lt; size - 1; i++){        int smallest = i;        for (int j = i + 1; j &lt; size; j++)            if(comp(db[j], db[smallest]))                smallest = j;        if (smallest != i)            swap(db[i], db[smallest]);    }}int main(){    std::vector&lt;Account&gt; customers;    char cmd;    bool done = false;    do{        cout &lt;&lt; \"[A]dd [N]ame [I]D [B]alanc [Q]uit ==&gt; \";        cin &gt;&gt; cmd;        switch(cmd){            case 'A':            case 'a':                add_account(customers);                break;            case 'P':            case 'p':                print_accounts(customers);                break;            case 'N':            case 'n':                sort(customers, less_than_by_name);                print_accounts(customers);                break;            case 'I':            case 'i':                sort(customers, less_than_by_id);                print_accounts(customers);                break;            case 'B':            case 'b':                sort(customers, less_than_by_balance);                print_accounts(customers);                break;            case 'Q':            case 'q':                done = true;                break;        }    }while(!done);}",
        
        "url": "/dv/c++/2020/09/28/OOP-13-class-object.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-12-array-vector-html": {
        "title": "12: Array, Vector (정적배열, 동적배열)",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "What is Array?직접적으로 값을 순차적으로 매핑한다. C언어에서 오래된 기술이고, 객체가 아니다. 처음에 배열의 크기를 지정하고 선언하는 정적 배열(static Array)이 있고, 배열의 크기를 유동적으로 조절할 수 있는 동적 배열(Dynamic Array)이 있다.배열도 함수 포인터와 마찬가지로, 특정 배열을 내가 선언하게 되면 배열의 이름으로 선언해준 변수는 포인터 이다.정적배열 (Static Array)메모리 공간에서 배열 원소의 배치#include &lt;iostream&gt;using namespace std;int main(){    int ary[3] = {1, 2, 3};    cout &lt;&lt; ary &lt;&lt; endl;    cout &lt;&lt; endl;    cout &lt;&lt; ary[0] &lt;&lt; endl;    cout &lt;&lt; ary + 0 &lt;&lt; endl;    cout &lt;&lt; *(ary+0) &lt;&lt; endl;    cout &lt;&lt; endl;    cout &lt;&lt; ary[1] &lt;&lt; endl;    cout &lt;&lt; ary + 1 &lt;&lt; endl;    cout &lt;&lt; *(ary+1) &lt;&lt; endl;    cout &lt;&lt; endl;    cout &lt;&lt; ary[2] &lt;&lt; endl;    cout &lt;&lt; ary + 2 &lt;&lt; endl;    cout &lt;&lt; *(ary+2) &lt;&lt; endl;    return 0;}0x7ffeefbff4fc10x7ffeefbff4fc120x7ffeefbff500230x7ffeefbff5043Program ended with exit code: 0각각의 주소를 간단하게 나타내고, 이것을 표로 나타내보면,배열과 메모리Array element 접근, 출력 방법#include &lt;iostream&gt;using namespace std;int main(){    int ary[] = {1,2,3,4,5};    for(int i = 0; i &lt; 5; i++){        cout &lt;&lt; a[i] &lt;&lt; endl;    }    return 0;}이번에는 이 배열을 함수의 인자로 받아 출력해주는 print 함수를 만들어보자.#include &lt;iostream&gt;using namespace std;void print(const int *ary, int length){\t\t// 이 함수 내에서 ary는 변화하지 않음을 의미함.    for(int i = 0; i &lt; length; i++){        cout &lt;&lt; *(ary + i) &lt;&lt; \"\\t\";    }    cout &lt;&lt; endl;}int main(){    int ary[] = {1,2,3,4,5};    print(ary, 5);    return 0;}이번에는 이 배열을 함수의 인자로 받아 모든 요소의 합을 구해주는 sum 함수를 만들어보자.#include &lt;iostream&gt;using namespace std;int sum(int* begin, int* end){\t// 인자로 넘긴 값이 주소이기 때문에 포인터 변수로 받아준다.    int result = 0;    for(int* i = begin; i &lt; end; i++){\t\t// 포인터 변수의 시작점부터 루프를 돌려야 하므로        \t\t\t\t\t\t\t\t\t// i도 포인터 변수로 잡아준다.        result += *i;    }    return result;}int main(){    int ary[] = {1,2,3,4,5};    int* begin, *end;\t// int 자료형의 주소를 받는 포인터 변수 두개를 선언한다.    begin = ary;\t\t// 배열의 시작주소를 포인터 변수 begin에 받는다.    end = ary + 5;\t\t// 배열의 끝주소를 end에 받는다.    cout &lt;&lt; sum(begin, end) &lt;&lt; endl;\t// 두 주소를 넘겼을 때, 출력 값을 받아 화면에 띄운다.    return 0;}while 문도 한번 사용해보자.#include &lt;iostream&gt;using namespace std;int sum(int* begin, int* end){    int* curr;    curr = begin;    int result = 0;    while(curr != end){        result += *(curr);        curr++;    }    return result;}int main(){    int ary[] = {1,2,3,4,5};    int* begin, *end;    // int 자료형의 주소를 받는 포인터 변수 두개를 선언한다.    begin = ary;        // 배열의 시작주소를 포인터 변수 begin에 받는다.    end = ary + 5;        // 배열의 끝주소를 end에 받는다.    cout &lt;&lt; sum(begin, end) &lt;&lt; endl;    // 두 주소를 넘겼을 때, 출력 값을 받아 화면에 띄운다.    return 0;}지금까지 진행한 예제에서 ary[] 를 선언할 때, 크기가 정해진 녀석을 넣어주었다. 이런 것을 정적 배열이라하고, 배열의 크기를 조정할 수 없다.#include &lt;iostream&gt;using namespace std;int main(){    const int length = 5;    int ary[length];    return 0;}정적 배열은 이렇게 배열의 크기를 선언하는 변수 length를 만들 때, 이 값은 constant로 만들어 주어야 한다. 만약 int length = 5 와 같이 선언해준다면, 값이 바뀔 수 있으므로 오류를 뱉는다.동적배열 (Dynamic Array)#include &lt;iostream&gt;using namespace std;int main(){    int size;    cout &lt;&lt; \"Size : \";    cin &gt;&gt; size;    int* dyary;    dyary = new int [size];        // 동적 배열 생성    // 입력 받기    for(int i = 0; i &lt; size; i++){        cin &gt;&gt; dyary[i];    }    // 출력 하기    int *curr = 0;    int* begin, *end;    begin = dyary;    end = dyary + size;    curr = begin;    while(curr != end){        cout &lt;&lt; *(curr) &lt;&lt; \"\\t\";        curr++;    }    cout &lt;&lt; endl;    // 배열 삭제하기    delete[] dyary;    return 0;}OutputSize : 31231\t2\t3Program ended with exit code: 0Matrix 만들기#include &lt;iostream&gt;using namespace std;int main(){    double dMatrix[2][3] = {    {1,2,3},        {4,5,6}    };// 또는 이렇게 선언해도 된다.//    dMatrix[0][0] = 1; dMatrix[0][1] = 2; dMatrix[0][2] = 3;//    dMatrix[1][0] = 4; dMatrix[1][1] = 5; dMatrix[1][2] = 6;    for (int row = 0; row &lt; 2; row++){        for(int col = 0; col &lt; 3; col++){            cout &lt;&lt; dMatrix[row][col] &lt;&lt; \"\\t\";        }        cout &lt;&lt;  endl;    }    return 0;}2차원 배열에서 포인터의 관계p[i]  =  *(p+i);p[j][i] = *(*(p+j) + i)결국 1차원 메모리 공간에 나열되어 있는 요소들의 주소값들의 관계를 정의해 놓은 것이다.문자열에서 문자 찾기#include &lt;iostream&gt;using namespace std;bool find_char(const char *s, char c){    while(*s != '\\0'){        if(*s == c)            return true;        s++;    }    return 0;}int main(){    const char* ch = \"phrase\";    for (char c = 'a'; c &lt;= 'z'; c++){        cout &lt;&lt; \"[\" &lt;&lt; c &lt;&lt; \"] is \";        if(!find_char(ch, c))            cout &lt;&lt; \"Not \";        else            cout &lt;&lt; \"    \";        cout &lt;&lt; \"in \" &lt;&lt; ch &lt;&lt; endl;    }    return 0;}  main 에서 \"phrase\" 라는 문자열의 첫번째 주소를 char 형 포인터 변수 ch에 담는다.  반복문 안에서 선언된 char c 는 a~z 의 문자값을 가지는데,  만약 이 문자열이 \"phrase\" 안에 있다면 공백을, 없다면 Not 을 출력하도록 만들자.  그럼 해당 문자열이 있는지 없는지를 판단해줄 함수를 밖에 만들건데,  이때 입력 파라미터를 문자열의 시작 주소를 가지고 있는 ch 와 검사할 문자 c 를 넘겨주자.  ch 는 문자열 포인터 변수이므로 char* 로 선언해서 받아주고,  c 는 복사해서 받아오자.  받아온 주소 s 의 값으로 점프한 *s 는 문자열의 제일 첫번째 값인 p 를 나타내고 있을 것이다.  이제 우리는 이 값이 NULL('\\0') 이 아니면 돌아가는데,  만약에 추가로 입력받은 c 의 값과 같다면 TRUE를, 아니면 FALSE를 반환한다.  이제 출력값에 따라 제어하면 된다.추가로 문자열이 구성될 때 컴퓨터는 마지막 '\\0' NULL 을 기준으로 구분한다.What is Vector Container?  메모리의 블락을 관리해주는 객체  자동으로 메모리를 할당해주는 배열  벡터에 들어가는 자료형은 모두 동일해야 한다.vector의 구조Vector 선언 방법  헤더파일 추가  namespace 추가 // std:: 사용  벡터 선언#include &lt;iostream&gt;using namespace std;int main(){    vector&lt;int&gt; vec_a;\t// 이름만 선언함    vector&lt;int&gt; vec_b(10);\t// 최초 크기 10으로 선언함    vector&lt;int&gt; vec_c(10, 8);\t// 최초 크기 10, 초기화 8로 선언함    vector&lt;int&gt; vec_d{10, 20, 30, 40}\t// 4개 요소로 벡터를 만듦    return 0;}vector 선언과 시각화벡터 인덱싱배열과 동일하게 0~size -1 의 범위를 가진다.Vector primary Methodv.front();\t\t\t// 맨 앞 값을 읽어온다.v.back();\t\t\t// 맨 뒤 값을 읽어온다.v.push_back();\t\t// 맨 뒤에 값을 집어 넣는다.v.pop_back();\t\t// 맨 뒤값을 읽어오고 지운다.v.at(index_value);\t// v[index_value]와 동일하다.\t\t\t\t\t// 하지만 메소드를 사용하는 것이 쓰면서 생기는 오류를 방지하는데 유용하다.v.size();\t\t\t// 벡터의 크기를 가져온다.\t\t\t\t\t// 함수의 반환값이 unsigned int 이므로 이 값을 쓰는데 있어서\t\t\t\t\t// unsigned int로 받아주어야 한다.Vector Example#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void print(vector&lt;int&gt;&amp; v){    for(unsigned int i = 0; i &lt; v.size(); i++){        cout &lt;&lt; v[i] &lt;&lt; \"\\t\";        // 또는        // cout &lt;&lt; v.at(i) &lt;&lt; \"\\t\";    }    cout &lt;&lt; endl;}int main() {    vector&lt;int&gt; v{10, 20, 30};    cout &lt;&lt; \"값 바꾸기\" &lt;&lt; endl;    cout &lt;&lt; v[0] &lt;&lt; \", \" &lt;&lt; v[1] &lt;&lt; endl;    v[0] = 1000;    cout &lt;&lt; v[0] &lt;&lt; \", \" &lt;&lt; v[1] &lt;&lt; endl;    cout &lt;&lt; \"push_back\" &lt;&lt; endl;    v.push_back(2000);    print(v);    cout &lt;&lt; \"pop_back\" &lt;&lt; endl;    v.pop_back();    print(v);    return 0;}Output값 바꾸기10, 201000, 20push_back1000\t20\t30\t2000pop_back1000\t20\t30Program ended with exit code: 0값 넣기/ 출력하기 다른 방법int main(){    vector&lt;double&gt; v(3);    for (double elem : v)        cin &gt;&gt; elem;    // v 벡터 값을 복사한후 하나씩 출력함    for (double elem : v)        cout &lt;&lt; elem &lt;&lt; '\\t';    cout &lt;&lt; endl;    // v 벡터 값을 reference 해서 출력함    for (double&amp; elem : v)        cout &lt;&lt; elem &lt;&lt; '\\t';    cout &lt;&lt; endl;    return 0;}벡터를 사용한 소수 찾기#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool is_prime(int num){    if (num &lt; 2)        return false;    for(int i = 2; i &lt; num; i++){        if(num % i == 0)            return false;    }    return true;}vector&lt;int&gt; primes(int low, int up){    vector&lt;int&gt; vec;    for(int i = low; i&lt;= up; i++){        if(is_prime(i)){            vec.push_back(i);        }    }    return vec;}int main(){    int lower = 10, upper = 100;    vector&lt;int&gt; v_prime = primes(lower, upper);    for(int elem : v_prime)        cout &lt;&lt; elem &lt;&lt; '\\t';    cout &lt;&lt; endl;    return 0;}Output11\t13\t17\t19\t23\t29\t31\t37\t41\t43\t47\t53\t59\t61\t67\t71\t73\t79\t83\t89\t97Program ended with exit code: 0벡터를 사용해 매트릭스 만들기#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    // vector&lt;int&gt;를 자료형으로 가지는 벡터를 선언    // 가장 바깥 쪽에 있는 벡터는 크기 2, 그리고 안의 요소는 크기가 3인 vector&lt;int&gt;로 초기화한다.    vector&lt;vector&lt;int&gt;&gt; v(2, vector&lt;int&gt;(3));    // 입력    for (vector&lt;int&gt;&amp; row : v)        for(int&amp; elem : row)            cin &gt;&gt; elem;    // 출력    for(vector&lt;int&gt;&amp; row : v){        for(int&amp; elem : row){            cout &lt;&lt; elem &lt;&lt; '\\t';        }        cout &lt;&lt; endl;    }    return 0;}",
        
        "url": "/dv/c++/2020/09/28/OOP-12-Array-Vector.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-11-pointer-function-pointer-html": {
        "title": "11: Pointer, Function Pointer",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "What is pointer포인터는 먼저 자료형으로 선언할 수 있다. 각각의 자료형에 대해 * 를 달게 되면 선언할 수 있다. 이 의미를 말로 파악하는 것이 중요한데, int* p 와 같은 경우, 특정 자료형이 int인 변수의 주소를 받을 수 있는 포인터 변수 p를 생성해라 로 생각 할 수 있다.char* c 와 같은 경우, 특정 자료형이 char인 변수의 주소를 받을 수 있는 포인터 변수 c를 생성해라로 판단하면 된다. 그렇다면 어떤 식으로 메모리 공간에 할당이 될까?#include &lt;iostream&gt;using namespace std;int main(){    int x;    x = 4;    int* p;    p = &amp;x;    cout &lt;&lt; p &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; *p &lt;&lt; endl;    return 0;}메모리와 할당이렇게 메모리 공간에 자리잡게 된다. 이때 p의 주소의 있는 값으로가서, 그 값을 출력하게 하는 방법은 포인터 변수 p에 * 를 달면 가능하다. 해당 주소로 점프 를 한다고 이해하면 직관적이다.Output0x044, 4이것을 그림으로 좀더 직관적으로 이해해보자.포인터 시각화여기서 가장 핵심적으로 생각해야 하는 부분은, 포인터 변수를 선언한 뒤에 꼭 이 변수가 가리키는 주소를 할당해주어야 한다는 것이다.PassingByAddress이제까지 함수호출에 관해 Callbyvalue, Callbyreference와 같은 것을 배웠다. 그런데 이제 포인터를 배우게 되면, 함수의 인자를 포인터 변수로 선언하고, 값을 넘길 때 주소 를 넘겨줄 수 있다.함수를 호출하고 나면, 메모리 공간에 저장된 두 변수의 값을 변경하는 Swap 함수를 만들어보자.#include &lt;iostream&gt;using namespace std;void swap(int* var1, int* var2){    int temp = *var1\t// var1의 주소로 점프한 값을 temp에 저장해라    *var1 = *var2;\t\t// var1의 주소로 점프한 값에 var2의 주소로 점프한 값을 할당해라    *var2 = temp;\t\t// var2의 주소로 점프한 값에 temp의 값을 넣어라.}int main(){    int a = 4, b = 5;    cout &lt;&lt; a &lt;&lt; \",\" &lt;&lt; b &lt;&lt; endl;    swap(&amp;a,&amp;b);    cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; endl;    return 0;}Output4, 55, 4Function Pointer함수 포인터? 함수역시 포인터로 구성되어 있다는 사실을 모른다면 당황스러울 수 있다. 우리가 함수를 호출한다는 것은, 컴파일 이후 특정 메모리 공간에 정의되어 있는 행의 위치로 가서 읽어오라는 뜻이다.그러기 위해서는 함수호출을 했을 때, 그 위치로 가야한다는 의미이고, 결국은 메모리의 주소를 알아야 한다는 결론을 얻을 수 있다. 따라서 우리가 함수의 이름을 설정하고 나면, 이 함수의 이름은 포인터이다.즉, 컴파일 이후 메모리 공간에 생성된 일련의 작업 행위가 적힌 곳의 시작 위치 주소를 가지고 있다. 이 구조를 알고 있다면 우리는 특정 다른 함수를 짤때, 파라미터로 이 함수의 시작 주소를 넣어 더 고차원적인 프로그래밍을 가능하게 할 수 있다.함수 포인터 사용법함수가_반환하는_자료형 (*함수포인터로_사용할_변수_이름)(인풋파라미터의_자료형, 인풋파라미터의_자료형, ...)Example#include &lt;iostream&gt;using namespace std;int add(int a, int b){    return x + y;}int multiply(int a, int b){    return x*y;}int evaluate(int (*f)(int, int), int x, int y){    return f(x, y);\t\t// main 으로부터 함수의 시작주소를 포인터 변수 f로 받고,    \t\t\t\t\t// 그 함수의 인풋으로 x, y를 준 값을 반환해라.}int main(){    cout &lt;&lt; add(2, 3) &lt;&lt; endl;    cout &lt;&lt; multiply(2, 3) &lt;&lt;  endl;    cout &lt;&lt; evaluate(&amp;add, 2, 3) &lt;&lt; endl;    cout &lt;&lt; evaluate(&amp;multiply, 2, 3) &lt;&lt; endl;}Output5656",
        
        "url": "/dv/c++/2020/09/28/OOP-11-pointer-function-pointer.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-10-rand-srand-html": {
        "title": "10: String library, rand(), srand()",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "String libraryMethod#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main(){    string word = \"good\";    word.length();\t// 길이 리턴    word.empty();\t// 빈 문자열인지 1, 0값 리턴    word.clear();\t// 문자열 삭제    word += \"-bye\";\t// 더하기 가능    word[0];\t\t// h    word[word.length() - 1];\t// 마지막 단어 i    word.find(\"a\"); \t// 해당 문자열이 없으면 string::npos 리턴    return 0;}substrstring word = \"good-bye\";word.substr(2, 5);substrrand()rand()는 난수를 발생시키는 함수이다. 하지만 사실 자연적으로 발생하는 랜덤이라는 현상을 컴퓨터 내에서 구성하기는 쉽지 않다. 따라서 이미 저장된 난수표로 부터 이 값들을 불러오게 되는데, 이것을 기반으로 값을 불러오는 것이 rand() 이다.#include &lt;iostream&gt;using namespace std;int main(){    cout &lt;&lt; rand() &lt;&lt; endl;    cout &lt;&lt; rand() &lt;&lt; endl;    cout &lt;&lt; rand() &lt;&lt; endl;    cout &lt;&lt; rand() &lt;&lt; endl;    return 0;}// output4118467633426500아무런 세팅을 하지 않는다면 기본 저장된 난수표에서 이것을 가져온다. 이 난수표를 세팅하는 것을 seed를 정한다고 하는데, 기본 값은 1이다. 따라서 내가 rand() 를 여러번 치더라도 항상 같은 값이 순차적으로 출력될 것이다.그러면 정말 랜덤은 어떻게 만들 수 있을까? 이 시드값 자체를 계속해서 새로운 값을 넣어주면 된다. 그러면 계속해서 새로운 값을 주는 방법에는 어떤것이 있을까? 이 시드값에 현재 시간(초) 를 대입해주는 것이다. 이 때 ctime library 를 사용하는데, time() 함수를 사용하면, 1970년 1월 1일부터 현재까지의 누적 시간(초)를 반환하기 때문에 프로그램 실행시마다 완전히 새로운 시간값을 입력할 수 있다.srand()이 시드값을 설정할 수 있게 해주는 함수는 srand() 이다. (set random) 코드를 만들어보면,#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;int main(){    srand((unsigned int)time(0));    cout &lt;&lt; rand() &lt;&lt; endl;    cout &lt;&lt; rand() &lt;&lt; endl;    cout &lt;&lt; rand() &lt;&lt; endl;    cout &lt;&lt; rand() &lt;&lt; endl;    return 0;}srand() 의 파라미터는 unsigned int 타입의 값이다. 그렇기 때문에 반환된 time() 의 값을 형변환 해줘야 한다.원하는 범위의 수 얻기#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;int main(){    srand((unsigned int)time(0));    // 0 ~ 99 의 난수    int nRandom0 = rand() % 100;    // 1 ~ 100 의 난수    int nRandom1 = rand() % 100 + 1;    return 0;}모듈러 연산을 통해서 원하는 범위의 값을 얻자!성적 계산 후 출력하는 프로그램  데이터 파일로 저장되어 있는 파일을 읽어서  평균을 낸 뒤,  범위에 따라 성적을 산출하는 프로그램을 만든다.#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;using namespace std;bool getStu(ifstream &amp;fin, int &amp;id, int &amp;exam1, int &amp;exam2, int &amp;exam3){    fin &gt;&gt; id &gt;&gt; exam1 &gt;&gt; exam2 &gt;&gt; exam3;    if(!fin)        return false;    return true;}void calcAvgGrade(int exam1, int exam2, int exam3, int &amp;avg, char &amp;grade){    avg = (exam1 + exam2 + exam3)/3;    if(avg &gt;= 90)        grade = 'A';    else if(avg &gt;=680)        grade = 'B';    else        grade = 'F';    }void writeStu(ofstream &amp;fout, int &amp;id, int &amp;avg, char &amp;grade){    fout &lt;&lt; setw(4) &lt;&lt; id &lt;&lt; setw(4) &lt;&lt; avg &lt;&lt; setw(4) &lt;&lt; grade &lt;&lt; endl;}int main(){    // 파일을 읽고, 각각의 값을 받는데,    // 파일안에는 id exam1 exam2 exam3 식으로 저장되어 있음    // 평균 1+ 2 + 3/ 3 grade 계산    // id avg grade 저장    ifstream fin(\"ch7STUFL.DAT\");    ofstream fout(\"output.txt\");    int id, exam1, exam2, exam3, avg;    char grade;    while(getStu(fin, id, exam1, exam2, exam3)){        calcAvgGrade(exam1, exam2, exam3, avg, grade);        writeStu(fout, id, avg, grade);    }    fin.close();    fout.close();    return 0;}output.txt  90  90   A  89  89   B  81  81   B  79  79   F  69  69   F  60  60   F  59  59   F",
        
        "url": "/dv/c++/2020/09/28/OOP-10-rand-srand.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-09-file-input-output-html": {
        "title": "09: File Input &amp; Output (파일입출력)",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "fstreamReading from file#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;int main(){    string line;    ifstream myfile(\"input.txt\");    if (myfile.is_open()){        while(getline (myfile, line)){\t// string의 함수 getline   \t\t\t\t\t\t\t\t\t\t// myfile 에서 1줄씩 읽어들여 line 스트링 변수에넣는다.            \t\t\t\t\t\t\t// 없으면 0을 반환한다.            \t\t\t\t\t\t\t// 있으면 1을 반환한다.            cout &lt;&lt; line &lt;&lt; endl;        }        myfile.close();    }    else {        cout &lt;&lt; \"unable to open file\";    }    return 0;}Writing to file#include &lt;iostream&gt;#include &lt;fstream&gt;int main(){    ofstream myfile(\"output.txt\");    myfile &lt;&lt; \"writing this to a file.\\n\";    myfile.close();    return 0;}Formatting Data#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;int main(){    ofstream fout(\"output.txt\");    int a = 123;    double b = 12.12345678;    fout.width(15);\t// 값을 출력하는데 있어 기본 칸 크기    fout &lt;&lt; a &lt;&lt; endl;    fout.width(15);    fout.precision(10);    fout &lt;&lt; b &lt;&lt; endl;    fout.close();    return 0;}            12312.12345678cin.unsetf()cin.unsetf(ios::skipws);\t// 파일을 읽을 때 공백 문자가 나오면 버린다.",
        
        "url": "/dv/c++/2020/09/28/OOP-09-File-Input-Output.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-08-selection-repetition-html": {
        "title": "08: Selection and Repetition",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "기존에 작업한 글이 있어 링크로 대체한다.  선택문  반복문 1  반복문 2iomanip library기본적으로 iostream 라이브러리로 출력을 하게되면, 왼쪽 정렬이다. 그리고 내가 원하는 칸에 정렬하기가 힘든데,이 라이브러리를 불러오고,sd::cout &lt;&lt; std::setw(10) &lt;&lt; endl;이런식으로 쳐주면, 10개의 칸중 오른쪽에 정렬되어 출력된다.//         1//        10//       100locale library1000단위로 끊어준다!std::cout.imbue(std::locale(\"\"));while  보통 무한 루프 돌릴 때 많이 쓴다.  왠만한 건 다 for 루프break  while 탈출  유효성 검사후 탈출Continue  이 이후를 수행하지말고 처음으로 돌아가라  보통 loop 랑 함께 사용함.do-while  먼저 실행하고 조건문 판단  보통 입력을 먼저 받아야 하는 무한루프에서 사용하는 경향이 있음for  너무 많이 사용해서 생략Switch  조작에 관련된 것  프로그램 종료할 때 사용  if 문보다 뭔가 명확한 것일 때 사용하면 좋음",
        
        "url": "/dv/c++/2020/09/28/OOP-08-Selection-Repetition.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-07-function-5-html": {
        "title": "07: Functions #5 - CallbyValue, CallbyReference",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "참조변수와 일반변수의 사용의 차이점을 알았다면, main 함수가 동작하는 도중 다른 함수를 호출할때, 그 함수의 인자 역시 두 종류가 있음을 알 수 있다. 마찬가지로 일반변수와, 참조변수를 사용할 수 있다.두 변수의 값을 바꾸는 함수 swap 을 main 함수에서 호출하는 상황을 가정하고 비교해보자.Swap_callbyValue#include &lt;iostream&gt;using namespace std;int swap(int a, int b){    int temp = a;    a = b;    b = temp;    return 0;}int main(){    int x = 5, y = 10;    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl;    swap(x, y);    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl;    return 0;}출력// x = 5, y = 10// x = 5, y = 10왜 같은 값이 출력될까?main 함수에서 swap 함수를 호출했을 때, x , y 값이 swap 함수에 들어가고, 이 값은 각각 a , b 에 복사 된다. 따라서 swap 함수 안에서는 복사된 a, b 안에 들어간 값이 서로 바뀌게 되고, swap 함수가 종료된 후에 이 값은 사라진다. **결국 내가 원한 결과인 x , y 는 바뀌지 않는게 당연하다. 이렇게 값이 복사되어 함수를 호출하는 것을 **callbyvalue 라 한다.Swap_callbyReference#include &lt;iostream&gt;using namespace std;int swap(int &amp;a, int &amp;b){    int temp = a;    a = b;    b = temp;    return 0;}int main(){    int x = 5, y = 10;    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl;    swap(x, y);    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl;    return 0;}출력// x = 5, y = 10// x = 10, y = 5이렇게 할 경우, swap 함수를 호출한 뒤에 안에 들어갈 때, &amp;a = x , &amp;b = y 이런식으로 들어가기 때문에 a 와 b 는 x , y 자체를 가리킨다. 따라서 내가 원하는 결과인 x , y 의 값이 바뀌게 된다. 이렇게 실제값을 가지고 함수를 호출하는 것을 callbyreference 라 한다.",
        
        "url": "/dv/c++/2020/09/28/OOP-07-Function-5.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-06-function-4-html": {
        "title": "06: Functions #4 - Reference Variable vs. Pointer",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "참조변수는 내가 선언한 값을 동시에 가리킨다는 점에서 포인터와 유사한 측면이 있다. 또 헷갈리는 점이 있다. C에서 &amp;의 사용은, 내가 저장한 변수의 주소값을 불러오는 용도로 사용했었다. 그런데 C++에 와서는 이 녀석을 참조변수로 사용할 수 있다고 하니 여간 혼돈스러운게 아니다.Diffrence between Pointer &amp; Reference VariableC에서 포인터는 장단점이 아주 명확하다.  장점          메모리에 직접적으로 접근할 수 있다.        단점          그렇기 때문에 사용자의 선택이 지배적이다. 즉, 아무렇게나 접근하여 잘못된 주소로 접근할 수 있다는 위험성이 있다.        포인터의 문제점은 선언과 할당을 나누기 때문에 발생한다.#include &lt;stdio.h&gt;int main(){    int x;    int *a;    x = 4;    *a = x;    return 0;}위와 같은 방식으로 선언과 할당을 해준다.메모리와 할당을 나타내는 그림이런식으로 가리키게 된다. 그런데 만약 내가 이것보다 복잡한 구조에 포인터를 잘못사용한다면 NULL 또는 Garbage 값이 들어갈 위험이 있다 이런 단점을 보안하는 방식으로 참조변수 가 만들어졌다.#include &lt;iostream&gt;int main(){    int x = 4;    int &amp;r = x;    return 0;}이렇게 사용할 경우 r은 x를 가리키는 또다른 별칭이 된다.alias이런식으로 구성된다. 참조변수는 포인터와 다르게 선언과 할당이 분리되어서 사용되지 않고, 동시에 이루어져야 한다. 즉, 선언과 초기화가 동시에 이루어진다. 그렇기 때문에 포인터에서 발생하는 잘못된 객체를 가리키는 문제점이 해결된다.SummaryPointer  선언과 할당이 분리되어 이루어짐  자유롭게 객체를 가리킬 수 있으나, 그렇기 때문에 오류 발생확률이 높음 (Null 값)  선언과 할당이 분리되니, 포인터 변수안의 주소값을 바꿀 수 있음  포인터 변수안에는 해당 객체의 주소값이 들어가있음  * 를 사용해서 선언하고 사용함Reference Variable  선언과 할당이 동시에 이루어짐  그렇기 때문에 포인터에 비해 오류가 날 확률이 줄어듦  또한 선언과 할당이후 다른 객체를 가리킬 수 없음  참조변수는 x 값 자체를 가리킴  x 의 별칭이라고 생각하면 됨  &amp; 을 사용해서 선언하고 사용함주소를 가져오는 &amp; 와 참조변수의 &amp;C 에서 scanf() 같은 함수를 사용할 때, &amp;a 와 같은 방식으로 입력을 받았다. 이 때, &amp;는 변수의 주소를 가져오는 방법으로 생각하고 사용했었다. 같은 &amp;를 쓰면서 왜 하나는 주소를 가져오는 방법으로, 또 참조변수라고 다르게 얘기하는 걸까? 사용법은 2가지가 있는데, 구체적으로 알아보면 굉장히 간단함을 알 수 있다. 차례차례 알아보자.주소를 가져오는 &amp;#include &lt;stdio.h&gt;int main(){   int x;   int *a;   a = &amp;x;   return 0;}이 코드를 보면, a 는 x 의 주소를 받음을 알 수 있다. 이때 &amp;은 참조변수가 아니고 x의 주소를 가져온다. = 연산자의 오른쪽 에 있는 것을 기억하자.참조변수 &amp;#include &lt;iostream&gt;int main(){    int x = 4;    int &amp;a = x;    return 0;}c++ 에서 참조변수는 다음과 같이 선언과 초기화를 한다. 이때 &amp;는 = 연산자 왼쪽 에 있다.  주소를 가져올 때 &amp; 는 오른쪽, 참조변수를 사용할 때는 왼쪽",
        
        "url": "/dv/c++/2020/09/28/OOP-06-Function-4.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-05-function-3-html": {
        "title": "05: Functions #3 - Recursion Function, Reference Variable (재귀함수)",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "Recursion FunctionFactorial 같은 함수를 구현하기 위해서는, 자기자신의 출력값을 다시 불러야 되는 필요성이 있다. 이것을 재귀함수라 한다.Example#include &lt;iostream&gt;using namespace std;int factorial(int n);int main(){    cout &lt;&lt; factorial(0) &lt;&lt; endl;    cout &lt;&lt; factorial(1) &lt;&lt; endl;    cout &lt;&lt; factorial(6) &lt;&lt; endl;    cout &lt;&lt; factorial(10) &lt;&lt; endl;    return 0;}int factorial(int n){    if (n == 0)\t\t\t\t\t\t\t// 제약조건        return 1;    else        return n * factorial(n-1);}이 과정을 알아보면,factorial6일 때, n-1 factorial 을 불러야 하므로 5 factorial 로 간다. 같은 방법으로 제약조건인 n==1 일 때까지 갔다가, 도착하면 순차적으로 값을 얻어와 최종 값을 반환한다.factorial 연산 과정Aliasing (Reference Variable)기본적으로, 우리가 선언된 변수를 다른 변수에 할당하게 되면 이 값을 복사해서 사용하는 셈이 된다. 작은 값의 경우 복사를 해서 프로그램을 짜는 것이 문제가 없을 수 있지만, 구조체나 객체같은 경우 복사를 해서 쓴다면 메모리 낭비가 될 수 있다.또한, 함수의 인자로 값을 그냥 넘겨준다면, 그 함수 내에서만 선언되는 지역변수들만 가지고 장난을 치게되어, 내가 원하는 결과, 원래 값 자체를 가지고 반환하는 것이 도출되지 않을 수 있다.그렇기 때문에 우리는 내가 저장한 값 자체를 가리킬 필요성이 생기는데, C에서는 이걸 Pointer 로 가능하게 했었다. 하지만 포인터의 문제점 때문에, C++ 은 참조변수라는 새로운 개념을 도입한다. 포인터와 참조변수의 차이점과 장단점은 밑에서 다뤄보도록 하고 지금은 참조변수에 대해서 알아보자.int x = 3;int &amp;r = x;밑의 &amp;r 이 참조 변수이다. 저렇게 할 경우 r은 x가 저장된 메모리공간을 동시에 가르키는 변수이다. 즉, x가 가리키는 3의 별명 이 생겼다고 생각하면 된다.Example#include &lt;iostream&gt;int main(){    int x = 5;    int y = x;    int &amp;r = x;    std::cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; '\\n';    std::cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; '\\n';    std::cout &lt;&lt; \"r = \" &lt;&lt; r &lt;&lt; '\\n';    x = 7;    std::cout &lt;&lt; \"---------------\" &lt;&lt; endl;    std::cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; '\\n';    std::cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; '\\n';    std::cout &lt;&lt; \"r = \" &lt;&lt; r &lt;&lt; '\\n';    return 0;}출력// x = 5// y = 5// r = 5// ---------------// x = 7// y = 5// r = 7x 값을 바꿨더니, r에는 바뀐 값이 들어간 것을 볼 수 있다. 반대로 y는 5라는 값이 그대로 들어가 있다. y는 x값을 복사해서 메모리에 넣은 것이고, r은 x의 메모리공간을 함께 뜻하고 있음을 알 수 있다.여기서 여러 혼란이 올 수 있다. C에서는 &amp; 는 저장된 값의 주소를 불러오는 방법이었다. 그런데 여기서는 참조변수라는 다른 이름을 가져다가 쓰고 있다. 같은 값을 가리킨다는 점에서 C언어에서 Pointer 가 생각났다.그런데 애매하게 다른 점이 있는 것 같다. 구체적으로 어떤점이 다를까?",
        
        "url": "/dv/c++/2020/09/28/OOP-05-Function-3.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-04-function-2-html": {
        "title": "04: Functions #2 - Local, Global Variable",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "Local, Global VariablesLocal Variables  함수 안에서만 동작하고 함수가 끝나면 메모리에서 삭제된다.  main 함수안에서 계속 살아있는 녀석이 아니다!  main 함수도 함수 이기 때문에 main 함수 종료후 main 함수 안에서 선언된 변수는 사라진다.Global Variables  함수가 실행되기 전에 선언되는 변수  프로그램의 주가 되는 main 함수가 끝나기 전까지 항상 살아있는 변수이다.Example #1#include &lt;iostream&gt;using namespace std;int x = 10;\t\t\t\t\t\t\t// 전역변수int makeDouble(int param){\t\t\t// 4    int x;\t\t\t\t\t\t\t// 5 \tmakeDouble 함수 안의 지역변수    cout &lt;&lt; \"02: \" &lt;&lt; x &lt;&lt; '\\n';\t// 6    x = param;\t\t\t\t\t\t// 7    cout &lt;&lt; \"03: \" &lt;&lt; x &lt;&lt; '\\n';\t// 8    return param * 2;\t\t\t\t// 9}\t\t\t\t\t\t\t\t\t// 10int main(){\t\t\t\t\t\t\t// 1    cout &lt;&lt; \"01: \" &lt;&lt; x &lt;&lt; '\\n';\t// 2    x = makeDouble( x );\t\t\t// 3 // 11    cout &lt;&lt; \"04: \" &lt;&lt; x &lt;&lt; '\\n';\t// 12    return 0;\t\t\t\t\t\t// 13}출력// [Output]// 01: 10// 02: -1031346592 (Garbage)// 03: 10// 04: 20함수안에 적어둔 숫자 순서대로 작동한다. 실행절차를 적어보자.여기서 주의깊게 봐야하는 것은 값을 같다고 놨을 때, 복사 한다는 점. 그리고 전역 변수, 지역 변수 가 어떻게 돌아가는지에 대한 구조 이다.  main 함수 안으로 들어간다.  전역변수 x 를 출력한다.          01: 10        전역 변수 x의 10을 makeDouble 함수로 복사한다.  그 값을 makeDouble 함수의 param 으로 복사한다.  makeDouble 함수의 지역 변수 x 를 만든다. 값은 저장되지 않았다.  이 값을 출력한다. 값을 할당하지 않았으므로 쓰레기값이 출력된다.          02: -1031346592 (Garbage)        makeDouble 함수의 x 에 넘어온 param 값을 복사한다.  복사된 x 를 출력한다.          03: 10        param * 2 값을 반환한다. param 은 makeDouble 함수가 아직 끝나지 않았으므로 살아있다.  함수가 종료되고, makeDouble 의 x , param 은 사라지고 param * 2 만 임시 저장소에 저장된다.  반환된 param * 2 을 main 함수 x 에 넣는다. param * 2 은 사라진다.  main 함수의 x 를 출력한다.          04: 20        main 함수가 끝나고 0 을 반환한다.  프로그램이 종료된다.Example #2위의 예제를 이해했다면, 아래 코드의 결과값도 이해될 것이다.#include &lt;iostream&gt;void increment(int x){    std::cout &lt;&lt; \"함수 증가전, x = \" &lt;&lt; x &lt;&lt; '\\n';    x++;    std::cout &lt;&lt; \"함수 증가후, x = \" &lt;&lt; x &lt;&lt; '\\n';}int main(){    int x = 5;    std::cout &lt;&lt; \"증가전, x = \" &lt;&lt; x &lt;&lt; '\\n';    increment(x);    std::cout &lt;&lt; \"증가후, x = \" &lt;&lt; x &lt;&lt; '\\n';}출력// 증가전, x = 5// 함수 증가전, x = 5// 함수 증가후, x = 6// 증가후, x = 5increment 함수 통과후 사용되었던 지역변수는 모두 사라졌기에, main 함수에서의 x 는 그대로 5 이다.만약 main 함수에서 x 값을 변화시키고 싶다면, increment 함수에서 반환값을 만들어 x 에 대입하는 방향으로 코드를 썼어야 했다.",
        
        "url": "/dv/c++/2020/09/28/OOP-04-Function-2.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-03-function-1-html": {
        "title": "03: Functions #1 - Calling (호출)",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "함수의 기본 모양수학에서의 함수와 같이, input , output 이 있고, input 이 들어갔을 때, 어떤 작업을 한 뒤, output 을 내보내는 방식으로 작동한다.함수여기서는 input , output 에 아무 숫자나 넣어줘도 되지만, 컴퓨터는 이 숫자 자체도 명시적으로 써줘야 하기 때문에 어떤 input 이 들어가는지, 예상되는 output 은 어떤 녀석인지 명시적으로 써줄 필요가 있다.Function in C++int iSqrt(int p){\t\t// #1    return p * p;\t\t// #2}  int p : input 파라미터의 자료형은 integer 이어야 한다.          int iSqrt : output 의 자료형은 integer 이다.        어떻게 작용하는지 적어주는 함수의 body 이다.함수의 구조Input, output paramater수학에서의 함수와 다르게 input , output 파라미터가 없을 수 있다.input 파라미터가 없는 경우#include &lt;iostream&gt;int helloworld(void){    cout &lt;&lt; \"hello world\";    return 0;}int main(){    helloworld();}출력// helloworldoutput 파라미터가 없는 경우#include &lt;iostream&gt;void helloworld(void){    cout &lt;&lt; \"helloworld\";}int main(){    helloworld();}출력// helloworldvoid 자료형은 window 운영체제에서만 가능하다.Main 함수 안에서 사용선언(Declare) , 정의(Define) , 호출(Calling) 의 세 과정을 거친다.선언(Declare)int iSqrt(int);  main 함수로 들어가기 전에, 먼저 함수의 반환형과, 파라미터의 자료형이 써진 함수의 원형(prototype) 을 적어준다. 변수 이름은 써 줄 필요없다.정의(Define)int iSqrt(int p){return p \\* p;}  main 함수 밑에 어떻게 작용하는지 함수의 내용을 적어준다. 이때는 input 파라미터로 변수의 이름까지 적어줘야 사용가능하다.호출(Calling)y = iSqrt( x );  main 함수에서 불러서 사용한다. 함수를 돌리고난 반환값이 y에 저장된다.전체코드 예제# include &lt;iostream&gt;using namespace std;int sum(int a, int b);\t\t\t\t\t// Declareint main(){    int x, y;    cout &lt;&lt; \"x 입력\" &lt;&lt; endl;    cin &gt;&gt; x;    cout &lt;&lt; \"y 입력\" &lt;&lt; endl;    cin &gt;&gt; y;    cout &lt;&lt; sum(x, y) &lt;&lt; endl;\t\t\t// Calling    return 0;}int sum(int a, int b){\t\t\t\t\t// Define    return a + b;}Default Arguments함수를 호출했을 때, 아무 인자도 넣지 않았다면, default로 파라미터를 넘길 수 있다. 선언할 때, 인자값까지 같이 전달하면 된다. 또한, input이 적게 들어왔을 경우, 앞 인자만 초기값으로 설정된다.# include &lt;iostream&gt;using namespace std;int sum(int a, int b);\t\t\t\t\t// Defalut Argumentsint main(){    int x, y;    cout &lt;&lt; \"x 입력\" &lt;&lt; endl;\t\t\t\t// 8    cin &gt;&gt; x;    cout &lt;&lt; \"y 입력\" &lt;&lt; endl;\t\t\t\t// 5    cin &gt;&gt; y;    cout &lt;&lt; sum(x, y) &lt;&lt; endl;\t\t\t// 13    cout &lt;&lt; sum(x) &lt;&lt; endl;\t\t\t\t// 9    cout &lt;&lt; sum() &lt;&lt; endl;\t\t\t\t// 7    return 0;}int sum(int a, int b){    return a + b;}함수의 동작과정#include &lt;iostream&gt;#include &lt;cmath&gt;\t\t// cmath 라이브러리 포함using namespace std;int main(){    double value;    // 변수 할당    value = 16;    // 루트 계산    double root = sqrt(value);    // 다른 값 계산 후 할당    root = sqrt(100);}cmath 는 수학 함수들을 모아둔 표준 c++ 라이브러리 이다. 우리가 주 목적을 두는 함수는 main 함수이다. 이때, 다른 함수를 불러올때, 어떤 방법으로 실행되는지 그림으로 살펴보자. main 함수가 동작하다가, 중간에 sqrt 를 만나면 만들어둔 그 함수로 갔다가, 반환값을 다시 가져오고, 또 만나면 다시 갔다가 반환값을 가져오는 방식으로 동작한다.cmath Library#include &lt;iostream&gt;  종류math library",
        
        "url": "/dv/c++/2020/09/28/OOP-03-Function-1.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-02-identifier-variable-constant-std-io-operator-html": {
        "title": "02: Identifier, Variable, constant, Std IO, Operator",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "IdentifierReserved Words(예약어)사용가능 문자  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789  예약어는 안된다.Variable Assignment    #include &lt;iostream&gt;    int main(){        int x;\t\t// 메모리에 integer 자료형을 넣을 공간만들고, 그 이름을 x라 하겠다.    }Variable, ConstantC와 같으므로 링크로 대체하겠다.Standard Input &amp; Output기본적으로 iostream 헤더파일을 가져와서 사용한다. iostream.h 헤더 파일은, c++에 있는 입출력을 위한 헤더파일이다. C언어의 stdio.h 와 같은 역할을 한다.출력 (cout)  #include &lt;iostream&gt;  int main(){  std::cout &lt;&lt; “Please enter two intger values: “;  }namespace 를 사용하면 다음과 같이 함수를 사용하는데 있어 std:: 를 쓰지 않고 사용할 수 있다.    #include &lt;iostream&gt;    using namespace std;    int main(){        cout &lt;&lt; “Please enter two intger values: “;    }입력 (cin)  #include &lt;iostream&gt;  int main(){  std::cin &gt;&gt; value1 &gt;&gt; value2;  }여러개를 한번에 입력받을 수 있다. 마찬가지로, namespace 를 사용하면 다음과 같이 함수를 사용하는데 있어 std:: 를 쓰지 않고 사용할 수 있다.    #include &lt;iostream&gt;    using namespace std;    int main(){        cin &gt;&gt; value1 &gt;&gt; value2;    }예제  #include &lt;iostream&gt;  using namespace std;  int main() {  int value1, value2, sum;  cout &lt;&lt; \"Please enter two integer values: \";  cin &gt;&gt; value1 &gt;&gt; value2;  sum = value1 + value2;  cout &lt;&lt; value1 &lt;&lt; \" + \" &lt;&lt; value2 &lt;&lt; \" = \" &lt;&lt; sum &lt;&lt; '\\n';  }Operator마찬가지로 C와 같으므로 링크로 대체하겠다.",
        
        "url": "/dv/c++/2020/09/28/OOP-02-Identifier-Variable-constant-Std-IO-Operator.html"
      }
      ,
    
      "dv-c-2020-09-28-oop-01-introduction-html": {
        "title": "01: Introduction",
        "tags": "c++, OOP",
        "date": "September 28, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "C++  발표년도 : 1983  설계자 : Bjarne Stroustrup, 덴마크  패러다임 : 절차적 프로그래밍, 함수형 프로그래밍, 객체 지향 프로그래밍  절차지향, 객체지향의 성격을 동시에 띄기 깨문에, 굉장히 유연하고 강력하다. 만능설계가 가능  하지만 복잡하다는 단점이 있다.Software Build Process &amp; ToolsBuild ProcessEditor  대부분의 에디터는 신택스에러를 막기위해 색을 칠한 단어로 표기되는 경향이 있다.  에디터는 사용자가 프로그램의 소스코드에 들어갈 수 있게 허용한다.  신택스 에러가 뜬다면 컴파일이 되지 않는다.Pre-Processor  전처리기는 코드를 처리하기 전에 소스코드의 요소들을 수정하고 더한다.  보통 #include 를 사용해서 우리 프로그램이 사용하는 라이브러리 정보를 가져온다.Compiler  컴파일러는 소스 코드를 타겟 코드로 변환한다.  타겟 코드는 장치나 특정 플랫폼을 위한 기계 언어일지 모른다.  일지 모른다고 한 이유는, 특정 프로그래밍 언어를 컴파일 할 경우, 다른 언어의 소스 언어가 될지 모르기 때문이다.  예를 들어, 초기 C++ 컴파일러는 C로 변환했다.  즉 컴파일 한 타겟 코드가 다른 소스 언어로 변환 된 것이다.  요즘의 C++ 컴파일러는 바로 기계언어로 변환한다.Linker  링커는 컴파일러에 의해 만들어진 기계 코드와, 사전에 처리된 라이브러리 코드 또는 다른 소스로 부터 만들어진 소스들을 하나의 실행가능한 프로그램으로 만들기 위해 묶는다.  대부분의 컴파일 된 C++ 코드는 혼자서 작동할 수 없다.  실행가능한 하나의 프로그램을 만들기 위해서는 추가적인 기계 코드가 필요하다.  이 없는 기계 코드는 이미 컴파일 되어 있고, 라이브러리 라는 저장소에 저장되어 있다.  이 링커라고 불리는 프로그램은 프로그래머가 한 컴파일 된 코드와 라이브러리 코드를 묶어 완성된 프로그램을 만든다.Debugger  디버거는 프로그래머가 프로그램 구현시 오류를 찾아서 수정하기 위해 프로그램의 실행을보다 쉽게 추적 할 수있게 한다.  디버거를 사용하면 개발자는 프로그램을 구동하면서 동시에 프로그램의 동작에 있어 어떤 소스코드 라인이 책임이 있는지 알 수 있다.Profiler  성능분석을 한다.  프로그램의 시간 복잡도를 분석한다.  함수 호출 주기, 빈도등도 분석할 수 있다.",
        
        "url": "/dv/c++/2020/09/28/OOP-01-Introduction.html"
      }
      ,
    
      "cv-awards-2020-09-23-2020-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-8a-a4-ed-85-8c-ec-9d-b4-ec-85-98-ec-b5-9c-ec-a0-81-ec-9c-84-ec-b9-98-ec-84-a0-ec-a0-95-html": {
        "title": "공공자전거 스테이션 최적 위치 선정 - 장려상",
        "tags": "awards, CV",
        "date": "September 23, 2020",
        "author": "",
        "category": "CV/Awards",
        "content": "",
        
        "url": "/cv/awards/2020/09/23/2020-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%8A%A4%ED%85%8C%EC%9D%B4%EC%85%98-%EC%B5%9C%EC%A0%81-%EC%9C%84%EC%B9%98-%EC%84%A0%EC%A0%95.html"
      }
      ,
    
      "ds-dl-2020-09-18-computer-vision-15-gram-matrix-html": {
        "title": "15: Gram Matrix",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, GAN, Style Transfer",
        "date": "September 18, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "개요style transfer에서는 input의 style을 target의 style과 맞게 만들어주는 방법이 필요한데, 이에 대한 방법론의 핵심을 담당하는 Gram Matrix에 대해 알아본다.수식먼저, 논문에서 제안하고 있는 Gram Matrix의 형태는 다음과 같다.우리는 쉬운 이해를 위해서 채널, 정규화 과정을 제거한 채로 살펴보자.  l : layer  F : Filter  i, j : Filter Index수식으로 들어온다면 여기까지만 읽으면 된다.의미이미지 $\\vec{x}$ 가 있다고 하자. 해당 벡터는 2차원 이미지가 있을 때, 이를 1차원으로 faltten 한 것이다. 이 이미지의 크기를 M=3이라 하자.각 이미지가 통과하는 필터(M=2)가 2개 있다고 하자. 해당 필터는 $F$로 표기한다. 각각의 filter에 image를 통과시킨 결과를 $\\vec{F}$라 하자.$F_{ik}$는 $F_i$ 필터에 $x_k$ 픽셀을 넣었을 때의 activation(response)이다. 그렇다면 Gram Matrix의 의미가 무엇인지 알아보자. 일단어디서 많이 본 모양이다. pixel별 filter activation의 Covariance이다! 결과적으로 발생하는 모든 항을 더하게되면 다음의 의미이다.  pixel의 filter activation들에 대한 covariance 모든 항의 합이렇게 발생한 값을 가지고 input의 filter가 원하는 target filter의 gram matrix 값과 같도록 학습을 진행한다.최종적으로는 밀도로 나누어서 사용해야 한다.ReferenceGram Matrix 설명",
        
        "url": "/ds/dl/2020/09/18/computer-vision-15-Gram-Matrix.html"
      }
      ,
    
      "book-finance-2020-09-16-ea-b8-88-ec-9c-b5-ec-b1-85-01-html": {
        "title": "01: ",
        "tags": "금융, 책 리뷰, 서평, 책",
        "date": "September 16, 2020",
        "author": "",
        "category": "Book/Finance",
        "content": "배경/단상줄거리/ 주요 내용 요약발췌 및 해석전체 느낌/추천 대상/추천 이유",
        
        "url": "/book/finance/2020/09/16/%EA%B8%88%EC%9C%B5-%EC%B1%85-01.html"
      }
      ,
    
      "book-finance-2020-09-16-ea-b8-88-ec-9c-b5-ec-9a-a9-ec-96-b4-ec-9d-b4-ed-95-b4-05-ec-82-b0-ec-97-85-ec-83-9d-ec-82-b0-ec-a7-80-ec-88-98-html": {
        "title": "05: 산업 생산 지수",
        "tags": "금융, 산업생산지수",
        "date": "September 16, 2020",
        "author": "",
        "category": "Book/Finance",
        "content": "경제성장률의 단점지금까지 배운 내용을 바탕으로 문제를 하나 내보자. 지금 현재까지 대한민국의 물질적 부가 얼마나 증가하고 있는지 궁금할 때 우리는 무엇을 해야 할까? 너무나 쉬운 질문이다. 대한민국의 물질적부가 얼마나 증가했는지 말해주는 경제성장률을 보면 된다.하지만 문제가 그렇게 간단하지 않다. 경제성장률은 3개월에 한번씩 발표가 된다는 치명적인 단점을 가지고 있다. 따라서 경제성장률을 이용해서는 당장의 궁금증을 해결할 수가 없다. 물론 3개월만 기다리면 되지만 우리는 매달 대한민국의 물질적부를 확인하고 싶다.뭔가 획기적인 방법이 없는 것일까? 바로 이때 우리가 이용할 수 있는 것이 산업생산지수이다.산업생산지수산업생산지수는 대한민국 공장에서 각종 물건이 과거에 비해 얼마나 많이 생산되고 있는지 조사를 한 것이다.만약 산업생산지수가 팍팍 증가하고 있다면 공장에서 각종 물건이 과거에 비해 팍팍 생산되고 있다는 이야기가 된다. 그리고 만약 산업생산지수가 팍팍 줄어들고 있다면 공장이 과거에 비해 잘 돌아가지 않고 있다는 이야기이다.산업생산지수는 크게 봐서 광공업생산지수, 서비스업생산지수, 건설업생산지수, 공공행정활동지수, 농림어업생산지수와 이들을 종합한 전산업생산지수로 나누어진다.하지만 이 많은 지수가 똑같은 사랑을 받는 것은 아니다. 여러 가지 세부 지수 중에서 가장 큰 관심을 받는 것은 광공업생산지수이다. 쉽게 말해서 대한민국 광산에서, 공장에서, 발전소에서 얼마나 많은 물건과 전기가 생산되었는지 조사한 광공업생산지수가 세상 사람들의 특별한 사랑을 받고 있다는 이야기다.광공업생산지수가 사랑을 받는 이유는 쉽게 짐작할 수 있다. 한 나라의 물질적 부를 생산하는 가장 근원적인 장소가 바로 공장이기 때문이다.산업생산지수의 종류  전산업생산지수          ‘전산업’이라는 말이 상징하듯이 농업·어업, 광업, 제조업, 전기·가스업, 건설업, 서비스업 등의 생산량을 모두 조사 한 것이 전산업생산지수이다. 전산업생산지수는 다시 농림어업생산지수, 광공업생산지수, 건설업생산지수, 서비스업생산지수, 공공행정활동지수로 나누어진다.        광공업생산지수          광업, 제조업, 전기·가스업의 생산량을 조사한 것이 광공업생산지수이다. 특별한 수식어 없이 신문이나 방송에서 ‘산업생산지수’라는 말을 사용하면 ‘광공업생산지수’를 말하는 것이라고 생각하면 된다.        제조업생산지수          제조업체의 생산량을 조사한 것이 제조업생산지수이다. 전산업생산지수의 엑기스가 광공업생산지수라면, 광공업생산지수의 엑기스는 제조업생산지수라고 할 수 있다.      산업생산지수그런데 산업생산지수의 자태가 그렇게 화려하지 만은 않다. 우리가 기대했던 화려한 자태는 온데 간데없고 끝없이 위로 올라만 가고 있다.산업생산지수가 이렇게 끝없이 승천하는 이유는 간단하다. 긴 시간의 흐름에서 보면 대한민국의 물질적 부가 끝없이 증가하기 때문이다. GDP가 계속해서 상승하는 것과 비슷한 논리이다.물론 단기적인 관점에서 보면 지난달보다 이번 달이 먹고 살기 팍팍할 수는 있다. 하지만 분명한 사실이 있다. 오늘 우리는 과거 어느 때보다 물질적으로 풍요한 삶을 살고 있다는 사실이다. 그리고 10년 뒤에는 오늘보다 더 풍요로운 삶을 살고 있을 것이라는 사실이다.따라서 공장에서 나오는 각종 물건의 생산량을 조사한 산업생산지수는 끝없이 고공승천을 할 수밖에 없는 것이다.산업생산지수 전년동월비산업생산지수 전년동월비9월의 자동차 생산량이 얼마나 증가 했는지 궁금할 때 우리는 8월과 비교를 해서는 안 된다. 8월에는 휴가를 떠나는 사람들이 많은 관계로 아무래도 생산량이 작을 수밖에 없다. 따라서 9월 자동차 생산증가율이 궁금하다면 작년 9월과 비교를 해야 한다. 이렇게 작년 같은 달과 비교하는 것을 가리켜 전년동월비라 한다.산업생산지수 역시 마찬가지이다. 대한민국 공장에서 생산되는 각종 물건이 얼마나 증가했는지 제대로 알고 싶다면 작년 같은 달과 비교를 해야 한다. 이같은 원리를 이용해 산업생산지수를 전년동월비로 바꾼 것이 위의 그래프이다.이렇게 전년동월비로 바꾸고 나니 산업생산지수 그 자체를 보았을 때는 쉽게 눈에 들어오지 않던 대한민국 경제의 파란만장했던 삶이 한 눈에 들어 온다. 경제 성장률과 비슷한 양상을 보여주고 있다.세계각국의 산업생산지수산업생산지수는 수많은 경제지표 중에서 가장 기본이 되는 경제지표이다. 즉, 미국경제나 유럽경제가 얼마나 잘 나가고 있는지 알고 싶을 때 수많은 경제지표 가운데 제일 먼저 체크해야 할 것이 산업생산지수이다.산업생산지수만 살펴보면 그 나라의 물질적 부가 얼마나 증가하고 있는지 단번에 알 수 있기 때문이다.",
        
        "url": "/book/finance/2020/09/16/%EA%B8%88%EC%9C%B5-%EC%9A%A9%EC%96%B4-%EC%9D%B4%ED%95%B4-05-%EC%82%B0%EC%97%85%EC%83%9D%EC%82%B0%EC%A7%80%EC%88%98.html"
      }
      ,
    
      "book-finance-2020-09-16-ea-b8-88-ec-9c-b5-ec-9a-a9-ec-96-b4-ec-9d-b4-ed-95-b4-04-ea-b2-bd-ec-a0-9c-ec-84-b1-ec-9e-a5-eb-a5-a0-html": {
        "title": "04: 경제 성장률",
        "tags": "금융, 경제성장률",
        "date": "September 16, 2020",
        "author": "",
        "category": "Book/Finance",
        "content": "경제 성장률열일의 이유가 무엇일까? 당연하다. 오늘 하면 내일은 좀 더 받지 않을까? 이 생각이다. GDP 역시 마찬가지다. 대한민국에서 향유하는 물질적 부가 늘어나기를 바란다. 점점 부자가 되길 바라는 것.올해 대한민국의 GDP가 1000조였다면 내년엔 무조건 1000조를 넘어서야 한다. 내년에도 GDP가 1000조라면 대한민국의 물질적부가 전혀 증가하지 않았다는 이야기다. 1년동안 신나게 일했는데 월급이 한 푼도 오르지 않는 김 빠지는 상황인 것이다.만약 GDP가 1000조 보다 작아졌다면 너무나 끔찍합니다. 대한민국의 물질적부가 줄어든 것이기 때문입니다. 1년동안 뼈 빠지게 일했는데 월급이 깎인 것.(~~하~~)월급이 얼마냐도 중요하지만(GDP), 월급인상률도 무척이나 중요한 것처럼 GDP도 지난해보다 얼마나 커졌는가 따져보는 것(경제성장률)이 너무나 중요합니다. 그래서 등장한 개념이 경제성장률이다. 우리나라의 물질적 부가 얼마나 커졌는가를 측정한 것이 바로 경제성장률인 것이다.경제성장률을 계산하는 공식은 간단하다.예를 들어 지난해의 GDP가 1000조 였는데 올해의 GDP가 1100조라면 경제성장률은 10%가 된다.경제성장률 10%가 무엇을 뜻하는지 가슴에 와 닿지 않는다면 ‘대한민국 모든 국민의 월급이 10%씩 올랐다’고 생각하면 된다.전년동기비 성장률과 전기비 성장률전년동기비 성장률과 전기비 성장률전년동기비 성장률경제가 작년 같은기간보다 얼마나 성장했는지 따져 보는 것이 전년동기비 성장률이다. 예를 들어, 올해 1분기(1월~3월)에 생산된 대한민국의 물질적부가 작년 1분기에 생산된 물질적 부보다 얼마나 증가했는지 조사한 것이 전년동기비 성장률이다.전기비성장률경제가 직전 분기보다 얼마나 성장했는지 따져 보는 것이 전기비 성장률이다. 예를 들면, 올해 2분기(4월~6월)에 생산된 물질적 부가 올해 1분기(1월~3월)에 생산된 물질적 부보다 얼마나 증가했는지 조사한 것이 전기비 성장률이다.전년동기비 성장률과 전기비 성장률경제성장률 그래프를 가만히 보고 있으면 재미있는 사실을 하나 발견할 수 있습니다. 예를 들어 1998년~1999년 부분을 자세히 한번 보십시요.추락하던 경제가 다시 좋아질 때 전년동기비 성장률보다 전기비 성장률이 먼저 방향을 틀고 있다는 사실을 우리는 쉽게 발견할 수 있다. 이 같은 일은 1999년에도 일어난다. 잘나가던 경제가 추락을 시작할 때 전년동기비 성장률보다 전기비 성장률이 먼저 하락을 시작한다. 사실 이는 당연한 것이, 방향을 튼다면 바로 앞에 있는 지표가 먼저 방향을 틀기 때문이다.그래서 경제가 어느 방향으로 튈지 알고 싶을때는 전년동기비 성장률보다 전기비 성장률이 더 영양가 있다.그렇다면 전년동기비 성장률은 아무 영영가 없는 것일까요? 그것은 아닙니다. 전년동기비 성장률을 통해서 우리는 대한민국 경제가 그동안 어떤 길을 걸어 왔는지 쉽게 알수 있다. 전기비성장률을 보면 눈만 아플 뿐 대한민국 경제의 발자취를 살펴보는것이 쉽지 않지만, 전년동기비 성장률은 한눈에 알 수 있다.그래서 많은 분들이 이런 말을 한다. 변화의 방향을 읽을 때는 전기비 성장률이 좋고, 변화의 폭을 볼 때는 전년동기비 성장률이 좋다고 말이다.경제성장기여도집 앞에 있는 짜장면집의 매출액이 2% 늘었다고 하자.이때 매출액이 2% 늘었다고 짜장면, 짬뽕, 팔보채의 매출이 모두 2%씩 늘어난 것은 아닙니다. 그 중에는 매출이 10%, 20% 늘어나 평균을 웃 돈 메뉴가 있는가 하면 매출이 줄어들어 오히려 평균을 까먹은 메뉴도 있다.경제성장률도 마찬가지이다. 지난해 경제성장률이 3%라고 온 세상 사람들이 대한민국의 경제발전에 딱 3%씩 공헌을 한 것은 아니다. 즉 대한민국 소비자, 기업, 정부, 그리고 해외의 소비자가 대한민국 경제에 기여한 정도는 다르기 마련이다.그래서 나온 것이 경제성장기여도 이다. 경제성장기여도는 소비자, 기업, 정부, 해외 소비자가 우리나라의 경제성장에 얼마나 기여를 했는지 조사를 한 것이다.경제성장기여도를 표시하는 방법은 간단하다. 경제성장율이 3%라면 소비자의 경제성장기여도는 0.5%포인트, 기업의 경제성장기여도는 1%포인트, 정부의 경제성장 기여도는 1%포인트, 해외 소비자의 경제성장기여도는 1%포인트하는 식으로 표시를 힌다. 그리고 이들의 경제성장도를 모두 합치면 3%가 된다.경제성장기여율경제성장기여율은 경제성장률을 100으로 잡았을 때 각 부분이 얼마나 성장에 기여했는지 조사를 한 것이다.예를 들어, 경제성장률이 3%라고 하자.3%의 경제성장을 이룩하는데 각 부분이 기여한 정도는 다른데, 소비자의 기여율은 20%, 기업의 기여율은 20%, 정부의 경제성장기여율은 10%, 해외 소비자의 경제성장기여율을 50% 하는 식으로 표시를 하는것이 경제성장기여율이다.이렇게 나온 경제성장기여율을 모두 합치면 100%가 된다.잠재성장력직원들이 사무실 빠져나가 사우나에서 몸 풀 생각이나 하고, 공금횡령해서 뒷돈 챙길 생각만 하는 회사가 있다고 하자. 이 회사의 앞날은 너무나 뻔하다.반면 하루 24시간 ‘회사가 나를 위해 무엇을 해줄 것인가?’ 생각하기 전에, ‘내가 회사를 위해 무엇을 할 것인가?’ 생각하는 직원들만 있는 회사는 어떨까? 지금 당장은 회사 사정이 어려운 수도 있지만 장기적으로 보면 무궁한 영광과 발전이 예상된다. 멋진 직원들이 많은 만큼 회사의 성장잠재력이 크기 때문이다.경제성장 역시 마찬가지이다. 국민이 똑똑하고, 여기저기 사방팔방에 공장이 세워져 있으면 당장은 경제가 어렵더라도 언젠가는 벌떡 일어나 벅찬 내일을 향해 질주할 수 있다. 성장의 잠재력이 있기 때문이다.한 나라의 모든 생산요소(노동, 자본 등)를 정상적으로 동원해서 이룰 수 있는 성장능력을 어려운 말로 잠재성장력이라고 한다.가끔 잠재성장력 이상으로 경제성장을 이루는 경우가 있습니다. 예를 들어, 잠재성장력은 5%인데 실제 경제성장은 7%인 경우가 있다. 이 같은 경우는 정상적이라고 할 수 없다. 무언가 상식적이지 않은 활동이 있는 것. 국민이 하루 8시간 일할 것을 20시간씩 일하고, 하루 10시간 이상 돌리면 안 되는 공장을 24시간 돌려서 그와 같은 성장을 이루었다고 볼 수 있다. 당장의 성장률은 높아서 좋을지 몰라도 장기적으로는 피해가 심각하다. 사람도, 기계도 골병이 나게 된다.경기가 어려울 때면 ‘잠재성장력이 낮아지고 있다’는 기사가 자주 나온다. 당장 돈이 없으니 투자를 할 수 없고, 국민도 먹고 살기 어렵다보니 자기계발에 대한 지출을 줄이게 돼 국가적으로 경쟁력이 낮아지게 된다. 이 같은 일이 계속된다면 몇 년 뒤에는 경제성장을 하고 싶어도 기술이 없어서, 쓸 만한 인재가 없어서 경제성장을 하지 못하는 상황이 닥칠 수도 있다.요소투입주도 경제성장이성를 꼬시는 방법에는 크게 보아서 두 가지 방법이 있다.그 하나는 24시간 내내 쫄쫄 따라다니고, 선물을 퍼 붇는 물량 공세이고, 나머지 하나는 결정적인 순간에 한방에 넘어뜨리는 방법이다.앞의 방법은 성공하면 다행이지만 실패하면 정신적으로, 물질적으로 손해가 막급하고, 지극히 생산성이 낮지만,후자는 실패하면 시간 버린셈 치고, 미친놈 취급당하면 그만이지만 생산성은 상당히 높은 방법이다.한나라의 경제성장도 똑같다.막 퍼부어서 경제를 일으키는 방법이 있고, 적당히 퍼붓지만 생산성을 높여서 경제를 일으키는 방법이 있다.요소투입주도 경제성장이란, 생산성에는 관심을 두지 않고 일단 퍼 부어 놓으면 언젠가는 돈이 되고, 떡이 되어 나온다는 논리이다. 이제 막 일부의 외국인들이 한국의 경제성장이 가장 대표적인 요소투입주도 경제성장이라고 합니다. 과거의 대한민국은 그랬다.처음에는 퍼부우니까 떡이 나왔는데 지금은 구멍이 막혀서 아무것도 나오지 않게 되었고, 결국 그러다가 요모양 요꼬라지가 되었다는 이야기이다.이제는 막힌 구멍을 뚫어야 하고, 퍼붓기가 아니라 생산성, 즉 투입이 아니라 산출에 신경을 쓰야 한다고 이야기 한다.",
        
        "url": "/book/finance/2020/09/16/%EA%B8%88%EC%9C%B5-%EC%9A%A9%EC%96%B4-%EC%9D%B4%ED%95%B4-04-%EA%B2%BD%EC%A0%9C%EC%84%B1%EC%9E%A5%EB%A5%A0.html"
      }
      ,
    
      "book-finance-2020-09-16-ea-b8-88-ec-9c-b5-ec-9a-a9-ec-96-b4-ec-9d-b4-ed-95-b4-03-gdp-html": {
        "title": "03: GDP",
        "tags": "금융, GDP",
        "date": "September 16, 2020",
        "author": "",
        "category": "Book/Finance",
        "content": "GDP의 탄생설화경제는 ‘세상을 경영해 백성을 부유하게 한다’는 뜻이다. 그런데 여기서 우리는 의문을 가질 수밖에 없다. 도대체 무슨 수로 백성의 부를 측정할 수 있을까?실제로 이 문제 때문에 많은 사람들이 고민을 했다. 고민의 결과로 나온 첫 번째 대답은 금 덩어리였다(금본위 제도). 금덩어리 많은 나라가 부자나라라는 이야기. 하지만 금덩이리는 단점을 가지고 있다. 극단적으로 가정해서 아프리카 사막에 떨어졌다고 생각해보자. 금덩어리가 아무리 많아도 할게 없다. 사막에서 제일 필요한 것은 물과, 음식, 그리고 햇빛을 가려줄 양산이다. 즉, 금이라는 물건의 양이 해당 나라가 살산다는 사실을 대변할 수 없다는 것.금덩어리가 부자나라를 가리킬 수 없다면 도대체 어떤 나라가 부자나라일까? 혹시 돈 많은 나라가 부자나라일까? 하지만 이것도 치명적인 문제가 있다. 돈 많은 나라가 부자라면 나라 안에 돌아다니는 종이라는 종이는 모조리 끓어 모아서 돈을 막 찍어내면 된다. 하지만 이렇게 돈을 찍어내고 또 찍어내다보면 어느 순간에는 그냥 종이쪼가리가 될 뿐이다. 즉, 돈이라는 물건도 해당 나라의 살산다는 사실을 대변해 줄 수 없다.금덩어리가 많은 나라도, 돈이 많은 나라도 부자나라가 아니면 어떤 나라가 부자나라일까? 이 때, 등장하는 형이 아담 스미스 형이다.형은 물질적부는 금이나 돈이 아니라 국민들이 먹고 마시고 즐기는 물건이라 말했다. 즉 온 나라에 먹고 마실 음식이 흘러넘치고, 국민들의 생활을 윤택하게 해줄 핸드폰과 자동차와 멋진 집이 흘러넘치는 나라가 부자나라이다. 음.. 지금 생각해보니 당연한 이야기다.GDP와 GNPGDP(Gross Domestic Product)위의 말을 근간으로 해당 나라에 존재하는 물질적 부를 모두 합한 것이 GDP(국내총생산)이다. 일단 대한민국 땅덩어리 안에서 만들어진 것이면 인정사정 보지않고 모두 합친것이 GDP이다. 만약 GDP가 1000조라면 우리나라 안에서 만들어진 물질적 부가 1000조원 어치라는 이야기.직관적인 이해를 끝냈다면, 사전적 정의에 대해 알아보자.  GDP(국내총생산) : ‘한 나라 안에 있는 가계, 기업, 정부 등 모든 경제주체가 일정기간 동안 새로이 생산한 재화와 서비스의 가치를 시장가격으로 평가하여 합산한 것하지만 그냥 직관적으로 GDP는 대한민국에서 생산된/향유하는 모든 물질적 부를 합친 것으로 이해하는 것이 편하다.GNP(Gross National Product)GNP(국민총생산)는 세계 어디에서 생산되었든 상관없이 우리나라 국민이 생산한 것은 무조건 합쳐서 계산한 물질적 부이다. 미국에 살고 있든 우간다 밀림 속에 살고 있든 대한민국 사람이 만든 것이라면 무조건 합친 것이 바로 GNP다.과거에는 GNP를 정말 중요하게 생각했고, 거의 모든 경제정책은 GNP를 크게 하는데 집중되었다. 그런데 지금은 대부분의 나라들이 옛날만큼은 GNP를 소중히 생각하지 않는다. 왜일까?예를 들어, 미국에 살고 있는 완식이가 돈을 벌면 미국에서 쇼핑하고, 미국에서 이발을 한다. 결국 완식이가 돈을 쓰면 미국 이발사, 미국 쇼핑몰 사장님이 좋아할 일이다. 우리나라 경제와는 아무 상관이 없는 것.이와 달리 GDP는 국적에 상관없이 땅덩어리에 관심을 둔 개념이다. 사실 필리핀 기술연수생 아저씨가 돈을 벌면 결국 한국에서 물 사 먹고, 한국에서 옷을 산다. 결국 우리나라 옷가게, 물가게 사장님을 행복하게 만드는 것은 미국의 갑돌이가 아니라 우리나라에서 일하고 있는 필리핀 기술연수생 아저씨인 것이다. 그래서 이제는 국적개념의 GNP보다 땅덩어리 개념의 GDP를 더 중요하게 생각하고 있다.명목(Nominal) GDP와 실질(Real) GDP예를 들어, 작년에 대한민국에서 생산한 모든 물질적 부가 쌀 한가마라고 하자. 그리고 작년의 쌀가격이 만원이었다면 대한민국의 GDP는 쌀 한가마*1만원=1만원이 된다.그런데 올해도 대한민국 땅덩어리 안에서 생산한 모든 물질적 부가 쌀 한가마라고 하자. 그리고 올해의 쌀가격이 2만원이라면 대한민국의 GDP는 쌀한가마*2만원=2만원이 된다.띠용. 실제로 생산된 물질적부는 쌀 한가마로 변함이 없는데 쌀가격이 뛰는 바람에 명목상, 쉽게 말해서 수치상의 GDP는 2만원이 되고 말았습니다. 이런 결과는 지표를 잘못해석하게 되면, 생산된 재화의 양에 대한 평가 없이 평가하게 된다.따라서 우리는 대한민국의 물질적 부가 실제로 얼마나 생산되었는지 알고 싶을 때는 명목상의 GDP가 아니라 진짜로 생산된/향유한 물질적 부에 관심을 기울여야 한다. 바로 이런 필요에 의해 나온 것이 실질GDP이다.실질GDP를 계산하는 방법은 여러가지가 있는데 우리나라는 연쇄가중법을 이용해 실질GDP를 계산하고 있다. 연쇄가중법이라는 말이 어렵게 들리는데, 쉽게 말하면 여러해의 물가를 잘 고려해서 실제로 생산된 GDP를 계산한다는 이야기이다. 가중평균을 한다는 의미.GNI(Gross National Income)1인당 국민총소득은 한 나라의 국민들의 생활수준을 알아보기 위하여 국제적으로 사용하는 소득 지표이다. 한 나라의 국민이 일정 기간 생산 활동에 참여하고, 그 대가로 받은 소득이 얼마인지를 합한 것이 GNI다.국민 1인당 평균치를 계산한 것은 1인당 GNI라고 한다. 즉, 1인당 국민 총소득, 국민이 얼마나 잘 벌고 사는지를 나타내는 지표이다.다른 계산법도 있다. 국내총생산(GDP)을 활용하는 것입니다. GDP에서 외국인이나 외국기업이 번 소득을 빼고, 외국에 있는 우리나라 사람이나 기업이 번 돈은 포함시키는 것. 한 마디로 순수하게 한국국적을 가진 사람의 소득의 합이 GNI이다.손흥민 선수의 소득은 GDP에서는 빠지지만 GNI에는 포함된다. GNI는 국민이 벌어들인 소득으로, 국민의 소비와 생활이 크게 반영된다는 점에서 중요한 개념이다.요약            용어      의미                  GDP      국가가 향유한 재화를 시장가격으로 평가(국가에 초점)              GNP      국민이 향유한 재화를 시장가격으로 평가(국민에 초점) - 안쓰임              명목 GNP      GDP를 단순히 시장가격으로 봄(숫자에 초점)              실질 GNP      시장 가격으로 평가하지 않고 실제 생산 재화를 고려하여 평가함 (재화에 초점)              GNI      국민 총소득      ",
        
        "url": "/book/finance/2020/09/16/%EA%B8%88%EC%9C%B5-%EC%9A%A9%EC%96%B4-%EC%9D%B4%ED%95%B4-03-GDP.html"
      }
      ,
    
      "book-sm-2020-09-15-ec-9e-90-ea-b8-b0-ea-b4-80-eb-a6-ac-ec-b1-85-01-html": {
        "title": "01: ",
        "tags": "자기관리, 책 리뷰, 서평, 책",
        "date": "September 15, 2020",
        "author": "",
        "category": "Book/SM",
        "content": "배경/단상줄거리/ 주요 내용 요약발췌 및 해석전체 느낌/추천 대상/추천 이유",
        
        "url": "/book/sm/2020/09/15/%EC%9E%90%EA%B8%B0%EA%B4%80%EB%A6%AC-%EC%B1%85-01.html"
      }
      ,
    
      "book-leadership-2020-09-15-eb-a6-ac-eb-8d-94-ec-8b-ad-ec-b1-85-01-html": {
        "title": "01: ",
        "tags": "리더십, 책 리뷰, 서평, 책",
        "date": "September 15, 2020",
        "author": "",
        "category": "Book/Leadership",
        "content": "배경/단상줄거리/ 주요 내용 요약발췌 및 해석전체 느낌/추천 대상/추천 이유",
        
        "url": "/book/leadership/2020/09/15/%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%B1%85-01.html"
      }
      ,
    
      "book-ch-2020-09-15-eb-ac-b8-ed-99-94-ec-97-ad-ec-82-ac-ec-b1-85-01-html": {
        "title": "01: ",
        "tags": "문화, 역사, 책 리뷰, 서평, 책",
        "date": "September 15, 2020",
        "author": "",
        "category": "Book/CH",
        "content": "배경/단상줄거리/ 주요 내용 요약발췌 및 해석전체 느낌/추천 대상/추천 이유",
        
        "url": "/book/ch/2020/09/15/%EB%AC%B8%ED%99%94-%EC%97%AD%EC%82%AC-%EC%B1%85-01.html"
      }
      ,
    
      "book-classics-2020-09-15-ea-b3-a0-ec-a0-84-ec-b1-85-01-html": {
        "title": "01: ",
        "tags": "고전, 책 리뷰, 서평, 책",
        "date": "September 15, 2020",
        "author": "",
        "category": "Book/Classics",
        "content": "배경/단상줄거리/ 주요 내용 요약발췌 및 해석전체 느낌/추천 대상/추천 이유",
        
        "url": "/book/classics/2020/09/15/%EA%B3%A0%EC%A0%84-%EC%B1%85-01.html"
      }
      ,
    
      "book-bm-2020-09-15-ea-b2-bd-ec-98-81-eb-a7-88-ec-bc-80-ed-8c-85-ec-b1-85-01-html": {
        "title": "01: ",
        "tags": "경영, 마케팅, 책 리뷰, 서평, 책",
        "date": "September 15, 2020",
        "author": "",
        "category": "Book/BM",
        "content": "배경/단상줄거리/ 주요 내용 요약발췌 및 해석전체 느낌/추천 대상/추천 이유",
        
        "url": "/book/bm/2020/09/15/%EA%B2%BD%EC%98%81-%EB%A7%88%EC%BC%80%ED%8C%85-%EC%B1%85-01.html"
      }
      ,
    
      "cv-projects-2020-09-11-ea-b3-a0-ec-96-91-ec-8b-9c-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-b5-9c-ec-a0-81-ec-9e-85-ec-a7-80-ec-84-a0-ec-a0-95-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-09-eb-b3-b4-ea-b3-a0-ec-84-9c-html": {
        "title": "09: 최종 보고서",
        "tags": "project, CV",
        "date": "September 11, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "  공공자전거의 최적 위치를 수요와 리밸런싱을 고려하여 제시하였다.파일을 불러오는데 시간이 좀 걸립니다!",
        
        "url": "/cv/projects/2020/09/11/%EA%B3%A0%EC%96%91%EC%8B%9C-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%B5%9C%EC%A0%81-%EC%9E%85%EC%A7%80-%EC%84%A0%EC%A0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-09-%EB%B3%B4%EA%B3%A0%EC%84%9C.html"
      }
      ,
    
      "cv-projects-2020-09-11-ea-b3-a0-ec-96-91-ec-8b-9c-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-b5-9c-ec-a0-81-ec-9e-85-ec-a7-80-ec-84-a0-ec-a0-95-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-08-html": {
        "title": "08: 결과 분석",
        "tags": "project, CV",
        "date": "September 11, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/09/11/%EA%B3%A0%EC%96%91%EC%8B%9C-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%B5%9C%EC%A0%81-%EC%9E%85%EC%A7%80-%EC%84%A0%EC%A0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-08.html"
      }
      ,
    
      "cv-projects-2020-09-11-ea-b3-a0-ec-96-91-ec-8b-9c-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-b5-9c-ec-a0-81-ec-9e-85-ec-a7-80-ec-84-a0-ec-a0-95-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-07-html": {
        "title": "07: 최적 후보군 선정 알고리즘",
        "tags": "project, CV",
        "date": "September 11, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/09/11/%EA%B3%A0%EC%96%91%EC%8B%9C-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%B5%9C%EC%A0%81-%EC%9E%85%EC%A7%80-%EC%84%A0%EC%A0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-07.html"
      }
      ,
    
      "cv-projects-2020-09-11-ea-b3-a0-ec-96-91-ec-8b-9c-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-b5-9c-ec-a0-81-ec-9e-85-ec-a7-80-ec-84-a0-ec-a0-95-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-06-ed-9b-84-eb-b3-b4-ea-b5-b0-ec-83-9d-ec-84-b1-html": {
        "title": "06: 후보군 생성 &amp; 수요 예측 모델",
        "tags": "project, CV",
        "date": "September 11, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/09/11/%EA%B3%A0%EC%96%91%EC%8B%9C-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%B5%9C%EC%A0%81-%EC%9E%85%EC%A7%80-%EC%84%A0%EC%A0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-06-%ED%9B%84%EB%B3%B4%EA%B5%B0-%EC%83%9D%EC%84%B1.html"
      }
      ,
    
      "cv-projects-2020-09-11-ea-b3-a0-ec-96-91-ec-8b-9c-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-b5-9c-ec-a0-81-ec-9e-85-ec-a7-80-ec-84-a0-ec-a0-95-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-05-eda-ed-9b-84-eb-b3-b4-ea-b5-b0-ec-83-9d-ec-84-b1-html": {
        "title": "05: EDA &amp; 후보군 생성",
        "tags": "project, CV",
        "date": "September 11, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/09/11/%EA%B3%A0%EC%96%91%EC%8B%9C-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%B5%9C%EC%A0%81-%EC%9E%85%EC%A7%80-%EC%84%A0%EC%A0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-05-EDA-%ED%9B%84%EB%B3%B4%EA%B5%B0-%EC%83%9D%EC%84%B1.html"
      }
      ,
    
      "cv-projects-2020-09-11-ea-b3-a0-ec-96-91-ec-8b-9c-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-b5-9c-ec-a0-81-ec-9e-85-ec-a7-80-ec-84-a0-ec-a0-95-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-04-eda-html": {
        "title": "04: EDA 2",
        "tags": "project, CV",
        "date": "September 11, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/09/11/%EA%B3%A0%EC%96%91%EC%8B%9C-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%B5%9C%EC%A0%81-%EC%9E%85%EC%A7%80-%EC%84%A0%EC%A0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-04-EDA.html"
      }
      ,
    
      "cv-projects-2020-09-11-ea-b3-a0-ec-96-91-ec-8b-9c-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-b5-9c-ec-a0-81-ec-9e-85-ec-a7-80-ec-84-a0-ec-a0-95-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-03-eda-html": {
        "title": "03: EDA 1",
        "tags": "project, CV",
        "date": "September 11, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/09/11/%EA%B3%A0%EC%96%91%EC%8B%9C-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%B5%9C%EC%A0%81-%EC%9E%85%EC%A7%80-%EC%84%A0%EC%A0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-03-EDA.html"
      }
      ,
    
      "cv-projects-2020-09-11-ea-b3-a0-ec-96-91-ec-8b-9c-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-b5-9c-ec-a0-81-ec-9e-85-ec-a7-80-ec-84-a0-ec-a0-95-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-02-ec-a0-84-ec-b2-98-eb-a6-ac-eda-html": {
        "title": "02: 전처리 &amp; EDA",
        "tags": "project, CV",
        "date": "September 11, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/09/11/%EA%B3%A0%EC%96%91%EC%8B%9C-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%B5%9C%EC%A0%81-%EC%9E%85%EC%A7%80-%EC%84%A0%EC%A0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-02-%EC%A0%84%EC%B2%98%EB%A6%AC-EDA.html"
      }
      ,
    
      "cv-projects-2020-09-11-ea-b3-a0-ec-96-91-ec-8b-9c-ea-b3-b5-ea-b3-b5-ec-9e-90-ec-a0-84-ea-b1-b0-ec-b5-9c-ec-a0-81-ec-9e-85-ec-a7-80-ec-84-a0-ec-a0-95-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-01-ec-a0-84-ec-b2-98-eb-a6-ac-html": {
        "title": "01: 전처리",
        "tags": "project, CV",
        "date": "September 11, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "",
        
        "url": "/cv/projects/2020/09/11/%EA%B3%A0%EC%96%91%EC%8B%9C-%EA%B3%B5%EA%B3%B5%EC%9E%90%EC%A0%84%EA%B1%B0-%EC%B5%9C%EC%A0%81-%EC%9E%85%EC%A7%80-%EC%84%A0%EC%A0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-01-%EC%A0%84%EC%B2%98%EB%A6%AC.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-14-mask-rcnn-html": {
        "title": "14: Mask R-CNN",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Segmentation",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "개요structure of mask RCNN  Facebok AI Research (FAIR), Kaiming He, 24 Jan 2018  Marr Prize at ICCV 2017object instance segmentation을 위한 프레임 워크이다. 기존의 semantic segmentation을 넘어서 각각의 instance도 구분이 가능한 구조를 만들었다. 학습이 쉽고 Faster RCNN에 조금의 overhead만 추가하여 5fps의 빠르기로 실행된다. COCO 데이터셋에서 instance segmentation, bbox object detection, person keypoint detection 에서 가장 높은 결과를 보였다.핵심 아이디어  Faster R-CNN에서 detect한 각각의 box에 mask를 씌워주자!instance segmentation은 두 가지 과제를 합친 것이다.  object detection          bbox를 이용하여 object를 분류하고, 위치를 찾는 것.        semantic segmentation          object instance는 구별하지 않지만, 정해진 카테고리별로 각각의 pixel을 분류하는 것      이전의 Segmentation에서 중요한 논문인 FCN에서는 총 3가지를 고려하였다.  pixel 단위의 classification  그렇기 때문에 pixel 단위 softmax 값 추출이 필요  multi instance를 고려해야 함하지만 mask RCNN은 Faster RCNN을 그대로 가져다가 쓰기 때문에, 이 문제가 다소 변경된다.  pixel 단위의 classification -&gt; 이미 bounding box로 구분을 해줌  그렇기 때문에 pixel 단위 softmax 값 추출이 필요 -&gt; bounding box 안에서 물체 인지 아닌지만 구분해주면 됨(Sigmoid)  multi instance를 고려해야 함 -&gt; 이미 multi instance로 bounding box를 쳐줌class, box 외에 mask FCN만 추가한다.결과적으로, 이 문제에서 해야할 일은 masking을 수행하는 것이다. 그래서 논문이름도 Mask RCNN이다.Equivariance  input에서의 변화가 output의 변화에 영향을 준다.Invariance vs. Equivarianceclassification 문제에서는 label을 도출하는 문제이기 때문에 Invariance 하다. 하지만 segmentation 문제 같은 경우에는 output이 원래 이미지 사이즈와 같아야 하기 때문에 이 문제는 Equivariance로 해결 해야한다. 이 때, 저자들은 convolution은 translation-equivariance 하기 때문에 이 네트워크를 사용했다.Fully convolutional network 사용mask RCNN의 구조를 담당하는 Faster RCNN은 Fully conv net을 사용하고 있다. 여기서 mask RCNN은 뒤의 mask head부분 역시 FCN을 사용하여 제작하였다.RoI Align기존의 Faster RCNN의 구조기존에 Faster RCNN에서는 feature map을 뽑아낸 뒤, Region proposal Network를 사용하여 이를 제시하였다. 그 방법은 RoI pooling이었다. 하지만 segmentation은 detection 문제와 다르게 단지 box를 치는 문제가 아니다. 좀더 정확한 위치정보를 담은 상태의 feature map이 필요하다.RoI pooling은 proposal의 위치를 반올림한다.기존의 RoI Pooling을 생각해보면, 4개의 좌표 변환 값을 regression하고, 이를 기반으로 예상 좌표를 얻어낸 뒤(실수) 이를 반올림하여 정수단위인 pixel의 위치를 제안한다. 하지만, 소수점을 반올림한 좌표를 가지고 Pooling을 해주면 input image의 원본 위치 정보가 왜곡된다. classfication에는 이런 문제가 심각하지 않지만, pixel-by-pixel로 detection을 진행해야 하는 segmentation 에서는 문제가 발생한다.RoI Align이 문제를 해결하기 위해 저자들은 다음과 같은 방법을 통해 이를 해결한다.  제안된 proposal을 들고온다.  Roi pooling에서 4등분 했던 것처럼 일단 자른다.  그 안에서 추가적으로 4등분을 한다. (subcell)  이렇게 발생한 격자내에 들어오는 픽셀의 면적을 기준으로 가중평균한다.  발생한 값을 기준으로 pooling한다.이 방법은 Mask Accuracy에서 큰 향상을 보였다.Mask RCNN architectureMask R-CNN은 여러 가지 아키텍쳐를 합친 네트워크인데, 크게 두 가지로 나뉜다.  Convolutional backbone architecture          이미지에서 feature extraction        Network head          bounding-box 인식(classification &amp; regression), mask 예측      Head ArchitectureResNet Backbone논문에서는 ResNet 과 ResNeXt networks 를 depth 50 or 101 layers에 대해 평가했다. 원래 Faster R-CNN은 ResNet을 사용하는데, 4번째 스테이지의 마지막 Conv layer(이하 C4)에서 features를 뽑아낸다.이 경우, 이 backbone을 사용한다면 우리는 ResNet-50-C4 와 같이 부를 것이다. ResNet-50-C4가 일반적으로 사용된다.ResNet-FPN BackboneFPN은 Feature Pyramid Network로, top-down architecture를 사용한다. FPN backbone을 사용하는 Faster R-CNN은 피쳐 피라미드의 서로 다른 레벨로부터 RoI features를 뽑아내지만, 나머지는 vanilla ResNet과 같다. Mask R-CNN에서 피쳐 추출을 위해 ResNet-FPN backbone을 이용하는 것은 정확도와 속도 면에서 엄청난 향상을 보였다. Feature Pyramid Network는 추후 글에서 작성하도록 하겠다.Loss function (decoupling)  $L_{cls}$ : Softmax Cross Entropy (loss of classification)  $L_{box}$ : bbox regression  $L_{mask}$ : Binary Cross Entropy위의 아이디어를 그대로 가져와서, 결과적으로 masking만 하는 loss 함수를 정의하여 사용한다. 그림으로 이해해 보자.이전 방법들과의 비교그림을 보게되면, 단순히 masking을 하는 구조를 추가하고, 이를 반영하는 방식으로 진행된다.mask Head의 loss update 방법update 방법은 상당히 단순한데, 일단 전체 mask loss는 모든 클래스(사람, 말 등)에서 차이가 나는 mask의 정도로 정의가 된다. 하지만 해당 사진에서 bounding box는 하나만 box 처리가 되어 있다. 기존의 faster RCNN에서 bounding box를 예측할 때는 하나의 box만 처리하기 때문이다. 이런 상황에서 mask에 대한 업데이트는 모든 사물에 대해서 업데이트를 할 수 없게 된다. 그래서 이렇게 해당 사진의 class가 정해질 경우, 해당 class에 해당하는 mask만을 선택하고 이를 업데이트 해준다. 즉, 말이 정답 class인 경우, 이 class에 해당하는 mask만 학습된다.결과적으로 이렇게 학습되는 mask branch는 어떠한 class인지 상관 없이 물체의 masking만 따는 것을 배우게 된다.test senario이렇게 학습된 mask branch는 실제로 여러개의 물체에 대한 mask라고 예측할 것이다. 하지만 이 녀석은 어떠한 물체인지 분간하지 못하는데, 이부분에 있어서 classification의 결과를 넣어주어, 하나의 masking을 제안한다. 즉 mask prediction에서는 단지 이 pixel이 mask인지, 아닌지 만을 구분(sigmoid 사용)하도록 하여 성능의 향상을 보였다. 이러한 방법을 Mask prediction 과 class prediction 을 decouple 했다고 한다.decouple을 시도했을 때 올라간 정확도ReferenceMask R-CNN 정리PR-057: Mask R-CNN",
        
        "url": "/ds/dl/2020/09/07/computer-vision-14-Mask-RCNN.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-13-deep-lab-html": {
        "title": "13: Deep Lab",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Segmentation",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "개요앞서 배운 Dilated Convolution(atrous convolution) 을 적극적으로 활용할 것을 제안하여 segmentation 을 해결하자는 논문이다.발전 방향  DeepLab V1 : Atrous convolution을 처음 적용  DeepLab V2 : multi-scale context를 적용하기 위한 Atrous Spatial Pyramid Pooling (ASPP) 기법을 제안  DeepLab V3 : 기존 ResNet 구조에 Atrous Convolution을 활용해 좀 더 Dense한 feature map을 얻는 방법을 제안  DeepLab V3+ : Depthwise Separable Convolution과 Atrous Convolution을 결합한 Atrous Separable Convolution의 활용을 제안DeepLab V3+ 논문은 2018년 8월 경, 구글에서 작성된 논문이다.Semantic Segmentation을 해결하기 위한 방법론은 여러가지가 존재한다. 그 중 DeepLab 시리즈는 여러 segmentation model 중 성능이 상위권에 많이 포진되어 있는 model들이다. 그 중에서도 가장 성능이 높으며 DeepLab 시리즈 중 가장 최근에 나온 DeepLab V3+에 대해 살펴보자. 해당 논문은 앞서 작성된 V1, V2, V3에 대한 내용을 계승하고 있다. 따라서 V3+를 리뷰하며 이 내용들을 모두 알아보자 한다.사용 개념Atrous ConvolutionAtrous ConvolutionAtrous에서 trous는 구멍(hole)을 의미함으로써, Atrous Convolution은 기존 Convolution과 다르게 필터 내부에 빈 공간을 둔 채 작동하게 된다.위 그림에서 얼마나 빈 공간을 둘지 결정하는 파라미터값 r(rate의 약자)이 1인 경우, 기존 Convolution과 동일하고 r이 커질수록 빈 공간이 넓어지게 되는 것이다.이러한 Atrous Convolution을 활용함으로써 얻을 수 있는 이점은 기존 convolution과 동일한 양의 파라미터와 계산량을 유지하면서도, field of view(한 픽셀이 볼 수 있는 영역)를 크게 가져갈 수 있게 된다는 것이다.보통 Semantic Segmentation에서 높은 성능을 내기 위해서는 CNN의 마지막에 존재하는 한 픽셀이 입력값에서 어느 크기의 영역에서 커버할 수 있는지를 결정하는 receptive field 크기가 중요하게 작용한다.즉, 여러 convolution과 pooling 과정에서 디테일한 정보가 줄어들고 특성이 점점 추상화되는 것을 어느정도 방지할 수 있기 때문에 DeepLab series에서는 이를 적극적으로 활용하려 노력한다.Atrous Spatial Pyramid Pooling(ASPP)Atrous Spatial Pyramid PoolingSemantic segmentaion의 성능을 높이기 위한 방법 중 하나로, spatial pyramid pooling 기법이 자주 활용되고 있는 추세이다.DeepLab V2에서 feature map으로부터 rate가 다른 Atrous Convolution을 병렬로 적용한 뒤, 이를 다시 합쳐주는 ASPP기법을 활용할 것을 제안했었다. 최근 발표된 PSPNet에서도 Atrous Convolution을 활용하진 않았지만 이와 비슷한 Pyramid Pooling 기법을 활용하였다.Atrous Spatial Pyramid Pooling이러한 이러한 방법들은 multi-scale context를 모델 구조로 구현하여 보다 정확한 Semantic Segmentation을 수행할 수 있도록 도우며, DeepLab V3부터는 ASPP를 기본 모듈로 계속 사용하고 있다.Depthwise separable convolution일반적으로 사용되는 Convolution 모습위 그림은 일반적으로 사용되는 Convolution을 나타낸 사진이다. 입력 이미지가 883(HWC)이고, Convolution 필터 크기가 33(FF)이라고 할 때, 필터 한개가 가지는 파라미터 개수는 333(FFC)=27이 된다. 만약 필터가 4개라면, 해당 Convolution의 총 파라미터 수는 3*3*3*4(F*F*C*N)만큼 지니게 된다.Depthwise Convolution 모습Convolution 연산에서 Channel 축을 필터가 한 번에 연산하는 대신에 위 그림과 같이 입력 영상의 Channel 축을 모두 분리시킨 뒤, Channel 축 길이를 항상 1로 가지는 여러 개의 Convolution 필터로 대체시킨 연산을 Depthwise Convolution이라고 한다.Depthwise Separable Convolution 모습위의 Depthwise Convolution으로 나온 결과에 대해 11C 크기의 Convolution 필터를 적용한 것을 Depthwise Separable Convolution이라 한다.이처럼 복잡한 연산을 수행하는 이유는 기존 Convolution과 유사한 성능을 보이면서도 사용하는 파라미터 수와 연산량을 획기적으로 줄일 수 있기 때문이다.예를 들어, 입력값이 883이고 16개의 3*3 Convolution 필터를 적용할 때 사용되는 파라미터 개수는  Convolution : 33316(HWCN) = 432  Depth Separable Convolution : 333(HWC1) + 316(113*N) = 27+48 = 75임을 확인 할 수 있다.Depthwise Separable Convolution은 기존 Convolution 필터가 Sepatial Dimension과 Channel Dimension을 동시에 처리하던 것을 따로 분리시켜 각각 처리한다고 볼 수 있다. 이 과정에서, 여러 개의 필터가 Spatial Dimension 처리에 필요한 파라미터를 하나로 공유함으로써 파라미터의 수를 더 줄일 수 있게 되는 것이다. 이 부분은 Dilated convolution에서 배운 내용과 상등하다.두 축을 분리시켜 연산을 수행하더라도 최종 결과값은 결국 두 가지 축 모두를 처리한 결과값을 얻을 수 있으므로, 기존 convolution filter가 수행하던 역할을 충분히 대체할 수 있게 된다.Encoder-DecoderDeepLab V3+는 위에서 설명한 모듈을 Encoder-Decoder로 구조화시켰다.U-net구조동작미리 보기DeepLab V3 구조DeepLab V3는 기본적으로 ResNet을 Backbone으로 사용하였으며 구조는 다음과 같다.  Encoder : ResNet with Atrous Convolution  ASPP  Decoder : Bilinear UpsamplingDeepLab V3+ 구조여기서 DeepLab V3+가 변경된 부분은 다음과 같다.  Encoder : ResNet with Atrous Convolution를 Xception으로 변경  ASP을 ASSPP (Atrous Separable Spatial Pyramid Pooling)로 변경  Decoder : Bilinear Upsampling을 Simplified U-Net style decoder으로 변경세부 설명DeepLab V3+ 세부 구조Encoder with Atrous ConvolutionDCNN에서 Atrous Convolution을 통해 임의의 resolution으로 feature map을 뽑아낼 수 있도록 한다.여기서 Output Stride의 개념이 쓰이는데 “input image의 resolution과 최종 output의 비”로 생각하면 된다. 즉, 최종 feature map이 input image에 비해 32배 줄어들었다면 output stride는 32가 되는 것이다.Semantic Segmentation에서는 더욱 디테일한 정보를 얻어내기 위해 마지막 부분의 Layer을 1개 혹은 2개를 삭제 후 Atrous Convolution해줌으로써 Output Stride를 16 혹은 8로 줄인다.그리고 아래 사진과 같이 다양한 크기의 물체 정보를 잡아내기 위해 다양한 rate의 Atrous Convolution을 사용하는 ASPP(Atrous Spatial Pyramid Pooling)을 사용한다.Atrous Spatial Pyramid PoolingDecoder이전의 DeepLab V3에서는 Decoder 부분을 단순히 bilinear upsampling해주었으나, V3+에서는 Encoder의 최종 Output에 1*1 Convolution을 하여 Channel을 줄이고 bilinear upsampling 해준 후 Concat하는 과정이 추가되었다.하지만 이러한 과정을 거치더라도 bilinear interpolation만으론 정확하게 객체의 픽셀 단위까지 위치를 정교히 segmentation하는게 불가능하다. 저자들은 뒷부분에 CRF(Conditional Random Field)를 이용하여 post-processing(후처리)을 수행하도록 했다. 이에 대한 자세한 설명은 밑에 하도록 하겠다.BackboneDeepLab V3+에서는 Xception을 backbone으로 사용하지만 MSRA의 Aligned Xception과 다른 3가지 변화를 주었다.왼쪽 : 원래의 Xception 모델, 오른쪽 : 논문에서 사용된 변형 Xception 모델  빠른 연산과 메모리 효율을 위해 Entry Flow Structure 를 수정하지 않았다.  Atrous Separable Convolution을 적용하기 위해 모든 Pooling Opearation을 Depthwise Separable Convolution으로 대체하였다.  각각의 3*3 Depthwise Convolution 이후에 추가적으로 Batch-norm과 ReLU 활성화 함수를 추가해주었다.Fully Connected CRFCRF 사용 후 선명도의 개선일반적으로 1/8크기 해상도를 갖는 DCNN 결과를 bilinear interpolation을 통해 원영상 크기로 확대하면 아래처럼 해상도가 떨어지는 문제가 있다. DeepLab 구조에서는 이 문제 해결을 위해 CRF(Conditional Random Field)를 사용하는 후처리를 이용해 성능을 향상시켰다.CRF 반복 횟수에 따른 결과 양상왜 CRF(Conditional Random Field)가 필요한가?Classification과 같이 object-centric한 경우 가능한 높은 수준의 공간적인 불변성(spatial invariance)를 얻기 위해 여러 단계의 conv+pooling을 통해 영상 속에 존재하며 변화에 영향을 크게 받지 않은 강인한 특징을 추출해야하며, 이로인해 detail한 정보보단 global한 정보에 집중하게 된다.반면 semantic segmenation은 픽셀 단위의 조밀한 예측이 필요해 classification 네트워크 기반으로 segmentation 망을 구상하게 된다면 계속 feature map의 크기가 줄어들게되는 특성상 detail한 정보들을 잃게 된다.이 문제에 대한 해결책으로 FCN에선 skip connection을 사용하였고, dilated conv나 DeepLab에서는 마지막에 오는 pooling layer 2개를 없애고 dilated/atrous conv를 사용했다. 후에 작성할 Mask RCNN에서는 Roi align을 사용해서 이를 해결하고자 했다.하지만 이러한 방법을 사용하더라도 분명히 한계는 존재하기에 DeepLab에서는 atrous conv에 그치지 않고 CRF를 후처리 과정으로 사용하여 픽셀 단위 예측의 정확도를 더 높일 수 있게 되었다.개념  이전 노드(pixel)간의 관계(조건부 확률 같은)를 기반으로 현재 노드의 값을 추론한다.일반적으로 좁은 범위(short-range)의 CRF는 segmentation을 수행한 뒤 생기는 segmentation noise를 없애는 용도로 많이 사용된다.하지만 앞서 살펴본 것처럼 DCNN에서는 여러 단계 conv+pooling을 거치며 feature map의 크기가 작아지게 되고 이를 upsampling을 통해 원 영상 크기로 확대하기에 이미 충분히 smoothen되어있는 상태이며, 여기에 기존처럼 short-range CRF를 적용하면 결과가 더 나빠지게 된다.Noise 성분도 같이 upsampling 되므로 세분화된 segmentation 결과를 얻기 어렵다. 이에 대한 해결책으로 Efficient Inference in Fully Connected CRFs with Gaussian Edge Potentials (Philipp Karahenbuhl)라는 논문이 발표되었으며, 해당 논문에선 기존에 사용되던 short-range CRF대신 전체 픽셀을 모두 연결한 (fully connected) CRF 방법을 개발해 놀라운 성능 향상을 얻어내었고 이 후 많은 사람들이 fully connected CRF를 후처리에서 사용하게 된다.기존에 사용되던 short-range CRF는 아래 그림처럼 local connection 정보만을 사용한다.이렇게 되면 detail 정보가 누락되게 된다.short range CRF 적용반면 fully connected CRF를 사용하면 아래처럼 detail 정보들이 살아있는 결과를 얻을 수 있다. 물론 모든 노드(pixel)을 연결하여 처리하기 때문에 굉장히 오랜 시간이 걸린다는 것을 알 수 있다.Fully connected CRF 적용위처럼 MCMC(Markov Chain Monte Carlo) 방식을 사용할 경우 좋은 결과가 나오지만 연산량이 많다는 단점이 있어 적용이 불가했다. 하지만 Philipp Karahenbuhl의 논문에서 이를 0.2초만에 효과적으로 연산가능하게 했다.Philipp Karahenbuhl는 일명 mean field approximation 방법을 적용해 message passing을 사용한 iteration 방법을 적용하여 효과적으로 빠른 fully connected CRF를 수행 가능하도록 했다.여기서 mean field approximation이란 물리학이나 확률이론에서 많이 사용되는 방법으로, 복잡한 모델을 설명하기 위해 더 간단한 모델을 선택하는 방식을 의미한다. 수많은 변수들로 이루어진 복잡한 관계를 갖는 상황에서 특정 변수와 다른 변수들의 관계의 평균을 취하게 되면, 평균으로부터 변화(fluctuation)를 해석하는데도 용이하고, 평균으로 단순화/근사화된 모델을 사용하면 전체를 조망하기에 좋다.수식Conditional Random FieldCRF의 수식을 보면 unary term과 pairwise term으로 구성됨. 아래의 식에서 x는 각 픽셀의 위치에 해당하는 픽셀의 label이며, i와 j는 픽셀의 위치좌표를 나타낸다. Unary term은 CNN 연산을통해 얻어질 수 있으며, 픽셀간의 detail한 예측에서 pairwise term이 중요한 역할을 한다. Pairwise term에서는 마치 bi-lateral filter에서 그러듯이 픽셀값의 유사도와 위치적인 유사도를 함께 고려한다.(필터에 대해서는 [Learn opencv by examples] 6. Gaussian 필터, Bilateral 필터, Median 필터를 읽어보자.)Conditional Random Field위 CRF 식을 보면, 2개의 가우시안 커널로 구성된 것을 볼 수 있으며 표준편차 를 통해 scale을 조절 할 수 있다. 첫 번째 가우시안 커널은 비슷한 컬러를 갖는 픽셀들에 대해 비슷한 label이 붙을 수 있도록 하며, 두 번째 가우시안 커널은 원래 픽셀의 근접도에 따라 smooth 수준을 결정한다. 위 식에서 $p_i, p_j$는 픽셀의 위치(position)를 나타내며 $I_i, I_j$는 픽셀의 컬러값(intensity)이다.이것을 고속처리하기 위해 Philipp Krahenbuhl 방식을 사용하게 되면 feature space에서는 Gaussian convolution으로 표현 할 수 있게되어 고속 연산이 가능해진다. (아 이부분은 도저히..)CRF가 적용된 동작 방식CRF까지 적용된 동작 방식  DCNN을 통해 1/8 크기의 coarse score-map을 구한다.  이것을 bilinear interpolation을 통해 원영상 크기로 확대시킴.  Bilinear interpolation을 통해 얻어진 결과는 각 픽셀 위치에서의 label에 대한 확률이 되며 이것은 CRF의 unary term에 해당함.  최종적으로 모든 픽셀 위치에서 pairwise term까지 고려한 CRF 후보정 작업을 해주면 최종적인 출력 결과를 얻을 수 있음결과Encoder : Xceptiondecoder 변경 후 결과Encoder를 Xception으로 교체 후 실험하였을 때는 약 2% 가량의 성능 향상을 가져왔다.ASPP 부분과 Decoder 부분에 사용되는 Convolution들을 모두 Separable Convolution으로 대체할 경우 성능은 기존 Convolution을 사용할 때와 거의 비슷하였지만, 모델이 사용하는 연산량 자체가 획기적으로 줄어들었음을 확인 할 수 있었다.Decoder : U-Net 사용decoder 변경 후 결과다양한 파라미터와 세팅에 대해서 실험을 진행하였는데, 우선 ResNet-101 구조를 Encoder로 사용하였을 때, 성능을 측정한 것이다. Decoder 부분을 bilinear upsampling 대신, 단순화된 U-Net 구조로 변경할 경우 기존 대비 mIOU 1.64% 향상이 있음을 확인 할 수 있다.Pascal VOC 2012 validation set에서의 visualization 결과위 Visualization 결과를 보면 상당히 안정적이고 정확하게 각각의 픽셀에 대해 클래스를 예측하고 있음을 확인할 수 있다. Xception 기반의 encoder로 양질의 high level semantic 정보를 가지는 feature를 추출할 수 있고, ASPP 모듈을 통해 각 픽셀이 여러 스케일의 context 정보를 취해 보다 정확한 추론이 가능하며, U-Net 구조의 decoder를 통해 각 물체에 해당하는 정교한 boundary를 그려낼 수 있기에 위와 같은 visualization 결과를 얻어낼 수 있다고 해석해 볼 수 있다.ReferenceDeepLabv3+ 원리Efficient Inference in FullyConnected CRFs with GaussianEdge Potentials",
        
        "url": "/ds/dl/2020/09/07/computer-vision-13-deep-lab.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-12-xception-html": {
        "title": "12: Xception",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Base-Model",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "개요Pretrained model을 사용하거나 Transfer Learning 을 사용하는 모델들에 대해서 읽을 때 Backbone이 되는 CNN 모델들이 몇 개 있다. VGG family, ResNet family, Inception family, 그리고 Xception. 복잡한 작업(e.g. Semantic Segmentation 등)의 기초가 되는 이 네트워크에 대해서 정리해 보자.Xception 모델이란?Xception 은 구글이 2017년에 발표한 모델로, 2015년에 ILSVRC 대회에서 2등을 한 Google 의 Inception-V3 모델보다 훨씬 좋은 결과를 냈다.Encoder-Decoder 형태의 모델들에서 pretrain 된 Xception 모델이 Encoder로 자주 쓰인다. 또한 Xception 에서 제시하는 모델의 구조나 핵심인 modified depthwise separable convolution의 개념이 간단하기 때문에 다른 모델에도 적용하기 쉽다.Xception 이라는 이름 자체가 Extreme + Inception 에서 나온 만큼 Inception 모델이 기본이 된다. 먼저 Inception 모델들에 대해서 간단하게 정리해 보자.Inception Family요즘에는 version 4과 ResNet이 합쳐진 Inception-ResNet v2 혼종까지 나왔다.Inception-ResNet v2다른 모델에 활용하기에는 복잡해서, 연산량이나 parameter의 개수가 VGG보다 훨씬 적음에도 불구하고 vgg net이 더 자주 사용된다고 한다.차이점보통 5x5 또는 7x7의 하나의 convolution 필터로 진행하는데, Inception 모델에서는 conv 레이어 여러 개를 한 층에서 구성하는 형태를 취하고 있다.영화 Inception 에서 이름을 따온 이유가 여기 있다! ‘동시에’ (같은 Layer(꿈)에서) 다양한 convolution 을 진행하기 때문이다. 끼워 맞춘 것 같은거는 나만 그래?naive Inception module목적딥러닝은 망이 깊을수록 (deep), 레이어가 넓을수록 (wide) 성능이 좋지만, overfitting &amp; vanishing gradient 의 문제로 깊고 넓게만 모델을 만드는 것은 문제이다. Inception 은 Convolution 레이어를 sparse 하게 연결하면서 행렬 연산은 dense하게 처리하기 위해 고안한 모델이다.이러한 방법을 사용하면 두가지의 이득을 얻을 수 있다.  파라미터 개수가 줄어든다.  연산량이 줄어든다.Kernel size가 늘어날수록 연산량의 크기가 굉장히 커지기 때문에 나중에는 5x5 가 아니라 3x3을 2번 하는 방향으로 바뀐다. 더 나아가서 3x3 를 쪼개서 3x1 과 1x3 convolution 을 2번 하는 방향Asymmetric Convolution Factorizing으로 가기도 한다.사용하는 개념1x1 ConvolutionConvolution의 연산은 [Batch Size, Width, Height, Channel], 4차원의 데이터로 표기한다. Batch Size는 이미지 뭉터기의 개수를 의미한다. 보통의 convolution 은 채널의 개수를 늘리는 방향으로 진행하지만(conv filter의 개수를 늘리는), 1x1 연산의 목적은 채널의 개수를 줄여서 압축하는데에 있다.Residual Network(ResNet)            _왼쪽: 가장 간단한 형태의 residual-connection      오른쪽: 1 x 1 conv 를 추가해서 연산량을 줄인 모델_      ResNet의 Idea는 gradient vanishing 문제를 이전 Layer의 결과를 더해줌으로써 해결하자이다. Inception 모델 역시 이를 사용했다.Residual을 사용하여 학습 수렴속도상승정리  하나의 Convoltion X다양한 크기 Convolution -&gt; Concate OInception 모델이 주안점을 두고 설계한 포인트는 다음과 같다.  Convolution 을 할 때 하나의 큰 kernel 을 사용할게 아니라 다양한 크기를 이어붙이기  Residual 사용  Convolution 연산에 Asymmetric Convolution Factorizing 사용Xception  파라미터 개수를 더 줄여보자. 극단적으로.  영향을 받은 핵심 포인트          VGG16 : 깊게, 더 깊게      Inception Family: Conv 를 할 때 몇개의 branch 로 factorize 해서 진행      Depthwise Separable Convolution                  네트워크의 사이즈와 연산량을 줄이기 위한 연구(채널별로 conv 를 진행한 후 feature map에 대해서 conv 를 진행)                      변화된 핵심 포인트          Modified Depthwise Separable Convolution      Depthwise Separable Convolution  Depthwise(깊이 별로 == 채널 별로) Separable(나누어서) convolutionDepthwise Separable ConvolutionChannel-wise nxn spatial convolution위에 그림에서와 같이 인풋으로 5개의 채널이 들어오면 5개의 n x n convolution 을 따로 진행해서 합친다.Pointwise Convolution원래 우리가 알고있는 1x1 convolution입니다. 채널의 개수를 줄이기 위한 방법으로 사용된다.Depthwise Separable Convolution process위와 같이 256 x 256 x 3 의 인풋이 있을 때, 1) 256 x 256 x 1 을 3번 진행해서 concat을 한다. 2) pointwise convolution을 이용해서 채널의 개수를 1개로 줄인다! (단순하게 weighted sum 을 계산하는 것) 위와 같은 과정으로 Convolution 을 하면 약 9배 정도 빠르다고 한다.계산량 확인  동일한 정보          특징 맵의 크기: F x F      입력 채널 수: N      커널 크기: K x K      출력 채널 수: M      위와 같은 상황에서 어떻게 계산량이 달라지는지 보자.  일반 convolution 의 계산량          계산량 F x F x N x K x K x M      Parameter 수: K x K x N x M        Point-wise 의 계산량          Channel-Wise                  Parameter 수: N x M Depthwise: 특징맵 채널마다 각각 공간 방향의 convolution 을 한다          채널방향으로 수행하지 않기 때문에 일반 convolution 1회의 cost -&gt; K x K          계산량: F x F x N x K x K          Parameter 수: K x K x N                    Pointwise                  같은 크기의 아웃풋을 만들어 낸다          특징 맵의 차원을 늘리거나 줄일 때 사용된다          K = 1 으로 만든 것.          계산량: F x F x N x M                    결론: 계산량: FxFxNxKxKxM –&gt; FxFxNxM + FxFxNxKxK로 감소즉, 소요시간은 1/M + 1/K^2 이다. 보통 M » K^2 이므로 계산량은 1/9정도가 된다.Modified Depthwise Separable ConvolutionDepthwise Separable Convolution와 큰 부분이 달라지진 않는다. 간략하게 차이점만 이해해보자.  연산의 순서          원래는 depthwise 를 진행하고, pointwise 를 했는데, 이제는 pointwise -&gt; depthwise 로 바꿈        Non-Linearity 의 유무          Inception 모델의 경우, 첫 연산 후에 non-linearity (ReLU)가 있지만, Xception은 중간에 ReLU non-linearity 를 적용하지 않음.        Residual connection 이 거의 모든 Layer 에 있다.          없애고 실험해봤더니 있을때의 정확도가 훨씬 높았음.      residual connection 이 굉장히 중요한 요소임      구조구조 자체는 굉장히 간단해서 밑에 있는 사진을 보면 쉽게 이해가 간다.Overall ArchitectureEntry, Middle, Exit의 3개 구조로 나뉜다.  Entry Flow          인풋: 229 x 229 x 3      모든 convolutional layer 다음에는 batch normalization 을 사용한다      2번 normal convolution (3x3) -&gt; 필터의 갯수: 32 -&gt; 64      Residual Network 가 합쳐진 Inception Module 3번        Middle Flow          반복되는 단순한 모델: 필터의 개수와 width/height 는 바뀌지 않음      ReLU -&gt; Separable Conv -&gt; Separable Conv 8번 반복        Exit Flow          filter의 개수를 늘린다음 -&gt; Maxpooling -&gt; 2번 separable convolution -&gt; Global Average Pooling -&gt; Optional Fully-Connected -&gt; Logistic Regression      Reference이제는 기본 모델이 된 ‘Xception’ 이해하기",
        
        "url": "/ds/dl/2020/09/07/computer-vision-12-Xception.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-11-inception-html": {
        "title": "11: Inception",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Base-Model",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "개요ReferenceGoogle Inception Model",
        
        "url": "/ds/dl/2020/09/07/computer-vision-11-Inception.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-10-u-net-html": {
        "title": "10: U-Net",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Segmentation",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "개요ReferenceU-Net 원리",
        
        "url": "/ds/dl/2020/09/07/computer-vision-10-U-Net.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-09-conditional-random-field-html": {
        "title": "09: Conditional Random Field(CRF)",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Sequence-Model",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "개요Referenceshasum -a 256 ~/Downloads/Anaconda3-2020.07-MacOSX-x86_64.shbash ~/Downloads/Anaconda3-2020.07-MacOSX-x86_64.sh",
        
        "url": "/ds/dl/2020/09/07/computer-vision-09-conditional-random-field.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-08-dilated-convolution-html": {
        "title": "08: Dilated Convolution",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Segmentation",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "개요앞서 알아본, FCN에서 발생하는 문제를 Dilated Convolution으로 해결하겠다는 논지이다.핵심 아이디어  Dilated Convolution으로 parameter 수를 유지하면서 Pooling의 효과를 누리고, Resoultion이 줄어드는 것을 막는다.(일석삼조)기존의 FCN에서는 pooling으로 인한 해상도 감소문제를 skip connection으로 해결하였다. 여기서, 근본적으로 pooling에 대해 해결하보려는 의지가 엿보인다. 우리가 Pooling을 하는 이유는 global feature를 multi-scale로 보기 위해서이다. 하지만 이런 관점은 classification의 관점에서 맞는 말이다.segementation을 위해서는 결국 dense prediction을 얻어내야 하는데, 이는 up-convolutions와 multi-scale inputs를 통해 가능하다. up-convolutions는 이전 글에서 찾아볼 수 있다. multi sclae inputs은 이름에서도 유추가 가능하듯이 하나의 이미지에 대해서 여러 scale에서 test를 하는 방법을 의미한다.multi scale inputs 예시Dilated Convolution은 애초에 pooling을 해야돼? 라는 질문에서 출발한다.Dilated ConvolutionDilated Convolution은 필터 내부에 zero padding을 추가해 강제로 receptive field를 늘리는 방법이다. 위 그림은 파란색이 인풋, 초록색이 아웃풋인데, 진한 파랑 부분에만 weight가 있고 나머지 부분은 0으로 채워진다. receptive field란 필터가 한 번의 보는 영영으로 볼 수 있는데, 결국 필터를 통해 어떤 사진의 전체적인 특징을 잡아내기 위해서는 receptive field는 높으면 높을 수록 좋다. 그렇다고 필터의 크기를 크게하면 연산의 양이 크게 늘어나고, 오버피팅의 우려가있다.그래서 일반적인 CNN에서는 이를 conv-pooling의 결합으로 해결한다. pooling을 통해 dimension을 줄이고 다시 작은 크기의 filter로 conv를 하면, 전체적인 특징을 잡아낼 수 있다. 하지만 pooling을 수행하면 기존 정보의 손실이 일어난다. 이를 해결하기 위한것이 Dilated Convolution으로 Pooling을 수행하지 않고도 receptive field의 크기를 크게 가져갈 수 있기 때문에 spatial dimension의 손실이 적고, 대부분의 weight가 0이기 때문에 연산의 효율도 좋다.StructureStructure of using Dilated Convolution첫번째 그림은 classification을 위한 CNN VGG-16의 아키텍쳐이다. conv-pooling을 반복적으로 수행한 후, 마지막으로 Fully Connected Layer에 통과하여 최종 classification 결과를 얻는 과정을 보여주고있다. 그 아래의 그림은 Dilated Convolution을 통하여 이미지를 segmentation하는 예를 보여주고 있다. 이 아키텍쳐의 아웃풋의 사이즈는 28x28xN 이며, (N은 segmentation 원하는 클래스의 수) 이를 다시 upsampling하여 원래의 크기로 복원한다. (이부분에서 공간적 정보의 손실이 있다.)이 아키텍쳐와 classification 아키텍쳐의 다른점은 우선 다이아몬드 모양으로 표시한 dilated convolution으 통해 공간적 정보의 손실을 최소화하였다. 그리고 dilated convolution 2번을 적용한 뒤 나온 28x28x4096 에 대하여 1x1 convolution으로 channel의 dimension reduction을 수행한다. 최종적으로 28x28xN이 나오고 이를 8x upsampling하여 최종적인 segmention 결과를 output으로 내놓는다. 이 때 1x1 convolution 은 공간적인 정보를 잃지 않기 위해 사용되며, classification의 Fully Connected Layer(FC)와 비슷한 역할을 한다. 하지만 classification에서는 공간적인 정보는 중요하지 않기 때문에 Flatten하여 사용하는 것이다. 이는 앞선 글에서 자세하게 다뤄보았다.결과comparison of whether using dilated conv이 그림을 통해 pooling-conv후 upsampling을 하는 것과 dilated convolution(astrous convolution)을 하는 것의 차이를 볼 수 있다. 위 그림에서 볼 수 있듯 공간적 정보의 손실이 있는 것을 upsampling 하면 해상도가 떨어진다. 하지만 dilated convolution의 그림을 보면 receptive field를 크게 가져가면서 convolution을 하면 정보의 손실을 최대화하면서 해상도는 큰 output을 얻을 수 있다.ReferenceLearning Deconvolution Network for Semantic Segmentation",
        
        "url": "/ds/dl/2020/09/07/computer-vision-08-Dilated-Convolution.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-07-learning-deconvolutional-network-for-semantic-segmentation-html": {
        "title": "07: Learning Deconvolution Network for Semantic Segmentation",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Segmentation",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "개요  Noh, H., Hong, S., and Han, B. Learning Deconvolution Network for Semantic Segmentation. ICCV, 2015.이번 논문은 앞서 다뤘던 Fully Convolutional Networks와 같은 년도(2015)에 다른 학회(FCN은 CVPR, 본 논문은 ICCV)에 발표된 논문이다. FCN이나 이후에 다룰 UNet보다는 다소 인기가 적었지만, FCN이 가진 한계를 잘 짚어주셨다는 점에서 의의가 있다.핵심 아이디어  크기, 디테일에 약해? -&gt; layer 를 추가하자. (Upconvolution)크기의 문제점위의 예시들처럼 FCN의 추론 결과를 보면, 대상 물체가 너무 큰 경우(a)에는 파편화되고, 너무 작은 경우(b)에는 배경으로 무시되는 경향이 있다. FCN에서는 receptive field(상위 레이어의 한 지점에서 참조하는 하위 레이어의 영역)의 크기가 고정되어, 단일 배율(scale)만을 학습하는 것이 이 문제의 원인이라고 본 논문은 지적한다. 여러 레이어의 결과를 조합하는 skip 구조가 이러한 현상을 완화시켜주기는 하지만, 근본적인 해법은 아니라는 주장한다.디테일의 문제점FCN이 비록 기존 기법들에 비해 큰 발전을 이루었지만, 세부적인 영역을 찾아내는 데에서는 아직 개선의 여지가 있다고 이 논문은 보고 있다. FCN에서는 deconvolution에 들어가는 입력부터 이미 세부 묘사가 떨어지고, deconvolution 과정 자체도 충분히 깊지 않고 너무 단순하다고 말한다.네트워크 구조의 변경부족하면 더 넣으면 된다. FCN에서는 CNN의 결과를 입력이미지의 원래 차원으로 확대(upsampling)하는데 있어서 deconvolution을 사용했지만, 이 논문에서는 deconvolution시 차원을 유지하는 방법으로, CNN의 layer만큼 레이어 숫자를 늘렸다. 즉, 완전한 대칭 모양이다.uppoolingCNN으로 인해 원래 이미지보다 축소된 차원 크기는 uppooling으로 복원합니다. 여기서 unpooling이란 CNN의 max pooling 시의 위치 정보를 기억했다가, 원래 위치로 그대로 복원해주는 작업이다.uppooling 과정 (a-&gt;b)그 효과는 위의 그림과 같다. (b)에서 (c)로 갈 때의 unpooling에 의해, 해상도가 커지는 대신 신호가 흩어져서 희소(sparse)해진다. 이것을 (c)에서 (d)로 deconvolution을 거치면, 디테일을 살려내면서 신호가 고르게 밀집(dense)된다. 이러한 과정이 반복되자 노이즈도 점차 자연스럽게 사라지는 것을 볼 수 있다.학습 방법edge-box단일 데이터셋에서 다양한 크기의 사례들을 학습하기 위해, 논문에서는 edge-box라는 object proposal 알고리즘을 사용하여 무언가 있을만한 영역을 다양한 크기의 상자로 골라낸다. 학습 시에는 우선 실제 정답이 가운데에 들어가도록 잘라낸(crop) 이미지들로 1차 학습을, 그 다음 edge-box의 결과물 중 실제 정답과 잘 겹치는 것들을 활용하여 조금 더 심도있는 2차 학습을 진행한다.edge-box inference이렇게 학습에 사용된 edge-box는 추론 시에도 사용되는데, 추론 시 사용하는 object proposal의 수(상자 수)를 증가시킬 수록 성능은 좋아진다고 한다. 물론 그만큼 계산량과 시간은 늘어난다.결과result이렇게 세심하게 설계되고 학습된 결과는 FCN이 실수하는 물체들도 보다 세밀하게 잘 찾아내는 모습을 보인다. 다만 FCN이 잘 맞추는 곳에서 실수를 할 때도 있는데, 결국 둘을 앙상블하여 conditional random field로 후처리하면 두 가지 모델을 모두 뛰어넘게 되어, FCN과 상호 보완적인 관계에 있다고 논문은 맺는다.ReferenceLearning Deconvolution Network for Semantic Segmentation",
        
        "url": "/ds/dl/2020/09/07/computer-vision-07-Learning-Deconvolutional-Network-for-Semantic-Segmentation.html"
      }
      ,
    
      "ds-dl-2020-09-07-computer-vision-06-fully-convolutional-networks-html": {
        "title": "06: Fully Convolutional Networks",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Segmentation",
        "date": "September 7, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "Task  SegmentationTypes of Tasksemantic segmentation은 이미지 내에 있는 물체들을 의미 있는 단위로 분할해내는 것이다. 좀 더 구체적으로 이야기하면, 이미지의 각 픽셀이 어느 클래스에 속하는지 예측하는 것이다. 이렇게 이미지 내 모든 픽셀에 대해서 예측을 진행하기 때문에 이 과제를 dense prediction이라고 부르기도 한다. 어떤 이미지 내에는 사람, 자동차, 강아지, 고양이, 노트북, 선풍기 등 여러 종류의 물체가 포함되어 있을 수 있다. 이렇게 서로 다른 종류의 물체들을 깔끔하게 분할해내는 것이 semantic segmentation의 목적이다.관련 논문들 할거개많다이 중에서 의미론적인 구분을 하는 Sementic Segmentation 중에서 Deep Lab에 대해 알아볼 것이다. 다음으로는 U-Net, 마지막으로 instance 단위로 segmentation을 진행하는 instance segmentation을 알아볼 것이다.알아두어야 할 것  평가 metric          IoU(intersection over Union)        사용 데이터셋          Pascal VOC 2012      cityscape      Fully Convolutional Networks  Fully connected 대신 Fully convolution!  Baseline          Fully Convolutional Networks for Semantic Segmentation”, 2014        Sematic Segmentation = Pixel level Calssification??CNN은 image classification을 잘한다. 그렇다면 Sememtation은 pixel 단위로 classification을 진행하면 되지 않을까? 하지만 굉장히 비효율적이다. 그렇다면, 최대한 기존 network의 구조를 변경하지 않으면서 이걸 가능하게 할 방법은?기존 VGG16 networkAlexNet, VGGNet 등 이미지 분류(image classification)용 CNN 알고리즘들은 일반적으로 컨볼루션 층들과 fully connected 층들로 이뤄져있다. 입력이미지에 의존도가 크기 때문에 항상 입력이미지를 네트워크에 맞는 고정된 사이즈로 작게 만들어서 입력해준다. 그러면 네트워크는 그 이미지가 속할 클래스를 예측해서 알려준다. 아래 그림에서 네트워크는 입력된 이미지의 클래스를 얼룩무늬 고양이(tabby cat)라고 예측해냈다.이 분류용 CNN 알고리즘들은 이미지에 있는 물체가 어떤 클래스에 속하는지는 예측해낼 수 있지만, 그 물체가 어디에 존재하는지는 예측해낼 수 없다. 왜냐하면 네트워크 후반부의 fully connected 층에 들어서면서 위치정보가 소실되었기 때문이다. 따라서 AlexNet, VGGNet 등과 같은 알고리즘들을 수정함없이 Semantic segmentation 과제에 그대로 사용하는 것은 불가능하다.Fully Convolutional Network그래서 저자들은 1x1 filter를 사용하여 위치정보를 살렸다. 마지막 단에는 7x7 heatmap 을 output으로 내고, 이를 원래 image size로 upsampling을 진행하여 문제를 해결하고자 하였다.결과적으로 네트워크 전체가 컨볼루션층들로 이뤄지게 되었다. fully connected 층들이 없어졌으므로 더 이상 입력 이미지의 크기에 제한을 받지 않게 되었다.입력 크기에 대해 자유로워졌다.저자들은 Fully Convolutional Network는 1x1 filter를 사용하기 때문에 input image에 대한 dependency가 작은 것도 장점이라 했다. 1x1 conv는 Width, Height에 대해 의존도가 없기 때문에 channel 수를 마음대로 조정하여 원하는 output 모양을 맞출 수 있다. 여러 층의 컨볼루션층들을 거치고 나면 특성맵(feature map)의 크기가 H/32 x W/32가 되는데, 그 특성맵의 한 픽셀이 입력이미지의 32 x 32 크기를 대표한다. 즉, 입력이미지의 위치 정보를 ‘대략적으로’ 유지하고 있는 것이다.Upsampling  feature map을 키워서 image size로 만들자!Heatmap과 Upsampling입력이미지의 위치 정보를 가지고 있는 Heapmap은 아직 대략적인 정보(Coarse)일 뿐이다. 이러한 정보를 기반으로 원래 이미지의 Pixel Size에서 class를 예측하는 dense Prediction을 수행해야 한다. 이 과정에서 Heat map을 원래 image size로 크기를 키워주는 과정을 upsampling이라 한다.FCN-32s 모델의 전체 과정하지만 단순히 upsampling을 진행하면 예상하겠지만 여전히 Coarse한 segmentation map을 얻게 된다. 단숨에 32배 한다면 coarse 할수 밖에 없다. 이렇게 단숨에 32배 upsampling한 네트워크를 FCN-32s라 소개하고 있다. 확실히 정확도가 많이 떨어진다.FCN-32s : Coarse OutputSkip Combining  이전 단계의 컨볼루션층들의 특성맵을 참고하여 upsampling을 해주자!FCN-16s컨볼루션과 풀링 단계로 이뤄진 이전 단계의 컨볼루션층들의 특성맵을 참고하여 upsampling을 해주면 좀 더 정확도를 높일 수 있지 않겠냐는 생각에서 Skip combining이라는 방법을 제안한다. 왜냐하면 이전 컨볼루션층들의 특성맵들이 해상도 면에서는 더 낫기 때문이다. 이렇게 바로 전 컨볼루션층의 특성맵(pool4)과 현재 층의 특성맵(conv7)을 2배 upsampling한 것을 더한다. 그 다음 그것(pool + 2x conv7)을 16배 upsampling으로 얻은 특성맵들로 segmentation map을 얻는 방법을 FCN-16s라고 부른다.FCN-8s또 더 나아가서 전전 컨볼루션층의 결과도 참고해서 특성맵들을 얻고, 또 그 특성맵들로 segmentation map을 구할 수도 있다. 이 방법은 FCN-8s라고 부른다. 좀 더 구체적으로 이야기하면, 먼저 전전 단계의 특성맵(pool3)과 전 단계의 특성맵(pool4)을 2배 upsampling한 것과 현 단계의 특성맵(conv7)을 4배 upsampling 한 것을 모두 더한 다음에 8배 upsampling을 수행하므로 특성맵들을 얻는다. 이것을 모두 종합해서 최종 segmentation map을 산출한다.skip combining의 depth에 따른 결과 비교Referencesemantic segmentation의 목적과 대표 알고리즘 FCN의 원리",
        
        "url": "/ds/dl/2020/09/07/computer-vision-06-Fully-Convolutional-Networks.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-05-faster-rcnn-html": {
        "title": "05: Faster R-CNN",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Object-Detection",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "핵심 아이디어  Region Proposal도 Network안에 포함시키자!Faster R-CNN의 핵심 아이디어는 Resion Proposal Network(이하 RPN)이다. 기존 Fast R-CNN구조를 계승하면서 selective search를 제거하고 RPN을 통해서 Roi를 계산한다. 이를 통해서 GPU를 통해 Roi를 계산할 수 있게 되었고, 이 RoI를 추출하는 것 역시 학습시켜 정확도를 높일 수 있다. 결과적으로 selective search가 2000개 RoI를 계산하는데 반해, 800개 정도로 더 높은 정확도를 가진다.Faster R-CNN structure그림을 보면 알겠지만, feature map으로 부터 selective search를 거치치 않고 이를 RPN에 전달하여 계산을 진행한다. 여기서 얻은 RoI로 RoI Pooling을 진행한 다음 object detection을 진행한다.Region Proposal NetworkRegion Proposal Network structure이 그림보다는 순차적으로 된 그림으로 이해하는 것이 쉽다.Region Proposal Network structureCNN을 통해 뽑아낸 feature map을 입력으로 받는다. 어떤 pretrained model을 사용할 지 모르므로 이를 HxWxC로 둔다.feature map에 (3x3)x256 또는 (3x3)x512 conv 연산을 수행한다. 엄밀히 말하면 C와 256, 512는 같아야 한다. 일단 연산이 가능하다고 가정하자. 이 때, HxW가 보존될 수 있게 padding을 1로 설정한다.전 과정에서 나온 feature map을 가지고 classification을 위한 확률값과, bounding box regression 값을 뽑아낸다. 이 과정에서 너무 많은 연산을 진행하게 되면 모델이 지나치게 무거워 진다. 저자들은 1 x 1 conv만을 수행하여 예측값을 뽑아내고자 하였다.Anchor먼저 Classification의 경우, 더욱 가볍게 진행하기 위해 물체인지 아닌지를 구분하는 binary classification을 진행하고자 하였다. 하지만 이 문제는 bounding box와 엮어서 이를 생각해야 하는데, 저자들은 이 단계에서 Anchor라는 개념을 도입하여 이를 진행하였다. Anchor는 간단하게 사전에 정의해 둔 Box들이다. 총 9개를 사용하였다.이 모든 내용을 정리하면, classification의 결과는 총 (HxW)의 각각의 위치에 제안된 Anchor(9개)에 대해 물체의 여부(2)를 나타내는 총 18개의 Node를 가져야 한다. 그러기 위해 (1x1)x(2x9)의 conv 연산을 진행하였다. 결과적으로 (HxW)x(2x9)의 Feature map이 나오고, 각각의 노드는 순서대로 (h, w) 위치에 있는 1번 anchor가 물체일 logit, (h, w) 위치에 있는 1번 anchor가 물체가 아닐 logit … 로 정의된다. 최종적으로 이를 확률 값으로 변경해주기 위해 적절히 reshape 해준 다음 Softmax를 적용한다.두번째로 Bounding Box Regression을 진행한다. 같은 방법을 사용한다. 이번에는 9개 anchor에 대해 총 4개의 좌표를 수정하기 위한 조절값을 예측해야 하므로 (H W)x(4x9)의 결과를 얻어야 한다. 이번에는 regression이기 때문에 그대로 결과값으로 사용하면 된다.앞선 과정은 순차적으로 진행된다. 즉, classification을 먼저 진행하고, 이 결과를 기반으로 물체일 확률을 sorting한다. 이 중 높은 순으로 K개의 anchor를 후보군으로 선정한다. 이 후보군에 각각 bounding Box Regression을 진행한다. 마지막으로 Non-Maximum-Suppression을 적용하고, 이것을 기반으로 RoI를 제안한다.이러한 방법을 통해서 RoI를 제안하는 Network를 만들었다. 이 후 과정은, 이렇게 만들어진 RoI를 첫번째 Feature map (HxWxC) 에 투영하는 과정을 거친다. 이 부분은 Fast R-CNN 구조와 같다.RPN’s Loss functionRPN은 앞서서 Classification과 Bouding Box Regression을 수행했다. 로스 펑션은 이 두 가지 테스크에서 얻은 로스를 엮은 형태를 취하고 있다.여기서 i는 하나의 anchor를 말한다. $p_i$는 classification을 통해서 얻은 해당 anchor가 object일 확률을 의미한다. $t_i$는 bounding box regression을 통해서 얻은 박스 조정 값 벡터를 의미한다. *이 붙은 변수는 ground truth label에 해당된다.classification은 binary cross entropy, regression은 smooth L1 loss를 사용한다.주목해야 할 점은 각각 $N_{cls}$와 $N_{reg}$를 가진다는 점이다. $N_{cls}$는 minibatch 사이즈이며 논문에서는 256입니다. $N_{reg}$는 엥커 개수에 해당하며 약 2400개 (256 x 9)에 해당한다. 실제 실험을 진행했을 떄 이부분이 큰 부분을 담당하지는 않는다고 말한다. $\\lambda$는 Classifiaction Loss와 Regression Loss 사이에 가중치를 조절해주는 부분인데 논문에서는 10으로 설정되어 있어, 사실상 두 로스는 동일하게 가중치가 매겨진다. 이후는 Fast R-CNN 구조와 같다. 이제 남은 것은 어떻게 이 두 네트워크를 학습시키느냐에 대한 것이다.Training Method하지만 전체 모델을 한번에 학습시키기란 매우 어려운 작업이다. RPN이 제대로 RoI를 계산해내지 못하는데 뒷 단의 Classification 레이어가 학습될 리가 없다. 여기서 저자들은 4단계에 걸쳐서 모델을 번갈아서 학습시키는 Alternating Training 기법을 취한다. 말이 어렵지 그냥 따로 하고 지지고 볶으면서 학습시킨거다.  ImageNet pretrained 모델을 불러온 다음, RPN을 학습시킨다.  1 단계에서 학습시킨 RPN에서 기본 CNN을 제외한 Region Proposal 레이어만 가져온다. 이를 활용하여 Fast RCNN을 학습시킨다. 이 때 , 처음 피쳐맵을 추출하는 CNN까지 fine tune 시킨다.  앞서 학습시킨 Fast RCNN과 RPN을 불러온 다음, 다른 웨이트들은 고정하고 RPN에 해당하는 레이어들만 fine tune 시킨다. 여기서부터 RPN과 Fast RCNN이 컨볼루션 웨이트를 공유하게 된다.  마지막으로 공유하는 CNN과 RPN은 고정시킨 채, Fast R-CNN에 해당하는 레이어만 fine tune 시킨다.의의  region proposal을 한번에 수행한계  여전히 real time이라고 하기에는 무리가 있음  여전히 학습과정이 복잡하고 2step 임Reference갈아먹는 Object Detection [4] Faster R-CNN",
        
        "url": "/ds/dl/2020/09/02/computer-vision-05-Faster-RCNN.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-04-fast-rcnn-html": {
        "title": "04: Fast R-CNN",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Object-Detection",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "핵심 아이디어  Feature Extraction, classification, bounding box regression까지 한번에 학습할 수 있는 모델을 만들자!Fast R-CNN은 이전 SSP Net이 가지는 한계점을 극복하는 시도에서 출발한다. SSP Net은 1) Multi stage model이고 2) FC layer 만 학습 시킬 수 있다는 한계점이 있었다.Fast R-CNN Architecture알고리즘  pretrained model로 부터 feature map을 추출한다.  Selective Search를 통해 찾은 각각의 ROI에 대해 *ROI Pooling을 진행한다. 그 결과로 고정된 크기의 feature vector를 얻는다.  feature vector는 FC layer를 통과하고 두개의 branch로 나뉜다.  하나의 branch에서는 softmax를 통과하여 해당 ROI가 어떤 물체인지 clasification을 진행한다.  다른 branch에서는 bounding box regression을 통해 selective search로 찾은 박스의 위치를 조정한다.핵심 의의는 multi stage model에서 end-to-end로 model을 구성했다는 것에 있다. 결과적으로도 속도, 정확도, 학습 속도 모두를 향상시켰다는데 의의가 있다.ROI pollingRoi pooling의 아이디어는 앞서 보았던 SPP Net과 유사하다. SPP Net은, pretrained model으로 부터 도출되는 feature map으로 부터, 피라미드 filter를 거친 후 이를 vectorize 하여 고정된 개수의 vector를 얻을 수 있었다. 이 아이디어를 조금 변경하여 제시하는 것이 Roi pooling이다.ROI pooling  feature map에서 Selective search를 통해 Resion Proposal을 진행한다.  이 proposal에 Roi pooling을 진행하여 고정된 형태의 작은 feature map을 만든다.Roi pooling은, Resion Proposal을 고정된 형태의 output 모양으로 바꾼다. (H x W) 크기의 feature map을 output으로 원한다면, proposal을 이에 맞게 칸을 나눈 후, max pooling을 진행한다. 이렇게 되면 항상 같은 크기의 결과를 얻을 수 있다.Multi Task Loss딥러닝을 공부하면서 가장 새롭고 즐거웠던 부분은 손실함수 부분이었다. object detection은 기본적으로 bounding box regression과 classication을 동시에 진행해야 하는 Task이다. 그래서 예전 접근은 multi stage로 이루어졌었다. 하지만 이 Fast R-CNN에서 처음으로 이 두가지 task를 하나로 엮는 방법이 고안된다.우리는 이미지로 부터 feature map을 추출했고, 이 feature map에서 Roi를 제안 받아 Roi pooling을 통해 feature vector를 만들었다. 이제 이 벡터로 classification과 bounding box regression을 적용하여 각각의 loss를 얻어내고, 이를 back propagation하여 전체 모델을 학습시키면 된다. 이 두 Task 모두를 반영한 손실함수를 보자.각 변수 하나하나에 대해서 알아보자. 먼저, $p$ 는, Softmax를 통해 얻어낸 $K+1$ 개의 확률값이다.(이산 확률 분포) $K+1$인 이유는 K개의 object와 배경(아무 물체도 아님)을 추가한 것이다. $u$는 해당 Roi의 ground truth label 벡터이다.다음으로는 bounding box regression을 진행한다. 고정 처리된 feature map을 가지고 regression을 했을 때 결과는, 각각의 class (K + 1) 에 대해 각각 x, y, w, h를 조정하는 파라미터 $t^k$를 리턴한다. 말로 풀어보면 다음과 같다. feature map으로 부터 1번 클래스 일 때 (x, y, w, h)를 ($t_x$, $t_y$, $t_w$, $t_h$) 로 변화시켜. 2번 클래스 일때는 …(중략). 이 중에서 우리가 하고 싶은 것은, 이 결과를 바탕으로 이를 수정하는 loss function을 만들고 싶은 것이므로 이 결과들 중 ground truth에 속하는 u번째 t만 가져와서 사용한다. $v$는 ground truth bounding box 조절 값에 해당한다.그렇다면 이제 각각의 loss function에 대해서 알아보자. 먼저 classification loss 는 log loss를 사용한다. 못맞출 수록 패널티를 크게 준다.location을 담당하는 loss는 아래와 같다.bounding box를 만들기 위한 예측 조절값에서 실제 조절값을 smooth L1을 통과시킨 것의 합을 사용한다.저자들은 실험 과정에서 라벨 값과 지나치게 차이가 많이 나는 outlier가 많았고, 이런 outlier에 민감하게 반응하는 L2 loss를 그대로 사용할 경우 gradient explode현상이 발생하는 것을 확인했다고 한다. 이를 제어하기 위해 custom한 loss function을 사용했다.Backpropagation through RoI Pooling Layer이제 네트워크를 학습하면 된다. 그런데 이전의 SSP Net을 보면, feature map을 뽑아낸 후, SSP를 거쳐 나온 vector들에 대해 FC layer를 구성하고, 이 단계만 학습시켰던 것을 기억할 거다.(fine tuning) 위 논문에서 저자들은, 이미지의 특징을 추출하는 가장 중요한 역할인 CNN이 학습될 수 없다는 것에 집중한다. 즉, 어느 단계까지 fine tuning을 진행할 것인지, 또 그 fine funing을 진행할 경우 학습이 진행이 되는지(역전파가 전달이 되는지)를 이론적으로 검증한다.$x_i$라고 하는 것은 CNN을 통해 추출된 feature map에서 하나의 feature를 의미하고 이는 실수이다. 전체 Loss에 대해서 이 피쳐 값의 편미분 값을 구하면 그 값이 곧 xi에 대한 loss 값이 되며 역전파 알고리즘을 수행할 수 있다. 이제 피쳐 맵에서 RoI를 찾고 RoI Pooling을 적용하기 위해서 H x W 크기의 grid로 나눈다. 이 그리드들을 sub-window라 부르며, 위 수식에서 j란 몇번째 sub-window인지를 나타내는 인덱스이다. $y_{rj}$는 이 Roi Pooling 을 통과하여 최종적으로 얻어진 ouput의 값이며 이 역시 실수이다.Back Propagation through RoI Pooling$x_i$ 가 최종 prediction 값에 영향을 주려면 $x_i$가 속하는 모든 Roi의 sub-window 에서 해당 $x_i$가 최댓값이 되야 한다. $i^*(r, j)$란 Roi와 sub-window index j가 주어졌을 때, 최대 피쳐 값의 인덱스를 말한다.즉 수식을 보면 $[i = i^*(r, j)]$ 이렇게 표현되어 있는데, 최대 패쳐 인덱스가 내가 구하길 원하는 피쳐와 같을 때는 1을 return, 아니면 0 을 return 하라는 의미이다. 결과적으로 우리는 $\\partial L \\over \\partial y_{rj}$ 이 값을 가지고 있고, 발생하는 모든 이 값을 더해서 적용시켜주면 $x_i$에 대한 gradient를 구할 수 있다.종합하면, 우리는 앞서 구한 multitask loss를 RoI Pooling layer를 통과하여 CNN 단까지 fine-tuning 할 수 있다. 저자드은 실험을 통해서 실제로 CNN단 까지 fine tuning 하는 것이 성능 향상에 도움이 되었다는 실험 결과를 보여준다.fine tuning depth에 따른 성능 변화위 실험 결과는 fine-tuning 하는 깊이를 조절해가며 성능 변화를 실험한 것이다. CNN의 단을 깊이 학습시킬 수록 성능이 향상되었으며, 이 때 테스트에 소요되는 시간 변화는 거의 없는 것을 확인할 수 있다. 즉, CNN 단을 Object Detection에 맞게끔 fine-tuning 하는 것이 성능 향상의 키 포인트였다.의의  end-to-end 모델 제안  학습 단계 간소화  정확도, 성능 개선한계  region proposal을 selective search를 사용          이는 CPU 연산으로만 가능하기 때문에 병목이 발생      이 부분이 inference를 수행하는데 있어 가장 많은 시간을 차지함      Reference갈아먹는 Object Detection [3] Fast R-CNN",
        
        "url": "/ds/dl/2020/09/02/computer-vision-04-Fast-RCNN.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-03-spatial-pyramid-pooling-network-html": {
        "title": "03: Spatial Pyramid Pooling Network",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Object-Detection",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "핵심 아이디어  입력 이미지의 크기나 비율에 관계없이 CNN 학습은 불가한가?Fast R-CNN으로 넘어가기전 상당히 많은 아이디어를 가져온 논문이다. 이전의 R-CNN을 보게되면, proposal roi가 CNN에 들어가기 전에 입력 이미지를 바꿔주어야 하는 한계가 존재했다. 여기서 저자들은 의문을 갖는다. 이 제한 요소를 없앤 상태로 CNN을 학습시키는 것이다.SPPNet의 핵심 아이디어사실 CNN의 입력이미지 크기는 고정될 필요가 없다. CNN의 핵심 아이디어는 filter를 가지고 연산을 수행하는 것이고, 이것의 연산 방식은 sliding window 방식으로 진행된다. 하지만, 이 입력 이미지의 크기가 고정이어야 하는 이유는, 마지막에 도출되는 fully connected layer의 크기가 고정적으로 나와야 하기 때문이다. 이 문제점으로 부터 SPPNet가 제안된다.  입력 이미지 상관 없이 통과시키고, FC 전에 polling을 통해서 동일한 크기로 만들자!굉장히 단순한 방법을 제안하였다. (…) 이런 방식을 사용할 경우, 원본 이미지의 특징을 고스란히 간직한 feature map을 얻을 수 있다. 추가적으로 비율도 조절하지 않기 때문에, 사물의 크기에 따른 변화도 감지가 가능하다.위의 그림을 보면 Crop 후 conv에 넣는 것이 아니고, feature map을 만든 후, 이를 SSPNet에 넣어 모양을 맞춘 후에 output을 만드는 것을 볼 수 있다.알고리즘  전체 이미지를 pretrained model을 통과시켜 feature map을 추출한다.  해당 feature map으로 부터 selective search를 통해 ROI를 뽑아낸다. 이 때 발생하는 ROI는 모두 크기와 비율이 다르다. 여기서 SSPNet을 적용하여 고정된 크기의 feature vector를 추출한다.  FC layer를 통과시킨다.  앞서 추출한 벡터로 각 이미지 클래스 별로 SVM을 학습시킨다.  마찬가지로 해당 벡터로 bounding box regressor를 학습시킨다.Spatial Pyramid Pooling출처 : http://kaiminghe.com/eccv14sppnet/index.html그렇다면 어떤 방식으로 SPP가 돌아가는지 이해해야 한다. 먼저 CNN을 거친 feature map을 input으로 받는다. 그리고 이것을 미리 정해져 있는 영여긍로 나누어 준다. 위의 예시에서는 4x4, 2x2, 1x1 3개의 영역이 적용되어 있고, 이 각각을 하나의 피라미드라 부른다. 즉, 3개의 피라미드를 설정한 것.이 피라미드는 4x4 짜리 고정된 CNN 필터 같은 것이 아니다. 어떠한 input이 들어오더라도 4x4 격자로 만든다는 표현이 더 맞는 표현이다. 예를 들어 입력이 64 x 64 x 256 크기의 피쳐 맵이 들어온다고 했을 때, 4x4의 피라미드의 bin의 크기는 16x16이 된다.이제 이 각각의 bin에서 가장 큰 값만 추출하는 max pooling을 수행하고, 그 결과를 쭉 이어 붙인다. 입력 feature map의 채널 크기가 k, bin의 개수를 M이라 한다면, 해당 SSP의 output은 k x M의 크기를 가진 1차원의 벡터가 될 것이다.한계  여전히 multi stage model이다.  여전히 SVM, selective search를 사용한다.  feature map을 만들어내는 network를 학습시키지 못한다.ReferencePR-012: Faster R-CNN : Towards Real-Time Object Detection with Region Proposal Networks",
        
        "url": "/ds/dl/2020/09/02/computer-vision-03-Spatial-Pyramid-Pooling-Network.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-02-rcnn-html": {
        "title": "02: R-CNN",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review, Object-Detection",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "Computer Vision의 Task이중 Object Detection에 해당하는 문제이다.속도가 느려보여도 정확도 측면에서 높은 것을 알 수 있다.R-CNN  region proposal을 진행한다.  CNN에 각각 넣는다. -&gt; 느리다, CNN을 사용하기 때문에 입력 크기가 동일해야 한다.(warpping)  CNN의 마지막 feature map에서 SVM을 사용하여 구분한다.  또한 입력으로 주어진 bounding box를 조정하기 위해 regression을 진행한다.Region Proposalinitial bounding box를 selective search를 사용하여 뽑아낸다. -&gt; 느리다.Training  pretrained model = alexnet for ImageNet classification dataset          이미지넷에서 사전 훈련된 알렉스 넷을 사용했다. 마지막단을 잘라서 사용한다.        가지고 있는 데이터를 넣어서 훈련한다.  여기서 발생한 마지막 feature map을 가지고 와서 classification, bounding box regression 을 진행한다.이러한 방법은, 두가지 문제를 발생시킨다.  속도  마지막 단의 feature map을 사용하기 때문에 back propagation을 통한 학습이 불가하다.Bounding-Box RegressionBox는 centerX, centerY, Width, Height로 표현된다.우리의 목적은 $P^i$ 박스를 최대한 G에 가깝게 이동시키는 함수를 학습시키는 것이다. 이를 표현해보면 다음과 같다.x, y의 경우는 평행이동이 연산의 전부이기 때문에 linear 연산으로 처리가 가능하다. 반면 너비와 높이는 확대, 축소 변환이 필요하다. 단순한 확대 축소 연산을 사용하게 되면, 추후에 backpropagation을 통한 학습이 어려워지기 때문에 여기서는 exp를 사용했다.왜 굳이 식을 이렇게 만들었냐 보다는, 이러한 방식으로 제안을 하려고 했다고 생각해보자. P에 대한 변수는 초기에 제안하는 것이므로, 우리는 함수 $d_*(P)$ 가 어떤 녀석인지 아는 것이 목표이다. 그리고 이 함수를 알아내는 과정은 deep learning network를 사용하여 만들 것이다.여기서 $\\phi_5(P)$는 pretraioned model의 가장 마지막 feature map을 의미한다. 결국 feature맵에 선형 연산을 추가하여 원하는 함수를 구한다.그렇다면, 이제는 문제가 변화했다. ground truth에서 발생하는 함수와 제안된 방법의 함수 $w^T_* \\phi_5(P)$ 의 가중치 $w^T_*$ 를 구하는 문제이다.ground truth에서 발생하는 값인 $t^i_*$는 각각의 사진 한장에 대해서 고정되어 있다. 이를 반영한 손실 함수는 다음과 같다. 저자들은 람다를 1000으로 설정하였다.한계  느리다.  SVM은 CNN을 훈련시키지 못한다.  Multostage Training Pipeline이다.ReferencePR-012: Faster R-CNN : Towards Real-Time Object Detection with Region Proposal Networks",
        
        "url": "/ds/dl/2020/09/02/computer-vision-02-RCNN.html"
      }
      ,
    
      "ds-dl-2020-09-02-computer-vision-01-ec-9a-a9-ec-96-b4-ec-a0-95-eb-a6-ac-html": {
        "title": "01: 컴퓨터 비전 용어 정리",
        "tags": "DataScience, DeepLearning, Computer-Vision, Paper-Review",
        "date": "September 2, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "Descripter  이미지를 비교하기 위해 동일한 방법을 통해 하나의 비교 대상으로 만드는 것descripter두 가지 이미지가 있다. 이 두가지 이미지가 비슷한지 아닌지를 구분하기 위해 만든 것이 descripter이다. 위의 그림에서는 픽셀의 값들을 기반으로 gradients를 구해 이를 grid에 plot하여 표현하였다. 여기서 이 gradients를 descripter로 사용했다고 말한다.HOG algorithm예를 들어 HOG 알고리즘은 각 pixel에서 gradient를 구하고 이 값들을 총 8가지 방향으로 매핑한 후, 히스토그램을 생성한다. 이렇게 추출돈 Feature vector는 keypoint이고 이를 기반으로 bounding box등을 만드는데 활용한다. 요즘은 이 feature mapCNN을 통해 생성한다.Region Proposal  이미지로부터 영역을 선택하기 위해 사용되는 알고리즘기존의 sliding window방식은 매우 비효율적이었고, 이를 개선한 방법이다. “물체가 있을 법한” 영역을 빠른 속도로 찾아내는 알고리즘이다. 보편적으로 selective search, edge box algorithm이 있다. 하지만 이 역시도 추후에 end-to-end 방식으로 개선된다.RoI(Region of Interest)  이미지내에서의 관심 영역원래 input에서 잘라낸 관심 영역들을 RoI라 한다.Caption generation  이미지로 부터 문장을 생성하는 것이 연구는 Human-object interaction에 기초하여 연구되고 있다.Smooth L1 LossL1, L2 Loss는 생략하였다. 수식에서의 x는 $|y-\\hat{y}|$로 정답 label과 차이이다. 오차가 작은 부분은 제곱을 사용했고, 그렇지 않은 부분에서는 직선을 사용했다. 이러한 방식은 L1 Loss와 L2 Loss의 장점을 결합한 형태이다. 즉, error가 클경우 안정적으로 loss를 감소시키고($x$), 작을 경우에는 L2 Loss를 사용하여 업데이트 과정중 진동을 감소시킨다.IOU (Intersection over union)  예측한 bounding box와 ground truth box간의 겹치는 넓이 비율IOU이것은 사진으로 직관적으로 이해할 수 있다.Ablation study  기존 모델에서 feature를 제거하면서 영향력을 확인하는 것여기서 feature는 변수보다는 network, layer등을 말한다.Jittered examples  IoU를 기준으로 사용하겠다고 판단한 bounding boxbounding box regression을 진행한 후에 각각의 proposal에 대해 예측한 결과 중 학습에 재사용하기 위한 샘플을 걸러낼 때 사용되는 개념이다. 예를 들어 IoU가 0.5이상 인 샘플을 positive sample이라 정의할 경우, 이 샘플을 Jittered examples이라 한다.Non-maximum suppression (NMS)  동일한 클래스라 판명된 bounding box들 중 중복을 제거하는 방법Non-maximum suppression (NMS)알고리즘은 다음과 같다.  동일한 클래스에 대해 검출된 bounding box들을 confidence 순서로 정렬한다.  가장 confidence가 높은 bounding box와 IoU가 일정 이상인 bounding box는 동일 물체를 detect했다 판단하여 지운다.          가장 confidence높은것만 남기고 보통 0.5이상 box들을 지운다.      OHEM (Online Hard Example Mining)먼저, Hard Example과 Easy Example의 개념부터 알아보자. 사람인지 아닌지를 분류하는 모델이 있다고 하자. 우리의 목적은 이 모델을 훈련시키는 것이다. 대부분의 사람 이미지는 분류하도록 만들었다. 하지만 사람 동상과 같은 샘플에 대해서는 모델이 구분하기 어려울 것이다. 이러한 상황에서 일반적으로 잘 동작하는 샘플을 Easy Example, 사람 동상 이미지를 Hard Example 이라 한다. 이런 것들을 제대로 훈련하기 위해서는 Hard Example에 대해 가중치를 주거나 해서 모델을 훈련시켜야 할 것이다.다음은 positive와 negative에 대한 개념이다. positive는 문제에서 내가 원하는 클래스를 의미한다. positive sample은 bounding box의 label이 사람인 것을 의미하고, negative sample은 배경임을 의미한다.그렇다면 hard negative란, 실제로는 배경인데, 사람이라고 예측한 sample이다. 반대로 easy negative는 실제로 배경이며 배경으로 예측했음을 의미한다.즉, hard negative sample은, 네거티브 샘플이라고 보기 어렵다라는 의미이다. 해당 샘플에 대해 배경이라고 말해야 하는데, confidence는 높게 나오는 상황을 말한다.우리가 알아볼 object detection문제에서는 resion proposal을 통해 여러가지 후보를 선택하게 된다. 이 후보군의 대부분은 배경이라고 말해야 하는 easy negative sample이 차지하고 있다. 또한 사람이라고 말해야 하는 positive sample의 개수는 매우 부족하다. 보통 이러한 상황에서는 모집단의 balance를 맞추는 resampling을 진행하거나, boosting알고리즘으로 진행하게 된다. 하지만 이것은 label의 불균형을 알고있고, 이를 처리할 수 있을 때 가능하다. detection문제는 후보군의 label을 모르기 때문에 이 방법은 사용할 수 없다. 그렇다면 만약 이 상황에서 그대로 훈련을 진행하게 되면, easy negative sample의 양이 너무 많기 때문에 배경을 배경이라 하는 예측만이 대다수를 이루고, 이에 대해서만 학습을 진행하게 된다.Cross Entropy &amp; Binary Cross Entropy일반적으로 Classification에서 사용하는 Loss 함수는 Cross Entropy 이다. 이러한 imbalance를 고려하여 업데이트를 하지 않기 때문에, 기존의 방식을 사용할 경우, background만 잘 맞추는 요상한 모델이 결과로 도출된다.OHEM (Online Hard Example Mining)우리는 결과적으로 배경은 배경이라하고, 사람은 사람이라고 하는 좋은 모델을 제작해야 한다. 그러기 위해서는 후보군의 대부분을 차지하고 있는 easy negative sample에 대해서 업데이트는 줄이고, 배경인데 배경이 아니라고 하는 hard negative sample에 대해 주된 업데이트를 진행해야 한다. 이를 위해 제안된 방법이 OHEM (Online Hard Example Mining)이다. 결과적으로 positive sample과 hard negative sample을 가지고 문제를 해결한다. 이와 같은 불균형 문제를 Class Imbalance라 한다.Focal Loss위의 OHEM과 비슷하게 class Imbalance를 해결하기 위한 방법이다. loss function을 수정하여 이를 해결한다.이런 loss funtion을 이해하는 가장 좋은 방법은 양 극단치를 넣어보는 것이다. y=1일 경우, ground truth가 사람인 경우에는 해당 class가 나올 확률을 그대로 넣어준다. 즉 $p_t = p$ 이다. 그렇다면 만약 잘 맞췄을 경우에는 loss가 0에 가까워진다. 결과적으로 postitive에 대해 잘 예측할 경우 loss를 작게 주고, 그렇지 않은 경우 loss를 크게 준다.y!=1인 경우, $p_t = 1-p$이고, 그렇게 될 경우 $FL(p_t) = -p\\gamma log(1-p)$이다. cross entropy식에서 앞항과 뒤 항의 변형을 통해 log함수가 가지는 특징을 사용했다. 잘 예측할 경우 loss를 크게 주고, 그렇지 않을 경우 loss를 작게준다. 다만 log 함수에 엮여 있는 부분은 잘 예측했을 경우에 더 큰 loss값을 주게 되므로, 이 식의 의도는, 너무 잘 예측하는 데이터(p가 계속 너무 높게 나옴)의 영향력을 줄이기 위한 것이 강하다. 실제로 OHEM 보다 성능이 더 좋다고 한다.Contextual feature2d image에서 contextual based classification은 pixel의 주변 neighborhood 과의 relationship에 초점을 맞춘 approach를 뜻한다. 즉, 어떤 특정 pixel의 contextual feature는 주변 pixel들과의 relationship에 기반해서 추출한 feature를 뜻한다.Reference컴퓨터비전에서의 기본 용어 및 개념 정리",
        
        "url": "/ds/dl/2020/09/02/computer-vision-01-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC.html"
      }
      ,
    
      "ds-server-2020-09-01-server-01-nginx-html": {
        "title": "01: Nginx",
        "tags": "DS, python, nginx",
        "date": "September 1, 2020",
        "author": "",
        "category": "DS/Server",
        "content": "nginx란?  트래픽이 많은 웹사이트를 위해 설계한 비동기 이벤트 기반 구조의 웹서버 소프트웨어러시아의 프로그래머,이고르 시쇼브가 Apache의 C10K Problem(하나의 웹서버에 10,000개의 클라이언트의 접속을 동시에 다룰 수 있는 기술적인 문제)를 해결하기 위해 만든 Event-driven구조의 HTTP, Reverser Proxy, IMAP/POP PROXY server를 제공하는오픈소스 서버 프로그램이다.Apache vs nginx  Apache  쓰레드 / 프로세스 기반 구조로 요청 하나당 쓰레드 하나가 처리하는 구조  사용자가 많으면 많은 쓰레드 생성, 메모리 및 CPU 낭비가 심함  하나의 쓰레드 : 하나의 클라이언트 라는 구조  nginx  비동기 Event-Driven 기반 구조.  다수의 연결을 효과적으로 처리가능.  대부분의 코어 모듈이 Apache보다 적은 리소스로 더 빠르게 동작가능  더 작은 쓰레드로 클라이언트의 요청들을 처리가능thread와 Event-driven 방식그림만 봐도 딱 알겠지만, Event-driven 방식은 java-script에서와 같이 비동기 이벤트를 처리하는 방식으로 구동된다. 그렇기 때문에 자원을 효율적으로 사용한다.그렇지 않아도 node.js의 창시자 라이언 달은 nginx를 프록시 서버로 앞단에 두고, node.js를 뒤쪽에 놓는게 버퍼 오버플로우 공격을 방지할 수 있다고 하였다.버퍼 오버플로우버퍼는 보통 데이타가 저장되는 메모리 공간을 뜻한다. 이 때, 메모리 공간을 벗어나는 경우 오버플로우가 되고 이 때 사용되지 않아야 할 영역에 데이터가 덮어씌워져 주소, 값을 바꾸는 공격이다.​버퍼 오버플로우로 인한 큰 이슈 : 하트블리드사태즉, 실제포트를 숨기고 nginx의 80포트를 통해서 프록시하면 보안적으로 막을 수 있다는 것인데 이것 말고도 정적자료에 대한 gzip압축, 그리고 앞단에서의 로그를 저장할 수 있다.",
        
        "url": "/ds/server/2020/09/01/Server-01-Nginx.html"
      }
      ,
    
      "dv-docker-2020-09-01-docker-04-image-ec-83-9d-ec-84-b1-ec-97-85-eb-a1-9c-eb-93-9c-html": {
        "title": "04: image 생성, 업로드",
        "tags": "DV, Docker",
        "date": "September 1, 2020",
        "author": "",
        "category": "DV/Docker",
        "content": "image 화 하기  코드가 다른 것으로 파악, 아래 코드는 동작한다.    $ docker commit -a \"jjy\" &lt;container name&gt; &lt;원하는 image repo 이름&gt;$ docker commit -a \"jjy\" laughing_wilson wansook/mask_rcnn      dockerhub 에 올리기  Login하기    $ docker login        repository 만들기보통 형식은 계정이름/해당 repo이름 으로 결정된다.내가 만든 이미지의 repository이름을 이와 같게 바꿔주어야 한다.    $ sudo docker image tag &lt;기존 계정이름/repo name&gt;:&lt;tag&gt; &lt;새 계정이름/new repo name&gt;:&lt;new tag&gt;$ docker image tag wansook/mask_rcnn wansook0316/mask_rcnn:first_commit        docker hub 에 push하기    $ docker push wansook0316/mask_rcnn:first_commit      ",
        
        "url": "/dv/docker/2020/09/01/Docker-04-image%EC%83%9D%EC%84%B1-%EC%97%85%EB%A1%9C%EB%93%9C.html"
      }
      ,
    
      "dv-docker-2020-09-01-docker-03-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-a0-80-ec-9e-a5-html": {
        "title": "03: 데이터 저장 (Volume, Mount)",
        "tags": "DV, Docker, Cheet Sheet",
        "date": "September 1, 2020",
        "author": "",
        "category": "DV/Docker",
        "content": "Volume과 MountDocker Conatiner에 쓰여진 데이터는 컨테이너가 삭제될 때 함께 사라진다. 하지만 이에 관계없이 우리는 데이터를 영속적으로 저장할 필요가 있다. 또한 여러개의 컨테이너를 생성하여 사용할 경우, 하나의 폴더를 공유해야 하는 일이 빈번하다.이러한 필요성에 대해 Docker는 두가지 옵션을 제공한다. 첫째가 Volume, 둘째가 Mount이다.Volume이 방법은 Docker에서 권장하는 방법이다.Volume의 생성$ docker volume create hellohelloVolume의 조회$ docker volume lsDRIVER              VOLUME NAMElocal               hello$ docker volume inspect hello[    {        \"CreatedAt\": \"2020-05-09T17:03:46Z\",        \"Driver\": \"local\",        \"Labels\": {},        \"Mountpoint\": \"/var/lib/docker/volumes/our-vol/_data\",        \"Name\": \"our-vol\",        \"Options\": {},        \"Scope\": \"local\"    }]Mountpoint를 보면 해당 볼륨이 어디에 있는지 알 수 있다.볼륨을 컨테이너에 마운트하기$ docker run -v hello:/home/app --name one hugojuhel/notebook touch /app/test.txtdocker run -v &lt;볼륨 이름&gt;:&lt;컨테이너 내의 절대 경로&gt; --name &lt;컨테이너 이름&gt; &lt;image 이름&gt; &lt;명령&gt; &lt;파라미터&gt; 형식으로 구성되어 있다.$ docker inspect hello(...생략...)    \"Mounts\": [        {            \"Type\": \"volume\",            \"Name\": \"our-vol\",            \"Source\": \"/var/lib/docker/volumes/our-vol/_data\",            \"Destination\": \"/app\",            \"Driver\": \"local\",            \"Mode\": \"z\",            \"RW\": true,            \"Propagation\": \"\"        }    ],(...생략...)실제로 생성된 컨테이너를 조사하면 다음과 같이 뜨며, Type이 volume으로 지정된 것을 확인할 수 있다.이러한 방법은 다른 컨테이너에 마운트할 때에도 동일하게 적용된다.Volume 삭제$ docker volume rm helloError response from daemon: remove hello: volume is in use - [f73130c9dad14644ac46b89fe4018e561a7bcbfa4118d637949642d0d5d742e4, 666dda54f6be8ca852f3150b9741a9cab5a4659fa2e83fe6ca339550072c861ex]삭제할 때는 mount 된 컨테이너를 모두 삭제한 뒤에야 삭제가 가능하다.삭제를 수행했다면 에러가 뜨지 않을 것이다.Volume 청소$ docker volume pruneWARNING! This will remove all local volumes not used by at least one container.Are you sure you want to continue? [y/N] y마운트 되지 않은 모든 볼륨을 한번에 정리할 수 있다.Bind-Mount위의 Volume 방법을 보면, 경로를 docker가 제시한 경로에 맞춰서 생성된다. 하지만 시스템의 특정 경로를 기반으로 작업하고 싶은 경우도 많다. 이런 필요성에 대해 docker는 Bind-Mount를 제공한다.사용법은 매우 간단하다. 위의 Volume 명이 들어가는 자리에, 원하는 호스트 경로를 적어주는 것으로 끝난다.docker run -it --name jpt -v /Users/Choiwansik/Documents/internship/image_processing/share:/home/jovyan/share -p 28888:8888 hugojuhel/notebook /bin/bash이 때 역시나 container의 절대 경로를 써주어야 한다.\"Mounts\": [            {                \"Type\": \"bind\",                \"Source\": \"/Users/Choiwansik/Documents/internship/image_processing/share\",                \"Destination\": \"/home/jovyan/share\",                \"Mode\": \"\",                \"RW\": true,                \"Propagation\": \"rprivate\"            }        ],...Type이 bind로 묶여있음을 확인할 수 있다.Volume vs Bind-Mount  경로(Mount Point) 관리해 줄까? 말까?둘의 가장 큰 차이점은, docker가 mount point를 관리해 주느냐의 여부로 나뉜다. 그냥 막 사용하고 싶은 경우애는 volume이 맞을 수 있지만, 컨테이너화된 개발 환경을 구축하고 싶을 때는 bind-mount가 더 유리하다.ReferenceDocker 컨테이너에 데이터 저장 (볼륨/바인드 마운트)",
        
        "url": "/dv/docker/2020/09/01/Docker-03-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%80%EC%9E%A5.html"
      }
      ,
    
      "dv-docker-2020-09-01-docker-02-eb-aa-85-eb-a0-b9-ec-96-b4-eb-aa-a8-ec-9d-8c-html": {
        "title": "02: 명령어 모음",
        "tags": "DV, Docker, Cheet Sheet",
        "date": "September 1, 2020",
        "author": "",
        "category": "DV/Docker",
        "content": "설치brew install dockermac 용 도커 설치하기Docker image downloaddocker pull hugojuhel/notebook  Docker Hub 에서 원하는 docker 이미지를 다운로드  혹은 아래 예제와 같이 명령어로 다운받을 수도 있음  사용한 이미지Docker image 확인docker images설치한 이미지들을 볼 수 있다.Docker container 생성 및 실행docker run -it --name jpt -v /Users/Choiwansik/Documents/internship/image_processing/share:/home/jovyan/share -p 28888:8888 hugojuhel/notebook /bin/bash사용자 상황에 맞게 옵션 골라 사용  명령어는 항상 root 권한으로 실행한다.  -i(interactive), -t(Pseudo-try) 옵션 : 실행된 Bash 셸에 입력 및 출력을 할 수 있다.  -v, --volume 옵션 : host folder와 공유할 수 있다.jupyter notebook 실행jupyter notebook --ip=0.0.0.0 --allow-root실행하게 되면, 아까 연결해 두었던 로컬 포트로 접속할 경우 사용할 수 있다.Docker 명령어도커 명령어 Cheat Cheet이다. 나중에 이거만 보고 사용하도록 하자.프로세스 보기sudo docker ps -a-a 옵션을 사용하면 정지된 컨테이너까지 모두 출력하고, 옵션을 사용하지 않으면 실행되고 있는 컨테이너만 출력한다.컨테이너 시작하기sudo docker container start hello이름 대신 container_id를 사용해도 된다.컨테이너 재부팅sudo docker container restart hello운영체제 재부팅과 유사하다.컨테이너 접속하기sudo docker container attach hellobash에서 exit 혹은 Ctrl+D 를 입력하면 컨테이너가 정지된다.exec 명령으로 컨테이너 외부에서 명령 실행하기현재 hello 컨테이너의 bin/bash를 실행한 상태라고 가정하자. 그리고 해당 컨테이너에 접속하지 않은 상태로, hello 컨테이너 안의 명령을 실행해보자.sudo docker container exec hello echo \"Hello World\"docker container exec &lt;컨테이너 이름&gt; &lt;명령&gt; &lt;매개변수&gt; 형식이다. 컨테이너 대신 컨테이너 id를 사용할 수 있다. 이 명령어는 컨테이너가 실행되고 있는 상태에서만 사용할 수 있으며 정지된 상태에서는 사용할 수 없다.docker exec 명령은 이미 실행된 컨테이너에 apt-get, yum 과 같은 명령으로 패키지를 설치하거나 각종 데몬을 실행할 때 활용할 수 있다.컨테이너 정지하기sudo docker container stop hello정지한 경우 다시 attach하고 싶으면 start후 가능하다.컨테이너 삭제하기sudo docker container rm hellocontainer 명령어를 쓰지 않아도되지만 최신 버전에서는 권장한다.컨테이너 실행 상태로 빠져나오기컨테이너 안에서 ctrl+pq을 누르면 된다.컨테이너 내 사용자 비밀번호를 모를 때docker container exec -u 0 -it jpt /bin/bash-u는 default user라 password를 필요로 하지 않는다.이미지 삭제하기sudo docker rmi ubuntu:latestdocker rmi &lt;이미지 이름&gt;:&lt;태그&gt; 형식이다. 이미지 이름 대신 id를 사용해도 된다. 태그를 주는 이유는 같은 이름 인 경우 모두 삭제되기 때문이다.정리            명령      Code                  버전 확인      $ docker -v              이미지 다운로드      $ docker pull [이미지 명]              다운로드된 이미지 목록      $ docker images              컨테이너 생성      $ docker create [옵션] [이미지 명]              컨테이너 생성 및 실행      $ docker run [옵션] [이미지 명]              컨테이너 실행      $ docker start [컨테이너 명]              컨테이너 재실행      $ docker restart [컨테이너 명]              컨테이너 접속      $ docker attach [컨테이너 명]              컨테이너 정지      $ docker stop [컨테이너 명]              실행중인 컨테이너 목록      $ docker ps              정지된 컨테이너 목록      $ docker ps -a              컨테이너 명 변경      $ docker rename [기존 컨테이너 명] [새로운 컨테이너 명]              컨테이너 삭제      $ docker rm [컨테이너 명]      Reference[Docker] 설치, 다운로드, 실행, jupyter notebook 연동, 삭제, 기타 등등pre.highlight margin-top 1emul margin-bottom 0p margin-bottm 1emp margin-top 1em",
        
        "url": "/dv/docker/2020/09/01/Docker-02-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%AA%A8%EC%9D%8C.html"
      }
      ,
    
      "dv-docker-2020-09-01-docker-01-ea-b0-9c-ec-9a-94-html": {
        "title": "01: 개요",
        "tags": "DV, Docker",
        "date": "September 1, 2020",
        "author": "",
        "category": "DV/Docker",
        "content": "도커란? (되게 귀엽다)개념  개발자와 시스템 관리자가 컨테이너 기술을 사용하여 어플리케이션을 개발, 배포, 실행하기 위한 플랫폼컨테이너 기술을 리눅스에서 사용되던 기술이다. 이 때, 이 기술을 사용하여 응용프로그램을 배포하는 것을 컨테이화 시킨 것이다. 새로운 기술은 아니지만, 이를 통해 매우 편리하고 간편하게 배포하는 것이 가능하다.컨테이너 기술은 아래와 같은 특징들이 있다.  유연성 (Flexible) : 복잡한 어플리케이션들도 모두 컨테이너화 할 수 있다.  경량화 (Lightweight) : 컨테이너는 호스트 커널을 활용하고 공유한다.  변화 관리 편의성 (InterChangeable) : 업데이트 및 업그레이드를 즉시 배포할 수 있다.  포터블 (Portable) : 로컬로 구축하고, 클라우드와 가상화에 배치가 가능하고, 어디서나 실행할 수 있다.  확장성 (Scalable) : 컨테이너 복제본을 늘리고 자동 배포가 가능하다.  스택화 (Stackable) : 서비스들에 대한 수직적 또는 수평적 디자인이 매우 용이하다.어마무시한 도커 사용량이미지와 컨테이너docker contatiner  이미지          코드, 런타임, 라이브러리, 환경 변수 및 구성 파일 등 응용프로그램을 실행하는 데 필요한 모든 것을 포함하는 실행가능 패키지        컨테이너          이미지의 런타임 인스턴스      이 두개의 개념은 도커를 이해하는 데 매우 중요하다. class는 instance의 설계도이다. 마찬가지로 이 class에 해당하는 것이 바로 image이며, 이를 메모리단에 올린 것을 container라 한다.컨테이너의 동작 방식가상 머신과 도커의 차이점기존에 사용하던 가상 머신은, Host OS위에 Guest OS를 얹어 사용하는 방식이다. 사용법은 간단하지만 느리다라는 치명적인 단점을 갖고 있다.이러한 상황을 개선하기 위해 CPU 가상화 기술을 사용한 KVM(Kernel-based Virtual Machine)이 등장했다. 하지만 여전히 성능 문제가 있었다. 이를 해결한 것이 Docker contatiner이다. 이는 바로 Host OS위에서 격리만하여 프로세스를 처리하는 방식이다.Reference초보를 위한 도커 안내서 - 도커란 무엇인가?",
        
        "url": "/dv/docker/2020/09/01/Docker-01-%EA%B0%9C%EC%9A%94.html"
      }
      ,
    
      "cv-language-2020-09-01-python-html": {
        "title": "Python",
        "tags": "CV, Language",
        "date": "September 1, 2020",
        "author": "",
        "category": "CV/Language",
        "content": "",
        
        "url": "/cv/language/2020/09/01/Python.html"
      }
      ,
    
      "cv-language-2020-09-01-javascript-html": {
        "title": "Javascript",
        "tags": "CV, Language",
        "date": "September 1, 2020",
        "author": "",
        "category": "CV/Language",
        "content": "",
        
        "url": "/cv/language/2020/09/01/Javascript.html"
      }
      ,
    
      "cv-language-2020-09-01-c-html": {
        "title": "C++",
        "tags": "CV, Language",
        "date": "September 1, 2020",
        "author": "",
        "category": "CV/Language",
        "content": "",
        
        "url": "/cv/language/2020/09/01/C++.html"
      }
      ,
    
      "cv-internship-2020-09-01-updater-ec-98-81-ec-83-81-ec-b2-98-eb-a6-ac-ec-9d-b8-ed-84-b4-html": {
        "title": "Updater Software Intern",
        "tags": "Internship, CV",
        "date": "September 1, 2020",
        "author": "",
        "category": "CV/Internship",
        "content": "Data AugmentaterPyQt5를 사용한 Image AugmentatorBC Card",
        
        "url": "/cv/internship/2020/09/01/Updater-%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC-%EC%9D%B8%ED%84%B4.html"
      }
      ,
    
      "ds-ml-2020-08-24-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-8b-9c-ea-b0-81-ed-99-94-02-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-03-deckgl-html": {
        "title": "03: deckgl",
        "tags": "DS, python, deckgl",
        "date": "August 24, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "공간 데이터를 시각화 할 수 있는 deckgl에 대해 알아본다.",
        
        "url": "/ds/ml/2020/08/24/%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-02-%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-03-deckgl.html"
      }
      ,
    
      "ds-ml-2020-08-24-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-8b-9c-ea-b0-81-ed-99-94-02-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-02-folium-html": {
        "title": "02: folium",
        "tags": "DS, python, folium",
        "date": "August 24, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "공간 데이터를 시각화 할 수 있는 folium에 대해 알아본다.",
        
        "url": "/ds/ml/2020/08/24/%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-02-%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-02-folium.html"
      }
      ,
    
      "ds-ml-2020-08-24-ea-b3-b5-ea-b0-84-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-8b-9c-ea-b0-81-ed-99-94-01-geopandas-html": {
        "title": "01: geopandas",
        "tags": "DS, python, geopandas",
        "date": "August 24, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "공간 데이터를 다룰 수 있게 하는 패키지 geopandas에 대해 알아본다.",
        
        "url": "/ds/ml/2020/08/24/%EA%B3%B5%EA%B0%84%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-01-geopandas.html"
      }
      ,
    
      "cv-extraact-2020-08-01-eb-a9-8b-ec-9f-81-ec-9d-b4-ec-82-ac-ec-9e-90-ec-b2-98-eb-9f-bc-7-ea-b8-b0-ec-9a-b4-ec-98-81-ec-a7-84-html": {
        "title": "멋쟁이 사자처럼 - 7기 운영진",
        "tags": "Extra Curricular Acts, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/ExtraAct",
        "content": "",
        
        "url": "/cv/extraact/2020/08/01/%EB%A9%8B%EC%9F%81%EC%9D%B4-%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC-7%EA%B8%B0-%EC%9A%B4%EC%98%81%EC%A7%84.html"
      }
      ,
    
      "cv-extraact-2020-08-01-eb-a9-8b-ec-9f-81-ec-9d-b4-ec-82-ac-ec-9e-90-ec-b2-98-eb-9f-bc-6-ea-b8-b0-html": {
        "title": "멋쟁이 사자처럼 - 6기",
        "tags": "Extra Curricular Acts, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/ExtraAct",
        "content": "",
        
        "url": "/cv/extraact/2020/08/01/%EB%A9%8B%EC%9F%81%EC%9D%B4-%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC-6%EA%B8%B0.html"
      }
      ,
    
      "cv-awards-2020-08-01-2020-ea-b8-b0-ec-83-81-eb-b9-85-eb-8d-b0-ec-9d-b4-ed-84-b0-eb-8c-80-ed-9a-8c-eb-8d-b0-ec-9d-b4-ed-84-b0-eb-b6-84-ec-84-9d-eb-b6-84-ec-95-bc-ec-9a-b0-ec-88-98-ec-83-81-html": {
        "title": "빅콘테스트 퓨쳐스리그 - 장려상",
        "tags": "awards, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/Awards",
        "content": "",
        
        "url": "/cv/awards/2020/08/01/2020-%EA%B8%B0%EC%83%81-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8C%80%ED%9A%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EB%B6%84%EC%95%BC-%EC%9A%B0%EC%88%98%EC%83%81.html"
      }
      ,
    
      "cv-awards-2020-08-01-2019-eb-b9-85-ec-bd-98-ed-85-8c-ec-8a-a4-ed-8a-b8-ed-93-a8-ec-b3-90-ec-8a-a4-eb-a6-ac-ea-b7-b8-ec-9e-a5-eb-a0-a4-ec-83-81-html": {
        "title": "기상 빅데이터 대회 - 우수상",
        "tags": "awards, CV",
        "date": "August 1, 2020",
        "author": "",
        "category": "CV/Awards",
        "content": "",
        
        "url": "/cv/awards/2020/08/01/2019-%EB%B9%85%EC%BD%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%93%A8%EC%B3%90%EC%8A%A4%EB%A6%AC%EA%B7%B8-%EC%9E%A5%EB%A0%A4%EC%83%81.html"
      }
      ,
    
      "book-finance-2020-07-29-ea-b8-88-ec-9c-b5-ec-9a-a9-ec-96-b4-ec-9d-b4-ed-95-b4-02-ed-8f-ac-ed-8a-b8-ed-8f-b4-eb-a6-ac-ec-98-a4-ec-9d-b4-eb-a1-a0-html": {
        "title": "02: 포트폴리오 이론",
        "tags": "금융, 포트폴리오 이론",
        "date": "July 29, 2020",
        "author": "",
        "category": "Book/Finance",
        "content": "개요  자산은 분산투자한다.  왜?          위험과 수익은 Trade off 관계이다.      하지만 자산을 섞어 운용할 경우, 최적선을 만들 수 있다.      원리항상 포트폴리오 관리를 하라고 한다. 왜일까? 근본적인 이유는 매우 간단하다.지금부터 이유에 대해 이해해보도록 하자.위험이란?  수익률의 변동성  변동성이란?          자산의 수익률이 평균으로 부터 크게 움직일 때      즉, 표준편차가 큰 경우 변동성이 크다 판단한다.      해당 기준은, 내가 어떤 전략을 원하느냐에 따라 달라진다.      자산의 총 위험  자산의 총 위험 = 개별 자산 특수 위험 + 시장 위험여기서 개인이 할 수 있는 부분은 개별 자산 특수 위험을 줄이는 것이다.이 때, 시장 위험에 따른 개별 자산의 위험도의 정도를 베타라 한다.결론  변동폭이 높은 여러 주식을 섞을 경우 표준편차가 확률적으로 줄어든다.  추가적으로 특정 이벤트가 발생 했을 때, 공분산(상관계수)가 -1을 지향하는 것이 안정적이다.  이벤트에 대해 일정한 수익률을 보장할 수 있는 포트폴리오를 만드는 것이 중요하다이러한 점은, 곧 포트폴리오에 자산을 추가함에 있어서 그 자산이 전체 포트폴리오의 방향성에 어떠한 점을 가져오느냐를 판단하는 것이 중요하다는 것을 의미한다.의문  그렇다면, 자산을 추가할 수록 위험은 0에 수렴하는가?          아니다. 통제불가능한 bias가 존재한다.                  이는 거시 경제 변수(환율, 금리, 통화량)에 의한 위험을 의미한다.                    이 거시 경제 변수는 내가 진행하는 주식 시장에 따라 결정된다.                  예를 들어, 한국 시장이라면 한국 시장 자체가 같은 위험도에 따라 위험도가 결정된다.          즉, 코스피 수익률의 표준편차는 안고 간다는 의미이다.                    약 50개의 자산을 함께 운용 했을 때, 최소점에 다다른다고 한다.        그렇다면, 무조건 적으로 분산 투자를 많이 하는 것이 좋은 것인가?          아니다. 주식에 답은 없다.      많은 수의 자산을 관리하는 것과 수익률과는 어느 정도의 trade off 관계가 존재한다.                  즉, 많은 수의 자산을 관리할 경우 수익률은 떨어지는 경향이 있다.          그렇다고 너무 적은 수의 자산으로 관리할 경우 안정성이 떨어진다.                    ",
        
        "url": "/book/finance/2020/07/29/%EA%B8%88%EC%9C%B5-%EC%9A%A9%EC%96%B4-%EC%9D%B4%ED%95%B4-02-%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4-%EC%9D%B4%EB%A1%A0.html"
      }
      ,
    
      "book-finance-2020-07-29-ea-b8-88-ec-9c-b5-ec-9a-a9-ec-96-b4-ec-9d-b4-ed-95-b4-01-ea-b8-88-ec-9c-b5-ed-88-ac-ec-9e-90-ec-9a-a9-ec-96-b4-html": {
        "title": "01: 금융/투자 용어",
        "tags": "금융, 용어정리",
        "date": "July 29, 2020",
        "author": "",
        "category": "Book/Finance",
        "content": "금융/주식 용어 정리            용어      설명                  주식      기업 설립 후, 기업 가치를 기반으로 한 주식 발행 개수를 기업들이 정해서 처음에 상장함  많이 먹으면 회사 먹었다고 판단 가능              매수      주식을 사는 행위              매도      주식을 파는 행위              체결/미체결      체결이 되야 내가 현금이 생긴다.              MTS      모바일 트레이딩 시스템              HTS      홈 트레이팅 시스템              현재가      현재 해당 주식의 가격              종가      마감 했을 때, 가격              지정가      매도나 매수를 할 때, 내가 원하는 가격을 정해서 내놓을 수 있음              시장가      현재 시장가에 해당하는 가격으로 매도나 매수를 진행할 수 있음              시간외      정규장 이외 시간에 거래를 하는 방법 이 때는 종가 기준으로 거래가 이루어 진다.  정규장 이전 시간 : 8:30~9:00 (전일 종가 기준)  정규장 이후 시간 : 15:40~16:00 (당일 종가 기준)              신용      신용 기준으로 증권회사가 대출해줌 내가 산 주식 가격 기준 70% 금액정도              시가 총액      시가 * 발행주식수 = 현재 기준으로 기업의 가치를 돈으로 매긴 것              주문 번호      같은 금액에 대해 사려는 사람이 5000명,  근데 해당 가격에 매도한 사람이 3000명일 경우,  주문 번호 3000번 까지만 먼저 체결됨              거래 대금      특정 기간에 대해 체결된 양              외인      외국인              기관      주식 거래를 하는 기관              배당      주식을 산다는 건 회사의 일부를 가진다는 것 이 회사가 잘 되었을 때, 그 이익의 일부를 나눠주는 것              차트      주식 가격의 변동성을 기간 별로 파악할 수 있다.              선물 거래      미래 상품의 판매권을 현재에 사고, 해당 시기 가격에 그 판매권에 해당하는 금액을 받음              VI      존나 팍 올라도 스턴, 존나 팍 내려가도 스턴              서킷 브레이크      전체 시장의 변동성이 큰 경우 시장을 멈춰버리는 것              사이드카      변동성 완화장치              프로그램 매매      말 그대로 프로그램을 기반으로 주식을 거래하는 것을 말함              EPS      순이익/주식수 = 주식 1주당 창출한 이익              ROE      자기 자본이익률 = 투입한 자기자본으로 얼마만큼의 이익을 내었는가?      해외 선물 용어 정리            용어      설명                  선물      미래에 발생할 거래에 대해 계약한다.  현재 시점에서 미래에 대한 가치를 정하고, 먼저(선) 물건(물)을 거래한다. 이 때, 미래 가치가 상승한다, 혹은 하락한다에 베팅을 진행할 수 있다.              헷지 거래      앞서 선물 거래는 업다운에 베팅이 가능하다 했다. 그렇기 때문에 위험이 크다. 이러한 손실을 만회할 수단으로 양쪽에 베팅하는 것을 말한다. 물론 이 베팅은 같은 상품에 대해 진행하지 않아도 된다. 상관성이 반대인 상품에 대해 잘 조절해서 베팅한다.              기초 자산      선물 거래의 대상 목록  금융자산(주가지수, 국채 금리, 통화 화폐)  원자재(옥수수, 금, 원유)  딱 봐도 알겠지만 이 기초 자산은 국내를 벗어난다. 그래서 해외 선물 거래다.              레버리지      지렛대.  자본이 많아야 손익폭이 크다. 부채 추가해서 넣는 것              해외 거래소      선물 거래소를 의미  CME Group - 세계 1위 거래소  EUREX - 유럽 최대 거래소  SGX - 아시아 거래소 (싱가폴)              위탁 증거금      선물 거래를 하기 위해서는 레버리지가 필수 불가결하다.  그렇기 때문에 이를 위한 담보가 있어야 한다.              유지 증거금(마진콜)      선물 거래가 지속되기 위해 최소한 유지되어야 하는 담보 금액(보증금)  일정 수준 하회할 경우 추가로 요청한다.              정산가      일일 정산을 위한 기준 가격.  마감 직전 거래량의 가중 평균을 사용한다.              만기일      주식과 다르게, 만기가 존재한다.              만기연장  (롤오버)      다음 종목으로 들어가서 만기를 연장하는 개념      펀드 용어 정리            용어      설명                  펀드      투자를 목적으로 모아진 기금              거치식 펀드      한번에 납입              적립식 펀드      여러번에 나눠 납입              증권 펀드      50% 이상 증권 투자              주식형 펀드      증권 펀드 중 주식 비율이 60% 이상인 경우              채권형 펀드      증권 펀드 중 채권 비율이 60% 이상인 경우              주식혼합형 펀드      증권 펀드 중 주식 비율이 50% 이상인 경우              채권혼합형 펀드      증권 펀드 중 채권 비율이 50% 이상인 경우              부동산 펀드      50%이상 부동산 투자              MMF      100% 단기 금융 상품 투자              공모 펀드      불특정 다수에게 오픈된 펀드              사모 펀드      49명 이하의 투자자로 유지해야 하는 펀드              헤지 펀드      하락 위험에 이익을 발생시키는 상품에 투자하는 펀드 (사모펀드로 구분)              뮤츄얼 펀드      투자 목적으로 설립된 펀드이자 투자회사      펀드 네이밍 법칙            구분      설명                  운용사      판매를 하는 곳과 달리, 펀드를 만들고 운용하고 상태를 투자자에게 보내주는 회사              고유이름      고유의 브랜드명              운용전략      대표 운용전략을 파악할 수 있음 (고배당, 인덱스)              순번      펀드 규모가 커질 경우 붙는 숫자              투자의 대상      주요 투자 대상              수수료 방식      펀드 클래스라 부르며 수수료에 대한 정보를 준다.              설정액/판매액      펀드에 들어온 돈의 총액              기준가      펀드의 현재 가격              설정일      펀드의 생일              환매      투자자가 펀드에 투자한 자본을 회수              모닝스타      펀드를 평가하는 회사, 등급을 매긴다.              보수/수수료      펀드 비용              보수      펀드 운용 회사에 지급하는 보수 비용 등등              환매수수료      펀드 운용의 안정성을 추구하기 위해 기간을 설정하기도 한다. 이 기간보다 빠르게 환매할 경우 환매 수수료를 내야한다.              판매수수료      펀드 판매사들의 수수료      재무 재표 용어            용어      설명                  ROE(Return Of Equity)      주주가 준 돈으로 어느정도의 이익을 올리고 있는지, 투자에 대한 운용 효율을 의미한다. ROE = (당기순이익 / 평균자기자본) * 100              PER(Price Earning Ratio)      주가 / 1주당 예상순이익  = 주가 / (순이익/주식 수)  = (주가 * 주식 수) / 순이익  = 시가총액 / 순이익  = 이 순이익으로 회사를 사려면 몇 년이 걸릴까요?  PER이 크다? 덩치는 큰데 순이익이 적다.  왜? 분자가 크거나 분모가 작거나  얘는 주가에 증권과 같은 다른 요소가 껴있다.              EV(Enterprise Value)      자기자본 + 부채  = 시가총액 + 순부채  = 기업을 사기 위해 지불해야 하는 금액              PBR  (Earnings Before Interest, Taxes, Depreciation and Amortization)      이자, 세금, 감가상각비등을 빼기 전의 순이익  순수하게 벌어드리는 현금 창출 능력              EV/EBITDA      영업활동을 통한 이익의 몇 배가 기업가치인가      ",
        
        "url": "/book/finance/2020/07/29/%EA%B8%88%EC%9C%B5-%EC%9A%A9%EC%96%B4-%EC%9D%B4%ED%95%B4-01-%EA%B8%88%EC%9C%B5-%ED%88%AC%EC%9E%90-%EC%9A%A9%EC%96%B4.html"
      }
      ,
    
      "cs-algorithm-2020-07-09-eb-b0-b1-ec-a4-80-ec-98-a4-ec-95-84-ec-8b-9c-ec-8a-a4-ec-9e-ac-ea-b2-b0-ed-95-a9-html": {
        "title": "백준(3015번): 오아시스 재결합",
        "tags": "백준, 알고리즘, stack",
        "date": "July 9, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드1 : stack 문제이다.생각아, 어려웠다.. 처음에 dp로 풀생각을 했더니, $O(n^2)$ 이라 500,000인 input에 맞지 않는다. 또한 그 과정에서 세그먼트 트리 혹은 우선 순위 큐를 사용하려 했지만 구현 난이도가 올라가 고민했다.역시 알고리즘 문제는 약간은 컴퓨터 처럼 순차적으로 규칙을 찾는 것이 가장 중요하다는 생각을 한다. 또한, 어떠한 자료구조를 사용하여 문제의 input을 어떠한 규칙을 갖는 무언가를 만드는 것이 매우 중요하다.해당 문제에서 핵심은, i번째 사람의 입장에서 앞을 보았을 때, 보이는 모습을 상상해보는 것이 중요하다. 이를 상상해보면 그 사람은 계속 사람의 키가 올라가는 모양으로 보인다. 이는 index 0에서 부터 생각해 볼때, i까지의 위치까지 감소하는 수열을 갖고 있는다고 생각할 수 있다. 이런 감소하는 수열을 갖고 있다면, i+1 번째의 감소하는 수열을 만드는 과정에서 답안을 도출할 수 있다.물론, 이 문제는 키가 같을 수 있다는 점에서 이를 처리하는 방법이 필요하다. 이를 해결하는 방법은 역시나 i번째 사람의 입장에서 앞을 보았을 때, 어떤 식으로 pair가 구성되는지 시뮬레이션 하는 것이 도움이 된다.Code#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;int N;vector&lt;pair&lt;int, int&gt;&gt; line;long long ans = 0;  // 답의 개수가 무지하게 많이 나오니 이거 꼭 체크!void print(){    for (int i = 0; i &lt; int(line.size()); i++) {        cout &lt;&lt; line[i].first &lt;&lt; \" \";    }cout &lt;&lt; '\\n';    for (int i = 0; i &lt; int(line.size()); i++) {        cout &lt;&lt; line[i].second &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        int nowH;        cin &gt;&gt; nowH;        bool same = false;        // 감소하는 수열을 만들며 규칙에 따라 답을 업데이트한다.        while(!line.empty()){            pair&lt;int, int&gt; near = line.back();            // 현재 키가 가장 근방에 있는 사람보다 클 경우            if (nowH &gt; near.first) {                // 감소하는 수열을 만들어 놓은 상태이기 때문에                // 이 사람은 나와 쌍이 될 수 있다.                ans += near.second;                line.pop_back(); // 답을 추가했으니 뺀다.            } // 현재 키가 가장 근방에 있는 사람보다 작을 경우            else if (nowH &lt; near.first) {                // 이 사람까지 답에 추가할 수 있다. 같은 키를 다 넣을 수는 없고                // 딱 마지막 사람만 가능하다!!!                // 추가하고 나서는 while문을 탈출한다.                ans += 1;                break;            } // 현재 키가 가장 근방에 있는 사람과 같을 경우            else {                // 같은 키를 가진 사람은 답에 추가가능하다.                ans += near.second;                // 현재 가장 뒤에 있는 사람을 빼온다.                int count = near.second;                line.pop_back();                // 뺀뒤에도 비어있지 않다는 얘기는 현재 같은 키 말고 큰 키를 가진 사람이 앞에 있다는 얘기이다.                // 가장 근방에 있는 사람까지 pair가 가능하다.                if (!line.empty()) {                    ans += 1;                }                // 지금 있는 사람의 count 정보에 +1 하여 다시 넣어준다.                line.push_back(make_pair(nowH, count+1));                // 이미 내 현재 높이가 앞 높이와 같으므로 이것보다 작은 키는 나올 수 없다.                same = true;                break;            }        }        // 기존의 line을 업데이트한 후에, 현재 사람의 정보를 추가한다.        if (!same) {            line.push_back(make_pair(nowH, 1));        }//        cout &lt;&lt; ans &lt;&lt; '\\n';//        print();    }    cout &lt;&lt; ans;    return 0;}Reference백준(3015번) - 오아시스 재결합",
        
        "url": "/cs/algorithm/2020/07/09/%EB%B0%B1%EC%A4%80-%EC%98%A4%EC%95%84%EC%8B%9C%EC%8A%A4%EC%9E%AC%EA%B2%B0%ED%95%A9.html"
      }
      ,
    
      "cs-algorithm-2020-07-09-eb-b0-b1-ec-a4-80-ec-86-8c-ec-88-98-ea-b2-bd-eb-a1-9c-html": {
        "title": "백준(1963번): 소수 경로",
        "tags": "백준, 알고리즘, BFS, 완전탐색",
        "date": "July 9, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드5 : bfs 문제이다.생각최소 경로를 묻는 문제로써, 완전 탐색으로 풀이할 수 있다. 이 때, 중요한 점은, 한번의 스텝을 넘어감에 있어서 소수여야 한다는 것, 그리고 불가능하다는 것을 알려주기 위한 visited를 만드는 것이다. 재방문 했을 경우, 탐색을 하지 않을 경우 불가능한 것은 모든 경로를 다 검토했을 때, 답이 없는 경우이다.  소수인가?  방문한 숫자인가?  최종 경로인가?이 세가지 질문을 구현하면 답은 쉽게 나온다.Code#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;bool isPrime[10000];bool isVisit[10000];int T;void SieveOfEratosThenes(){    memset(isPrime, 1, sizeof(isPrime));    isPrime[0] = false;    isPrime[1] = false;    for (int i = 2; i*i &lt; 10000; i++) {        if (!isPrime[i]) continue;        for (int j = i*i; j &lt; 10000; j += i) {            isPrime[j] = false;        }    }}int BFS(int start, int end){    queue&lt;pair&lt;int, int&gt;&gt; q;    q.push(make_pair(start, 0));    while (!q.empty()) {        pair&lt;int, int&gt; now = q.front();        q.pop();        isVisit[now.first] = true;        if (now.first == end) return now.second;        for (int i = 0; i &lt; 4; i++) {            for (int j = 0; j &lt; 10; j++) {                if (i == 0 &amp;&amp; j == 0) continue;                string now_s = to_string(now.first);                int nowDepth = now.second;                now_s[i] = char('0' + j);                int candidate = stoi(now_s);                if (!isVisit[candidate] &amp;&amp; isPrime[candidate]) {                    q.push(make_pair(candidate, nowDepth+1));                }            }        }    }    return -1;}int main(){//    cout &lt;&lt; char('0' + 7);    cin &gt;&gt; T;    SieveOfEratosThenes();    for (int tc = 0; tc &lt; T; tc++) {        memset(isVisit, 0, sizeof(isVisit));        int a, b;        cin &gt;&gt; a &gt;&gt; b;        int result = BFS(a, b);        if (result == -1) cout &lt;&lt; \"Impossible\" &lt;&lt; '\\n';        else cout &lt;&lt; result &lt;&lt; '\\n';    }    return 0;}Reference백준(1963번) - 소수 경로",
        
        "url": "/cs/algorithm/2020/07/09/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%88%98_%EA%B2%BD%EB%A1%9C.html"
      }
      ,
    
      "ds-ml-2020-07-04-santander-02-eda-html": {
        "title": "02: EDA",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "July 4, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Santander Customer Transaction Prediction 데이터의 EDA를 수행한다.EDA  탐험적 데이터 탐색을 통해 재료를 알아보자.Check the data# 모양train_df.shape, test_df.shape((200000, 202), (200000, 201))train_df.head()test_df.head()Train contains:ID_code (string);target;200 numerical variables, named from var_0 to var_199;Test contains:ID_code (string);200 numerical variables, named from var_0 to var_199;Missing Datadef missing_data(data):    total = data.isnull().sum()    percent = (data.isnull().sum()/data.isnull().count()*100)    tt = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])    types = []    for col in data.columns:        dtype = str(data[col].dtype)        types.append(dtype)    tt['Types'] = types    return(np.transpose(tt))%%timemissing_data(train_df)CPU times: user 2.07 s, sys: 134 ms, total: 2.2 sWall time: 2.2 s%%timemissing_data(test_df)CPU times: user 2.2 s, sys: 132 ms, total: 2.33 sWall time: 2.33 s  결측치가 없는 것을 확인했다.Describe%%timetrain_df.describe()%timetest_df.describe()관찰의 결과  train, test 모두 표준 편차가 크다.  train, test 데이터의 mean, std, min 등의 특성치가 매우 근접하다. 즉, 같은 집합을 대변하는 것처럼 보인다.  각 feature의 평균값은 각기 다르다. 범위가 넓다.  train, test의 크기는 같다.변수 상관도Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/07/04/santander-02-EDA.html"
      }
      ,
    
      "ds-ml-2020-07-04-santander-01-eb-ac-b8-ec-a0-9c-ec-a0-95-ec-9d-98-ec-99-80-ec-a4-80-eb-b9-84-html": {
        "title": "01: 문제 정의 &amp; 준비",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "July 4, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Santander Customer Transaction Prediction 문제를 분석한다.문제 정의  거래 금액에 관계없이 미래에 어떤 고객이 특정 거래를 할 것인지 파악한다.Load Data, Packageimport gcimport osimport loggingimport datetimeimport warningsimport numpy as npimport pandas as pdimport seaborn as snsimport lightgbm as lgbfrom tqdm import tqdm_notebook # 진행바 표시하기import matplotlib.pyplot as pltfrom sklearn.metrics import mean_squared_errorfrom sklearn.metrics import roc_auc_score, roc_curvefrom sklearn.model_selection import StratifiedKFoldwarnings.filterwarnings('ignore') # 주피터에서 경고 안뜨게하기IS_LOCAL = Falseif(IS_LOCAL):    PATH=\"../input/Santander/\"else:    PATH=\"../input/\"os.listdir(PATH)['sample_submission.csv', 'test.csv', 'train.csv']캐글에서 한다면 위에 같이 하면 된다.# 읽는데 걸리는 시간 파악하기%%timetrain_df = pd.read_csv(PATH+\"train.csv\")test_df = pd.read_csv(PATH+\"test.csv\")CPU times: user 15.2 s, sys: 2.09 s, total: 17.3 sWall time: 17.4 sReferencekaggle Notebook",
        
        "url": "/ds/ml/2020/07/04/santander-01-%EB%AC%B8%EC%A0%9C%EC%A0%95%EC%9D%98%EC%99%80_%EC%A4%80%EB%B9%84.html"
      }
      ,
    
      "ds-dl-2020-07-04-tf2-02-expert-html": {
        "title": "02: Expert Start Code",
        "tags": "DataScience, DeepLearning, tensorflow",
        "date": "July 4, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "Tensorflow 2.0 Tutorials의 Expert Start Code를 정리한다.Code# 파이썬 3에서 쓰던 문법을 파이썬 2에서 사용가능하게 해줌from __future__ import absolute_import, division, print_function, unicode_literals!pip install -q tensorflow-gpu==2.0.0-rc1  # q 옵션은 quiet 이다.. 한참찾았네..import tensorflow as tffrom tensorflow.keras.layers import Dense, Flatten, Conv2Dfrom tensorflow.keras import Modelmnist = tf.keras.datasets.mnist(x_train, y_train), (x_test, y_test) = mnist.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0# 채널을 나타내는 차원을 추가합니다. mnist는 흑백이므로 하나만.x_train = x_train[..., tf.newaxis]x_test = x_test[..., tf.newaxis]x_train.shape(60000, 28, 28, 1)# tf.data에 있는 slices를 사용하여 섞고, batch 단위로 나누자.train_ds = tf.data.Dataset.from_tensor_slices(    (x_train, y_train)).shuffle(10000).batch(32)test_ds = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)# 케라스(Keras)의 모델 서브클래싱(subclassing) API를 사용하여 tf.keras 모델을 만든다.class MyModel(Model):  def __init__(self):    super(MyModel, self).__init__()    self.conv1 = Conv2D(32, 3, activation='relu')    self.flatten = Flatten()    self.d1 = Dense(128, activation='relu')    self.d2 = Dense(10, activation='relu')  def call(self, x):    x = self.conv1(x)    x = self.flatten(x)    x = self.d1(x)    return self.d2(x)model = MyModel()# 훈련에 사용할 optimizer와 loss function을 선택한다.loss_object = tf.keras.losses.SparseCategoricalCrossentropy()optimizer = tf.keras.optimizers.Adam()# metric을 선택한다.train_loss = tf.keras.metrics.Mean(name='train_loss')train_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='train_accuracy')test_loss = tf.keras.metrics.Mean(name='test_loss')test_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='test_accuracy')# tf.GradientTape를 사용하여 모델을 훈련한다.# 이것은 모든 작업을 기록한다는 의미에서 Tape를 사용한 듯하다.@tf.function # decorator를 사용하여 진행한다.def train_step(images, labels):  # with 문은 자주 사용하는 함수를 클래스로 묶은 것을 가져와서 사용할 수 있게한다.  # 재사용에 매우 유리하다.  # 작동 방식은, GradientTape라는 클래스 안에는 시작, 끝을 알리는 행위가 기록되어 있다.  # 우리가 하는 작업 이후에 이를 꼭 해줘야 한다면, with문을 사용할 경우 이를 무조건 보장한다.  # 보통 파일 읽기, 쓰기와 같은 작업에서 많이 사용한다고 보면 된다.  # 여기서는 GradientTape에서 with 문 아래에 있는 context의 내용을 실행하고,  # 모든 연산을 \"기록\"한다.  # 우리는 train data를 넣고, loss를 뽑는 작업 이외에 수행하는 것은 항상 같다.  # 따라서 with 문으로 설계하는 것이 맞다.  with tf.GradientTape() as tape:    predictions = model(images) # 예측 결과를 저장한다.    loss = loss_object(labels, predictions)  # 기록을 완료한뒤, 기록한 gradient를 뽑자. 기록된 tape에서 후진 자동 미분을 수행한다.  gradients = tape.gradient(loss, model.trainable_variables)  # 계산된 gradient를 적용한다.  optimizer.apply_gradients(zip(gradients, model.trainable_variables))  # 현재 loss와 accuracy를 저장한다.  train_loss(loss)  train_accuracy(labels, predictions)여기서 잠깐, trainable_variables은 실제로 model에 데이터가 들어갔을 때,  [  &lt;tf.Variable 'my_model/conv2d/kernel:0' shape=(3, 3, 1, 32) dtype=float32&gt;,  &lt;tf.Variable 'my_model/conv2d/bias:0' shape=(32,) dtype=float32&gt;,  &lt;tf.Variable 'my_model/dense/kernel:0' shape=(21632, 128) dtype=float32&gt;,  &lt;tf.Variable 'my_model/dense/bias:0' shape=(128,) dtype=float32&gt;,  &lt;tf.Variable 'my_model/dense_1/kernel:0' shape=(128, 10) dtype=float32&gt;,  &lt;tf.Variable 'my_model/dense_1/bias:0' shape=(10,) dtype=float32&gt;]위와 같이 배열 형태로 들어가게 된다. 이러한 입력에 대해 loss를 보고 gradient를 계산한다. 업데이트도 마찬가지고 입력과 gradients가 주어져야 할 수 있기 때문에 zip의 형태로 들어간다. 아주 편리하다,,# test에서도 만들어준다.# 이경우는 gradient를 할필요가 없다.@tf.functiondef test_step(images, labels):  predictions = model(images)  t_loss = loss_object(labels, predictions)  test_loss(t_loss)  test_accuracy(labels, predictions)EPOCHS = 5for epoch in range(EPOCHS):  for images, labels in train_ds:    train_step(images, labels)  for test_images, test_labels in test_ds:    test_step(test_images, test_labels)  template = '에포크: {}, 손실: {}, 정확도: {}, 테스트 손실: {}, 테스트 정확도: {}'  print(template.format(epoch+1,                        train_loss.result(),                        train_accuracy.result()*100,                        test_loss.result(),                        test_accuracy.result()*100))에포크: 1, 손실: 2.3113672733306885, 정확도: 9.899853706359863, 테스트 손실: 2.3025553226470947, 테스트 정확도: 9.800000190734863에포크: 2, 손실: 2.3101234436035156, 정확도: 9.895792961120605, 테스트 손실: 2.3025572299957275, 테스트 정확도: 9.800000190734863에포크: 3, 손실: 2.309101104736328, 정확도: 9.892754554748535, 테스트 손실: 2.3025825023651123, 테스트 정확도: 9.800000190734863에포크: 4, 손실: 2.3081705570220947, 정확도: 9.890397071838379, 테스트 손실: 2.3026015758514404, 테스트 정확도: 9.800000190734863에포크: 5, 손실: 2.307427406311035, 정확도: 9.88851261138916, 테스트 손실: 2.3026163578033447, 테스트 정확도: 9.800000190734863ReferenceTensorflow 2.0 tutorials",
        
        "url": "/ds/dl/2020/07/04/TF2-02-Expert.html"
      }
      ,
    
      "ds-dl-2020-07-04-tf2-01-beginner-html": {
        "title": "01: Beginner Start Code",
        "tags": "DataScience, DeepLearning, tensorflow",
        "date": "July 4, 2020",
        "author": "",
        "category": "DS/DL",
        "content": "Tensorflow 2.0 Tutorials의 Beginner Start Code를 정리한다.Code!pip install tensorflow-gpu==2.0.0-rc1import tensorflow as tfmnist = tf.keras.datasets.mnist(x_train, y_train), (x_test, y_test) = mnist.load_data()# 픽셀 값을 정수에서 실수로 변경해준다.x_train, x_test = x_train / 255.0, x_test / 255.0# 간단하게 만들 때는 이런 방법도 나쁘지는 않다.# 다만 나중에 관리가 짜증나겠지?model = tf.keras.models.Sequential([    tf.keras.layers.Flatten(input_shape=(28, 28)),    tf.keras.layers.Dense(128, activation='relu'),    tf.keras.layers.Dropout(0.2),    tf.keras.layers.Dense(10, activation='softmax')])model.compile(optimizer='adam',              loss='sparse_categorical_crossentropy',              metrics=[\"accuracy\"])model.fit(x_train, y_train, epochs=5)model.evaluate(x_test, y_test, verbose=2)Epoch 1/51875/1875 [==============================] - 4s 2ms/step - loss: 0.0355 - accuracy: 0.9879Epoch 2/51875/1875 [==============================] - 5s 3ms/step - loss: 0.0323 - accuracy: 0.9886Epoch 3/51875/1875 [==============================] - 5s 2ms/step - loss: 0.0322 - accuracy: 0.9890Epoch 4/51875/1875 [==============================] - 4s 2ms/step - loss: 0.0298 - accuracy: 0.9897Epoch 5/51875/1875 [==============================] - 4s 2ms/step - loss: 0.0289 - accuracy: 0.9901313/313 - 1s - loss: 0.0831 - accuracy: 0.9791[0.08314403146505356, 0.9790999889373779]ReferenceTensorflow 2.0 tutorials",
        
        "url": "/ds/dl/2020/07/04/TF2-01-Beginner.html"
      }
      ,
    
      "cs-algorithm-2020-07-04-eb-b0-b1-ec-a4-80-eb-b6-88-html": {
        "title": "백준(5437번): 불",
        "tags": "백준, 알고리즘, BFS, 시뮬레이션",
        "date": "July 4, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : bfs 문제이다.생각단순한 구현 문제이다. 이 때, 순서를 잘 파악하는 것이 중요하다. 먼저, 불을 번지게 한 상태에서, 사람의 현재 위치로 부터 어디로 가는 것이 좋은지를 판단해야 한다. 그리고 사람이 가장 자리에 도착한다면, 다음번째에 탈출이 가능하다.Code#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;// BFS를 사용하여 불을 붙인다.// 불을 붙이는 행위는 언제 까지 하면 돼? -&gt; 탈출하면 불 안붙여도 돼// 그렇다면 사람이 움직이는 것에 불을 붙이는 행위는 의존적// 그럼 q를 하나만 사용하면 될까?// 아니야 불은 따로 움직여야해// 이렇게 하자. 불의 시작 위치를 가지고 있는 q, 사람의 시작 위치를 가지고 있는 q를 두개를 만들자.// 그리고 사람 q안이 비어있을 때까지 루프를 돌리는데, 그때 불 q를 돌리자.const int MAX = 1000;struct Dir{    int y;    int x;};Dir moveDir[4] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0}};int W, H;string graph[MAX];bool visited[MAX][MAX];pair&lt;int, int&gt; start;vector&lt;pair&lt;int, int&gt;&gt; fire;void printG(){    for (int i = 0; i &lt; H; i++) {        cout &lt;&lt; graph[i] &lt;&lt; '\\n';    }    cout &lt;&lt; '\\n';}int BFS(){    int ans = 0;    queue&lt;pair&lt;int, int&gt;&gt; q;    queue&lt;pair&lt;int, int&gt;&gt; fire_q;    q.push(start);    for (int i = 0; i &lt; int(fire.size()); i++) {        fire_q.push(fire[i]);    }    while (!q.empty()) {        // 불을 먼저 붙인다.        int fireSize = int(fire_q.size());        for (int i = 0; i &lt; fireSize; i++) {            int y = fire_q.front().first;            int x = fire_q.front().second;            fire_q.pop();            for (int j = 0; j &lt; 4; j++) {                int nextY = y + moveDir[j].y;                int nextX = x + moveDir[j].x;                if (0 &lt;= nextY &amp;&amp; nextY &lt; H &amp;&amp; 0 &lt;= nextX &amp;&amp; nextX &lt; W){                    if (graph[nextY][nextX] == '.') {                        graph[nextY][nextX] ='*';                        fire_q.push(make_pair(nextY, nextX));                    }                }            }        }//        printG();        // 사람을 이동시킨다.        int manSize = int(q.size()); //  와 이거 안해주면 q가 동적으로 크기가 바뀌어서 이상하게됨..        for (int i = 0; i &lt; manSize; i++) {            int y = q.front().first;            int x = q.front().second;            q.pop();            // 가장 자리에 있을 경우에는 다음번에 탈출이다.            if (y == 0 || y == H-1 || x == 0 || x == W-1)                return ans + 1;            for (int i = 0; i &lt; 4; i++) {                int nextY = y + moveDir[i].y;                int nextX = x + moveDir[i].x;                if (0 &lt;= nextY &amp;&amp; nextY &lt; H &amp;&amp; 0 &lt;= nextX &amp;&amp; nextX &lt; W){                    if (visited[nextY][nextX] == false &amp;&amp; graph[nextY][nextX] != '*' &amp;&amp; graph[nextY][nextX] != '#') {                        visited[nextY][nextX] = true;                        q.push(make_pair(nextY, nextX));                    }                }            }        }        ans++;//        printG();    }    return -1;}int main(){    int T;    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        // tc 문제에서는 배열을 초기화 해주는 것을 까먹으면 안된다.        fire.clear();        memset(visited, false, sizeof(visited));        cin &gt;&gt; W &gt;&gt; H;        for (int i = 0; i &lt; H; i++) {            cin &gt;&gt; graph[i];            for (int j = 0; j &lt; W; j++) {                if (graph[i][j] == '@') {                    start = make_pair(i, j);                    visited[i][j] = true;                }                else if (graph[i][j] == '*') fire.push_back(make_pair(i, j));            }        }        int ans = BFS();        if (ans == -1) cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; '\\n';        else cout &lt;&lt; ans &lt;&lt; '\\n';    }    return 0;}Reference백준(5437번) - 불",
        
        "url": "/cs/algorithm/2020/07/04/%EB%B0%B1%EC%A4%80-%EB%B6%88.html"
      }
      ,
    
      "cv-projects-2020-07-01-ea-b2-b0-eb-a1-9c-eb-b0-9c-ec-83-9d-ec-98-88-ec-b8-a1-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-html": {
        "title": "현대 제철소 결로 발생 예측 프로젝트",
        "tags": "project, CV",
        "date": "July 1, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "  2 Stage model을 사용하여 효과적으로 결로를 예측하고과 서비스를 구축하였다.파일을 불러오는데 시간이 좀 걸립니다!",
        
        "url": "/cv/projects/2020/07/01/%EA%B2%B0%EB%A1%9C-%EB%B0%9C%EC%83%9D-%EC%98%88%EC%B8%A1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8.html"
      }
      ,
    
      "ds-statistics-2020-06-03-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-13-ea-b0-80-ec-84-a4-ea-b2-80-ec-a0-95-html": {
        "title": "12: 가설 검정",
        "tags": "DS, Statistics, sample distribution, 중심 극한 정리, central limit theorem",
        "date": "June 3, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "가설 검정에 대해 이해한다.",
        
        "url": "/ds/statistics/2020/06/03/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-13-%EA%B0%80%EC%84%A4-%EA%B2%80%EC%A0%95.html"
      }
      ,
    
      "ds-statistics-2020-06-03-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-12-ec-b6-94-eb-a1-a0-html": {
        "title": "11: 통계적 추론",
        "tags": "DS, Statistics, sample distribution, 중심 극한 정리, central limit theorem",
        "date": "June 3, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "통계적 추론에 대해 이해한다.통계적 추론  표본이 갖고 있는 정보를 분석하여 모수에 관한 결론을 유도하고, 모수에 대한 가설의 옳고 그름을 판단하는 것추정의 방법모수를 추정하는 방법에 대해서 알아본다.점 추정  모수를 추정하기 위해 하나의 값을 제안한다.해당 모수를 추정하기 위해 만들어진 통계량을 추정량이라 한다. 그리고 이 추정량으로 부터 하나의 추정치를 제시하는 것이 점 추정이다.구간 추정  모수를 추정하기 위해 모수가 포함될 것이라 예상되는 구간을 제시한다.이 때 제시되는 구간을 신뢰구간이라고 한다. 그리고 해당 신뢰구간에 모수가 들어올 확률을 신뢰 수준이라 한다.신뢰 구간의 의미모평균이 100이라 가정하고 표본의 크기가 15라고 생각하자. 이 때, 95% 신뢰수준을 가지는 신뢰구간을 25번 뽑는다고 생각해보자. 이 경우, 이 25개의 선중 23개(92%)가 모평균을 포함하게 된다. 그렇다면 내가 표본을 뽑는 횟수를 증가하면 할 수록 이는 95%에 가까워 진다.",
        
        "url": "/ds/statistics/2020/06/03/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-12-%EC%B6%94%EB%A1%A0.html"
      }
      ,
    
      "ds-statistics-2020-06-03-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-11-ed-91-9c-eb-b3-b8-eb-b6-84-ed-8f-ac-html": {
        "title": "11: 표본 분포",
        "tags": "DS, Statistics, sample distribution, 중심 극한 정리, central limit theorem",
        "date": "June 3, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "표본 분포와 통계량에 대해 이해한다.추론  표본을 가지고 모집단의 특성(모수)를 예측하는 것통계학의 핵심은 내가 원하는 집단의 특징을 알아내는 것이다. 즉, 우리가 관측할 수 있는 표본을 가지고, 이 표본의 특징을 통해 모집단의 특징(모수)를 예측하는 것이다.이러한 모수는 수치로 표현되는 모집단의 특성을 말하는데, 이 모수는 내가 모집단의 분포를 가정했을 때, 해당 분포를 나타내기 위한 parameter로 대변될 수 있다.통계량  표본의 관측값들에 의하여 결정되는 수치적인 양표본 평균, 표본 표준 편차와 같이 표본의 값을 기반으로 하여 얻을 수 있는 값을 통계량이라 한다. 이런 통계량을 기반으로 이와 모수와의 관계를 알아내고, 모수를 추론하는 과정을 거친다.이런 통계량을 랜덤변수로 사용할 수 있다. 우리가 표본을 뽑을 때 마다 표본에 해당하는 통계량 값은 변화하기 때문이다. 따라서 우리는 여러번의 표본을 뽑는다는 가정하에 이러한 통계량을 랜덤변수로써 사용할 수 있다.중심 극한 정리  어떠한 모집단이더라도, 모집단의 평균이 $\\mu$ 이고, 분산이 $\\sigma^2$ 일 때, 임의추출된 표본의 표본 평균 $\\bar X$ 는 표본의 크기가 클 경우 정규분포를 따른다.매우 중요한 중심극한 정리이다. 중심극한 정리의 핵심은, 표본을 뽑은 통계량으로 우리는 모집단의 모수를 추론할 것인데, 어떠한 분포에서 표본을 뽑던 간에 무조건 표본 평균이라는 통계량이 따르는 분포가 정해졌다는 것이다. 이러한 점에서 우리는 통계량의 분포를 가지고 모평균을 추론할 수 있게 된다.이 중심극한 정리의 증명은 적률 생성 함수를 가지고 할 수 있다. 자세한 점은 수리 통계학 책을 공부하기 바란다.",
        
        "url": "/ds/statistics/2020/06/03/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-11-%ED%91%9C%EB%B3%B8%EB%B6%84%ED%8F%AC.html"
      }
      ,
    
      "ds-statistics-2020-06-03-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-10-ec-a0-95-ea-b7-9c-eb-b6-84-ed-8f-ac-html": {
        "title": "10: 정규 분포",
        "tags": "DS, Statistics, normal distribution",
        "date": "June 3, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "정규분포에 대해 이해한다.정규 분포실제로 가장 많이 적용되는 분포는 이항 분포이다. 하지만 이는 이산 확률 변수에 대해 정의되는 변수이다. 이번에는 연속 확률 분포들 중에서 대부분의 통계학 이론의 기본이 되는 정규분포에 대해서 공부한다.정규분포는 종 모양의 확률밀도함수를 가지며, 이는 피에르 라플라스와 칼 가우스가 정리했다.정규분포의 성질  모든 관측치의 68%는 $\\pm \\sigma$ 에 속한다.  모든 관측치의 95%는 $\\pm 2\\sigma$ 에 속한다.  모든 관측치의 99.7%는 $\\pm 3\\sigma$ 에 속한다.이는 앞에서 배운 히스토그램이 종모양 일 때 적용되는 경험 법칙과 맥을 같이 한다.실질적인 계산은 표준정규분포를 가지고 계산하게 된다.이항 분포의 정규분포근사위의 경험 법칙에서 알 수 있듯, 이항 분포는 정규분포에 근사하는 성질이 있다.",
        
        "url": "/ds/statistics/2020/06/03/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-10-%EC%A0%95%EA%B7%9C%EB%B6%84%ED%8F%AC.html"
      }
      ,
    
      "ds-visualization-2020-05-31-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-15-ordered-bar-chart-html": {
        "title": "15: Ordered Bar Chart",
        "tags": "DS, python, matplotlib, Diverging lines",
        "date": "May 31, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "feature를 정리한 후 히스토그램을 그려보자.# Useful for:# This is a normal bar chart but ordered in a specific way.# From the lowest to the highest values# It's useful to show comparisons among discrete categories.# More info:# https://en.wikipedia.org/wiki/Bar_chart# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# groupby and create the target x and ygb_df = df.groupby([\"manufacturer\"])[\"cyl\", \"displ\", \"cty\"].mean()gb_df.sort_values(\"cty\", inplace = True)# fitler x and yx = gb_df.indexy = gb_df[\"cty\"]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 8))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# plot the datafor x_, y_ in zip(x, y):    # this is very cool, since we can pass a function to matplotlib    # and it will plot the color based on the result of the evaluation    ax.bar(x_, y_, color = \"red\" if y_ &lt; y.mean() else \"green\", alpha = 0.3)     # add some text    ax.text(x_, y_ + 0.3, round(y_, 1), horizontalalignment = 'center')# ----------------------------------------------------------------------------------------------------# prettify the plot# Add a patch below the x axis line to enphasize that they are below the mean# I had to copy and paste this code, since I didn't manage to figure it out.# red onep2 = patches.Rectangle((.124, -0.005), width = .360, height = .13, alpha = .1, facecolor = 'red', transform = fig.transFigure)fig.add_artist(p2)# green onep1 = patches.Rectangle((.124 + .360, -0.005), width = .42, height = .13, alpha = .1, facecolor = 'green', transform = fig.transFigure)fig.add_artist(p1)# rotate the x ticks 90 degreesax.set_xticklabels(x, rotation=90)# add an y labelax.set_ylabel(\"Average Miles per Gallon by Manufacturer\")# set a titleax.set_title(\"Bar Chart for Highway Mileage\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/31/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-15-Ordered-Bar-Chart.html"
      }
      ,
    
      "ds-visualization-2020-05-31-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-14-area-chart-html": {
        "title": "14: Area chart",
        "tags": "DS, python, matplotlib, Diverging lines",
        "date": "May 31, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "하나 또는 두개의 데이터에 대한 흐름을 파악할 때 유용한 Area chart를 알아보자.연습 kaggle notebook# Useful for:# Area chart is really useful when you want to drawn the attention about when a series is below a certain point.# The area between axis and line are commonly emphasized with colors, textures and hatchings.# Commonly one compares two or more quantities with an area chart.# More info:# https://en.wikipedia.org/wiki/Area_chart# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/economics.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# create the variation between 2 consecutive rowsdf[\"pce_monthly_change\"] = (df[\"psavert\"] - df[\"psavert\"].shift(1))/df[\"psavert\"].shift(1)# convert todatetimedf[\"date_converted\"] = pd.to_datetime(df[\"date\"])# filter our df for a specific datedf = df[df[\"date_converted\"] &lt; np.datetime64(\"1975-01-01\")]# separate x and yx = df[\"date_converted\"]y = df[\"pce_monthly_change\"]# calculate the max values to annotate on the ploty_max = y.max()# find the index of the max valuex_ind = np.where(y == y_max)# find the x based on the index of maxx_max = x.iloc[x_ind]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (15, 10))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# plot the dataax.plot(x, y, color = \"black\")ax.scatter(x_max, y_max, s = 300, color = \"green\", alpha = 0.3)# annotate the text of the Max valueax.annotate(r'Max value',             xy = (x_max, y_max),             xytext = (-90, -50),             textcoords = 'offset points',             fontsize = 16,             arrowprops = dict(arrowstyle = \"-&gt;\", connectionstyle = \"arc3,rad=.2\")           )# ----------------------------------------------------------------------------------------------------# prettify the plot# fill the area with a specific colorax.fill_between(x, 0, y, where = 0 &gt; y, facecolor='red', interpolate = True, alpha = 0.3)ax.fill_between(x, 0, y, where = 0 &lt;= y, facecolor='green', interpolate = True, alpha = 0.3)# change the ylim to make it more pleasant for the viewerax.set_ylim(y.min() * 1.1, y.max() * 1.1)# change the values of the x axis# extract the first 3 letters of the monthxtickvals = [str(m)[:3].upper() + \"-\" + str(y) for y,m in zip(df.date_converted.dt.year, df.date_converted.dt.month_name())]# this way we can set the ticks to be every 6 months.ax.set_xticks(x[::6])# change the current ticks to be our string month value# basically pass from this: 1967-07-01# to this: JUL-1967ax.set_xticklabels(xtickvals[::6], rotation=90, fontdict={'horizontalalignment': 'center', 'verticalalignment': 'center_baseline'})# add a gridax.grid(alpha = 0.3)# set the titleax.set_title(\"Monthly variation return %\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/31/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-14-Area-Chart.html"
      }
      ,
    
      "ds-visualization-2020-05-31-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-13-diverging-lollipop-chart-with-markers-html": {
        "title": "13: Diverging Lollipop Chart with Markers",
        "tags": "DS, python, matplotlib, Diverging lines",
        "date": "May 31, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "각 카테고리에 대한 값(평균, 중앙값, 표준화 값)을 비교하기 용이한 Diverging Bars를 동그라미로 나타내보자.연습 kaggle notebook# Useful for:# This plot is really useful to show the different performance of deviation of data.# We use text to annotate the value and make more easy the comparison.# This plot is very similar to the previous 2# But here we don't draw any lines and just play with the size of each point and make it a little bigger# More info:# https://blog.datawrapper.de/divergingbars/# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mtcars.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# here we standarize the data# More info:# https://statisticsbyjim.com/glossary/standardization/df[\"x_plot\"] = (df[\"mpg\"] - df[\"mpg\"].mean())/df[\"mpg\"].std()# sort value and reset the indexdf.sort_values(\"x_plot\", inplace = True)df.reset_index(inplace=True)# create a color list, where if value is above &gt; 0 it's green otherwise redcolors = [\"red\" if x &lt; 0 else \"green\" for x in df[\"x_plot\"]]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 8))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# plot the data# iterate over x and y and annotate text and plot the datafor x, y in zip(df[\"x_plot\"], df.index):    # make a horizontal line from the y till the x value    # this doesn't appear in the original 50 plot challenge    ax.hlines(y = y,               xmin = -3,               xmax = x,               linewidth = 0.5,               alpha = 0.3,               color = \"red\" if x &lt; 0 else \"green\")    # annotate text    ax.text(x,             y,             round(x, 2),             color = \"black\",             horizontalalignment='center',             verticalalignment='center',             size = 8)    # plot the points    ax.scatter(x,                y,                color = \"red\" if x &lt; 0 else \"green\",                s = 300,                alpha = 0.5)# ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Diverging plot in matplotlib\")# change x limax.set_xlim(-3, 3)# set labelsax.set_xlabel(\"Mileage\")ax.set_ylabel(\"Car Name\")# instead of y = 1, 2, 3...# put the car makers on the y axisax.set_yticks(df.index)ax.set_yticklabels(df.cars)# change the spines to make it nicerax.spines[\"top\"].set_color(\"None\")ax.spines[\"left\"].set_color(\"None\")# with this line, we change the right spine to be in the middle# as a vertical line from the originax.spines['right'].set_position(('data',0))ax.spines['right'].set_color('grey')Patch를 좀 더 간단하게# Useful for:# This plot is really useful to show the different performance of deviation of data.# In this plot we use rectagles and matplotlib patches to draw the attention to specific points# This example shows how to add patches more easily# More info:# https://blog.datawrapper.de/divergingbars/# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mtcars.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# here we standarize the data# More info:# https://statisticsbyjim.com/glossary/standardization/df[\"x_plot\"] = (df[\"mpg\"] - df[\"mpg\"].mean())/df[\"mpg\"].std()# sort value and reset the indexdf.sort_values(\"x_plot\", inplace = True)df.reset_index(inplace = True)# we plot everything with a black color except a specific Fiat model# this way we visually communicate something to the userdf[\"color\"] = df[\"cars\"].apply(lambda car_name: \"orange\" if car_name == \"Fiat X1-9\" else \"black\")# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (8, 12))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# plot the data# plot horizontal lines from the origin to each data pointax.hlines(y = df.index,          xmin = 0,          xmax = df[\"x_plot\"],          color = df[\"color\"],          alpha = 0.6)# plot the dotsax.scatter(x = df[\"x_plot\"],          y = df.index,          s = 100,          color = df[\"color\"],          alpha = 0.6)# add patches more easily# It's easier to draw shapes like rectangles or squares, since this way# we only must specify 2 points, and matplotlib does all the jobp1 = patches.Rectangle((-2.0, -1), width = .3, height = 3, alpha = .2, facecolor = 'red')p2 = patches.Rectangle((1.5, 27), width = .8, height = 5, alpha = .2, facecolor = 'green')ax.add_patch(p1)ax.add_patch(p2)# annotate textax.annotate('Mercedes Models',            xy = (0.0, 11.0),            xytext = (1.5, 11),            xycoords = 'data',            fontsize = 10,            ha = 'center',            va = 'center',            bbox = dict(boxstyle = 'square', fc = 'blue', alpha = 0.1),            arrowprops = dict(arrowstyle = '-[, widthB=2.0, lengthB=1.5', lw = 2.0, color = 'grey'), color = 'black')# ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Diverging Lollipop of Car Mileage\")# autoscaleax.autoscale_view()# change x limax.set_xlim(-3, 3)# set labelsax.set_xlabel(\"Mileage\")ax.set_ylabel(\"Car Name\")# instead of y = 1, 2, 3...# put the car makers on the y axisax.set_yticks(df.index)ax.set_yticklabels(df.cars)# change the spines to make it nicerax.spines[\"right\"].set_color(\"None\")ax.spines[\"top\"].set_color(\"None\")# add a gridax.grid(linestyle='--', alpha=0.5);ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/31/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-13-Diverging-Lollipop-Chart-with-Markers.html"
      }
      ,
    
      "ds-visualization-2020-05-20-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-12-diverging-lines-with-text-html": {
        "title": "12: Diverging lines with text",
        "tags": "DS, python, matplotlib, Diverging lines",
        "date": "May 20, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "각 카테고리에 대한 값(평균, 중앙값, 표준화 값)을 비교하기 용이한 Diverging Bars에 정보를 추가해보자.연습 kaggle notebook# Useful for:# This plot is really useful to show the different performance of deviation of data.# We use text to annotate the value and make more easy the comparison.# More info:# https://blog.datawrapper.de/divergingbars/# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mtcars.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# here we standarize the data# More info:# https://statisticsbyjim.com/glossary/standardization/df[\"x_plot\"] = (df[\"mpg\"] - df[\"mpg\"].mean())/df[\"mpg\"].std()# sort value and reset the indexdf.sort_values(\"x_plot\", inplace = True)df.reset_index(inplace=True)# create a color list, where if value is above &gt; 0 it's green otherwise redcolors = [\"red\" if x &lt; 0 else \"green\" for x in df[\"x_plot\"]]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 8))ax = fig.add_subplot()# plot horizontal lines that go from zero to the value# here we make the linewidht very thin.ax.hlines(y = df.index, xmin = 0 , color = colors,  xmax = df[\"x_plot\"], linewidth = 1)# ----------------------------------------------------------------------------------------------------# plot the data# iterate over x and y and annotate text and plot the datafor x, y in zip(df[\"x_plot\"], df.index):    # annotate text    ax.text(x - 0.1 if x &lt; 0 else x + 0.1,             y,             round(x, 2),             color = \"red\" if x &lt; 0 else \"green\",             horizontalalignment='right' if x &lt; 0 else 'left',             size = 10)    # plot the points    ax.scatter(x,                y,                color = \"red\" if x &lt; 0 else \"green\",                alpha = 0.5)# ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Diverging plot in matplotlib\")# change x limax.set_xlim(-3, 3)# set labelsax.set_xlabel(\"Mileage\")ax.set_ylabel(\"Car Name\")# make a gridax.grid(linestyle='--', alpha=0.5)# instead of y = 1, 2, 3...# put the car makers on the y axisax.set_yticks(df.index)ax.set_yticklabels(df.cars)# change the spines to make it nicerax.spines[\"top\"].set_color(\"None\")ax.spines[\"left\"].set_color(\"None\")# with this line, we change the right spine to be in the middle# as a vertical line from the originax.spines['right'].set_position(('data',0))ax.spines['right'].set_color('black')ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/20/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-12-Diverging-lines-with-text.html"
      }
      ,
    
      "ds-visualization-2020-05-19-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-11-diverging-bars-html": {
        "title": "11: Diverging Bars",
        "tags": "DS, python, matplotlib, Diverging Bars",
        "date": "May 19, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "각 카테고리에 대한 값(평균, 중앙값, 표준화 값)을 비교하기 용이한 Diverging Bars을 알아본다.연습 kaggle notebook# Useful for:# Based on a metric to compare, this plot helps you to see the divergence of the a value# to that metric (it could be mean, median or others).# More info:# https://blog.datawrapper.de/divergingbars/# ----------------------------------------------------------------------------------------------------# get the dataPATH = \"/kaggle/input/the-50-plot-challenge/mtcars.csv\"df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# here we standarize the data# More info:# https://statisticsbyjim.com/glossary/standardization/df[\"x_plot\"] = (df[\"mpg\"] - df[\"mpg\"].mean())/df[\"mpg\"].std()# sort value and reset the index# sort를 하게되면 index가 제멋대로 배열된다.# 우리는 배열된 이후의 index를 다시 갖고 싶은 것이기 때문에 index를 정렬후 새로 만들어준다.# 이 때, drop = True, inplace = True가 있는데 drop은 재생성한 후 이전 것을 버리는 것을 의미한다.# inplace는 원본 데이터를 대체할 것인지, 아니면 변경된 객체를 반환할 것인지를 결정한다.df.sort_values(\"x_plot\", inplace = True)df.reset_index(inplace = True)# create a color list, where if value is above &gt; 0 it's green otherwise redcolors = [\"red\" if x &lt; 0 else \"green\" for x in df[\"x_plot\"]]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 8))ax = fig.add_subplot()# plot using horizontal lines and make it look like a column by changing the linewidth# 가로선을 그음으로써 원하는 그래프와 비슷한 모양을 만든다.ax.hlines(y = df.index, xmin = 0 , xmax = df[\"x_plot\"],  color = colors, linewidth = 5)# ----------------------------------------------------------------------------------------------------# prettify the plot# set x and y axisax.set_xlabel(\"Mileage\")ax.set_ylabel(\"Car Name\")# set a titleax.set_title(\"Diverging plot in matplotlib\")# make a grid to help separate the linesax.grid(linestyle='--', alpha=0.5)# change the y ticks# first you set the yticks# 먼저 y에 index를 박고,ax.set_yticks(df.index)# then you change them using the car names# same can be achived using plt.yticks(df.index, df.cars)# 그 index에 맞는 차를 넣어준다.# 이 때, ;를 추가하여 output이 나오지 않게 만들어준다.ax.set_yticklabels(df.cars);ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/19/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-11-Diverging-Bars.html"
      }
      ,
    
      "ds-visualization-2020-05-19-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-10-pair-plot-html": {
        "title": "10: Pair plot",
        "tags": "DS, python, matplotlib, Pair plot",
        "date": "May 19, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "두 변수간의 관계를 한눈에 파악할 수 있는 Pair plot을 알아본다.연습 kaggle notebook# Useful for:# Plot pairwise relationships in a dataset.# Helps you to see in a glance of an eye all distribution and correlation of variables.# More info:# https://seaborn.pydata.org/generated/seaborn.pairplot.html# ----------------------------------------------------------------------------------------------------# get the datadf = sns.load_dataset('iris')# plot the data using seaborn# hue = 색조, 이 변수에 내가 원하는 그룹의 변수를 적어주면 된다.# 이 부분을 안하면, 대각원소에는 히스토그램이 그려진다.sns.pairplot(df,             hue = \"species\" # helps to separate the values by specios            );각각의 산점도에 종마다 회귀선을 그려보자.# Useful for:# Plot pairwise relationships in a dataset.# Helps you to see in a glance of an eye all distribution and correlation of variables.# This plot also plots a regression line to fit each of the data# More info:# https://seaborn.pydata.org/generated/seaborn.pairplot.html# ----------------------------------------------------------------------------------------------------# get the datadf = sns.load_dataset('iris')# plot the data using seabornsns.pairplot(df,             kind = \"reg\", # make a regression line for eac hue and each variables             hue = \"species\"            );ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/19/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-10-Pair-Plot.html"
      }
      ,
    
      "ds-visualization-2020-05-19-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-09-correlation-plot-html": {
        "title": "09: Correlation plot",
        "tags": "DS, python, matplotlib, Correlation plot",
        "date": "May 19, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "변수들의 상관관계를 한눈에 파악할 수 있는 Correlation plot을 알아본다.연습 kaggle notebook# Useful for:# The correlation plot helps us to comparte how correlated are 2 variables between them# More info:# https://en.wikipedia.org/wiki/Covariance_matrix#Correlation_matrix# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mtcars.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))ax = fig.add_subplot()# plot using matplotlib# https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.axes.Axes.imshow.htmlax.imshow(df.corr(), cmap = 'viridis', interpolation = 'nearest')# set the title for the figureax.set_title(\"Heatmap using matplotlib\");단순히 이렇게만 plot하면 알아보는 것이 어려우니, x, y축에 변수이름을 적어 나타내어 보자.# Useful for:# The correlation plot helps us to comparte how correlated are 2 variables between them# More info:# https://en.wikipedia.org/wiki/Covariance_matrix#Correlation_matrix# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mtcars.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# calculate the correlation between all variablescorr = df.corr()# create a mask to pass it to seaborn and only show half of the cells# because corr between x and y is the same as the y and x# it's only for estetic reasonsmask = np.zeros_like(corr) # 0행렬을 만든다.mask[np.triu_indices_from(mask)] = True # upper triangle 부분을 true로 바꾼다.# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))# plot the data using seabornax = sns.heatmap(corr,                 mask = mask,                 vmax = 0.3,                 square = True,                 cmap = \"viridis\")# set the title for the figureax.set_title(\"Heatmap using seaborn\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/19/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-09-Correlation-plot.html"
      }
      ,
    
      "ds-visualization-2020-05-16-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-08-marginal-histogram-html": {
        "title": "08: Marginal Histogram",
        "tags": "DS, python, matplotlib, Marginal Histogram",
        "date": "May 16, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "Scatter Plot에 각각의 histogram을 추가해보자.연습 kaggle notebook# Useful for:# This plot is a combination of 2 plots.# On one side we have a normal scatter plot that is helpful to see the relationship between data (x and y axis)# But we also add a histogram that is useful to see the concentration/bins and the distribution of a series.# More info:# https://en.wikipedia.org/wiki/Histogram# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# separate x and yx = df[\"displ\"]y = df[\"hwy\"]# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))# in this case we use gridspec.# check the basics section of this kernel if you need help.gs = fig.add_gridspec(5, 5)ax1 = fig.add_subplot(gs[:4, :-1])# ----------------------------------------------------------------------------------------------------# plot the data# main axis: scatter plot# this line is very nice c = df.manufacturer.astype('category').cat.codes# since it basically generate a color for each category# 이렇게 하면 카테고리별 색상을 구해준다. 총 78개의 category가 있는 것으로 보인다.ax1.scatter(x, y, c = df.manufacturer.astype('category').cat.codes)# set the labels for x and yax1.set_xlabel(\"Dist\")ax1.set_ylabel(\"Hwy\")# set the title for the main plotax1.set_title(\"Scatter plot with marginal histograms\")# prettify the plot# get rid of some of the spines to make the plot nicerax1.spines[\"right\"].set_color(\"None\")ax1.spines[\"top\"].set_color(\"None\")# using familiar slicing, get the bottom axes and plotax2 = fig.add_subplot(gs[4:, :-1])ax2.hist(x, 40, orientation = 'vertical', color = \"pink\")# invert the axis (it looks up side down)ax2.invert_yaxis()# prettify the plot# set the ticks to nullax2.set_xticks([])ax2.set_yticks([])# no axis to make plot nicerax2.axison = False# using familiar slicing, get the left axes and plotax3 = fig.add_subplot(gs[:4, -1])ax3.hist(y, 40, orientation = \"horizontal\", color = \"pink\")# prettify the plot# set the ticks to nullax3.set_xticks([])ax3.set_yticks([])# no axis to make plot nicerax3.axison = False# make all the figures look nicierfig.tight_layout()ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/16/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-08-Marginal-Histogram.html"
      }
      ,
    
      "ds-visualization-2020-05-16-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-08-marginal-boxplot-html": {
        "title": "09: Marginal Boxplot",
        "tags": "DS, python, matplotlib, Marginal Boxplot",
        "date": "May 16, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "Scatter Plot에 각각의 boxplot을 추가해보자.연습 kaggle notebooksns.set_style(\"whitegrid\")# Useful for:# A box plot or boxplot is a method for graphically depicting groups of numerical data through their quartiles.# It helps to see the dispersion of a series, thanks to the whiskers# More info:# https://en.wikipedia.org/wiki/Box_plot# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plottingx = df[\"displ\"]y = df[\"hwy\"]# in this plot we create the colors separatlycolors = df[\"manufacturer\"].astype(\"category\").cat.codes# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))# in this case we use gridspec.# check the basics section of this kernel if you need help.gs = fig.add_gridspec(6, 6)ax1 = fig.add_subplot(gs[:4, :-1])# ----------------------------------------------------------------------------------------------------# plot the data# main axis: scatter plot# this line is very nice c = df.manufacturer.astype('category').cat.codes# since it basically generate a color for each categoryax1.scatter(x, y, c = df.manufacturer.astype('category').cat.codes)# set the labels for x and yax1.set_xlabel(\"Dist\")ax1.set_ylabel(\"Hwy\")# set the title for the main plotax1.set_title(\"Scatter plot with marginal histograms\")# prettify the plot# get rid of some of the spines to make the plot nicerax1.spines[\"right\"].set_color(\"None\")ax1.spines[\"top\"].set_color(\"None\")# using familiar slicing, get the left axes and plotax2 = fig.add_subplot(gs[4:, :-1])ax2.boxplot(x,            vert = False,            whis = 0.75 # make the boxplot lines shorter           )# prettify the plot# set the ticks to nullax2.set_xticks([])ax2.set_yticks([])# left plotax3 = fig.add_subplot(gs[:4, -1])ax3.boxplot(y,            whis = 0.75 # make the boxplot lines shorter           )# prettify the plot# set the ticks to nullax3.set_xticks([])ax3.set_yticks([])# make all the figures look nicierfig.tight_layout()ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/16/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-08-Marginal-Boxplot.html"
      }
      ,
    
      "ds-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-09-eb-8b-a4-ec-96-91-ed-95-9c-ed-99-95-eb-a5-a0-eb-b6-84-ed-8f-ac-html": {
        "title": "09: 다양한 확률 분포",
        "tags": "DS, Statistics, probability distribution, parameter",
        "date": "May 15, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "다양한 확률분포에 대해 이해한다.이산 확률 변수의 분포대표적으로 사용하는 이산 확률 변수에 대한 분포를 알아본다. 의미적으로 이해하는 것을 우선으로 한다.베르누이 분포  확률 변수의 값이 성공 혹은 실패로 나타나는 경우에 따른 분포동전을 던졌을 때, 앞면이 나오는 사건에 대한 값을 확률 변수로 잡는 경우가 해당된다. 해당 사건이 나오는 확률을 정의해야 분포가 정의된다.초기하 분포  n번의 시행에서 k번 성공할 확률, 그런데 독립시행이 아닐 경우의 분포주머니에 10개의 공이 있다. 이 때 파란공이 3개, 빨간공이 7개 이다. 이런 상황에서의 확률 실험이 공을 5번 꺼내는 실험이다. 공은 다시 넣지 않는다.(비복원 추출) 이 떄 확률 변수 X를 빨간 공이 나오는 횟수라고 할 경우, 발생하는 확률 분포이다. 이 초기하 분포를 설명하기 위해서는 총 공이 몇개가 있는지(N), 몇개를 뽑을 것인지(n), 그 때 빨간공이 나오는 개수(k) 세가지 파라미터가 필요하다.초기하 분포의 상황에서 n이 특정수 이상으로 큰 경우 이항 분포로 가정하고 풀이한다.이항 분포  확률 변수의 값이 독립 시행의 성공 횟수로 표시되는 경우에 따른 분포동전을 5번 던졌을 때, 앞면이 나오는 횟수를 확률 변수로 잡는 경우이다. 문제에서 알 수 있듯 해당 분포를 설명하기 위해서는 몇번 던지는지(n), 그리고 한번의 시행에서 나오는 확률 얼마인지(p)를 정의해야 한다. 두개의 파라미터를 가진다.이항 분포는 베르누이 확률 변수의 합으로 정의되는 랜덤 변수의 분포로 정의된다.기하 분포  처음으로 성공하는 횟수를 확률 변수로 잡을 경우 나오는 분포동전을 던지는데, 처음으로 앞면이 나오는 시행 횟수를 확률 변수로 잡을 경우 나타나는 분포이다.음이항 분포  특정 횟수를 성공하기 위한 시행 횟수에 대한 분포동전의 앞면이 10번 나오기 위해 던져야 하는 횟수를 확률 변수로 정의했을 때 나타나는 분포이다. 해당 분포를 설명하기 위해서는 몇번 성공할 것인지(k) 그리고 그 독립 시행의 확률이 얼마인지(p)를 주어진 상태에서 x를 정의하고 그에 대한 확률을 정의한다.음이항 분포의 랜덤 변수는 기하 분포의 랜덤 변수의 합으로 정의된다.포아송 분포  단위 시간 안에 사건이 몇 번 발생할 것인지에 대한 분포버스정류장에 버스가 도착한다고 하자. 이 때, 단위 시간을 10분으로 설정했을 때, 10분안에 도착하는 버스의 수를 랜덤 변수로 정의했을 때 정의되는 분포이다. 포아송 분포를 정의하기 위해 필요한 인자는, 정해진 시간 안에 사건이 일어날 횟수에 대한 기댓값($\\lambda$)가 필요하다.연속 확률 변수의 분포대표적으로 사용하는 연속 확률 변수에 대한 분포를 알아본다. 의미적으로 이해하는 것을 우선으로 한다.지수 분포  한번의 사건이 발생하는데 까지 걸리는 시간에 대한 분포포아송 분포에서는 단위 시간에 발생하는 횟수에 대해 궁금했다면, 이번에는 하나의 사건이 발생하는데 까지 걸리는 시간을 확률 변수로 잡는다. 이 때 발생하는 분포가 지수 분포이다. 지수 분포를 정의하기 위해서는 해당 사건이 발생하는 확률(p)가 필요하다.감마 분포  a번째 사건이 발생할 때까지 걸리는 시간에 대한 분포음이항 분포와 매우 비슷하다. 음이항 분포가 기하 분포의 결합으로 설명되었던 것처럼, 감마 분포도 지수 분포의 결합으로 설명되는 확률 변수에 대해 표현된다.스튜던츠 t 분포  모분산을 모를 때, 표본에 대한 분포를 사용할 때 사용한다.사실 t분포는 추정에서 보다 정확히 사용처를 알 수 있다. 일단은, 모평균이 $\\mu$이고, 모분산이 $\\sigma^2$인 경우, 우리는 Z를 사용하여 이것이 표준 정규 분포를 따른다고 알고 있다.그런데, 우리가 하는 행위는 표본을 통하여 모집단을 예측하는 행위를 하는 것이고, 그렇기 때문에 현실에서 하는 모든 행위는 모집단을 알 수 없다. 그렇기 때문에 평균은 알 수 있을 지라도 모분산을 모르기 때문에 내가 뽑은 표본의 분포가 정규 분포라 가정하고 추정을 수행할 수 없다.이러한 문제에 대해 해결하기 위한 방법으로 모분산 대신 표본 분산을 사용하여 분포를 만들었다. 이것을 t 분포라 한다. 표본 분산을 구하는데에 있어서는 자유도가 필요하므로, t 분포를 사용하기 위해서는 자유도라는 매개변수가 필요하다.자세한 내용은 스튜던트 t 분포 를 확인하자.카이제곱 분포  정규 분포 랜덤 변수의 제곱의 합으로 표현되는 랜덤 변수에 관한 분포왜 카이제곱 분포가 필요할까? 기본적으로 카이제곱 분포는 표본의 분산에 관련된 무언가를 만들기 위해 탄생한 분포이다. 실제로 표준 정규 분포의 랜덤 변수를 제곱하여 자유도 만큼 더한 것으로 카이 제곱 분포의 랜덤 변수가 정의된다. 해당 분포는 분산의 특징을 대변한다는 특징이 있다.F 분포  두 확률 변수가 독립인 카이제곱 분포를 따른다고 할 때 다음의 랜덤 변수가 따르는 분포가우시안 분포  이항 분포의 n이 늘어났을 때 근사하는 분포가장 중요한 분포이며, 평균과 표준편차를 매개변수로 갖는 분포이다.",
        
        "url": "/ds/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-09-%EB%8B%A4%EC%96%91%ED%95%9C-%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html"
      }
      ,
    
      "ds-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-08-ed-99-95-eb-a5-a0-eb-b6-84-ed-8f-ac-html": {
        "title": "08: 확률 변수",
        "tags": "DS, Statistics, random variable",
        "date": "May 15, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "확률분포에 대해 이해한다.왜 배우는가?실생활에서 결국 엔지니어가 수행하는 역할은, 다양한 문제에 대해 이를 다룰 수 있는 문제로 바꾸는 것에 있다. 확률과 같이 애매하게 보이는 개념을 어떻게 수치화하여, 다룰 수 있는 문제로 바꾸는지에 대한 내용이 대부분이다. 다양한 문제에 대해 이에 맞는 분포에 대해 알고 있다면, 비슷한 문제에 대해서 이러한 내용을 적용하여 문제를 모델링 할 수 있다.확률 변수  실험 결과들에 수치를 대응시키는 것우리가 어떠한 실험을 관찰한다고 생각해보자. 예를 들어 동전을 3번 던지는 행위를 하고 있다. 이 때, 내가 관찰하고 싶은 것은 앞면이 몇번 나오는지에 대한 정보이다. 이럴 경우, 3번의 행위 속에 숫자에 대응되는 값은 0, 1, 2, 3으로 4가지이다. 여기서 내가 관찰하고 싶은 것, 앞면이 나오는 수, 가 확률 변수 X가 된다. 이렇게 되면 X는 수치적으로 대응된다. 이 때 발생하는 0, 1, 2, 3은 사건이라 부른다.(event)이산 확률 변수내가 관찰하고 싶은 확률 변수가 이산적으로 나오게 될 경우 이산 확률 변수이다. 위의 예에서 0, 1, 2, 3과 같이 값이 이산적이므로 위의 예는 이산 확률 변수라 할 수 있다.확률 질량 함수이산적으로 나온 확률 변수에 대한 확률이 정의되고, 이를 나타내는 함수가 있을 때 이것을 확률 질량 함수라 말한다.연속 확률 변수내가 관찰하고 싶은 확률 변수가 연속적일 경우 연속 확률 변수라 말한다. 예를 들어 버스한 대가 처음으로 도착했을 때 시간이 궁금하다고 하면(즉 확률 변수가) 이는 연속적으로 나오게 될 것이다.확률 밀도 함수연속적으로 나온 확률 변수에 대해 넓이를 확률로 정의하는 함수를 정의했다면, 이를 확률 밀도 함수라 한다.확률 밀도 함수는 히스토그램으로 연속 변수에 대한 상대 빈도를 나타내면서 만들어진 개념이다. 기본적으로 히스토그램은 구간을 가지고, 그 구간에 대한 빈도를 나타내는 그래프이다.연속 확률 변수에 대해서 하나의 값에 대한 확률을 구하면 0이다. 무한대에 가까운 실수 길이에 대해 하나의 점의 확률을 구하는 것이기 때문에 0에 수렴한다. 그렇기 때문에 히스토그램을 사용하여, 구간에 대한 발생 빈도를 나타내는 것이 하나의 방법이다.그렇다면 우리는 어떠한 구간에 대한 확률을 정의할 수 있다. 즉, 넓이와 같은 개념에 해당하는 것이 확률이고, 이 넓이를 기반으로 확률을 정의하기 위해서는 하나의 값은 밀도와 같은 의미를 가져야 한다. 이러한 점에서 정의된 함수를 확률 밀도 함수라 한다.이 때, 하나의 함수값, 즉 밀도와 대응되는 값을 우리는 우도(likelyhood)라 한다.기댓값과 평균기댓값과 평균은 기본적으로 같은 의미를 가진다. 그런데 나는 약간의 다른 견해를 가지는 편인데, 기본적으로 기댓값은 표본, 또는 새로운 통계량에 대한 평균에 대해 말하는 경향이 있다. 하지만 평균은 아무래도 모집단이 가지는 실제값을 나타내는데 더 많이 사용하는 경향이 있다.결합 확률 분포지금까지 우리는 하나의 확률 변수에 대한 확률을 어떻게 구하고 정의하는지에 대한 얘기를 했다. 그런데, 사실 두가지 확률 변수에 대한 확률이 발생할 수 있다. 예를 들어 확률 실험이 주사위를 하나 던지고 동전을 하나 던지는 실험이라 하자. 이 때 확률 변수 X를 주사위가 나오는 눈을 수, Y를 동전이 앞이 나오는 수라고 할 경우에 X, Y 상황에 따른 확률이 정의 된다. 이렇게 두가지 변수에 대해 확률이 정의되는 함수가 있을 때, 이를 결합 확률 분포라 한다.",
        
        "url": "/ds/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-08-%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html"
      }
      ,
    
      "ds-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-07-ed-99-95-eb-a5-a0-html": {
        "title": "07: 확률",
        "tags": "DS, Statistics, probability",
        "date": "May 15, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "확률에 대해 이해한다.사건에 확률을 부여하는 방법동전의 앞면이 나오는 것을 사건 A라 정의했을 때, P(A)를 구하는 방법에 대해 알아보자.  고전적 방법          단순히 1/2라 생각한다.      이 생각의 배경에는 앞면과 뒷면이 나오는 가능성이 동일하다 생각하고 부여한다.        상대도수 방법          100번을 던진 후, 앞면이 나온 수를 분자에 올려 정의한다.      실제 행위에 대한 결론을 가지고 확률을 정의한다.        주관적 방법          전문가가 이 사건에 대한 확률을 정의한다.      상호배타적 사건A와 B가 동시에 일어나는 경우가 없을 때 상호배타적이라 한다. 위의 수식을 기반으로 배반 사건이라고도 한다. 한번의 시행을 했을 때, A에 속하면 B에 속하지 못하므로 각각은 서로에게 종속되어 있다. 따라서 배반사건은 종속 사건이다.조건부 확률B가 일어났을 때, A가 일어날 확률이다.Marginal ProbabilityP(A), P(B)를 구하는 방법이다. 이는 결합 확률 밀도함수에서도 활용되는 개념이다. 수식적으로는 상호 배타적인 확률을 모두 더하는 것으로 구할 수 있다.독립 사건(Independent Events)B가 일어났다는 가정하에 A가 일어날 확률과 그냥 A가 일어날 확률이 같다면, A와 B사건은 서로 관련이 없다고 볼 수 있다. 이런 사건을 독립사건이라 한다. 이런 경우, 두 사건이 동시에 일어나는 확률은 두 사건이 발생하는 확률을 곱하여 구할 수 있다.",
        
        "url": "/ds/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-07-%ED%99%95%EB%A5%A0.html"
      }
      ,
    
      "ds-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-06-ed-91-9c-eb-b3-b8-ec-b6-94-ec-b6-9c-eb-b0-a9-eb-b2-95-html": {
        "title": "06: 표본 추출 방법",
        "tags": "DS, Statistics, sampling",
        "date": "May 15, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "모집단을 추정하기 위한 표본을 추출하는 방법에 대해 알아본다.표본 추출  단순 랜덤 추출          단순히 랜덤하게 모집단에서 추출하는 방법이다. 집단의 분포가 불균형할 경우 모집단의 특성을 대변하지 못한다는 단점이 있다.        층화 랜덤 추출          모집단의 분포를 고려하여 표본을 추출한다.        군집 추출법          대상의 클래스를 알 수 없을 때, 군집화를 한 상태에서 추출한다.      표본 추출 오차, 비표본 추출 오차  표본 추출 오차(sampling error)          표본을 선택하는 데 있어, 모집단을 대변하지 못하여 발생하는 오차이다.      추출하는 표본의 크기를 증가시키면 감소한다.        비표본 추출 오차(nonsampling error)          데이터 수집에 있어 발생하는 실수나 제어할 수 없는 에러를 의미한다.      이 부분은 제어할 수 없기 때문에 안고가야하는 부분이다. 최대한 좋은 데이터를 만드는 것이 좋다.      ",
        
        "url": "/ds/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-06-%ED%91%9C%EB%B3%B8%EC%B6%94%EC%B6%9C%EB%B0%A9%EB%B2%95.html"
      }
      ,
    
      "ds-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-05-ec-84-a0-ed-98-95-ea-b4-80-ea-b3-84-ec-9d-98-ec-b2-99-eb-8f-84-html": {
        "title": "05: 선형관계의 척도",
        "tags": "DS, Statistics, Covarience, Coefficient of correlation",
        "date": "May 15, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "데이터의 두 변수간 선형관계를 나타내는 척도에 대해서 알아본다.선형관계두 변수의 관계를 알아보는 것은 매우 중요하다. 어떠한 연관성을 통하여 유의미한 정보를 이끌어 낼 수 있기 때문이다. 이러한 선형관계를 알아내는 척도는 3가지 정도가 알려져 있다.공분산(Covarience)공분산을 직관적으로 이해하면 다음과 같다. 식을 보면, 결국 X에서 X의 평균을 빼고, Y에서 Y의 평균을 뺀뒤 곱한 것들을 모두 더한뒤 데이터의 개수로 나누는 것이다. 그렇다면 안에 있는 $(X-\\mu)(Y-\\nu)$ 만 확인해보자.위와 같은 그림이 된다.이러한 특징 때문에, 결과적으로 양의 상관관계를 가지는 경우는 +, 음의 상관관계는 -가 된다.0이 나오는 경우결론부터 말하자면 x, y축에 대해 평행한 직선에 대해 대칭이면 모두 0이 나온다. 실제로 그림을 그려보고 위의 작업을 해보도록 하자.상관계수(Coefficient of correlation)상관 계수는 위의 값을 정규화했다고 보면 된다. 결과적으로 -1~+1의 값으로 만들어 보다 수치적으로 정확히 판단할 수 있다. 이는 벡터의 내적과 동일한 연산이다.",
        
        "url": "/ds/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-05-%EC%84%A0%ED%98%95%EA%B4%80%EA%B3%84%EC%9D%98-%EC%B2%99%EB%8F%84.html"
      }
      ,
    
      "ds-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-04-ec-83-81-eb-8c-80-ec-9c-84-ec-b9-98-ec-99-80-eb-b0-95-ec-8a-a4-ed-94-8c-eb-a1-af-html": {
        "title": "04: 상대 위치와 boxplot",
        "tags": "DS, Statistics, boxplot",
        "date": "May 15, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "데이터를 설명하는 상대위치와 이를 나타내는 box plot에 대해 알아본다.상대위치중앙값이 50%에 위치하는 분위수라면, 이에 대응하는 다양한 분위수가 존재한다.백분위수분포를 100개로 쪼개어 생각하는 것이다.사분위수분위수 개념중에서 가장 많이 사용하는 개념이며, 25%, 50%, 75%, 100%로 구성된다. 각각을 1, 2, 3, 4분위수라 하며, 2분위수는 중앙값과 대응된다.사분위수간 범위(Interquartile Range)  $Q_3 - Q_1$사분위수간 범위는 관측치들의 중간 50%가 흩어져 있는 정도를 측정한다.Box Plotsboxplot에 대한 글box가 그려지는 부분의 하한, 상한은 $Q_1, Q_3$ 이다. 그 좌우로 선이 나타내는 상한은 수염(Whisker)라 불리며, 사분위수간 범위의 1.5배 범위까지 포함하는 점을 나타낸다. 이 후의 점은 그 범위를 넘어가는 점중 이상치가 아닌 점 중의 마지노선을 나타낸다.Referenceboxplot에 대한 글",
        
        "url": "/ds/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-04-%EC%83%81%EB%8C%80%EC%9C%84%EC%B9%98%EC%99%80-%EB%B0%95%EC%8A%A4%ED%94%8C%EB%A1%AF.html"
      }
      ,
    
      "ds-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-03-eb-b3-80-eb-8f-99-ec-84-b1-ec-9d-98-ec-b2-99-eb-8f-84-html": {
        "title": "03: 변동성의 척도",
        "tags": "DS, Statistics, variation",
        "date": "May 15, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "데이터를 설명하는 또 다른 척도인 변동성에 대해 알아본다.변동성  데이터의 분포를 나타냄에 있어 퍼진 정도를 측정한다.범위  range = 최대 관측치 - 최소 관측치해당 데이터의 값이 어디서 부터 어디까지인지 나타낸다.분산, 표준 편차얼마나 퍼져있는지에 대한 척도이다. 통계적으로 매우 중요한 역할을 수행한다.경험 법칙(Empirical Rule)가정 : 데이터의 히스토그램(분포)가 종모양이다.  모든 관측치의 68%는 $\\pm \\sigma$ 에 속한다.  모든 관측치의 95%는 $\\pm 2\\sigma$ 에 속한다.  모든 관측치의 99.7%는 $\\pm 3\\sigma$ 에 속한다.체비셰프의 정리위의 경험 법칙을 보다 일반화한 정리이다.  평균으로 부터 $k\\sigma$ ($k &gt; 1$) 이내에 속하는 관측치들의 비율은 적어도 다음과 같다.변동 계수(Coefficient of Variation)  표준 편차를 평균으로 나눈 척도무차원수에 대응되는 값이다. 차원을 갖게 해주어, 어떠한 의미를 갖게하기 위함이다.",
        
        "url": "/ds/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-03-%EB%B3%80%EB%8F%99%EC%84%B1%EC%9D%98-%EC%B2%99%EB%8F%84.html"
      }
      ,
    
      "ds-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-02-ec-a4-91-ec-8b-ac-ec-9d-84-eb-82-98-ed-83-80-eb-82-b4-eb-8a-94-eb-b0-a9-eb-b2-95-html": {
        "title": "02: 중심을 나타내는 방법",
        "tags": "DS, Statistics, mean, median, mode",
        "date": "May 15, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "데이터의 중심을 나타내는 척도에 대해서 배워본다.평균 (mean)  평균은 대표적으로 집단의 중심위치를 나타내는 척도로 사용된다.이 평균에는 보통 3종류가 사용된다. 각각에는 어떤 기하적의미가 있으며, 데이터를 보고 어떠한 형태인지를 인지하고 그에 맞는 척도로 판단하는 것이 중요하다.산술 평균산술 평균은 보통 평균이라고 불리는 가장 대표적인 방법이다. 하지만 이 수식을 보면, 각각의 $x_i$에 대해 같은 가중치로 내분점을 구하는 식과 같다. 그렇다면 각각의 $x_i$에 대해 같은 가중치이기 때문에 $x_i$가 가지는 값에 민감하게 값이 변하게 된다.즉, 만약 $x_i$의 원소중 값이 튀는 아웃라이어가 포함되어 있는 경우, 평균은 집단의 중심을 대변하기 어렵게 된다. 평균은 아웃라이어에 민감하다. 이점을 꼭 기억하자. 다른 말로 하면, 큰 값에 가중치를 준다. 라고 생각해도 좋다.기하 평균앞에서 얘기한 산술 평균은 각각의 $x_i$ 값이 개수, 값과 같은 column일 때 사용가능하다. 그 이유는, 값이나 개수는 더했을 때 어떠한 의미를 가지기 때문이다. 하지만, 만약 $x_i$ 가 상승률, 감소율과 같은 확률 값이면 어떻게 할까? 만약 첫째날 100%의 증가율, 둘째날 -50%의 증가율을 보였다면, $x(1+1)(1-0.5) = x$ 로 둘째날 까지의 증가율은 0이다. 당연히 평균도 0이다. 하지만 산술 평균으로 계산한다면 이 값은 0.25로 증가한다는 결론이 난다.이런 경우 우리는 첫째날, 둘째날의 확률을 곱하여 판단하는 것이 옳다는 것을 알고 있다. 이렇게 곱하는 연산이 어떤 중요한 의미를 가지는 경우 우리는 기하 평균으로 해당 분포의 중심을 잡는 것이 옳다.조화 평균역수의 산술평균의 역수. 수식적으로 의미를 뜯어보면, 역수를 취한다는 것은 결국 작은 수를 크게, 큰 수를 작게 만들겠다는 의미로 볼 수 있다. 그 다음에 산술평균을 취한다는 것은, 결국 작은 수에 가중치를 준 상태로 값을 구하겠다는 의미이고, 원래 차원을 맞춰주기 위해 다시 역수를 취한다.즉, 작은 수에 가중치를 준 평균으로 볼 수 있다.세 평균 정리두개의 수를 막대기로 생각했을 때, 산술 평균은 두 막대기의 크기의 내분점을 구하는 것과 동일하다. 그렇기 때문에 큰 막대기가 엄청 커지면 그게 맞춰 값도 커지게 된다.조화 평균은 작은 수에 가중치를 주어 구하기 때문에, 항상 작은 수보다 작은 지점에서 평균이 구해지게 된다.기하 평균은, 두 막대기를 각각 한 변으로 잡았을 때 면적을 만족하는 정사각형의 한 변의 길이와 동일한 길이가 책정된다. 이 값은 산술, 기하, 조화 평균의 관계에 의해 산술 평균보다는 작고, 조화 평균보다는 큰 값을 가진다.중앙값  순서 통계량으로, 순서대로 세었을 때 중앙에 있는 값을 의미한다.중앙값의 핵심은 아웃라이어에 민감하지 않다는 것이다. 따라서 사용하기 편리하다. 하지만, 계산 상 거리를 기반으로 한다는 점에서 (절댓값) 추가적인 무언가를 도출할 때 수학적으로 어려운 점이 있다. 따라서 아웃라이어를 제거한 평균을 사용하는 것이 좀더 옳지 않을까 생각한다.최빈값  가장 많이 나온 숫자정의에서 알 수 있듯, 이 값은 범주형에서 의미가 있다.분포에 따른 평균, 중앙값, 최빈값의 위치분포가 대칭일 경우에는 세값이 동일하다.하지만 비대칭일 경우, 중앙값은 평균보다 오른쪽에 있을 수 밖에 없다. 숫자를 세는 행위이기 때문이다.",
        
        "url": "/ds/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-02-%EC%A4%91%EC%8B%AC%EC%9D%84-%EB%82%98%ED%83%80%EB%82%B4%EB%8A%94-%EB%B0%A9%EB%B2%95.html"
      }
      ,
    
      "ds-statistics-2020-05-15-ed-86-b5-ea-b3-84-ea-b0-9c-eb-85-90-ec-a0-95-eb-a6-ac-01-ec-84-9c-eb-a1-a0-html": {
        "title": "01: 주요 개념",
        "tags": "DS, Statistics",
        "date": "May 15, 2020",
        "author": "",
        "category": "DS/Statistics",
        "content": "통계 개념 정리에 앞서 통계학이라는 학문에 대해 알아본다.통계는 왜 공부하는가  미래를 알기 위해서, 집단의 특징을 알기 위해서우리는 군중의 특징에 대해 알 필요가 있다. 예를 들어 물건을 판다고 생각해보자. 이 물건이 많이 팔릴지 아닐지는 해당 소비자의 특징을 분석할 필요가 있다.주요 통계학 개념  모수          모집단 (population)의 특성을 나타내는 척도, 특징        통계량          표본(sample)의 특성을 나타내는 척도, 특징      결과적으로 우리는 표본의 통계량을 기반으로 모수를 추정한다.데이터의 형태  interval data (numerical data)          수치형 데이터. 요금, 발생률 같이 실수 범위의 숫자가 나올 수 있는 것을 말한다.      이런 실수형 데이터는 내가 구간을 나누어 범주형 데이터로 처리를 할 수 있다.        nominal data (categorical data)          범주형 데이터이다. 범주형 데이터에는 서열이 존재하는 데이터, 그렇지 않은 데이터로 나눌 수 있다.      예를 들면, 순위와 같은 서열 데이터와 성별과 같은 데이터가 존재한다.      보통 계산을 위해 숫자로 대체한다.      범주형 데이터는 해당 범주에 대한 빈도수를 세는 도수분포표가 많이 사용된다.      또는 파이차트도 많이 사용된다.      히스토그램  수치형 데이터에서 계급에 대한 빈도수를 나타낼 때 사용한다.왜도(skerness)  히스토그램의 비대칭성의 정도를 나타내는 척도꼬리가 긴 쪽에 치우쳐서 파악하면 된다. 꼬리가 오른쪽이라면 양의 비대칭, 반대는 음의 비대칭이다.",
        
        "url": "/ds/statistics/2020/05/15/%ED%86%B5%EA%B3%84%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-01-%EC%84%9C%EB%A1%A0.html"
      }
      ,
    
      "ds-visualization-2020-05-14-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-07-count-plot-html": {
        "title": "07: Counts plot",
        "tags": "DS, python, matplotlib, Counts plot",
        "date": "May 14, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "카테고리 변수에 대한 y 갯수를 그려주는 Counts plot에 대해 알아보자.연습 kaggle notebook  카테고리 변수의 갯수 분포를 한눈에!이전의 stripplot이 category 변수를 x, 조사하고 싶은 연속 변수를 y라 했을 때 분포를 본다면, 이번에는 x 변수에 대한 y의 개수를 파악한다. 이 문장에 내포되어 있는 뜻은, x, y가 모두 카테고리 변수라는 얘기로 볼 수 있다. 단, 이산적인 숫자이다. 이것을 코딩하기 위해서 필요한 것은, group과 그 그룹에 속하는 개수를 알아야 한다.# Useful for:# Draw a scatterplot where one variable is categorical.# In this plot we calculate the size of overlapping points in each category and for each y.# This way, the bigger the bubble the more concentration we have in that region.# More info:# https://seaborn.pydata.org/generated/seaborn.stripplot.html# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# we need to make a groupby by variables of interest# cty, hwy에 따른 group을 묶고, 그 카테고리에 해당하는 개수를 갖고 있는다.# 그리고 그 개수의 column 이름을 counts라 한다.gb_df = df.groupby([\"cty\", \"hwy\"]).size().reset_index(name = \"counts\")# sort the valuesgb_df.sort_values([\"cty\", \"hwy\", \"counts\"], ascending = True, inplace = True)# create a color for each group.# there are several way os doing, you can also use this line:# colors = [plt.cm.gist_earth(i/float(len(gb_df[\"cty\"].unique()))) for i in range(len(gb_df[\"cty\"].unique()))]# colors 딕셔너리를 만든다. 각 cty 숫자에 대응하는 3개의 값(list)을 가지고 있는다.# 이 값은 RGB 값에 대응된다.colors = {i:np.random.random(3,) for i in sorted(list(gb_df[\"cty\"].unique()))}# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (10, 5))ax = fig.add_subplot()# ----------------------------------------------------------------------------------------------------# iterate over each category and plot the data. This way, every group has it's own color and size.for x in sorted(list(gb_df[\"cty\"].unique())):    # get x and y values for each group    x_values = gb_df[gb_df[\"cty\"] == x][\"cty\"]    y_values = gb_df[gb_df[\"cty\"] == x][\"hwy\"]    # extract the size of each group to plot    size = gb_df[gb_df[\"cty\"] == x][\"counts\"]    # extract the color for each group and covert it from rgb to hex    # 0~1의 실수 범위 색상을 16진수 색상으로 바꿔준다.    color = matplotlib.colors.rgb2hex(colors[x])    # plot the data    ax.scatter(x_values, y_values, s = size*10, c = color)# ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Count plot\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/14/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-07-Count-plot.html"
      }
      ,
    
      "ds-visualization-2020-05-14-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-06-stripplot-html": {
        "title": "06: Strip plot",
        "tags": "DS, python, matplotlib, Strip plot",
        "date": "May 14, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "카테고리 변수에 대한 y 분포를 그려주는 Strip plot에 대해 알아보자.연습 kaggle notebook  카테고리 변수와의 y 분포를 한눈에!이전의 산점도는 연속, 연속 변수에 대한 그래프로 볼 수 있다. 이번에는 x가 카테고리 변수일 때, 각각의 값에 대한 분포가 어떻게 되는지를 알아보자. 이 때 jitter란, 각각의 카테고리에 대해 산점도를 그린 후 겹치는 점에 대해 파악하기 어려운 점을 해결해주는 도구이다.위 그림은 겹치는 점에 대해 어떤 분포를 갖고 있는 지 알기 어렵다. 그렇기 때문에, 그리는데 있어서 x방향으로 랜덤 수를 주어 겹치지 않게 하는 기능이다.# Useful for:# Draw a scatterplot where one variable is categorical.# This is useful to see the distribution of the points of each category.# More info:# https://seaborn.pydata.org/generated/seaborn.stripplot.html# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# separate x and y variablesx = df[\"cty\"]y = df[\"hwy\"]# ----------------------------------------------------------------------------------------------------# instanciate the figureplt.figure(figsize = (10, 7))# ----------------------------------------------------------------------------------------------------# plot the data using seabornax = sns.stripplot(x, y)# ----------------------------------------------------------------------------------------------------# prettify the plot# set titleax.set_title(\"Jitter plot\");ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/14/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-06-Stripplot.html"
      }
      ,
    
      "ds-visualization-2020-05-14-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-05-ec-84-a0-ed-98-95-ed-9a-8c-ea-b7-80-ec-84-a0-ec-9d-84-ed-8f-ac-ed-95-a8-ed-95-9c-ec-82-b0-ec-a0-90-eb-8f-84-html": {
        "title": "05: 선형 회귀 선을 포함한 산점도",
        "tags": "DS, python, matplotlib, scatter plot",
        "date": "May 14, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "선형 회귀 선을 포함한 산점도 그래프를 그려보자.연습 kaggle notebook  산점도에서 추가적으로 간단한 회귀 선을 그려, x, y간의 상관관계를 볼 수 있다.# Useful for:# This is a normal scatter plot but we also plot a simple regression line to see the correlation between the x and the y variables.# More info:# https://visual.ly/m/scatter-plots-regression-lines/# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# filter only 2 clases to separate it more easily on the plot# cyl이 4, 8인 두 그룹에 대해 회귀를 진행한다.df = df[df[\"cyl\"].isin([4,8])]# ----------------------------------------------------------------------------------------------------# plot the data using seaborn# hue가 구분을 결정해주는 변수# x = \"displ\", y = \"hwy\"sns.lmplot(\"displ\", \"hwy\", df, hue = \"cyl\")# ----------------------------------------------------------------------------------------------------# prettify the plot# since we are using seaborn and this library uses matplotlib behind the scenes# you can call plt.gca (get current axes) and use all the familiar matplotlib commands# 저 위까지만 해도 그릴 수 있다. 하지만 내가 plot의 꾸미는 부분을 바꾸고 싶다면,# matplotlib의 axis 단계에 접근하여 수정할 수 있다.ax = plt.gca()# change the upper limit of the plot to make it more pleasantax.set_xlim(0, 10)ax.set_ylim(0, 50)# set titleax.set_title(\"Scatter plot with regression\");분리하여 그리기# Useful for:# This is a normal scatter plot but we also plot a simple regression line to see the correlation between the x and the y variables.# This plot is similar to the previous one but plots each data on separate axes# More info:# https://visual.ly/m/scatter-plots-regression-lines/# sns의 테마 정하기sns.set(color_codes=True)# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/mpg_ggplot2.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# prepare the data for plotting# filter only 2 clases to separate it more easily on the plotdf = df[df[\"cyl\"].isin([4,8])]# ----------------------------------------------------------------------------------------------------# plot the data using seabornaxes = sns.lmplot(\"displ\",                  \"hwy\",                  df,                  hue = \"cyl\",                  col = \"cyl\" # by specifying the col, seaborn creates several axes for each group                  # col을 명확하게 적으면 분리하여 그래프를 그려준다.                 )# ----------------------------------------------------------------------------------------------------# prettify the plot# change the upper limit of the plot to make it more pleasantaxes.set( xlim = (0.5, 7.5), ylim = (0, 50))# set title for all axes using pltplt.suptitle(\"Scatter plot with regression lines on different axes\", fontsize = 10);ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/14/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-05-%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80%EC%84%A0%EC%9D%84-%ED%8F%AC%ED%95%A8%ED%95%9C-%EC%82%B0%EC%A0%90%EB%8F%84.html"
      }
      ,
    
      "dv-python-2020-05-13-python-pipenv-ea-b0-80-ec-84-b1-ed-99-98-ea-b2-bd-ec-83-9d-ec-84-b1-ec-8b-a4-ed-8c-a8-html": {
        "title": "가상 환경 생성 실패",
        "tags": "pipenv, python, trouble-shooting",
        "date": "May 13, 2020",
        "author": "",
        "category": "DV/Python",
        "content": "pipenv를 사용하다가 가상환경이 생성되지 않는 경우 해결책을 정리한다.갑자기 가상환경 생성이 되지 않았다. 오류를 보니, python3 의 경로를 다른 것을 사용한다는 것을 알아냈다. 내가 원하는 python 버전으로 생성을 위해서는 해당 python의 설치 경로를 명시적으로 적어서 생성할 수 있다.pipenv install --python /usr/local/bin/python3Referencegithub issue",
        
        "url": "/dv/python/2020/05/13/python-pipenv-%EA%B0%80%EC%84%B1%ED%99%98%EA%B2%BD-%EC%83%9D%EC%84%B1-%EC%8B%A4%ED%8C%A8.html"
      }
      ,
    
      "cs-algorithm-2020-05-13-eb-b0-b1-ec-a4-80-ec-88-98-ec-a0-95-eb-a0-ac-ed-95-98-ea-b8-b0-2-html": {
        "title": "백준(2751번): 수 정렬하기 2",
        "tags": "백준, 알고리즘, 정렬",
        "date": "May 13, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버5 : 정렬 문제이다.생각정렬 문제이다. merge sort(합병 정렬)을 구현해보고자 시도했다.알고리즘기본적인 병합 정렬의 알고리즘은 다음과 같다.위키 백과 - 합병 정렬좀 더 자세한 설명partition나누는 방법은 간단하다. 시작과 끝점을 주고, 반을 자르면서 들어가는 것이다. 가장 작은 단위는 1개의 원소를 가질 때이다. 이 위치에 다다랐을 때 합치는 연산을 수행하면서 거꾸로 올라가면 된다.merge합칠 때는, 두 개의 바구니에 담긴 원소들을 비교하면서 새로운 바구니에 차곡차곡 담아두어야 한다. 이 때, 한 바구니의 최댓값이 다른 바구니의 중간 원소보다 작을 경우에 나머지 원소들을 한꺼번에 밀어 넣어주어야 한다는 것을 잊지 말자. 또한 최종 바구니에 다 넣었다면, 다른 바구니들을 비교하는데 있어 정렬된 바구니가 필요하므로 원래 배열에 밀어넣어준다.Code#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;int N;int *a, *temp;void merge(int start, int end) {    int mid = (start+end)/2;    int i = start, j = mid+1, k = start;    while (i &lt;= mid &amp;&amp; j &lt;= end) {        if (a[i] &lt;= a[j]) temp[k++] = a[i++];        else temp[k++] = a[j++];    }    int restLoc = i &gt; mid ? j : i; // 병합중 한쪽 바구니가 끝난 경우 나머지의 위치를 결정해줌    while (k &lt;= end) temp[k++] = a[restLoc++]; // (end-start)개수만큼을 채워야 하니, 나머지들을 넣어줌    for (int i = start; i &lt;= end; i++)  a[i] = temp[i]; // temp배열에 넣은 녀석들을 원래 것으로 업데이트 해줌}void partition(int start, int end){    if (end &lt;= start) return;    int mid = (start+end)/2;    partition(start, mid);    partition(mid+1, end);    merge(start, end);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    a = new int[N+1];    temp = new int[N];    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    partition(0, N-1);    for (int i = 0; i &lt; N; i++) cout &lt;&lt; a[i] &lt;&lt; '\\n';}Reference백준(2751번) - 수 정렬하기 2",
        
        "url": "/cs/algorithm/2020/05/13/%EB%B0%B1%EC%A4%80-%EC%88%98-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0-2.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-10-ensemble-html": {
        "title": "10: Ensemble",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 모델들을 앙상블하는 방법을 알아본다.앙상블  여러개의 모델을 만들고, 이것들의 결과들을 투표하는 방식으로 합치자.모델의 정확도간의 상관계수#compare algorithm predictions with each other, where 1 = exactly similar and 0 = exactly opposite#there are some 1's, but enough blues and light reds to create a \"super algorithm\" by combining themcorrelation_heatmap(MLA_predict)Hard Vote (다수결) &amp; Soft Vote (가중치)#why choose one model, when you can pick them all with voting classifier#http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.VotingClassifier.html#removed models w/o attribute 'predict_proba' required for vote classifier and models with a 1.0 correlation to another modelvote_est = [    #Ensemble Methods: http://scikit-learn.org/stable/modules/ensemble.html    ('ada', ensemble.AdaBoostClassifier()),    ('bc', ensemble.BaggingClassifier()),    ('etc',ensemble.ExtraTreesClassifier()),    ('gbc', ensemble.GradientBoostingClassifier()),    ('rfc', ensemble.RandomForestClassifier()),    #Gaussian Processes: http://scikit-learn.org/stable/modules/gaussian_process.html#gaussian-process-classification-gpc    ('gpc', gaussian_process.GaussianProcessClassifier()),    #GLM: http://scikit-learn.org/stable/modules/linear_model.html#logistic-regression    ('lr', linear_model.LogisticRegressionCV()),    #Navies Bayes: http://scikit-learn.org/stable/modules/naive_bayes.html    ('bnb', naive_bayes.BernoulliNB()),    ('gnb', naive_bayes.GaussianNB()),    #Nearest Neighbor: http://scikit-learn.org/stable/modules/neighbors.html    ('knn', neighbors.KNeighborsClassifier()),    #SVM: http://scikit-learn.org/stable/modules/svm.html    ('svc', svm.SVC(probability=True)),    #xgboost: http://xgboost.readthedocs.io/en/latest/model.html   ('xgb', XGBClassifier())]#Hard Vote or majority rules, 이 부분 코드가 약간 이해가 안되지만 일단 넘어간다.vote_hard = ensemble.VotingClassifier(estimators = vote_est , voting = 'hard')vote_hard_cv = model_selection.cross_validate(vote_hard, data1[data1_x_bin], data1[Target], cv  = cv_split)vote_hard.fit(data1[data1_x_bin], data1[Target])print(\"Hard Voting Training w/bin score mean: {:.2f}\". format(vote_hard_cv['train_score'].mean()*100))print(\"Hard Voting Test w/bin score mean: {:.2f}\". format(vote_hard_cv['test_score'].mean()*100))print(\"Hard Voting Test w/bin score 3*std: +/- {:.2f}\". format(vote_hard_cv['test_score'].std()*100*3))print('-'*10)#Soft Vote or weighted probabilitiesvote_soft = ensemble.VotingClassifier(estimators = vote_est , voting = 'soft')vote_soft_cv = model_selection.cross_validate(vote_soft, data1[data1_x_bin], data1[Target], cv  = cv_split)vote_soft.fit(data1[data1_x_bin], data1[Target])print(\"Soft Voting Training w/bin score mean: {:.2f}\". format(vote_soft_cv['train_score'].mean()*100))print(\"Soft Voting Test w/bin score mean: {:.2f}\". format(vote_soft_cv['test_score'].mean()*100))print(\"Soft Voting Test w/bin score 3*std: +/- {:.2f}\". format(vote_soft_cv['test_score'].std()*100*3))print('-'*10)Hard Voting Training w/bin score mean: 86.61Hard Voting Test w/bin score mean: 82.35Hard Voting Test w/bin score 3*std: +/- 4.91----------Soft Voting Training w/bin score mean: 87.21Soft Voting Test w/bin score mean: 82.43Soft Voting Test w/bin score 3*std: +/- 5.14----------Grid Search#WARNING: Running is very computational intensive and time expensive.#Code is written for experimental/developmental purposes and not production ready!#Hyperparameter Tune with GridSearchCV: http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.htmlgrid_n_estimator = [10, 50, 100, 300]grid_ratio = [.1, .25, .5, .75, 1.0]grid_learn = [.01, .03, .05, .1, .25]grid_max_depth = [2, 4, 6, 8, 10, None]grid_min_samples = [5, 10, .03, .05, .10]grid_criterion = ['gini', 'entropy']ㅁgrid_bool = [True, False]grid_seed = [0]grid_param = [            [{            #AdaBoostClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html            'n_estimators': grid_n_estimator, #default=50            'learning_rate': grid_learn, #default=1            #'algorithm': ['SAMME', 'SAMME.R'], #default=’SAMME.R            'random_state': grid_seed            }],            [{            #BaggingClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.BaggingClassifier.html#sklearn.ensemble.BaggingClassifier            'n_estimators': grid_n_estimator, #default=10            'max_samples': grid_ratio, #default=1.0            'random_state': grid_seed             }],            [{            #ExtraTreesClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.ExtraTreesClassifier.html#sklearn.ensemble.ExtraTreesClassifier            'n_estimators': grid_n_estimator, #default=10            'criterion': grid_criterion, #default=”gini”            'max_depth': grid_max_depth, #default=None            'random_state': grid_seed             }],            [{            #GradientBoostingClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier            #'loss': ['deviance', 'exponential'], #default=’deviance’            'learning_rate': [.05], #default=0.1 -- 12/31/17 set to reduce runtime -- The best parameter for GradientBoostingClassifier is {'learning_rate': 0.05, 'max_depth': 2, 'n_estimators': 300, 'random_state': 0} with a runtime of 264.45 seconds.            'n_estimators': [300], #default=100 -- 12/31/17 set to reduce runtime -- The best parameter for GradientBoostingClassifier is {'learning_rate': 0.05, 'max_depth': 2, 'n_estimators': 300, 'random_state': 0} with a runtime of 264.45 seconds.            #'criterion': ['friedman_mse', 'mse', 'mae'], #default=”friedman_mse”            'max_depth': grid_max_depth, #default=3            'random_state': grid_seed             }],            [{            #RandomForestClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier            'n_estimators': grid_n_estimator, #default=10            'criterion': grid_criterion, #default=”gini”            'max_depth': grid_max_depth, #default=None            'oob_score': [True], #default=False -- 12/31/17 set to reduce runtime -- The best parameter for RandomForestClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'oob_score': True, 'random_state': 0} with a runtime of 146.35 seconds.            'random_state': grid_seed             }],            [{            #GaussianProcessClassifier            'max_iter_predict': grid_n_estimator, #default: 100            'random_state': grid_seed            }],            [{            #LogisticRegressionCV - http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegressionCV.html#sklearn.linear_model.LogisticRegressionCV            'fit_intercept': grid_bool, #default: True            #'penalty': ['l1','l2'],            'solver': ['newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'], #default: lbfgs            'random_state': grid_seed             }],            [{            #BernoulliNB - http://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.BernoulliNB.html#sklearn.naive_bayes.BernoulliNB            'alpha': grid_ratio, #default: 1.0             }],            #GaussianNB -            [{}],            [{            #KNeighborsClassifier - http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier            'n_neighbors': [1,2,3,4,5,6,7], #default: 5            'weights': ['uniform', 'distance'], #default = ‘uniform’            'algorithm': ['auto', 'ball_tree', 'kd_tree', 'brute']            }],            [{            #SVC - http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html#sklearn.svm.SVC            #http://blog.hackerearth.com/simple-tutorial-svm-parameter-tuning-python-r            #'kernel': ['linear', 'poly', 'rbf', 'sigmoid'],            'C': [1,2,3,4,5], #default=1.0            'gamma': grid_ratio, #edfault: auto            'decision_function_shape': ['ovo', 'ovr'], #default:ovr            'probability': [True],            'random_state': grid_seed             }],            [{            #XGBClassifier - http://xgboost.readthedocs.io/en/latest/parameter.html            'learning_rate': grid_learn, #default: .3            'max_depth': [1,2,4,6,8,10], #default 2            'n_estimators': grid_n_estimator,            'seed': grid_seed             }]        ]start_total = time.perf_counter() #https://docs.python.org/3/library/time.html#time.perf_counterfor clf, param in zip (vote_est, grid_param): #https://docs.python.org/3/library/functions.html#zip    #print(clf[1]) #vote_est is a list of tuples, index 0 is the name and index 1 is the algorithm    #print(param)    start = time.perf_counter()    best_search = model_selection.GridSearchCV(estimator = clf[1], param_grid = param, cv = cv_split, scoring = 'roc_auc')    best_search.fit(data1[data1_x_bin], data1[Target])    run = time.perf_counter() - start    best_param = best_search.best_params_    print('The best parameter for {} is {} with a runtime of {:.2f} seconds.'.format(clf[1].__class__.__name__, best_param, run))    clf[1].set_params(**best_param)run_total = time.perf_counter() - start_totalprint('Total optimization time was {:.2f} minutes.'.format(run_total/60))print('-'*10)The best parameter for AdaBoostClassifier is {'learning_rate': 0.1, 'n_estimators': 300, 'random_state': 0} with a runtime of 37.28 seconds.The best parameter for BaggingClassifier is {'max_samples': 0.25, 'n_estimators': 300, 'random_state': 0} with a runtime of 33.04 seconds.The best parameter for ExtraTreesClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'random_state': 0} with a runtime of 68.93 seconds.The best parameter for GradientBoostingClassifier is {'learning_rate': 0.05, 'max_depth': 2, 'n_estimators': 300, 'random_state': 0} with a runtime of 38.77 seconds.The best parameter for RandomForestClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'oob_score': True, 'random_state': 0} with a runtime of 84.14 seconds.The best parameter for GaussianProcessClassifier is {'max_iter_predict': 10, 'random_state': 0} with a runtime of 6.19 seconds.The best parameter for LogisticRegressionCV is {'fit_intercept': True, 'random_state': 0, 'solver': 'liblinear'} with a runtime of 9.40 seconds.The best parameter for BernoulliNB is {'alpha': 0.1} with a runtime of 0.24 seconds.The best parameter for GaussianNB is {} with a runtime of 0.05 seconds.The best parameter for KNeighborsClassifier is {'algorithm': 'brute', 'n_neighbors': 7, 'weights': 'uniform'} with a runtime of 5.56 seconds.The best parameter for SVC is {'C': 2, 'decision_function_shape': 'ovo', 'gamma': 0.1, 'probability': True, 'random_state': 0} with a runtime of 30.49 seconds.The best parameter for XGBClassifier is {'learning_rate': 0.01, 'max_depth': 4, 'n_estimators': 300, 'seed': 0} with a runtime of 43.57 seconds.Total optimization time was 5.96 minutes.----------vote로 들어간 추정기 각각에 대해 최적 param을 찾는다.앙상블최적의 추정기들에 대해 마지막으로 Voting을 수행한다.#Hard Vote or majority rules w/Tuned Hyperparametersgrid_hard = ensemble.VotingClassifier(estimators = vote_est , voting = 'hard')grid_hard_cv = model_selection.cross_validate(grid_hard, data1[data1_x_bin], data1[Target], cv  = cv_split)grid_hard.fit(data1[data1_x_bin], data1[Target])print(\"Hard Voting w/Tuned Hyperparameters Training w/bin score mean: {:.2f}\". format(grid_hard_cv['train_score'].mean()*100))print(\"Hard Voting w/Tuned Hyperparameters Test w/bin score mean: {:.2f}\". format(grid_hard_cv['test_score'].mean()*100))print(\"Hard Voting w/Tuned Hyperparameters Test w/bin score 3*std: +/- {:.2f}\". format(grid_hard_cv['test_score'].std()*100*3))print('-'*10)#Soft Vote or weighted probabilities w/Tuned Hyperparametersgrid_soft = ensemble.VotingClassifier(estimators = vote_est , voting = 'soft')grid_soft_cv = model_selection.cross_validate(grid_soft, data1[data1_x_bin], data1[Target], cv  = cv_split)grid_soft.fit(data1[data1_x_bin], data1[Target])print(\"Soft Voting w/Tuned Hyperparameters Training w/bin score mean: {:.2f}\". format(grid_soft_cv['train_score'].mean()*100))print(\"Soft Voting w/Tuned Hyperparameters Test w/bin score mean: {:.2f}\". format(grid_soft_cv['test_score'].mean()*100))print(\"Soft Voting w/Tuned Hyperparameters Test w/bin score 3*std: +/- {:.2f}\". format(grid_soft_cv['test_score'].std()*100*3))print('-'*10)#12/31/17 tuned with data1_x_bin#The best parameter for AdaBoostClassifier is {'learning_rate': 0.1, 'n_estimators': 300, 'random_state': 0} with a runtime of 33.39 seconds.#The best parameter for BaggingClassifier is {'max_samples': 0.25, 'n_estimators': 300, 'random_state': 0} with a runtime of 30.28 seconds.#The best parameter for ExtraTreesClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'random_state': 0} with a runtime of 64.76 seconds.#The best parameter for GradientBoostingClassifier is {'learning_rate': 0.05, 'max_depth': 2, 'n_estimators': 300, 'random_state': 0} with a runtime of 34.35 seconds.#The best parameter for RandomForestClassifier is {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'oob_score': True, 'random_state': 0} with a runtime of 76.32 seconds.#The best parameter for GaussianProcessClassifier is {'max_iter_predict': 10, 'random_state': 0} with a runtime of 6.01 seconds.#The best parameter for LogisticRegressionCV is {'fit_intercept': True, 'random_state': 0, 'solver': 'liblinear'} with a runtime of 8.04 seconds.#The best parameter for BernoulliNB is {'alpha': 0.1} with a runtime of 0.19 seconds.#The best parameter for GaussianNB is {} with a runtime of 0.04 seconds.#The best parameter for KNeighborsClassifier is {'algorithm': 'brute', 'n_neighbors': 7, 'weights': 'uniform'} with a runtime of 4.84 seconds.#The best parameter for SVC is {'C': 2, 'decision_function_shape': 'ovo', 'gamma': 0.1, 'probability': True, 'random_state': 0} with a runtime of 29.39 seconds.#The best parameter for XGBClassifier is {'learning_rate': 0.01, 'max_depth': 4, 'n_estimators': 300, 'seed': 0} with a runtime of 46.23 seconds.#Total optimization time was 5.56 minutes.Hard Voting w/Tuned Hyperparameters Training w/bin score mean: 85.22Hard Voting w/Tuned Hyperparameters Test w/bin score mean: 82.31Hard Voting w/Tuned Hyperparameters Test w/bin score 3*std: +/- 5.26----------Soft Voting w/Tuned Hyperparameters Training w/bin score mean: 84.76Soft Voting w/Tuned Hyperparameters Test w/bin score mean: 82.28Soft Voting w/Tuned Hyperparameters Test w/bin score 3*std: +/- 5.42----------실제 validation에 적용 (for submit)#prepare data for modelingprint(data_val.info())print(\"-\"*10)#data_val.sample(10)#handmade decision tree - submission score = 0.77990data_val['Survived'] = mytree(data_val).astype(int)#decision tree w/full dataset modeling submission score: defaults= 0.76555, tuned= 0.77990#submit_dt = tree.DecisionTreeClassifier()#submit_dt = model_selection.GridSearchCV(tree.DecisionTreeClassifier(), param_grid=param_grid, scoring = 'roc_auc', cv = cv_split)#submit_dt.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_dt.best_params_) #Best Parameters:  {'criterion': 'gini', 'max_depth': 4, 'random_state': 0}#data_val['Survived'] = submit_dt.predict(data_val[data1_x_bin])#bagging w/full dataset modeling submission score: defaults= 0.75119, tuned= 0.77990#submit_bc = ensemble.BaggingClassifier()#submit_bc = model_selection.GridSearchCV(ensemble.BaggingClassifier(), param_grid= {'n_estimators':grid_n_estimator, 'max_samples': grid_ratio, 'oob_score': grid_bool, 'random_state': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_bc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_bc.best_params_) #Best Parameters:  {'max_samples': 0.25, 'n_estimators': 500, 'oob_score': True, 'random_state': 0}#data_val['Survived'] = submit_bc.predict(data_val[data1_x_bin])#extra tree w/full dataset modeling submission score: defaults= 0.76555, tuned= 0.77990#submit_etc = ensemble.ExtraTreesClassifier()#submit_etc = model_selection.GridSearchCV(ensemble.ExtraTreesClassifier(), param_grid={'n_estimators': grid_n_estimator, 'criterion': grid_criterion, 'max_depth': grid_max_depth, 'random_state': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_etc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_etc.best_params_) #Best Parameters:  {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'random_state': 0}#data_val['Survived'] = submit_etc.predict(data_val[data1_x_bin])#random foreset w/full dataset modeling submission score: defaults= 0.71291, tuned= 0.73205#submit_rfc = ensemble.RandomForestClassifier()#submit_rfc = model_selection.GridSearchCV(ensemble.RandomForestClassifier(), param_grid={'n_estimators': grid_n_estimator, 'criterion': grid_criterion, 'max_depth': grid_max_depth, 'random_state': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_rfc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_rfc.best_params_) #Best Parameters:  {'criterion': 'entropy', 'max_depth': 6, 'n_estimators': 100, 'random_state': 0}#data_val['Survived'] = submit_rfc.predict(data_val[data1_x_bin])#ada boosting w/full dataset modeling submission score: defaults= 0.74162, tuned= 0.75119#submit_abc = ensemble.AdaBoostClassifier()#submit_abc = model_selection.GridSearchCV(ensemble.AdaBoostClassifier(), param_grid={'n_estimators': grid_n_estimator, 'learning_rate': grid_ratio, 'algorithm': ['SAMME', 'SAMME.R'], 'random_state': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_abc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_abc.best_params_) #Best Parameters:  {'algorithm': 'SAMME.R', 'learning_rate': 0.1, 'n_estimators': 300, 'random_state': 0}#data_val['Survived'] = submit_abc.predict(data_val[data1_x_bin])#gradient boosting w/full dataset modeling submission score: defaults= 0.75119, tuned= 0.77033#submit_gbc = ensemble.GradientBoostingClassifier()#submit_gbc = model_selection.GridSearchCV(ensemble.GradientBoostingClassifier(), param_grid={'learning_rate': grid_ratio, 'n_estimators': grid_n_estimator, 'max_depth': grid_max_depth, 'random_state':grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_gbc.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_gbc.best_params_) #Best Parameters:  {'learning_rate': 0.25, 'max_depth': 2, 'n_estimators': 50, 'random_state': 0}#data_val['Survived'] = submit_gbc.predict(data_val[data1_x_bin])#extreme boosting w/full dataset modeling submission score: defaults= 0.73684, tuned= 0.77990#submit_xgb = XGBClassifier()#submit_xgb = model_selection.GridSearchCV(XGBClassifier(), param_grid= {'learning_rate': grid_learn, 'max_depth': [0,2,4,6,8,10], 'n_estimators': grid_n_estimator, 'seed': grid_seed}, scoring = 'roc_auc', cv = cv_split)#submit_xgb.fit(data1[data1_x_bin], data1[Target])#print('Best Parameters: ', submit_xgb.best_params_) #Best Parameters:  {'learning_rate': 0.01, 'max_depth': 4, 'n_estimators': 300, 'seed': 0}#data_val['Survived'] = submit_xgb.predict(data_val[data1_x_bin])#hard voting classifier w/full dataset modeling submission score: defaults= 0.75598, tuned = 0.77990#data_val['Survived'] = vote_hard.predict(data_val[data1_x_bin])data_val['Survived'] = grid_hard.predict(data_val[data1_x_bin])#soft voting classifier w/full dataset modeling submission score: defaults= 0.73684, tuned = 0.74162#data_val['Survived'] = vote_soft.predict(data_val[data1_x_bin])#data_val['Survived'] = grid_soft.predict(data_val[data1_x_bin])#submit filesubmit = data_val[['PassengerId','Survived']]submit.to_csv(\"../working/submit.csv\", index=False)print('Validation Data Distribution: \\n', data_val['Survived'].value_counts(normalize = True))submit.sample(10)&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 418 entries, 0 to 417Data columns (total 21 columns):PassengerId      418 non-null int64Pclass           418 non-null int64Name             418 non-null objectSex              418 non-null objectAge              418 non-null float64SibSp            418 non-null int64Parch            418 non-null int64Ticket           418 non-null objectFare             418 non-null float64Cabin            91 non-null objectEmbarked         418 non-null objectFamilySize       418 non-null int64IsAlone          418 non-null int64Title            418 non-null objectFareBin          418 non-null categoryAgeBin           418 non-null categorySex_Code         418 non-null int64Embarked_Code    418 non-null int64Title_Code       418 non-null int64AgeBin_Code      418 non-null int64FareBin_Code     418 non-null int64dtypes: category(2), float64(2), int64(11), object(6)memory usage: 63.1+ KBNone----------Validation Data Distribution: 0    0.6339711    0.366029Name: Survived, dtype: float64결론신기하게도 다른 알고리즘 보다, 내가 만든 트리의 정확도가 실제 제출시에 더 높았다. 이것은, 훈련 데이터 셋의 분포와 제출 데이터 셋의 분포가 다름을 나타낸다. 즉, CV를 통해 모델을 학습한다 할지라도 제출용 데이터의 분포가 성능에 지대한 역할을 미친다는 것이다. 알고리즘에 의존하는 것이 아닌, 전처리와 feature engineering이 더 중요한 경우도 많다.Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-10-Ensemble.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-09-hyper-parameter-tuning-html": {
        "title": "09: Hyper Parameter Tuning",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 모델 파라미터를 튜닝한다.Hyper Parameter Tuning지금까지 돌린 모델은, default setting을 가지고 수행했다. 이제 해당 모델의 세팅값을 변경하면서 결과를 도출해볼 것이다. 그런데, 문제가 있다. 기기를 다루기 위해서는 그 기기에 대해서 이해해야 한다는 것이다. 위에서 handmade 모델을 간단하게 구현해 본 이유가 그것이다. 추후에, 다양한 알고리즘의 세팅값을 변경하고 싶다면 알고리즘에 대해 어느정도 공부해야 한다. 이번에는 아까 구현한 decision tree 기법을 토대로, 해당 알고리즘에 대해 알아본다.Decision Trees  계속 되는 분기를 설정하여 예측을 하는 방법장점  이해하고 해석하기 편리하다. 시각화 할 수 있다.  데이터 준비가 거의 필요없다. 정규화 X, Dummy화 X. 하지만 결측치(NULL)을 지원하지 않는다.  트리를 학습하기 위한 Cost는 log(# of data) 이다.  수치 및 범주형 데이터를 모두 처리 가능하다. 일반적으로는 한가지 유형의 변수에 대해 분석을 수행한다.  multi-output 문제를 다룰 수 있다.  white box 모델이다. 즉, 결과에 대해 쉽게 설명이 가능하다.  통계적 검증을 test를 통해 검증이 가능하다. 모델의 설명력을 측정할 수 있다.단점  지나치게 깊은 트리를 사용하여 일반화를 놓치는 모델을 만들 수 있다. 즉 오버피팅이다. 최대 트리의 깊이나, 잎의 수와 같은 제약을 거는 것이 좋다.  결정 트리는 상당히 불안정하다. 데이터에서 약간의 변동이 생긴다면 즉각 적용이 되어 다른 트리가 생성되기 때문이다. 이러한 부분은 여러개의 트리를 앙상블하여 완화시킬 수 있다.  최적의 결정 트리를 학습하는 문제는 NP 문제이다. 따라서 트리를 만드는데 있어서는 Greedy 알고리즘을 사용한다. 그렇기 때문에 만들어진 트리는 최적의 결과라고 보장할 수 없다. 마찬가지로 앙상블을 통해 완화할 수 있다.  결정 트리로는 배타적 논리합이나 패리티, 멀티플렉서와 같은 문제를 학습하기 어렵다.  각각 서로 다른 수의 단계로 분류가 가능한 변수를 포함하는 데이터에 대하여 더 많은 단계를 가지는 속성 쪽으로 정보 획득량이 편향되는 문제가 있다. 데이터의 균형을 맞추는 것이 좋다. 하지만 이 문제는 조건부 추론을 통해 해결이 가능하다.sklearn parametersclass sklearn.tree.DecisionTreeClassifier(criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weight=None, presort=False)우리는 여기서 ParameterGrid, GridSearchCV, 그리고 sklearn scoring을 사용할 것이다.추가적으로 ROC_AUC scores에 대해서 배우고 오자. Click here to learn more about ROC_AUC scores. 다음으로는 graphviz을 사용하여 결정 트리를 시각화할 것이다.Grid search#base modeldtree = tree.DecisionTreeClassifier(random_state = 0)base_results = model_selection.cross_validate(dtree, data1[data1_x_bin], data1[Target], cv = cv_split)dtree.fit(data1[data1_x_bin], data1[Target])print('BEFORE DT Parameters: ', dtree.get_params())print(\"BEFORE DT Training w/bin score mean: {:.2f}\". format(base_results['train_score'].mean()*100))print(\"BEFORE DT Test w/bin score mean: {:.2f}\". format(base_results['test_score'].mean()*100))print(\"BEFORE DT Test w/bin score 3*std: +/- {:.2f}\". format(base_results['test_score'].std()*100*3))#print(\"BEFORE DT Test w/bin set score min: {:.2f}\". format(base_results['test_score'].min()*100))print('-'*10)#tune hyper-parameters: http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifierparam_grid = {'criterion': ['gini', 'entropy'],  #scoring methodology; two supported formulas for calculating information gain - default is gini              #'splitter': ['best', 'random'], #splitting methodology; two supported strategies - default is best              'max_depth': [2,4,6,8,10,None], #max depth tree can grow; default is none              #'min_samples_split': [2,5,10,.03,.05], #minimum subset size BEFORE new split (fraction is % of total); default is 2              #'min_samples_leaf': [1,5,10,.03,.05], #minimum subset size AFTER new split split (fraction is % of total); default is 1              #'max_features': [None, 'auto'], #max features to consider when performing split; default none or all              'random_state': [0] #seed or control random number generator: https://www.quora.com/What-is-seed-in-random-number-generation             }#print(list(model_selection.ParameterGrid(param_grid)))#choose best model with grid_search: #http://scikit-learn.org/stable/modules/grid_search.html#grid-search#http://scikit-learn.org/stable/auto_examples/model_selection/plot_grid_search_digits.htmltune_model = model_selection.GridSearchCV(tree.DecisionTreeClassifier(), param_grid=param_grid, scoring = 'roc_auc', cv = cv_split)tune_model.fit(data1[data1_x_bin], data1[Target])#print(tune_model.cv_results_.keys())#print(tune_model.cv_results_['params'])print('AFTER DT Parameters: ', tune_model.best_params_)#print(tune_model.cv_results_['mean_train_score'])print(\"AFTER DT Training w/bin score mean: {:.2f}\". format(tune_model.cv_results_['mean_train_score'][tune_model.best_index_]*100))#print(tune_model.cv_results_['mean_test_score'])print(\"AFTER DT Test w/bin score mean: {:.2f}\". format(tune_model.cv_results_['mean_test_score'][tune_model.best_index_]*100))print(\"AFTER DT Test w/bin score 3*std: +/- {:.2f}\". format(tune_model.cv_results_['std_test_score'][tune_model.best_index_]*100*3))print('-'*10)#duplicates gridsearchcv#tune_results = model_selection.cross_validate(tune_model, data1[data1_x_bin], data1[Target], cv  = cv_split)#print('AFTER DT Parameters: ', tune_model.best_params_)#print(\"AFTER DT Training w/bin set score mean: {:.2f}\". format(tune_results['train_score'].mean()*100))#print(\"AFTER DT Test w/bin set score mean: {:.2f}\". format(tune_results['test_score'].mean()*100))#print(\"AFTER DT Test w/bin set score min: {:.2f}\". format(tune_results['test_score'].min()*100))#print('-'*10)BEFORE DT Parameters:  {'class_weight': None, 'criterion': 'gini', 'max_depth': None, 'max_features': None, 'max_leaf_nodes': None, 'min_impurity_decrease': 0.0, 'min_impurity_split': None, 'min_samples_leaf': 1, 'min_samples_split': 2, 'min_weight_fraction_leaf': 0.0, 'presort': False, 'random_state': 0, 'splitter': 'best'}BEFORE DT Training w/bin score mean: 89.51BEFORE DT Test w/bin score mean: 82.09BEFORE DT Test w/bin score 3*std: +/- 5.57----------AFTER DT Parameters:  {'criterion': 'gini', 'max_depth': 4, 'random_state': 0}AFTER DT Training w/bin score mean: 89.35AFTER DT Test w/bin score mean: 87.40AFTER DT Test w/bin score 3*std: +/- 5.00----------grid search를 통해 최적의 파라미터를 찾았다.Feature Selection모든 변수를 찾는 것이 좋은 모델을 찾는 것으로 이어지지 않는다고 얘기했었다. 따라서 이번에는 많은 feature중 어떤 것을 선택했을 때 가장 좋은 성능을 가지는지 알아본다. sklearn에는 다양한 선택지가 있다. 그 중에서 recursive feature elimination (RFE) with cross validation (CV)를 사용할 것이다.#base modelprint('BEFORE DT RFE Training Shape Old: ', data1[data1_x_bin].shape)print('BEFORE DT RFE Training Columns Old: ', data1[data1_x_bin].columns.values)print(\"BEFORE DT RFE Training w/bin score mean: {:.2f}\". format(base_results['train_score'].mean()*100))print(\"BEFORE DT RFE Test w/bin score mean: {:.2f}\". format(base_results['test_score'].mean()*100))print(\"BEFORE DT RFE Test w/bin score 3*std: +/- {:.2f}\". format(base_results['test_score'].std()*100*3))print('-'*10)#feature selectiondtree_rfe = feature_selection.RFECV(dtree, step = 1, scoring = 'accuracy', cv = cv_split)dtree_rfe.fit(data1[data1_x_bin], data1[Target])#transform x&amp;y to reduced features and fit new model#alternative: can use pipeline to reduce fit and transform steps: http://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.htmlX_rfe = data1[data1_x_bin].columns.values[dtree_rfe.get_support()] # get_support()는 feature에서 사용한 것만 t/f로 표현해준다.rfe_results = model_selection.cross_validate(dtree, data1[X_rfe], data1[Target], cv  = cv_split)#print(dtree_rfe.grid_scores_)print('AFTER DT RFE Training Shape New: ', data1[X_rfe].shape)print('AFTER DT RFE Training Columns New: ', X_rfe)print(\"AFTER DT RFE Training w/bin score mean: {:.2f}\". format(rfe_results['train_score'].mean()*100))print(\"AFTER DT RFE Test w/bin score mean: {:.2f}\". format(rfe_results['test_score'].mean()*100))print(\"AFTER DT RFE Test w/bin score 3*std: +/- {:.2f}\". format(rfe_results['test_score'].std()*100*3))print('-'*10)# feature selection을 기본 모델로 평가하고, 그 모델로 부터 나온 feature를 가지고 모델의 입력으로 넣어# 다시 파라미터 튜닝을 한다.#tune rfe modelrfe_tune_model = model_selection.GridSearchCV(tree.DecisionTreeClassifier(), param_grid=param_grid, scoring = 'roc_auc', cv = cv_split)rfe_tune_model.fit(data1[X_rfe], data1[Target])#print(rfe_tune_model.cv_results_.keys()) # 어떤 메소드가 있는지 확인#print(rfe_tune_model.cv_results_['params']) # 파라미터 확인print('AFTER DT RFE Tuned Parameters: ', rfe_tune_model.best_params_)#print(rfe_tune_model.cv_results_['mean_train_score'])print(\"AFTER DT RFE Tuned Training w/bin score mean: {:.2f}\". format(rfe_tune_model.cv_results_['mean_train_score'][tune_model.best_index_]*100))#print(rfe_tune_model.cv_results_['mean_test_score'])print(\"AFTER DT RFE Tuned Test w/bin score mean: {:.2f}\". format(rfe_tune_model.cv_results_['mean_test_score'][tune_model.best_index_]*100))print(\"AFTER DT RFE Tuned Test w/bin score 3*std: +/- {:.2f}\". format(rfe_tune_model.cv_results_['std_test_score'][tune_model.best_index_]*100*3))print('-'*10)BEFORE DT RFE Training Shape Old:  (891, 7)BEFORE DT RFE Training Columns Old:  ['Sex_Code' 'Pclass' 'Embarked_Code' 'Title_Code' 'FamilySize' 'AgeBin_Code' 'FareBin_Code']BEFORE DT RFE Training w/bin score mean: 89.51BEFORE DT RFE Test w/bin score mean: 82.09BEFORE DT RFE Test w/bin score 3*std: +/- 5.57----------AFTER DT RFE Training Shape New:  (891, 6)AFTER DT RFE Training Columns New:  ['Sex_Code' 'Pclass' 'Title_Code' 'FamilySize' 'AgeBin_Code' 'FareBin_Code']AFTER DT RFE Training w/bin score mean: 88.16AFTER DT RFE Test w/bin score mean: 83.06AFTER DT RFE Test w/bin score 3*std: +/- 6.22----------AFTER DT RFE Tuned Parameters:  {'criterion': 'gini', 'max_depth': 4, 'random_state': 0}AFTER DT RFE Tuned Training w/bin score mean: 89.39AFTER DT RFE Tuned Test w/bin score mean: 87.34AFTER DT RFE Tuned Test w/bin score 3*std: +/- 6.21----------FareBinfeature가 삭제된 후, 성능이 올라갔다.Graph 그리기#Graph MLA version of Decision Tree: http://scikit-learn.org/stable/modules/generated/sklearn.tree.export_graphviz.htmlimport graphvizdot_data = tree.export_graphviz(dtree, out_file=None,                                feature_names = data1_x_bin, class_names = True,                                filled = True, rounded = True)graph = graphviz.Source(dot_data)graphReferencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-09-Hyper-parameter-tuning.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-08-eb-aa-a8-eb-8d-b8-ed-8f-89-ea-b0-80-ed-95-98-ea-b8-b0-html": {
        "title": "08: 모델링 평가하기",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제를 모델링한 결과를 바탕으로 모델을 평가한다.모델 성능 평가현재까지의 상황을 보면, baseline 코드로 82%의 정확도를 가지는 모델을 만들었다. 여기서 중요한 것은, 데이터 과학자가 사업적 측면을 생각하고 만든다는 것에 있다. 즉, 투자대비 성능(ROI)를 고민하는 것이 좋다. 연구하는 사람이 아니라면 지나친 성능확대는 시간 낭비일 뿐이기 때문이다.기준 정확도 결정동전 뒤집기를 생각해보자. 우리가 맞춰야 하는 것은 특정 상황에서 이 동전이 앞면이 나올지 뒷면이 나올지를 예측해야 한다. 그 예측값을 위해, 바람, 힘의 크기와 같은 변수들이 주어졌다고 하자. 그런데, 내가 만든 모델이 50%확률로 동전의 앞, 뒤를 맞춘다면, 이만큼 쓸모없는 모델도 없을 것이다. 왜냐하면, 이 정보는 그저 동전을 던지면서 발생하는 빈도수로도 예측이 가능한 결과이기 때문이다.이번에는 타이타닉 문제에 적용해보자. 우리는 training data를 근간으로 1,502 / 2,224=67.5%(약 68%)의 확률로 생존, 사망을 알 수 있다. 그러므로 내가 만든 모델의 성능은 이보다는 높은 결과를 가져와야 의미있는 것이라 할 수 있다. 이러한 방법으로 내가 만든 모델의 최악의 성능 마지노선을 설정할 수 있다.나만의 모델 만들기 (Handmade)어떻게 모델을 만들 수 있는 지 배워보는 입장에서 적어본다.Coin flip model#coin flip model with random 1/survived 0/died#iterate over dataFrame rows as (index, Series) pairs: https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.htmlfor index, row in data1.iterrows():    #random number generator: https://docs.python.org/2/library/random.html    if random.random() &gt; .5:     # Random float x, 0.0 &lt;= x &lt; 1.0        data1.set_value(index, 'Random_Predict', 1) #predict survived/1    else:        data1.set_value(index, 'Random_Predict', 0) #predict died/0# coin flip 모델의 성능을 검증해보자. 옳게 맞추면 1, 아니면 0이다.#the mean of the column will then equal the accuracydata1['Random_Score'] = 0 #assume prediction wrong 초기화data1.loc[(data1['Survived'] == data1['Random_Predict']), 'Random_Score'] = 1 #set to 1 for correct predictionprint('Coin Flip Model Accuracy: {:.2f}%'.format(data1['Random_Score'].mean()*100)) # 평균치를 구한다.# 혹은 그냥 내장 함수를 사용하자.#http://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html#sklearn.metrics.accuracy_scoreprint('Coin Flip Model Accuracy w/SciKit: {:.2f}%'.format(metrics.accuracy_score(data1['Survived'], data1['Random_Predict'])*100))Coin Flip Model Accuracy: 47.14%Coin Flip Model Accuracy w/SciKit: 47.14%group화 후 판단하기#group by or pivot table: https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.htmlpivot_female = data1[data1.Sex=='female'].groupby(['Sex','Pclass', 'Embarked','FareBin'])['Survived'].mean()print('Survival Decision Tree w/Female Node: \\n',pivot_female)pivot_male = data1[data1.Sex=='male'].groupby(['Sex','Title'])['Survived'].mean()print('\\n\\nSurvival Decision Tree w/Male Node: \\n',pivot_male)여자만 다양한 지표로 구분한 이유는 위의 EDA를 해보았을 때, 남자는 놀랍게도 class나, embarked에 따라 생존률이 다르지 않았다. 하지만 title이라는 변수는 유의미했다.Survival Decision Tree w/Female Node: Sex     Pclass  Embarked  FareBinfemale  1       C         (14.454, 31.0]     0.666667                          (31.0, 512.329]    1.000000                Q         (31.0, 512.329]    1.000000                S         (14.454, 31.0]     1.000000                          (31.0, 512.329]    0.955556        2       C         (7.91, 14.454]     1.000000                          (14.454, 31.0]     1.000000                          (31.0, 512.329]    1.000000                Q         (7.91, 14.454]     1.000000                S         (7.91, 14.454]     0.875000                          (14.454, 31.0]     0.916667                          (31.0, 512.329]    1.000000        3       C         (-0.001, 7.91]     1.000000                          (7.91, 14.454]     0.428571                          (14.454, 31.0]     0.666667                Q         (-0.001, 7.91]     0.750000                          (7.91, 14.454]     0.500000                          (14.454, 31.0]     0.714286                S         (-0.001, 7.91]     0.533333                          (7.91, 14.454]     0.448276                          (14.454, 31.0]     0.357143                          (31.0, 512.329]    0.125000Name: Survived, dtype: float64Survival Decision Tree w/Male Node: Sex   Titlemale  Master    0.575000      Misc      0.250000      Mr        0.156673Name: Survived, dtype: float64여기서 잘 관찰해 보면, 여자이면서 class가 3이며, S 항구에서 출항한 여성들의 요금 구간에 따라 생존율이 다른 것을 볼 수 있다. 이 부분은 tree 구조로 쪼개면 정확도가 상승할 것이다.남자의 경우는 title에 따라 생존율이 극명하게 다르다.내가 만드는 tree#handmade data model using brain power (and Microsoft Excel Pivot Tables for quick calculations)def mytree(df):    #initialize table to store predictions    Model = pd.DataFrame(data = {'Predict':[]})    male_title = ['Master'] #survived titles    for index, row in df.iterrows():        #Question 1: Were you on the Titanic; majority died 타이타닉에 있으면 일단 죽었다고 가정        Model.loc[index, 'Predict'] = 0        #Question 2: Are you female; majority survived : 여자는 살았다고 가정        if (df.loc[index, 'Sex'] == 'female'):                  Model.loc[index, 'Predict'] = 1        #Question 3A Female - Class and Question 4 Embarked gain minimum information        #클래스에 따라 나누는 것은 큰 정보이득이 없다. (즉, 클래스에 따른 생존률의 차이가 없다. 정보이득이 없다. 고르게 분포되어 있어 분기를 만드는 것이 의미가 없다.)        #Question 5B Female - FareBin; set anything less than .5 in female node decision tree back to 0        # 여자이며 클래스가 3번, 출항 항구가 S 그리고 돈을 8보다 많이 낸 사람들은 생존했다. 아마 못사는 사람들이 돈을 더 많이 내지 않았을까..        if ((df.loc[index, 'Sex'] == 'female') &amp;            (df.loc[index, 'Pclass'] == 3) &amp;            (df.loc[index, 'Embarked'] == 'S')  &amp;            (df.loc[index, 'Fare'] &gt; 8)           ):                  Model.loc[index, 'Predict'] = 0        #Question 3B Male: Title; set anything greater than .5 to 1 for majority survived        # master 지위를 가진 사람만 생존했다고 가정하자.그럼 남자중 57%는 생존했다고 할 수 있다.        if ((df.loc[index, 'Sex'] == 'male') &amp;            (df.loc[index, 'Title'] in male_title)            ):            Model.loc[index, 'Predict'] = 1    return Model#model dataTree_Predict = mytree(data1)print('Decision Tree Model Accuracy/Precision Score: {:.2f}%\\n'.format(metrics.accuracy_score(data1['Survived'], Tree_Predict)*100))#Accuracy Summary Report with http://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html#sklearn.metrics.classification_report#Where recall score = (true positives)/(true positive + false negative) w/1 being best:http://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html#sklearn.metrics.recall_score#And F1 score = weighted average of precision and recall w/1 being best: http://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html#sklearn.metrics.f1_scoreprint(metrics.classification_report(data1['Survived'], Tree_Predict))Decision Tree Model Accuracy/Precision Score: 82.04%             precision    recall  f1-score   support          0       0.82      0.91      0.86       549          1       0.82      0.68      0.75       342avg / total       0.82      0.82      0.82       891혼동 행렬(Confusion Matrix) 만들기#Plot Accuracy Summary#Credit: http://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.htmlimport itertoolsdef plot_confusion_matrix(cm, classes,                          normalize=False,                          title='Confusion matrix',                          cmap=plt.cm.Blues):    \"\"\"    This function prints and plots the confusion matrix.    Normalization can be applied by setting `normalize=True`.    \"\"\"    if normalize:        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis] # 차원을 하나 늘려 세로로 만들어주는 개념        print(\"Normalized confusion matrix\")    else:        print('Confusion matrix, without normalization')    print(cm)    plt.imshow(cm, interpolation='nearest', cmap=cmap)    plt.title(title)    plt.colorbar()    tick_marks = np.arange(len(classes))    plt.xticks(tick_marks, classes, rotation=45)    plt.yticks(tick_marks, classes)    fmt = '.2f' if normalize else 'd'    thresh = cm.max() / 2.    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):        plt.text(j, i, format(cm[i, j], fmt),                 horizontalalignment=\"center\",                 color=\"white\" if cm[i, j] &gt; thresh else \"black\")    plt.tight_layout()    plt.ylabel('True label')    plt.xlabel('Predicted label')# Compute confusion matrixcnf_matrix = metrics.confusion_matrix(data1['Survived'], Tree_Predict)np.set_printoptions(precision=2)class_names = ['Dead', 'Survived']# Plot non-normalized confusion matrixplt.figure()plot_confusion_matrix(cnf_matrix, classes=class_names,                      title='Confusion matrix, without normalization')# Plot normalized confusion matrixplt.figure()plot_confusion_matrix(cnf_matrix, classes=class_names, normalize=True,                      title='Normalized confusion matrix')Confusion matrix, without normalization[[497  52] [108 234]]Normalized confusion matrix[[ 0.91  0.09] [ 0.32  0.68]]Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-08-%EB%AA%A8%EB%8D%B8-%ED%8F%89%EA%B0%80%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-07-eb-aa-a8-eb-8d-b8-eb-a7-81-html": {
        "title": "07: 모델링",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 모델링을 수행한다.Modeling데이터 사이언스는 수학, CS, 산업에 대한 이해 모두가 필요한 분야이다. 그렇기 때문에 이 세 부분을 모두 주의깊게 공부할 필요가 있다. 지금 부터 할 작업은 수학적 이해가 있으면 좋지만 구현하는데에는 크게 필요가 없다. 지금은 큰 그림을 이해하는 것을 우선으로 한다.기계학습이라는 단어 자체에는 기계에게 학습을 가르친다는 착각을 일으킬 수 있는 여지가 많다. 하지만, 실제로는 그렇지 않다. 다양한 사람들이 좋은 라이브러리를 사용하여 많은 문제를 해결할 수 있게 된 것은 좋으나, 이러한 문제 때문에 오히려 제대로 된 방법을 사용못하는 사람도 많아졌다. 데이터 과학자는 데이터라는 목재를 가지고, 목표에 대한 적절한 도구를 사용하여 문제를 해결해야 한다. 개집을 짓는다면 그에 맞는 적절한 도구로 충분하지만, 큰 목조 건물을 짓는다면, 더 효율적인 도구를 통하여 문제를 해결해야 할 것이다. 결과적으로 알고리즘에 대한 정확한 이해도와 그를 사용할 수 있는 능력을 키워야 할 것이다.기계학습의 목적은, 인간의 문제를 해결하는 것이다. 이 방법으로는 크게 지도학습, 비지도 학습, 강화 학습으로 구분된다. 지도학습은 정답을 포함한 데이터 세트를 가지고 분류하는 것, 비지도 학습은 정답이 없는 데이터 세트를 가지고 모델을 학습하는 것이다. 강화학습은 두 학습의 하이브리드 방식으로 볼 수 있다.타이타닉 문제는 연속적인 값을 예측하는 것이 아닌, 이진 분류 문제이다. 따라서 지금부터 sklearn 라이브러리의 분류 알고리즘을 사용하여 분석을 시작한다.Sklearn Estimator OverviewSklearn Estimator DetailChoosing Estimator Mind MapChoosing Estimator Cheat Sheet지도 학습 중, 분류 문제에 대한 알고리즘에 대해 알아보자.Machine Learning Classification Algorithms:Ensemble MethodsGeneralized Linear Models (GLM)Naive BayesNearest NeighborsSupport Vector Machines (SVM)Decision TreesDiscriminant Analysis기계학습 알고리즘을 고르는 방법  최고의 알고리즘은 없다. NFLT (No Free Lunch Theorem)최고의 알고리즘은 존재하지 않는다. 다양한 알고리즘을 통해 검증하여 최고의 답안을 내는 것이 최선이다.머신 러닝 알고리즘 선택 및 초기화# Machine Learning AlgorithmMLA = [    #Ensemble Methods    ensemble.AdaBoostClassifier(),    ensemble.BaggingClassifier(),    ensemble.ExtraTreesClassifier(),    ensemble.GradientBoostingClassifier(),    ensemble.RandomForestClassifier(),    #Gaussian Processes    gaussian_process.GaussianProcessClassifier(),    #GLM (Generalized Linear Model)    linear_model.LogisticRegressionCV(),    linear_model.PassiveAggressiveClassifier(),    linear_model.RidgeClassifierCV(),    linear_model.SGDClassifier(),    linear_model.Perceptron(),    #Navies Bayes    naive_bayes.BernoulliNB(),    naive_bayes.GaussianNB(),    #Nearest Neighbor    neighbors.KNeighborsClassifier(),    #SVM    svm.SVC(probability=True),    svm.NuSVC(probability=True),    svm.LinearSVC(),    #Trees    tree.DecisionTreeClassifier(),    tree.ExtraTreeClassifier(),    #Discriminant Analysis (판별 분석)    discriminant_analysis.LinearDiscriminantAnalysis(),    discriminant_analysis.QuadraticDiscriminantAnalysis(),    #xgboost: http://xgboost.readthedocs.io/en/latest/model.html    XGBClassifier()    ]#split dataset in cross-validation with this splitter class: http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.ShuffleSplit.html#sklearn.model_selection.ShuffleSplit#note: this is an alternative to train_test_splitcv_split = model_selection.ShuffleSplit(n_splits = 10, test_size = .3, train_size = .6, random_state = 0 ) # 60/30 으로 나눈다. 10%는 일부러 둔다. 그 작업을 10번 만든다.# 알고리즘을 비교하기 위한 표를 만든다.MLA_columns = ['MLA Name', 'MLA Parameters','MLA Train Accuracy Mean', 'MLA Test Accuracy Mean', 'MLA Test Accuracy 3*STD' ,'MLA Time']MLA_compare = pd.DataFrame(columns = MLA_columns)# 각각의 알고리즘이 예측한 값을 보여줄 테이블을 만든다.MLA_predict = data1[Target]# row 하나에 하나의 알고리즘에 대한 결과를 적을 것이므로, row_index를 변수로 잡아준다.row_index = 0for alg in MLA:    #set name and parameters    MLA_name = alg.__class__.__name__    MLA_compare.loc[row_index, 'MLA Name'] = MLA_name    MLA_compare.loc[row_index, 'MLA Parameters'] = str(alg.get_params())    #score model with cross validation: http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.cross_validate.html#sklearn.model_selection.cross_validate    # 만들어진 10개의 split set에 대해 검증을 한다. 이 작업 이후에 결과는 10개가 나올 것이다.    cv_results = model_selection.cross_validate(alg, data1[data1_x_bin], data1[Target], cv  = cv_split)    MLA_compare.loc[row_index, 'MLA Time'] = cv_results['fit_time'].mean()    MLA_compare.loc[row_index, 'MLA Train Accuracy Mean'] = cv_results['train_score'].mean() # 10개의 결과에 대해 평균치    MLA_compare.loc[row_index, 'MLA Test Accuracy Mean'] = cv_results['test_score'].mean()    # https://ko.wikipedia.org/wiki/68-95-99.7_규칙    # 제대로 된 random으로 sampling을 했다면, cross-validation으로 나온 결과는 3시그마 규칙을 만족할 것이다.(즉, 정규 분포로 나왔을 것이다.)    # 이 값을 얻는 이유는, 최악의 훈련 결과를 알아보기 위함이다. 편차가 작을 수록 일반화된 모델이라는 생각을 할 수 있다.    MLA_compare.loc[row_index, 'MLA Test Accuracy 3*STD'] = cv_results['test_score'].std()*3   #let's know the worst that can happen!    #save MLA predictions - see section 6 for usage    alg.fit(data1[data1_x_bin], data1[Target])    MLA_predict[MLA_name] = alg.predict(data1[data1_x_bin])    row_index+=1#print and sort table: https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.sort_values.html# test 정확도가 높은 순서대로 sorting한다.MLA_compare.sort_values(by = ['MLA Test Accuracy Mean'], ascending = False, inplace = True)MLA_compareMLA_predict.sample(10)#barplot using https://seaborn.pydata.org/generated/seaborn.barplot.htmlsns.barplot(x='MLA Test Accuracy Mean', y = 'MLA Name', data = MLA_compare, color = 'm')#prettify using pyplot: https://matplotlib.org/api/pyplot_api.htmlplt.title('Machine Learning Algorithm Accuracy Score \\n')plt.xlabel('Accuracy Score (%)')plt.ylabel('Algorithm')Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-07-%EB%AA%A8%EB%8D%B8%EB%A7%81.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-06-eda-html": {
        "title": "06: EDA (Exploratory Data Analysis)",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 데이터를 탐험적 데이터 탐색을 통해 이해한다.EDA데이터 정제가 끝났으니, 탐험적 데이터 분석을 통해서, 데이터에 대한 이해를 시각적으로 해보자. 이 단계에서 변수를 분리하고, 종속 변수와의 상관관계를 결정해 볼 수 있다.이산적 변수와 y와의 관계for x in data1_x:    if data1[x].dtype != 'float64' :        print('Survival Correlation by:', x)        print(data1[[x, Target[0]]].groupby(x, as_index=False).mean())        # feature와 survived를 가져와서 해당 feature에 대해 group을 묶고, 그 group의 평균을 구해라        print('-'*10, '\\n')# 빈도표 만들기print(pd.crosstab(data1['Title'], data1[Target[0]]))Survival Correlation by: Sex      Sex  Survived0  female  0.7420381    male  0.188908----------Survival Correlation by: Pclass   Pclass  Survived0       1  0.6296301       2  0.4728262       3  0.242363----------Survival Correlation by: Embarked  Embarked  Survived0        C  0.5535711        Q  0.3896102        S  0.339009----------Survival Correlation by: Title    Title  Survived0  Master  0.5750001    Misc  0.4444442    Miss  0.6978023      Mr  0.1566734     Mrs  0.792000----------Survival Correlation by: SibSp   SibSp  Survived0      0  0.3453951      1  0.5358852      2  0.4642863      3  0.2500004      4  0.1666675      5  0.0000006      8  0.000000----------Survival Correlation by: Parch   Parch  Survived0      0  0.3436581      1  0.5508472      2  0.5000003      3  0.6000004      4  0.0000005      5  0.2000006      6  0.000000----------Survival Correlation by: FamilySize   FamilySize  Survived0           1  0.3035381           2  0.5527952           3  0.5784313           4  0.7241384           5  0.2000005           6  0.1363646           7  0.3333337           8  0.0000008          11  0.000000----------Survival Correlation by: IsAlone   IsAlone  Survived0        0  0.5056501        1  0.303538----------Survived    0    1TitleMaster     17   23Misc       15   12Miss       55  127Mr        436   81Mrs        26   99group by aka pivot tableusing crosstabs빈도표 만들기이산 데이터에 대한 plot이 부분에서 plot을 하는데 있어 연습을 위해 다양한 방법을 통해 구현해본다.#graph distribution of quantitative dataplt.figure(figsize=[16,12])plt.subplot(231)plt.boxplot(x=data1['Fare'], showmeans = True, meanline = True)plt.title('Fare Boxplot')plt.ylabel('Fare ($)')plt.subplot(232)plt.boxplot(data1['Age'], showmeans = True, meanline = True)plt.title('Age Boxplot')plt.ylabel('Age (Years)')plt.subplot(233)plt.boxplot(data1['FamilySize'], showmeans = True, meanline = True)plt.title('Family Size Boxplot')plt.ylabel('Family Size (#)')plt.subplot(234)plt.hist(x = [data1[data1['Survived']==1]['Fare'], data1[data1['Survived']==0]['Fare']],         stacked=True, color = ['g','r'],label = ['Survived','Dead'])plt.title('Fare Histogram by Survival')plt.xlabel('Fare ($)')plt.ylabel('# of Passengers')plt.legend()plt.subplot(235)plt.hist(x = [data1[data1['Survived']==1]['Age'], data1[data1['Survived']==0]['Age']],         stacked=True, color = ['g','r'],label = ['Survived','Dead'])plt.title('Age Histogram by Survival')plt.xlabel('Age (Years)')plt.ylabel('# of Passengers')plt.legend()plt.subplot(236)plt.hist(x = [data1[data1['Survived']==1]['FamilySize'], data1[data1['Survived']==0]['FamilySize']],         stacked=True, color = ['g','r'],label = ['Survived','Dead'])plt.title('Family Size Histogram by Survival')plt.xlabel('Family Size (#)')plt.ylabel('# of Passengers')plt.legend()범주형 데이터에 대한 plotseaborn을 사용한 plot을 해본다.#graph individual features by survivalfig, saxis = plt.subplots(2, 3,figsize=(16,12))sns.barplot(x = 'Embarked', y = 'Survived', data=data1, ax = saxis[0,0])sns.barplot(x = 'Pclass', y = 'Survived', order=[1,2,3], data=data1, ax = saxis[0,1])sns.barplot(x = 'IsAlone', y = 'Survived', order=[1,0], data=data1, ax = saxis[0,2])sns.pointplot(x = 'FareBin', y = 'Survived',  data=data1, ax = saxis[1,0])sns.pointplot(x = 'AgeBin', y = 'Survived',  data=data1, ax = saxis[1,1])sns.pointplot(x = 'FamilySize', y = 'Survived', data=data1, ax = saxis[1,2])이 단계에서 우리는 Pclass에 따른 생존률의 차이가 있다는 것을 알 수 있다. 조금더 자세하게 비교해보자.생존 여부, 클래스에 따른 추가 변수의 분포생존 여부, 클래스에 따른 지불 비용, 가족의 크기, 연령 등의 분포를 알아보자. 분포를 알아볼 때는 보통 boxplot을 사용한다. 하지만, boxplot을 사용했을 때 가독성이 떨어지는 경우가 있다. 그 이유는 점들이 찍혀 있고 그렇기 때문인데, 이럴경우 분포를 보는 것이 목적이라면 violin plot을 쓰는 것이 좋다.#graph distribution of qualitative data: Pclass#we know class mattered in survival, now let's compare class and a 2nd featurefig, (axis1,axis2,axis3) = plt.subplots(1,3,figsize=(14,12))sns.boxplot(x = 'Pclass', y = 'Fare', hue = 'Survived', data = data1, ax = axis1)axis1.set_title('Pclass vs Fare Survival Comparison')sns.violinplot(x = 'Pclass', y = 'Age', hue = 'Survived', data = data1, split = True, ax = axis2)# sns.boxplot(x = 'Pclass', y = 'Age', hue = 'Survived', data = data1, ax = axis2)axis2.set_title('Pclass vs Age Survival Comparison')sns.boxplot(x = 'Pclass', y ='FamilySize', hue = 'Survived', data = data1, ax = axis3)axis3.set_title('Pclass vs Family Size Survival Comparison')위는 boxplot을 사용했을 때이고, 아래는 violin을 사용했을 때이다. 분포만 보는 경우 아래 경우가 더 수월하다는 것을 알 수 있다. 이 때 option split를 False로 할 경우, 현재 3개의 violin이 나왔지만 이것을 6개로 나누어서 보여준다.성별과 2nd feature에 따른 생존률#graph distribution of qualitative data: Sex#we know sex mattered in survival, now let's compare sex and a 2nd featurefig, qaxis = plt.subplots(1,3,figsize=(14,12))sns.barplot(x = 'Sex', y = 'Survived', hue = 'Embarked', data=data1, ax = qaxis[0])axis1.set_title('Sex vs Embarked Survival Comparison')sns.barplot(x = 'Sex', y = 'Survived', hue = 'Pclass', data=data1, ax  = qaxis[1])axis1.set_title('Sex vs Pclass Survival Comparison')sns.barplot(x = 'Sex', y = 'Survived', hue = 'IsAlone', data=data1, ax  = qaxis[2])axis1.set_title('Sex vs IsAlone Survival Comparison')가족 구조와 성별에 따른 생존률 비교#more side-by-side comparisonsfig, (maxis1, maxis2) = plt.subplots(1, 2,figsize=(14,12))#how does family size factor with sex &amp; survival comparesns.pointplot(x=\"FamilySize\", y=\"Survived\", hue=\"Sex\", data=data1,              palette={\"male\": \"blue\", \"female\": \"pink\"},              markers=[\"*\", \"o\"], linestyles=[\"-\", \"--\"], ax = maxis1)#how does class factor with sex &amp; survival comparesns.pointplot(x=\"Pclass\", y=\"Survived\", hue=\"Sex\", data=data1,              palette={\"male\": \"blue\", \"female\": \"pink\"},              markers=[\"*\", \"o\"], linestyles=[\"-\", \"--\"], ax = maxis2)클래스, 출항 항구에 따른 생존률클래스도 여러개의 factor, 출항 항구도 factor이다. 이렇게 여러개에 대한 plot을 빠르게 하는 방법이 있다. seaborn의 facetgrid를 사용하는 것이다.e = sns.FacetGrid(data1, col = 'Embarked')e.map(sns.pointplot, 'Pclass', 'Survived', 'Sex', ci=60.0, palette = 'deep') # 순서대로 x의 구분, y의 구분, 추가 구분e.add_legend()나이에 따른 생존 확률 분포나이대에 따른 생존률의 분포를 알고 싶다. 이런 분포는 밀도 함수를 구하는 것과 같다. x가 나이, y가 생존확률이기 때문이다. 이럴 때, kernel함수를 사용하여 밀도함수를 만들어 낼 수 있다.a = sns.FacetGrid( data1, hue = 'Survived', aspect=4 )a.map(sns.kdeplot, 'Age', shade= True )a.set(xlim=(0 , data1['Age'].max()))a.add_legend()성별, 클래스에 따른 나이에 대한 사람 분포성별, 클래스에 따른 그래프를 하나씩 생성하기 위해 col, row 구분은 각각 성별, 클래스로 해준다. 그 상태에서 x는 age, y는 히스토그램에서의 개수가 될 것이다. 이 때, 각각의 그래프에서 색상 구분을 통해 survived를 구분해준다.#histogram comparison of sex, class, and age by survivalh = sns.FacetGrid(data1, row = 'Sex', col = 'Pclass', hue = 'Survived')h.map(plt.hist, 'Age', alpha = .75)h.add_legend()전체 feature들에 대한 plot#pair plots of entire datasetpp = sns.pairplot(data1, hue = 'Survived', palette = 'deep', size=1.2, diag_kind = 'kde', diag_kws=dict(shade=True), plot_kws=dict(s=10) )pp.set(xticklabels=[])feature를 2개씩 묶어 plot해준다. 이 때, kws은 keyword argument로 dictionary 자료형으로 넣어주면 된다. plot에 있어 설정들을 넘겨줄 수 있다. shade는 밀도함수의 안을 채워서 보여주는 역할을 한다. kde는 kernel density estimation을 의미하며, 커널을 씌워 밀도함수의 모양으로 plot한다.상관관계 히트맵각 변수들간의 상관관계에 대해서 plot 해본다. seaborn.diverging_palette#correlation heatmap of datasetdef correlation_heatmap(df):    _ , ax = plt.subplots(figsize =(14, 12))    colormap = sns.diverging_palette(220, 10, as_cmap = True)    _ = sns.heatmap(        df.corr(),        cmap = colormap, # 이친구가 matplot 객체를 입력으로 받는다. as_camp = True로 해줘야 한다.        square=True,        cbar_kws={'shrink':.9 },        ax=ax,        annot=True, # 박스에 값 입력해준다.        linewidths=0.1,vmax=1.0, linecolor='white',        annot_kws={'fontsize':12 }    )    plt.title('Pearson Correlation of Features', y=1.05, size=15)correlation_heatmap(data1)Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-06-EDA.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-05-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-a0-95-ec-a0-9c-html": {
        "title": "05: 데이터 정제",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 데이터를 정제한다.데이터 정제이 단계에서 우리는 데이터를 정제한다.방법론  잘못된 값과 이상치를 수정한다.  결측치를 채워넣는다.  분석에 필요한 새로운 feature를 생성한다.  계산을 위해 변수의 data format을 변경한다.이 방법에 대해 하나씩 자세히 알아보자.  Correcting          데이터를 다시 보면서 이상하거나 납득하기 어려운 데이터를 확인한다. 하지만 수정은 조심해야 한다. 잘못된 판단으로 원래 데이터를 수정할 경우 올바르지 않은 결과가 나올 수 있기 때문이다. 따라서 EDA를 수행한 후 어느정도의 지식을 얻은 후에 수행하기로 한다.            Completing          age, cabin, embarked field에는 결측치나 Null이 많다. Null은 상당히 위험한데, 알고리즘이 받아들일 수 없는 경우가 있기 때문이다. 예를 들어 결정 트리는 null을 받아들일 수 있지만, 다른 알고리즘은 그렇지 않다. 따라서 이 값을 변경하는 것은 매우 중요하다. 이 부분에 있어서는 두가지 접근이 사용된다.                  값을 지운다.                          추천하지는 않는 방법이다. 특히 많은 부분의 record(row)가 빈 값으로 생각되지 않는다면 수행하면 안된다.                                합리적인 값으로 대체한다.                          지우기 보다는 이것이 나은 방법이다.              좋은 방법론으로는, 결측치를 평균, 중앙값, 평균+편차, 최빈값등을 사용하는 것이다.              중급의 방법론은 특정 기준을 사용하여 채워넣는 것이다. 클래스별 나이, 요금에 따른 적재 항구와 같은 것들이 그것이다.              복잡한 방법론이 있지만, 최종 모델을 선정하기 전에, 추가한 feature로 인한 복잡도가 가치가 있는지를 확인해야 한다. 이번에는 age의 빈값은 중앙값으로, cabin은 삭제하며, embark는 최빈값으로 대체된다. 추후 모델에서 이러한 결정을 수정하며 모델을 개선할 수 있다.                                            Creating          Feature engineering은 이미 존재하는 feature를 가지고 새로운 feature를 제작하여 결과에 새로운 영향력을 주는지를 판단하는 과정이다. 예를 들어, 이번 문제에서는 title(master)이 생존에 있어 중요했는지를 판단할 수 있다.        Converting          마지막으로 데이터 포맷을 변경하는 것이다. 날짜나 통화와 같은 데이터 형식일 경우 이것을 변경해줘야 한다. 이번 문제에서는 이산, 연속, 범주형 등의 데이터 형식이 있다. 이런 부분을 계산이 가능하도록 dummy변수화 해준다.      print('Train columns with null values:\\n', data1.isnull().sum())print(\"-\"*10)print('Test/Validation columns with null values:\\n', data_val.isnull().sum())print(\"-\"*10)data_raw.describe(include = 'all') # 통계적으로 한번에 결과를 볼 수 있다.Train columns with null values: PassengerId      0Survived         0Pclass           0Name             0Sex              0Age            177SibSp            0Parch            0Ticket           0Fare             0Cabin          687Embarked         2dtype: int64----------Test/Validation columns with null values: PassengerId      0Pclass           0Name             0Sex              0Age             86SibSp            0Parch            0Ticket           0Fare             1Cabin          327Embarked         0dtype: int64----------정제 시작이제 어떻게 할 지 알았으니 실제로 시작해보자.Developer Documentation:pandas.DataFramepandas.DataFrame.infopandas.DataFrame.describeIndexing and Selecting Datapandas.isnullpandas.DataFrame.sumpandas.DataFrame.modepandas.DataFrame.copypandas.DataFrame.fillnapandas.DataFrame.droppandas.Series.value_countspandas.DataFrame.locComplete (채우기)# 결측치를 지운다.for dataset in data_cleaner:    # age를 중앙값으로 채운다.    dataset['Age'].fillna(dataset['Age'].median(), inplace = True)    # 최빈값으로 대체    dataset['Embarked'].fillna(dataset['Embarked'].mode()[0], inplace = True)    # 중앙값으로 대체    dataset['Fare'].fillna(dataset['Fare'].median(), inplace = True)# 사용하지 않을 feature를 제거해준다.drop_column = ['PassengerId','Cabin', 'Ticket']data1.drop(drop_column, axis=1, inplace = True)print(data1.isnull().sum())print(\"-\"*10)print(data_val.isnull().sum())Survived    0Pclass      0Name        0Sex         0Age         0SibSp       0Parch       0Fare        0Embarked    0dtype: int64----------PassengerId      0Pclass           0Name             0Sex              0Age              0SibSp            0Parch            0Ticket           0Fare             0Cabin          327Embarked         0dtype: int64Create (생성하기) - feature engineeringfor dataset in data_cleaner:    # Family Size 추가    dataset['FamilySize'] = dataset ['SibSp'] + dataset['Parch'] + 1 # 나까지 추가    dataset['IsAlone'] = 1 # 혼자라고 초기화    dataset['IsAlone'].loc[dataset['FamilySize'] &gt; 1] = 0 # 가족 크기가 1보다 클 경우 혼자가 아님    dataset['Title'] = dataset['Name'].str.split(\", \", expand=True)[1].str.split(\".\", expand=True)[0] # expand가 True이면, 하나의 컬럼을 두개로 나눌 수 있다.    # df[['split_1', 'split_2']] = df['email'].str.split('@', expand=True)    # 실수 값을 범주형으로 바꾼 feature를 추가한다.    dataset['FareBin'] = pd.qcut(dataset['Fare'], 4) # 같은 갯수에 해당하는 범위로 쪼갠다. 리턴은 해당 범주    dataset['AgeBin'] = pd.cut(dataset['Age'].astype(int), 5) # 등간격 5개로 쪼갠다. 리턴은 해당 범주# cleanup rare title namesprint(data1['Title'].value_counts()) # 만든 title의 개수를 생각해보자.stat_min = 10 # 작다는 것이 임의적이나, 만연하게 사용하는 작은 수는 10이다. http://nicholasjjackson.com/2012/03/08/sample-size-is-10-a-magic-number/title_names = (data1['Title'].value_counts() &lt; stat_min) # 10보다 count가 작은 친구들을 true로 만든다.#apply and lambda functions are quick and dirty code to find and replace with fewer lines of code: https://community.modeanalytics.com/python/tutorial/pandas-groupby-and-python-lambda-functions/data1['Title'] = data1['Title'].apply(lambda x: 'Misc' if title_names.loc[x] == True else x) # 잡다한 것들 Miscprint(data1['Title'].value_counts())print(\"-\"*10)#preview data againdata1.info()data_val.info()data1.sample(10)Mr              517Miss            182Mrs             125Master           40Dr                7Rev               6Col               2Major             2Mlle              2Lady              1Sir               1the Countess      1Jonkheer          1Don               1Capt              1Ms                1Mme               1Name: Title, dtype: int64Mr        517Miss      182Mrs       125Master     40Misc       27Name: Title, dtype: int64----------&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 891 entries, 0 to 890Data columns (total 14 columns):Survived      891 non-null int64Pclass        891 non-null int64Name          891 non-null objectSex           891 non-null objectAge           891 non-null float64SibSp         891 non-null int64Parch         891 non-null int64Fare          891 non-null float64Embarked      891 non-null objectFamilySize    891 non-null int64IsAlone       891 non-null int64Title         891 non-null objectFareBin       891 non-null categoryAgeBin        891 non-null categorydtypes: category(2), float64(2), int64(6), object(4)memory usage: 85.5+ KB&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 418 entries, 0 to 417Data columns (total 16 columns):PassengerId    418 non-null int64Pclass         418 non-null int64Name           418 non-null objectSex            418 non-null objectAge            418 non-null float64SibSp          418 non-null int64Parch          418 non-null int64Ticket         418 non-null objectFare           418 non-null float64Cabin          91 non-null objectEmbarked       418 non-null objectFamilySize     418 non-null int64IsAlone        418 non-null int64Title          418 non-null objectFareBin        418 non-null categoryAgeBin         418 non-null categorydtypes: category(2), float64(2), int64(6), object(6)memory usage: 46.8+ KBContinuous variable bins; qcut vs cutFare Bins/Buckets using qcut or frequency binsAge Bins/Buckets using cut or value binsqcut에서 사용하는 minimum sample sizepandas 문자열 다루기Convert (변환하기) - 수치화수학적 계산을 위해 범주형 데이터를 더미 변수화 한다. 범주형 데이터를 encoding하는 다양한 방법이 있다. sklearn과 pandas 함수를 사용하겠다.이 단계에서 우리는 사용한 독립 변수 x(independent/features/explanatory/predictor/etc.)와 종속 변수 y(dependent/target/outcome/response/etc.)를 정의한다.Developer DocumentationCategorical EncodingSklearn LabelEncoderSklearn OneHotEncoderPandas Categorical dtypepandas.get_dummies# code categorical datalabel = LabelEncoder()for dataset in data_cleaner:    dataset['Sex_Code'] = label.fit_transform(dataset['Sex'])    dataset['Embarked_Code'] = label.fit_transform(dataset['Embarked'])    dataset['Title_Code'] = label.fit_transform(dataset['Title'])    dataset['AgeBin_Code'] = label.fit_transform(dataset['AgeBin'])    dataset['FareBin_Code'] = label.fit_transform(dataset['FareBin'])#define y variable aka target/outcomeTarget = ['Survived']# raw 데이터에서 사용할 변수를 선택한다.data1_x = ['Sex','Pclass', 'Embarked', 'Title','SibSp', 'Parch', 'Age', 'Fare', 'FamilySize', 'IsAlone'] # pretty name/values for chartsdata1_x_calc = ['Sex_Code','Pclass', 'Embarked_Code', 'Title_Code','SibSp', 'Parch', 'Age', 'Fare'] #coded for algorithm calculationdata1_xy =  Target + data1_xprint('Original X Y: ', data1_xy, '\\n')# 숫자로 바꾼 데이터, 구간인 데이터를 숫자로 바꾼다. (양자화)data1_x_bin = ['Sex_Code','Pclass', 'Embarked_Code', 'Title_Code', 'FamilySize', 'AgeBin_Code', 'FareBin_Code']data1_xy_bin = Target + data1_x_binprint('Bin X Y: ', data1_xy_bin, '\\n')# 모델의 입력으로 사용할 dummy data를 만든다.data1_dummy = pd.get_dummies(data1[data1_x])data1_x_dummy = data1_dummy.columns.tolist()data1_xy_dummy = Target + data1_x_dummyprint('Dummy X Y: ', data1_xy_dummy, '\\n')data1_dummy.head()Original X Y:  ['Survived', 'Sex', 'Pclass', 'Embarked', 'Title', 'SibSp', 'Parch', 'Age', 'Fare', 'FamilySize', 'IsAlone']Bin X Y:  ['Survived', 'Sex_Code', 'Pclass', 'Embarked_Code', 'Title_Code', 'FamilySize', 'AgeBin_Code', 'FareBin_Code']Dummy X Y:  ['Survived', 'Pclass', 'SibSp', 'Parch', 'Age', 'Fare', 'FamilySize', 'IsAlone', 'Sex_female', 'Sex_male', 'Embarked_C', 'Embarked_Q', 'Embarked_S', 'Title_Master', 'Title_Misc', 'Title_Miss', 'Title_Mr', 'Title_Mrs']Double Checkprint('Train columns with null values: \\n', data1.isnull().sum())print(\"-\"*10)print (data1.info())print(\"-\"*10)print('Test/Validation columns with null values: \\n', data_val.isnull().sum())print(\"-\"*10)print (data_val.info())print(\"-\"*10)data_raw.describe(include = 'all')Train columns with null values: Survived         0Pclass           0Name             0Sex              0Age              0SibSp            0Parch            0Fare             0Embarked         0FamilySize       0IsAlone          0Title            0FareBin          0AgeBin           0Sex_Code         0Embarked_Code    0Title_Code       0AgeBin_Code      0FareBin_Code     0dtype: int64----------&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 891 entries, 0 to 890Data columns (total 19 columns):Survived         891 non-null int64Pclass           891 non-null int64Name             891 non-null objectSex              891 non-null objectAge              891 non-null float64SibSp            891 non-null int64Parch            891 non-null int64Fare             891 non-null float64Embarked         891 non-null objectFamilySize       891 non-null int64IsAlone          891 non-null int64Title            891 non-null objectFareBin          891 non-null categoryAgeBin           891 non-null categorySex_Code         891 non-null int64Embarked_Code    891 non-null int64Title_Code       891 non-null int64AgeBin_Code      891 non-null int64FareBin_Code     891 non-null int64dtypes: category(2), float64(2), int64(11), object(4)memory usage: 120.3+ KBNone----------Test/Validation columns with null values: PassengerId        0Pclass             0Name               0Sex                0Age                0SibSp              0Parch              0Ticket             0Fare               0Cabin            327Embarked           0FamilySize         0IsAlone            0Title              0FareBin            0AgeBin             0Sex_Code           0Embarked_Code      0Title_Code         0AgeBin_Code        0FareBin_Code       0dtype: int64----------&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 418 entries, 0 to 417Data columns (total 21 columns):PassengerId      418 non-null int64Pclass           418 non-null int64Name             418 non-null objectSex              418 non-null objectAge              418 non-null float64SibSp            418 non-null int64Parch            418 non-null int64Ticket           418 non-null objectFare             418 non-null float64Cabin            91 non-null objectEmbarked         418 non-null objectFamilySize       418 non-null int64IsAlone          418 non-null int64Title            418 non-null objectFareBin          418 non-null categoryAgeBin           418 non-null categorySex_Code         418 non-null int64Embarked_Code    418 non-null int64Title_Code       418 non-null int64AgeBin_Code      418 non-null int64FareBin_Code     418 non-null int64dtypes: category(2), float64(2), int64(11), object(6)memory usage: 63.1+ KBNone----------data1과 data_val 모두에 구간 변수가 잘 추가되었다.Training data와 Testing data를 나누자.3.25 Split Training and Testing Data우리가 가진 train데이터를 잘 나누어, 훈련한 모델의 성능을 확인해야 한다. 여기서 우리는sklearn 함수를 통해 데이터를 75/25로 나눌 것이다. 이 부분은 overfit our model을 방지하기 위해 중요하다. sklearn’s train_test_split function을 사용하여 데이터를 나눌 것이다. 이 단계 이후에는 sklearn’s cross validation functions을 사용하여 훈련된 모델을 비교할 것이다.#split train and test data with function defaults#random_state -&gt; seed or control random number generator: https://www.quora.com/What-is-seed-in-random-number-generation 랜덤 넘버를 주어서 원하는 랜덤을 정의할 수 있다.train1_x, test1_x, train1_y, test1_y = model_selection.train_test_split(data1[data1_x_calc], data1[Target], random_state = 0)train1_x_bin, test1_x_bin, train1_y_bin, test1_y_bin = model_selection.train_test_split(data1[data1_x_bin], data1[Target] , random_state = 0)train1_x_dummy, test1_x_dummy, train1_y_dummy, test1_y_dummy = model_selection.train_test_split(data1_dummy[data1_x_dummy], data1[Target], random_state = 0)print(\"Data1 Shape: {}\".format(data1.shape))print(\"Train1 Shape: {}\".format(train1_x.shape))print(\"Test1 Shape: {}\".format(test1_x.shape))train1_x_bin.head()# train1_x.head()# train1_x_dummy.head()Data1 Shape: (891, 19)Train1 Shape: (668, 8)Test1 Shape: (223, 8)이 부분을 통해서, data1에서 구간으로 나눈 feature에 대해 split하고, dummy화 된 data에 대해서도 이를 수행했다.Referencekaggle Notebookpandas 문자열 다루기",
        
        "url": "/ds/ml/2020/05/05/titanic-05-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%EC%A0%9C.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-04-eb-8d-b0-ec-9d-b4-ed-84-b0-eb-af-b8-eb-a6-ac-eb-b3-b4-ea-b8-b0-html": {
        "title": "04: 데이터 미리보기",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 데이터를 알아본다.데이터 불러오기, 미리보기# 우리는 데이터를 3단계로 나눠야 한다.# 1. train data# 2. test data(만든 모델을 test)# 3. validation(최종 예측 용)data_raw = pd.read_csv('../input/train.csv')data_val  = pd.read_csv('../input/test.csv')# 기본 데이터는 냅두고, 이걸 복사해서 쓰는 것이 효율적이다.# 여기서 python이 기본적으로 reference로 shellow copy를 한다는 점을 인지하고 deep copy를 해야한다.data1 = data_raw.copy(deep = True)# copy by reference를 한다는 점을 이용하여, 빈번하게 수정할 데이터를 한번에 list로 갖고 있자.data_cleaner = [data1, data_val]#preview dataprint (data_raw.info())#data_raw.head()#data_raw.tail()data_raw.sample(10) # random으로 10개를 뽑아준다.&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 891 entries, 0 to 890Data columns (total 12 columns):PassengerId    891 non-null int64Survived       891 non-null int64Pclass         891 non-null int64Name           891 non-null objectSex            891 non-null objectAge            714 non-null float64SibSp          891 non-null int64Parch          891 non-null int64Ticket         891 non-null objectFare           891 non-null float64Cabin          204 non-null objectEmbarked       889 non-null objectdtypes: float64(2), int64(5), object(5)memory usage: 83.6+ KBNone  Survived 변수는 종속 변수이다. 이진 데이터 타입이다. 다른 변수들은 종속 변수이다. 종속 변수들을 모두 사용한다고 좋은 결과가 나오는 것이 아니다. 올바른 변수를 사용해야 한다.  PassengerID 와 Ticket 변수는 random한 식별자이다. 따라서 사용하더라도 유용하지 않으므로 배제한다.  Pclass는 사회적 지위를 알 수 있는 지표이다. 1 = upper class, 2 = middle class, and 3 = lower class.  Name은 string 데이터이다. 이 변수는 성별, 지위 등을 알 수 있을 수 있다. 하지만 이미 지위 변수가 있기 때문에, Master와 같은 title이 붙었을 때, 유의미한 차이가 있는 지 확인하기 위해서 사용한다.  Sex 와 Embarked 변수는 string 데이터 이다. 이 부분을 사용하기 위해 dummy화를 진행한다.  Age 와 Fare 실수형 데이터이다.  SibSp 는 관련된 형제나 배우자의 수를 나타낸다.(siblings/spouse abroad) Parch 는 관련된 부모와 아이들의 수를 나타낸다. (parents/children aboard) 두 변수는 이산 데이터 타입이다. 이 변수를 가지고 가족의 크기나, 혼자인지를 판명하는 변수를 만들 수 있다.  Cabin string 데이터 이다. 이 변수를 가지고 사고가 일어났을 때, 해당 사람의 배 안에서의 대략적인 위치를 알 수 있다. 하지만 결측치가 많기 때문에 분석에서는 제외한다.            Variable      Definition      Key                  survival      Survival      0 = No, 1 = Yes              pclass      Ticket class      1 = 1st, 2 = 2nd, 3 = 3rd              sex      Sex                     Age      Age in years                     sibsp      # of siblings / spouses aboard the Titanic                     parch      # of parents / children aboard the Titanic                     ticket      Ticket number                     fare      Passenger fare                     cabin      Cabin number                     embarked      Port of Embarkation      C = Cherbourg, Q = Queenstown, S = Southampton      Referencekaggle Notebooksubprocess 모듈에 관하여seaborn 시각화",
        
        "url": "/ds/ml/2020/05/05/titanic-04-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-03-eb-9d-bc-ec-9d-b4-eb-b8-8c-eb-9f-ac-eb-a6-ac-eb-a1-9c-eb-93-9c-html": {
        "title": "03: 라이브러리 로드",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 라이브러리를 로드한다.데이터 정제제공된 데이터 셋을 사용하기 편하게 정제한다.라이브러리 사용사용하는 라이브러리를 확인한다.기본 라이브러리# It is defined by the kaggle/python docker image: https://github.com/kaggle/docker-python#load packagesimport sys # 시스템 파라미터에 접근할 수 있게 도와준다.print(\"Python version: {}\". format(sys.version))import pandas as pd # 데이터 정제에 도움을 주는 라이브러리print(\"pandas version: {}\". format(pd.__version__))import matplotlib # 매트랩에서 사용하는 시각화 도구를 사용할 수 있게 도와주는 시각화 도구print(\"matplotlib version: {}\". format(matplotlib.__version__))import numpy as np # 행렬 계산을 위해 필요한 라이브러리print(\"NumPy version: {}\". format(np.__version__))import scipy as sp # 수학 관련 함수가 내장된 라이브러리print(\"SciPy version: {}\". format(sp.__version__))import IPythonfrom IPython import display # 주피터 노트북에서 예쁘게 시각화 해주는 도구print(\"IPython version: {}\". format(IPython.__version__))import sklearn # 각종 통계 도구와 머신 러닝 알고리즘이 내장되어 있는 라이브러리print(\"scikit-learn version: {}\". format(sklearn.__version__))# 파이썬 내장 라이브러리import randomimport time# Jupyter Notebook 이나 ipython 을 사용하다보면 향후 버전이 올라갈 때 변경될 사항 등을 알려주는 경고 메시지(warning message)를 뜨지 않게 해준다.import warningswarnings.filterwarnings('ignore')print('-'*25)# input data 파일은 \"../input\"에 있다.# 아래 코드를 수행하게 되면, \"../input/\"에서 리눅스 명령어 \"ls\"를 수행한 결과를 보여주게 된다. 이 때 나온 binary code를 \"utf8\"로 디코딩해서 보여준다.from subprocess import check_outputprint(check_output([\"ls\", \"../input\"]).decode(\"utf8\"))# Any results you write to the current directory are saved as output.subprocess 모듈에 대해 궁금하다면 다음의 글을 읽어보자.subprocess 모듈에 관하여데이터 모델링 라이브러리# 일반적인 모델링 라이브러리from sklearn import svm, tree, linear_model, neighbors, naive_bayes, ensemble, discriminant_analysis, gaussian_processfrom xgboost import XGBClassifier# 모델링 시 헬퍼 함수들from sklearn.preprocessing import OneHotEncoder, LabelEncoderfrom sklearn import feature_selectionfrom sklearn import model_selectionfrom sklearn import metrics# 시각화 도구import matplotlib as mplimport matplotlib.pyplot as pltimport matplotlib.pylab as pylabimport seaborn as snsfrom pandas.tools.plotting import scatter_matrix# 시각화 도구 default 세팅%matplotlib inline # 주피터 노트북에서 plot 결과를 볼 수 있게 해준다.mpl.style.use('ggplot') # matplotlib에서 plot되는 결과를 선택할 수 있다.sns.set_style('white') # seaborn에서 사용할 style을 설정할 수 있다.pylab.rcParams['figure.figsize'] = 12,8 # plot의 크기와 선 등의 기본 값을 설정할 수 있다.matplotlib에서 style 바꾸는 법이 부분을 바꾸면 전체적인 그래프의 색등이 바뀐다.print(plt.style.available)['bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-bright', 'seaborn-colorblind', 'seaborn-dark-palette', 'seaborn-dark', 'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook', 'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk', 'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'seaborn', 'Solarize_Light2', 'tableau-colorblind10', '_classic_test']  사용법plt.style.use(['fivethirtyeight'])seaborn에서 스타일 바꾸는 법이 부분을 바꾸면 뒤의 배경과 같은 부분을 바꿀 수 있다.darkgrid, whitegrid, dark, white, 그리고 ticks 스타일을 제공한다.  사용법sns.set_style('darkgrid')seaborn 시각화Referencekaggle Notebooksubprocess 모듈에 관하여seaborn 시각화",
        
        "url": "/ds/ml/2020/05/05/titanic-03-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%A1%9C%EB%93%9C.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-02-eb-8d-b0-ec-9d-b4-ed-84-b0-ec-88-98-ec-a7-91-html": {
        "title": "02: 데이터 수집",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제의 데이터를 수집한다.데이터 수집Titanic: Machine Learning from Disaster이 부분은 kaggle에 있는 데이터 셋을 사용할 것이므로 생략 한다.Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-02-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91.html"
      }
      ,
    
      "ds-ml-2020-05-05-titanic-01-eb-ac-b8-ec-a0-9c-ec-a0-95-ec-9d-98-html": {
        "title": "01: 문제 정의",
        "tags": "Data Science, Machine Learning, kaggle",
        "date": "May 5, 2020",
        "author": "",
        "category": "DS/ML",
        "content": "Kaggle에 있는 Titanic Prediction 문제를 정의한다.문제 정의  타이타닉에 승선한 객원들 중 생존/사망 여부를 예측한다.프로젝트 요약타이타닉 침몰은 역사상 가장 악명 높은 난파선 중 하나이다. 1912 년 4 월 15 일, 첫 여행 중에 타이타닉은 빙산과 충돌하여 침몰하여 2224 명의 승객과 승무원 중 1502 명이 사망했다.인명 손실이 발생한 이유 중 하나는 승객과 승무원을 위한 구명 보트가 충분하지 않았기 때문이다. 일부 그룹의 사람들은 여성, 어린이 및 상류층과 같은 다른 그룹보다 생존 할 가능성이 더 컸다.어떤 종류의 사람들이 살아남을 가능성에 대한 분석을 수행한다. 특히 기계 학습 도구를 적용하여 어떤 승객이 비극에서 살아남 았는지 예측하는 것이 목표이다.Referencekaggle Notebook",
        
        "url": "/ds/ml/2020/05/05/titanic-01-%EB%AC%B8%EC%A0%9C%EC%A0%95%EC%9D%98.html"
      }
      ,
    
      "ds-visualization-2020-05-04-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-04-bubble-plot-html": {
        "title": "04: Circling을 통한 버블 플롯",
        "tags": "DS, python, matplotlib, scatter plot, bubble plot",
        "date": "May 4, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "산점도 그래프의 응용인 버블 플롯을 그려보자.연습 kaggle notebook  산점도에서 추가적으로 내가 원하는 그룹에 대해 원으로 그룹을 지어, 크기를 알 수 있다.원래 bubble plot은 특정 집단의 boundary를 측정하는데 용이하다. 여기서는 산점도에서 추가적으로 circling을 통하여 그 boundary를 측정하는 방법을 사용해본다. 알고리즘으로는 컨벡스 헐을 사용한다.기본적인 bubble plot# Useful for:# Visualize the relationship between data.# More info:# https://en.wikipedia.org/wiki/Scatter_plot# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/midwest_filter.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (12, 6))ax = fig.add_subplot(1,1,1,)# ----------------------------------------------------------------------------------------------------# 각 그룹마다 다르게 묶은 뒤, 연속해서 plot한다. 이럴 경우 각 포인트가 그룹마다 다른 색으로 칠해진다.for cat in sorted(list(df[\"category\"].unique())):    # filter x and the y for each category    ar = df[df[\"category\"] == cat][\"area\"]    pop = df[df[\"category\"] == cat][\"poptotal\"]    # plot the data    ax.scatter(ar, pop, label = cat, s = 10)# ----------------------------------------------------------------------------------------------------# prettify the plot# 맨 위 줄과 오른쪽 줄을 없애서 보기 편하게ax.spines[\"top\"].set_color(\"None\")ax.spines[\"right\"].set_color(\"None\")# set a specific label for each axisax.set_xlabel(\"Area\")ax.set_ylabel(\"Population\")# change the lower limit of the plot, this will allow us to see the legend on the leftax.set_xlim(-0.01)ax.set_title(\"Scatter plot of population vs area.\")ax.legend(loc = \"upper left\", fontsize = 10)추가적인 bubble plot# Useful for:# Visualize the relationship between data but also helps us encircle a specific group we might want to draw the attention to.# More info:# https://en.wikipedia.org/wiki/Scatter_plot# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/midwest_filter.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (12, 6))ax = fig.add_subplot(1,1,1,)# ----------------------------------------------------------------------------------------------------# prepare the data for plottingsize_total = df[\"poptotal\"].sum()# we want every group to have a different markermarkers = [\".\", \",\", \"o\", \"v\", \"^\", \"&lt;\", \"&gt;\", \"1\", \"2\", \"3\", \"4\", \"8\", \"s\", \"p\", \"P\", \"*\", \"h\", \"H\", \"+\", \"x\", \"X\", \"D\", \"d\"]# ----------------------------------------------------------------------------------------------------# create an encircle# based on this solution# https://stackoverflow.com/questions/44575681/how-do-i-encircle-different-data-sets-in-scatter-plotdef encircle(x,y, ax = None, **kw):    '''    Takes an axes and the x and y and draws a polygon on the axes.    This code separates the differents clusters    '''    # get the axis if not passed    if not ax: ax=plt.gca()    # concatenate the x and y arrays    p = np.c_[x,y]    # to calculate the limits of the polygon    hull = ConvexHull(p)    # create a polygon from the hull vertices    poly = plt.Polygon(p[hull.vertices,:], **kw)    # add the patch to the axes    ax.add_patch(poly) # 내가 그린 그림을 위에 덧칠하게 해줌# ----------------------------------------------------------------------------------------------------# iterate over each category and plot the data. This way, every group has it's own color and marker.# on the iteration we will calculate our hull/polygon for each group and connect specific groupsfor cat, marker in zip(sorted(list(df[\"category\"].unique())), markers):  # 이런 스킬이 굉장히 중요해 보임    # filter x and the y for each category    ar = df[df[\"category\"] == cat][\"area\"]    pop = df[df[\"category\"] == cat][\"poptotal\"]    # this will allow us to set a specific size for each group.    # 해당 population 값에 따라 marker의 크기를 다르게 해주기 위함    size = pop/size_total    # plot the data    ax.scatter(ar, pop, label = cat, s = size*10000, marker = marker)    try:        # try to add a patch        encircle(ar, pop, ec = \"k\", alpha=0.1)    except:        # if we don't have enough poins to encircle just pass        pass# ----------------------------------------------------------------------------------------------------# prettify the plot# eliminate 2/4 spines (lines that make the box/axes) to make it more pleasantax.spines[\"top\"].set_color(\"None\")ax.spines[\"right\"].set_color(\"None\")# set a specific label for each axisax.set_xlabel(\"Area\")ax.set_ylabel(\"Population\")# change the lower limit of the plot, this will allow us to see the legend on the leftax.set_xlim(-0.01)ax.set_title(\"Bubble plot with encircling\")ax.legend(loc = \"upper left\", fontsize = 10);ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/04/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-04-bubble-plot.html"
      }
      ,
    
      "ds-visualization-2020-05-04-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-03-ec-82-b0-ec-a0-90-eb-8f-84-html": {
        "title": "03: 산점도",
        "tags": "DS, python, matplotlib",
        "date": "May 4, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "산점도 그래프를 그려보자.연습 kaggle notebook  두 데이터의 관계를 알아볼 때 용이!산점도는 실제 데이터를 2차원 평면에 plot함으로써 대략적인 분포를 파악할 수 있다.# Useful for:# Visualize the relationship between data.# More info:# https://en.wikipedia.org/wiki/Scatter_plot# ----------------------------------------------------------------------------------------------------# get the dataPATH = '/kaggle/input/the-50-plot-challenge/midwest_filter.csv'df = pd.read_csv(PATH)# ----------------------------------------------------------------------------------------------------# instanciate the figurefig = plt.figure(figsize = (12, 6))ax = fig.add_subplot(1,1,1,)# ----------------------------------------------------------------------------------------------------# 각 그룹마다 다르게 묶은 뒤, 연속해서 plot한다. 이럴 경우 각 포인트가 그룹마다 다른 색으로 칠해진다.for cat in sorted(list(df[\"category\"].unique())):    # filter x and the y for each category    ar = df[df[\"category\"] == cat][\"area\"]    pop = df[df[\"category\"] == cat][\"poptotal\"]    # plot the data    ax.scatter(ar, pop, label = cat, s = 10)# ----------------------------------------------------------------------------------------------------# prettify the plot# 맨 위 줄과 오른쪽 줄을 없애서 보기 편하게ax.spines[\"top\"].set_color(\"None\")ax.spines[\"right\"].set_color(\"None\")# set a specific label for each axisax.set_xlabel(\"Area\")ax.set_ylabel(\"Population\")# change the lower limit of the plot, this will allow us to see the legend on the leftax.set_xlim(-0.01)ax.set_title(\"Scatter plot of population vs area.\")ax.legend(loc = \"upper left\", fontsize = 10)ReferencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/04/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-03-%EC%82%B0%EC%A0%90%EB%8F%84.html"
      }
      ,
    
      "ds-visualization-2020-05-04-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-02-matplotlib-ec-95-8c-ec-95-84-eb-b3-b4-ea-b8-b0-html": {
        "title": "02: matplotlib 알아보기",
        "tags": "DS, python, matplotlib",
        "date": "May 4, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "matplotlib의 기본적인 기능을 알아본다.Figure, axes, subplots  기본 플롯은 Figure와 axes로 시작한다.사실 그리는 방법은 여러가지가 있으나, 한가지 방법을 고수하는 것이 좋다. 이 글 에서는 OOP접근 방법에 기반하여 설명하도록 한다.Basic Way# figure 객체 생성fig = plt.figure()# subplot을 등록해준다. 1개만 그릴 경우 필요없지만,# 명백하게 적어주는 습관을 들이는 것이 좋다.ax1 = fig.add_subplot(1, 1, 1)# some datax = [1, 2, 3, 4, 5]y = [3, 2, 1, 4, 5]# plot basic thingsax1.plot(x, y);아래의 방법도 위와 같은 결과를 가져온다.# the same plot can be achieved doing this wayfig = plt.figure()ax1 = fig.subplots()ax1.plot(x, y);# you can even simplify it more by just doing thisplt.plot(x, y);간단하게 수행할 수 있지만, 명백한 방법을 일관되게 사용하는 것이 더 좋다. 이 방법 외에도 같은 결과를 만들 수 있는 다양한 코드가 존재한다. 이 부분에 대한 의문이 들었다면, matplotlib의 구조에 대해서 이해할 필요가 있다.matplotlib의 구조  Backend Layer          가장 낮은 단계      %matplotlib inline 을 사용하면, plt.show()를 호출 할 필요없이 모든 것을 렌더링하도록 백엔드에 지시한다.        Artist Layer          이 레이어는 스파인, 축, 색상 등을 변경할 수 있는 가능성을 제공한다.      ax1.plot()을 호출 할 때 이 계층에 액세스한다. 앞으로 이 단계에서 많은 기능을 수행할 것이다.        Script Layer          빠른 플롯에 매우 편리하다.      plt.plot()과 같이 사용할 때 사용합니다. 여전히 강력하지만 2 레이어만큼 강력하지 않다.      Script Layer에서 call 했을 떄 실제 동작            script Layer      actual calling Code      Details                  plt.subplot()      fig = plt.figure() fig.add_subplot()      figure를 생성하고 1개의 subplot을 fig에 추가한다.              plt.subplots()      fig = plt.figure() fig.subplots(n, m)      fig.subplots(n,m) 의 반환값은 (n,m)크기의 axes객체가 들어간 튜플이다. 따라서 plt.subplots()를 수행하면 fig와 axes 튜플 객체가 반환된다. fig, ax1 = plt.subplots() 이런식으로 받아주어야 한다.      Multiple plotsfig.subplots() 사용fig = plt.figure()# create a 4 plots and use tuple unpacking to name everyplot# subplots() 라는 함수로 한번에 axes를 설정할 수 있다.(ax1, ax2), (ax3, ax4) = fig.subplots(2,2)ax1.plot([1,2,3], color = \"red\")ax2.plot([3,2,1], color = \"blue\")ax3.plot([4,4,4], color = \"orange\")ax4.plot([5,4,5], color = \"black\")plt.tight_layout()plt.subplots() 사용# you can do the same using a for loopnrows = 2ncolumns = 2fig, axes = plt.subplots(nrows, ncolumns)    # return값이 2개이다.# axes is just a tuple as we saw before# since se specifiedfor row in range(nrows):    for column in range(ncolumns):        ax = axes[row, column]        ax.plot(np.arange(10))axis 안에 plot하기fig = plt.figure(figsize = (20, 10))# create a 4 plots and use tuple unpacking to name everyplot(ax1, ax2), (ax3, ax4) = fig.subplots(2,2)ax1.plot([1,2,3], color = \"red\")ax2.plot([3,2,1], color = \"blue\")ax3.plot([4,4,4], color = \"orange\")ax3_bis = fig.add_axes([0.15, 0.15, 0.15, 0.15])ax3_bis.plot([1,2,1], color = \"pink\") # you add it to the figure!ax3_bis.annotate(\"Small annotation inside a small added axes\",                xy = (0.5, 0.5),                xycoords = \"axes fraction\",                va = \"center\",                ha = \"center\")ax4.plot([5,4,5], color = \"black\")ax4.annotate(\"Just to demonstrate the power of matplotlib\",             xy = (0.5, 0.5), # fraction of the ax4. In the center.             xycoords = \"axes fraction\", # you can also specify data and pass the values of the x and y axis.             va = \"center\",             ha = \"center\")plt.tight_layout()grid를 사용하여 예쁜 plot하기gs를 사용하면, 행렬 처럼 슬라이싱을 하여 내가 원하는 곳에 그래프를 넣을 수 있다.fig = plt.figure(figsize = (10, 5))gs = fig.add_gridspec(3, 3)ax1 = fig.add_subplot(gs[0, :])ax1.plot([1,2,1,2])ax1.set_title(\"Random text\")ax2 = fig.add_subplot(gs[1,0])ax2.plot(1,3,1)ax3 = fig.add_subplot(gs[1,1])ax3.plot(3,1,3)ax4 = fig.add_subplot(gs[2,:-1])ax4.scatter([1,2,3], [1,2,3])ax5 = fig.add_subplot(gs[1:, -1])ax5.bar([1,2,3], [1,2,3])ax5_bis = fig.add_axes([0.75, 0.5, 0.1, 0.1])ax5_bis.plot([3,1,2])plt.tight_layout()referencePlotting with Python: learn 80 plots STEP by STEP",
        
        "url": "/ds/visualization/2020/05/04/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-02-matplotlib-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0.html"
      }
      ,
    
      "ds-visualization-2020-05-04-ec-8b-9c-ea-b0-81-ed-99-94-ec-a0-95-eb-a6-ac-01-eb-9d-bc-ec-9d-b4-eb-b8-8c-eb-9f-ac-eb-a6-ac-html": {
        "title": "01: 라이브러리",
        "tags": "DS, python, library",
        "date": "May 4, 2020",
        "author": "",
        "category": "DS/Visualization",
        "content": "시각화를 하는데 필요한 다양한 라이브러리에 대해서 알아본다.joypy  feature에 대한 특징을 밀도 기반으로 깔끔하게 볼 수 있다.Documentationpywaffle  분포에 대한 것을 네모 박스로 처리하여 깔끔하게 볼 수 있다.calmap  히트맵으로 표현해 준다.Documentationpandas  데이터 조작 및 분석을 위해 Python 프로그래밍 언어로 작성된 소프트웨어 라이브러리Documentationmatplotlib  파이썬에서 매트랩과 유사한 그래프를 그릴 수 있게 도와주는 라이브러리Documentationimport joypyfrom pywaffle import Waffleimport calmapimport pandas as pdimport matplotlib.pyplot as pltimport osimport numpy as npfrom scipy.spatial import ConvexHull # 볼록 다각형을 시각화해야할 때가 있다.",
        
        "url": "/ds/visualization/2020/05/04/%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A0%95%EB%A6%AC-01-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC.html"
      }
      ,
    
      "cs-database-2020-04-25-where-having-ec-b0-a8-ec-9d-b4-html": {
        "title": "where와 having의 차이",
        "tags": "database, SQL, having, where",
        "date": "April 25, 2020",
        "author": "",
        "category": "CS/Database",
        "content": "sql에서 조건문을 담당하는 쿼리인 having과 where의 차이를 알아본다.Where  select * from 테이블명 where 조건절위와 같은 방법으로 where 조건절을 사용한다. 항상 from뒤에 위치하고 조건에는 다양한 비교연산자들이 사용되어 구체적인 조건을 줄 수 있다.having  select * from 테이블명 group by 필드명 having 조건절  위와 같은 방법으로 having 조건절을 사용한다. 항상 group by뒤에 위치하고 where 조건절과 마찬가지로 조건에는 다양한 비교연산자들이 사용되어 구체적인 조건을 줄 수 있다.차이점where은 기본적인 조건절로서 우선적으로 모든 필드를 조건에 둘 수 있다.하지만 having은 group by 된 이후 특정한 필드로 그룹화 되어진 새로운 테이블에 조건을 줄 수 있다.즉, 전체 테이블 자체에서 쿼리를 수행하고 싶다면 where를, 전체 테이블을 그룹화 한뒤, 그 해당 그룹에서 어떠한 조건을 걸어 가져오고 싶다면 having을 사용한다.예제group by - having 문제위의 문제에서 답은 다음과 같이 나올 수 있다.SELECT NAME, COUNT(NAME) AS \"Count\" FROM ANIMAL_INS    GROUP BY NAME    HAVING COUNT(NAME) &gt; 1;현재 문제는, 내가 갖고 있는 table을 name이라는 키워드로 분리한 다음, 그 분리한 각각의 set의 크기가 1보다 클 경우에 대해 쿼리를 수행해야 한다. 코드를 잘 읽어보면 이해할 수 있다.",
        
        "url": "/cs/database/2020/04/25/where-having-%EC%B0%A8%EC%9D%B4.html"
      }
      ,
    
      "cs-algorithm-2020-04-25-eb-b0-b1-ec-a4-80-ed-86-b1-eb-8b-88-eb-b0-94-ed-80-b4-html": {
        "title": "백준(14891번): 톱니바퀴",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현",
        "date": "April 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 구현 문제이다.생각단순 구현 문제이다. 비트마스크 연습을 위해 비트마스크로 풀었다. 해당 과정을 하는 동안에 인접행렬 같은 matrix를 만들어 무언가를 해보려 했지만 좋지 못했다. 구현 문제는 노가다로 적어주는게 정신 건강에 이롭다.Sudo-algorithm  입력을 받는다.  어떤 톱니바퀴를 돌리는 지 판단한다.  그 톱니바퀴를 돌렸을 때, 따라서 돌아가는 톱니바퀴의 방향을 정한다.  그 구한 톱니 바퀴의 방향대로 돌린다.  마지막에 답을 구한다.특정 톱니바퀴를 돌렸을 때, 따라서 돌아가는 것의 숫자를 0이면 돌아가지 않는다. 1이면 시계방향, -1이면 반시계방향으로 정하여 구해주었다.vector&lt;int&gt; getAction(int gear, int dir){    vector&lt;int&gt; action(5);    if (gear == 1) {        action[1] = dir;        if (isRevolve(1, 2)) action[2] = -action[1];        if (isRevolve(2, 3)) action[3] = -action[2];        if (isRevolve(3, 4)) action[4] = -action[3];    } else if (gear == 2) {        action[2] = dir;        if (isRevolve(1, 2)) action[1] = -action[2];        if (isRevolve(2, 3)) action[3] = -action[2];        if (isRevolve(3, 4)) action[4] = -action[3];    } else if (gear == 3) {        action[3] = dir;        if (isRevolve(2, 3)) action[2] = -action[3];        if (isRevolve(3, 4)) action[4] = -action[3];        if (isRevolve(1, 2)) action[1] = -action[2];    } else {        action[4] = dir;        if (isRevolve(3, 4)) action[3] = -action[4];        if (isRevolve(2, 3)) action[2] = -action[3];        if (isRevolve(1, 2)) action[1] = -action[2];    }    return action;}특정 톱니 바퀴가 돌아갈 때, 이전 상태가 돌아갈 수 있는 상태라면, 인접한 톱니바퀴의 방향은 무조건 반대 방향인 것을 사용했다. 또한 이전 상태의 양극이 반대라 특정 톱니 바퀴가 돌아가게 되면 인접한 톱니바퀴 역시 돌아갈 수 있음에도 불구하고 특정 톱니가 돌아가지 않으면 0을 리턴하므로 인접 톱니도 돌아가지 않는다.참, 비트가 켜져있는지 아닌지 구분할 때에는 꼭 괄호를 써서 생각하자.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;int state[5];int N, ans = 0;bool isRevolve(int i, int j){    if ((state[i] &amp; 32 &amp;&amp; state[j] &amp; 2) || ((state[i] &amp; 32) == 0 &amp;&amp; (state[j] &amp; 2) == 0)) {        return false;    }    else return true;}void rotate(int gearNum, int way){    if (way == 0) return;    else if (way == 1) {        int flag = state[gearNum] &amp; 1;        state[gearNum] = state[gearNum] &gt;&gt; 1;        if (flag) state[gearNum] |= 128;    } else {        int flag = state[gearNum] &amp; 128;        state[gearNum] = state[gearNum] &lt;&lt; 1;        state[gearNum] &amp;= ~256;        if (flag) state[gearNum] |= 1;    }}void getScore(){    for (int i = 1; i &lt;= 4; i++) {        if (state[i] &amp; 128) ans += int(pow(2, i-1));    }}vector&lt;int&gt; getAction(int gear, int dir){    vector&lt;int&gt; action(5);    if (gear == 1) {        action[1] = dir;        if (isRevolve(1, 2)) action[2] = -action[1];        if (isRevolve(2, 3)) action[3] = -action[2];        if (isRevolve(3, 4)) action[4] = -action[3];    } else if (gear == 2) {        action[2] = dir;        if (isRevolve(1, 2)) action[1] = -action[2];        if (isRevolve(2, 3)) action[3] = -action[2];        if (isRevolve(3, 4)) action[4] = -action[3];    } else if (gear == 3) {        action[3] = dir;        if (isRevolve(2, 3)) action[2] = -action[3];        if (isRevolve(3, 4)) action[4] = -action[3];        if (isRevolve(1, 2)) action[1] = -action[2];    } else {        action[4] = dir;        if (isRevolve(3, 4)) action[3] = -action[4];        if (isRevolve(2, 3)) action[2] = -action[3];        if (isRevolve(1, 2)) action[1] = -action[2];    }    return action;}void solve(int gear, int dir){    vector&lt;int&gt; action = getAction(gear, dir);    for (int i = 1; i &lt;= 4; i++) rotate(i, action[i]);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    for (int i = 1; i &lt;= 4; i++) {        string s;        cin &gt;&gt; s;        for (int j = 7; j &gt;= 0; j--) {            int mul = int(pow(2, 7-j));            int num = s[j]-'0';            state[i] += num*mul;        }    }    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        int gear, dir;        cin &gt;&gt; gear &gt;&gt; dir;        solve(gear, dir);    }    getScore();    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}Reference백준(14891번) - 톱니바퀴",
        
        "url": "/cs/algorithm/2020/04/25/%EB%B0%B1%EC%A4%80-%ED%86%B1%EB%8B%88%EB%B0%94%ED%80%B4.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-a4-91-ec-84-b1-ed-99-94-ec-97-ac-eb-b6-80-ed-8c-90-eb-8b-a8-ed-95-98-ea-b8-b0-html": {
        "title": "08: 중성화 여부 판단하기",
        "tags": "프로그래머스, sql",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : case when을 사용하는 문제이다.생각쿼리로 가져온 table에 대해서 추출을 진행할 때, 사용할 수 있는 테크닉이다. 이건 예제로 보는 것이 정확하다.CodeSELECT ANIMAL_ID, NAME,        CASE WHEN            (SEX_UPON_INTAKE LIKE \"Neutered%\" OR SEX_UPON_INTAKE LIKE \"Spayed%\") THEN \"O\"            ELSE \"X\"        END AS \"중성화\"    FROM ANIMAL_INS    ORDER BY ANIMAL_ID;Reference프로그래머스 - 중성화 여부 판단하기",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A4%91%EC%84%B1%ED%99%94-%EC%97%AC%EB%B6%80-%ED%8C%90%EB%8B%A8%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-9e-85-ec-96-91-ec-8b-9c-ea-b0-81-ea-b5-ac-ed-95-98-ea-b8-b0-2-html": {
        "title": "07: 입양 시각 구하기 2",
        "tags": "프로그래머스, sql",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level4 : 변수를 사용하는 문제이다.생각이 문제는 group by를 사용할 수 없다는 것이 핵심이다. group by 는 있는 값을 DISTINCT하게 판단하여 집합을 구성해주는 쿼리이다. 그런데 이 문제는 0~23의 범위에서의 count를 구하기 때문에 사용할 수가 없다.해결이 문제를 해결하기 위해서는 임의로 0에서 23까지의 범위를 만들고, 그 숫자에 따르는 개수를 파악하여 넣는 것이 효율적으로 보인다. 이런 방법을 sub Query라 부른다. 변수 선언 방법은 SET으로 한다.CodeSET @hour = -1;SELECT @hour := @hour + 1 AS \"HOUR\", (        SELECT COUNT(ANIMAL_ID) FROM ANIMAL_OUTS        WHERE @hour = HOUR(DATETIME)    ) AS \"COUNT\"    FROM ANIMAL_OUTS    WHERE @hour &lt; 23Reference프로그래머스 - 입양 시각 구하기 2",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9E%85%EC%96%91%EC%8B%9C%EA%B0%81-%EA%B5%AC%ED%95%98%EA%B8%B0-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-9a-b0-ec-9c-a0-ec-99-80-ec-9a-94-ea-b1-b0-ed-8a-b8-ea-b0-80-eb-8b-b4-ea-b8-b4-ec-9e-a5-eb-b0-94-ea-b5-ac-eb-8b-88-html": {
        "title": "06: 우유와 요거트가 담긴 장바구니",
        "tags": "프로그래머스, sql",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level4 : table을 분리하는 방법을 사용해보자.생각문제가 잘 안풀리면, 제공해주는 table을 분리하고, 그 분리한 table로 부터 원하는 결과를 도출해보자. 즉 sub query를 사용해서 임의로 table을 만드는 것.CodeSELECT A.CART_ID FROM    (SELECT CART_ID FROM CART_PRODUCTS WHERE NAME = \"우유\") A    INNER JOIN # 둘다 있는것만 가져옴    (SELECT CART_ID FROM CART_PRODUCTS WHERE NAME = \"요거트\") B    ON A.CART_ID = B.CART_IDReference프로그래머스 - 우유와 요거트가 담긴 장바구니",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9A%B0%EC%9C%A0%EC%99%80-%EC%9A%94%EA%B1%B0%ED%8A%B8%EA%B0%80-%EB%8B%B4%EA%B8%B4-%EC%9E%A5%EB%B0%94%EA%B5%AC%EB%8B%88.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-98-a4-eb-9e-9c-ec-8b-9c-ea-b0-84-eb-b3-b4-ed-98-b8-ed-95-9c-eb-8f-99-eb-ac-bc-html": {
        "title": "04: 오랜 기간 보호한 동물",
        "tags": "프로그래머스, sql",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level3 : join을 사용하는 문제이다.생각이 문제를 풀기 위해서는, join이라는 쿼리가 어떻게 돌아가는 지 알아야 한다. right join, left join등 다양한 join의 방법이 있지만, 일단 기본적으로 join을 하면 그냥 합쳐진다. 그것이 핵심이다.Join두 table을 합친다고 하면 어떻게 합칠 수 있을까? A의 table의 column과 B table의 column은 서로 다른 것으로 보아야 한다. 아니 애초에 왜 합칠까? 이것은 당연히 두 table의 어떠한 관계가 있기 때문이다. 엮을 수 있기 때문이다. 그렇다면 당연히 합친다는 행위에는 무엇을 기준으로 두 행을 합칠 것인가? 라는 질문이 들어야 한다. 이 값을 key라 한다.집합과 같은 개념으로 보면 오히려 조금 헷갈릴 수 있다. 차라리 join은 두 table을 말 그래도 합치는 것이고 column도 늘어난다. 다만 어떤 행을 서로 엮어줄 지에 대한 정보가 필요할 뿐.그렇게 생각하면 이 문제는 상당히 쉽다.풀이  보호소에 있는 테이블(in)을 A, 입양을 간 테이블(out)을 B라 하자.  현재 보호소에 있고 입양을 가진 않은 행을 골라야 한다.  그러기 위해서는 합치는 데 있어서 A를 기준으로 합쳐야 골라낼 수 있다.  그 다음 만들어지는 table에 있어서 B에는 없는 A행을 고른 후,  그 행에서 시간을 기준으로 오름차순으로 정렬한다.  그 중 3개를 뺀다.CodeSELECT A.NAME, A.DATETIME    FROM (ANIMAL_INS A LEFT JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID)    WHERE B.ANIMAL_ID is NULL    ORDER BY A.DATETIME ASC  # 가장 초기에 있던 녀석이 가장 오래있었음    LIMIT 3Reference프로그래머스 - 오랜 기간 보호한 동물",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%A4%EB%9E%9C%EC%8B%9C%EA%B0%84-%EB%B3%B4%ED%98%B8%ED%95%9C-%EB%8F%99%EB%AC%BC.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-98-a4-eb-9e-9c-ea-b8-b0-ea-b0-84-eb-b3-b4-ed-98-b8-ed-95-9c-eb-8f-99-eb-ac-bc-2-html": {
        "title": "03: 오랜 기간 보호한 동물 2",
        "tags": "프로그래머스, sql",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : limit을 사용하는 문제이다.생각가져온 table에 대해 제한을 걸어, 그 만큼의 행만 가져오게 하는 문제이다.CodeSELECT A.ANIMAL_ID, A.NAME    FROM (ANIMAL_INS A RIGHT JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID)        WHERE B.ANIMAL_ID is NOT NULL # 전처리 : 입양만 보낸 동물은 있을 수 없다.    ORDER BY (B.DATETIME - A.DATETIME) DESC    LIMIT 2;Reference프로그래머스 - 오랜 기간 보호한 동물 2",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%A4%EB%9E%9C-%EA%B8%B0%EA%B0%84-%EB%B3%B4%ED%98%B8%ED%95%9C-%EB%8F%99%EB%AC%BC-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ec-97-86-ec-96-b4-ec-a7-84-ea-b8-b0-eb-a1-9d-ec-b0-be-ea-b8-b0-html": {
        "title": "02: 없어진 기록 찾기",
        "tags": "프로그래머스, sql",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level3 : join을 사용하는 문제이다.생각이 문제를 풀기 위해서는, join이라는 쿼리가 어떻게 돌아가는 지 알아야 한다. right join, left join등 다양한 join의 방법이 있지만, 일단 기본적으로 join을 하면 그냥 합쳐진다. 그것이 핵심이다.Join두 table을 합친다고 하면 어떻게 합칠 수 있을까? A의 table의 column과 B table의 column은 서로 다른 것으로 보아야 한다. 아니 애초에 왜 합칠까? 이것은 당연히 두 table의 어떠한 관계가 있기 때문이다. 엮을 수 있기 때문이다. 그렇다면 당연히 합친다는 행위에는 무엇을 기준으로 두 행을 합칠 것인가? 라는 질문이 들어야 한다. 이 값을 key라 한다.집합과 같은 개념으로 보면 오히려 조금 헷갈릴 수 있다. 차라리 join은 두 table을 말 그래도 합치는 것이고 column도 늘어난다. 다만 어떤 행을 서로 엮어줄 지에 대한 정보가 필요할 뿐.그렇게 생각하면 이 문제는 상당히 쉽다.풀이  입양을 보낸 테이블(out)을 B, 입양이 온 테이블(in)을 A라 하자.  만약 입양을 보낸 행위가 발생하면, ANIMAL_ID은 두 테이블에 항상이 있어야 한다.  하지만 현재 B의 ANIMAL_ID만 존재하고 A는 공란이 발생한 상황이다.  따라서 ANIMAL_ID만 생각해보면 B가 더 큰 집합이다.  그렇다면 A를 B와 합쳐버리면, 우리가 얻을 수 있는 것은 보낸 것과 온 것을 하나의 Table로 조사할 수 있다.  그 중에서 B에는 ANIMAL_ID가 있지만 A에는 없다면 그 것이 문제가 발생한 행이다.  즉, 합쳤을 때, ANIMAL_ID가 B에는 존재하지만 A에는 존재하지 않는 B의 ANIMAL_ID가 답이다.CodeSELECT B.ANIMAL_ID, B.NAME    FROM (ANIMAL_INS A RIGHT JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID)    WHERE A.ANIMAL_ID IS NULL    ORDER BY B.ANIMAL_IDReference프로그래머스 - 없어진 기록 찾기",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%97%86%EC%96%B4%EC%A7%84-%EA%B8%B0%EB%A1%9D-%EC%B0%BE%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-eb-b3-b4-ed-98-b8-ec-86-8c-ec-97-90-ec-84-9c-ec-a4-91-ec-84-b1-ed-99-94-ed-95-9c-eb-8f-99-eb-ac-bc-html": {
        "title": "01: 보호소에서 중성화한 동물",
        "tags": "프로그래머스, sql",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level3 : join을 사용하는 문제이다.생각이 문제를 풀기 위해서는, join이라는 쿼리가 어떻게 돌아가는 지 알아야 한다. right join, left join등 다양한 join의 방법이 있지만, 일단 기본적으로 join을 하면 그냥 합쳐진다. 그것이 핵심이다.Join두 table을 합친다고 하면 어떻게 합칠 수 있을까? A의 table의 column과 B table의 column은 서로 다른 것으로 보아야 한다. 아니 애초에 왜 합칠까? 이것은 당연히 두 table의 어떠한 관계가 있기 때문이다. 엮을 수 있기 때문이다. 그렇다면 당연히 합친다는 행위에는 무엇을 기준으로 두 행을 합칠 것인가? 라는 질문이 들어야 한다. 이 값을 key라 한다.집합과 같은 개념으로 보면 오히려 조금 헷갈릴 수 있다. 차라리 join은 두 table을 말 그래도 합치는 것이고 column도 늘어난다. 다만 어떤 행을 서로 엮어줄 지에 대한 정보가 필요할 뿐.그렇게 생각하면 이 문제는 상당히 쉽다.검색  SELECT id,name FROM member WHERE name LIKE ‘김%’  김으로 시작하는 사람을 모두 조회  SELECT id,name FROM member WHERE name LIKE ‘%김’  김으로 끝나는 사람을 모두 조회  SELECT id,p_name FROM member WHERE p_name LIKE ‘%프린터%’  ‘프린터’ 가 들어가는 제품을 모두 조회  SELECT id,name FROM member WHERE name LIKE ‘김?’  ‘김’ + 외자인 사람을 모두 조회CodeSELECT A.ANIMAL_ID, A.ANIMAL_TYPE, A.NAME    FROM ANIMAL_INS A INNER JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID    WHERE A.SEX_UPON_INTAKE LIKE \"Intact%\"        AND (B.SEX_UPON_OUTCOME LIKE \"Spayed%\" OR B.SEX_UPON_OUTCOME LIKE \"Neutered%\")    ORDER BY A.ANIMAL_ID ASC;Reference프로그래머스 - 보호소에서 중성화한 동물",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%B3%B4%ED%98%B8%EC%86%8C%EC%97%90%EC%84%9C-%EC%A4%91%EC%84%B1%ED%99%94%ED%95%9C-%EB%8F%99%EB%AC%BC.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-datetime-ec-97-90-ec-84-9c-date-eb-a1-9c-ed-98-95-eb-b3-80-ed-99-98-html": {
        "title": "09: DATETIME에서 DATE로 형 변환",
        "tags": "프로그래머스, sql",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : 제곧내 이다.생각간단하다. 예시를 보고 외우던가 나중에 찾아보자.CodeSELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, \"%Y-%m-%d\") AS \"날짜\"    FROM ANIMAL_INS;Reference프로그래머스 - DATETIME에서 DATE로 형 변환",
        
        "url": "/cs/algorithm/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-DATETIME%EC%97%90%EC%84%9C-DATE%EB%A1%9C-%ED%98%95-%EB%B3%80%ED%99%98.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-eb-b0-b1-ec-a4-80-ec-88-ab-ec-9e-90-ec-b9-b4-eb-93-9c-2-html": {
        "title": "백준(10816번): 숫자카드 2",
        "tags": "백준, 알고리즘, 이분탐색",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버4 : 이분 탐색 문제이다.생각특정 숫자가 등장하는 lowerBound와 UpperBound를 잡아내면 끝나는 문제이다.LowerBound  원하는 숫자가 처음으로 등장하는 곳의 번째기본적인 이분 탐색은, 내가 탐색한 index를 포함하지 않은 상태로 다음 index를 탐색한다. 그리고 찾으면 return한다. 하지만, 이번에 우리가 할 것은, 해당 숫자의 범위를 탐색하는 것이기 때문에, 찾았다고 해서 탐색을 끝낼 수 없다. 다만, 내가 원하는 값과 같은 값이 있다면, 그 index는 답의 후보가 될 수 있다. 최종적인 답은 끝까지 탐색한 후에 도출되도록 만들어야 한다. 예시를 보자.0   1   2   3   4   5   6   7   8   9   10-10 -10 2   3   3   6   7   10  10  10  13정렬이 된 상태에서 10의 lowerBound를 찾아보자.#1start :  0 end : 11 mid :  5 a[5] :  6이 상황에서 답은 무조건 5보다 큰 index에서 나올 수 밖에 없다. 따라서 start = mid + 1 해준다.#2start :  6 end : 11 mid :  8 a[8] : 108의 index에서 찾는 값이 나왔다. 해당 index는 답의 후보이다. 그렇기 때문에 이것을 포함한 상태로 다음 값으로 넘어가야 한다. end = mid#3start :  6 end :  8 mid :  7 a[7] : 10또 후보값이 나왔다. 이 때 index가 더 작으면서 10을 만족하기 때문에 end = mid해준다.#4start :  6 end :  7 mid :  6 a[6] :  77보다 큰곳에서 10은 나온다. 따라서 start = mid + 1 해준다.#5start :  7 end :  7 mid :  7 a[7] :  10start와 end가 같아졌다. 원래 이분탐색과 다르게 이러한 조건 때문에 start = end인 상황에서 탐색을 계속할 수 없다. 같아지는 순간 종료한다.기본적인 이 알고리즘의 핵심은,  원하는 수를 찾는다.  원하는 수를 찾았으면 그 수를 end에 박아두고 계속 탐색한다.이렇게 압축할 수 있다. 만약 원하는 수가 없다면 어떻게 될까? 기본적으로 제시한 숫자의 value가 원하는 값보다 크거나 같을 경우, end = mid하기 때문에 없다면 원하는 값보다 큰 수중에서 가장 작은 수의 위치를 return할 것이다. 즉, 1 3 5 7에서 4를 찾는다면, 없기 때문에 lowerBound는 3(index = 2)를 리턴한다.Codeint lowerBound(int num){    int start = 0, end = N, mid = 0;    while (start &lt; end) {        mid = (start+end)/2;        if (a[mid] &lt; num) {            start = mid + 1;        } else {            end = mid;        }    }    return end + 1;}UpperBound  원하는 숫자보다 처음으로 크게되는 위치lowerBound와 다르게, 10을 찾는다면, 10보다 처음으로 크게되는 위치를 리턴하게 된다.이분 탐색으로부터 생각해보자. 원래 같으면 같을 때, 탈출하여 답을 제시한다. 하지만, 내가 원하는 것은 찾은 뒤에 어떠한 조치가 필요하다. 찾은 값은, lowerBound에서와 다르게, 답의 후보가 될 수 없다. 예를 들어, 내가 10이라는 값을 찾았다. 하지만 위에 정한 정의는 10을 찾은 것이 중요한 것이 아니고, 10보다 언제 처음으로 커지냐가 궁금하다. 따라서 찾았다면, 해당 제시한 위치는 답이 될 수 없다. 따라서 이 값을 포함하지 않고 탐색해야 한다. 예시를 보자.#1start :  0 end : 11 mid :  5 a[5] :  66은 10보다 작으므로 이 곳에서 답이 나올 수는 없다. start = mid + 1#2start :  6 end : 11 mid :  8 a[8] : 108위치에서 10이 나왔지만, 이 10은 내가 원하는 답이 아니다. start = mid + 1#3start :  9 end : 11 mid : 10 a[10] : 1310의 위치에서 13이 나왔고, 10의 upperBound는 이 값을 포함한 아래 영역에서 나온다. 따라서 해당 10 index는 포함한 상태로 탐색을 진행한다. end = mid#4start :  9 end : 10 mid :  9 a[9] : 109위치에서 10이 나왔지만, 이 10은 내가 원하는 답이 아니다. start = mid + 1#5start :  10 end : 10 mid :  10 a[10] : 13start = end가 되어 종료한다. upperBound는 10이다.결국, 어느 범위에서 답이 나타날 수 있는지를 명확하게 규명하는 것이 중요하다. upperBound도 lowerBound와 마찬가지로 탐색하는 값이 없다면 이 값보다 큰 수들 중 가장 작은 수의 위치를 리턴한다. 아, 잘 생각해야 하는 부분이 있는데, 탐색 범위를 0~N-1로 하면 안된다. 그렇게 될 경우, 맨 끝에 내가 찾고싶은 값이 있을 때, 원하는 index를 반환할 수 없다.1 10 10 10이런 경우에 10의 upperBound를 찾는다고 해보자. 정의에 의하면 답은 당연히 5이다. 하지만 내가 탐색을 진행할 때, start = 0, end = 3이라고 놓고 생각하면, 최종 탐색 결과는 3을 넘지 못하고 return 값은 1을 더한 4이다. 즉 절대로 4를 넘은 값이 나올 수가 없다. 위에 정의한 upperBound 정의의 일관성을 잃지 않기 위해서는 end의 index를 하나 늘려서 정해놓는 것이 바람직하다.Codeint upperBound(int num){    int start = 0, end = N, mid = 0;    while (start &lt; end) {        mid = (start+end)/2;        if (a[mid] &lt;= num) { // 등호만 다르다.            start = mid + 1;        } else {            end = mid;        }    }    return end + 1;}이 문제 해설이 문제는 해설할 것이 없다. 저 위에 설명한 것이 곧 답이다..Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;int N, M;int a[500001];int lowerBound(int num){    int start = 0, end = N, mid = 0;    while (start &lt; end) {        mid = (start+end)/2;        if (a[mid] &lt; num) {            start = mid + 1;        } else {            end = mid;        }    }    return end + 1;}int upperBound(int num){    int start = 0, end = N, mid = 0;    while (start &lt; end) {        mid = (start+end)/2;        if (a[mid] &lt;= num) {            start = mid + 1;        } else {            end = mid;        }    }    return end + 1;}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    sort(a, a+N);    cin &gt;&gt; M;    for (int i = 0; i &lt; M; i++) {        int num, ans = 0;        cin &gt;&gt; num;        int low = lowerBound(num);        int high = upperBound(num);        if (low != high) ans = high-low;        cout &lt;&lt; ans &lt;&lt; \" \";    }    return 0;}STL upperBound, lowerBound를 이용한 풀이#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;int N, M;int a[500001];int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    sort(a, a+N);    cin &gt;&gt; M;    for (int i = 0; i &lt; M; i++) {        ll num, ans = 0;        cin &gt;&gt; num;        ll low = lower_bound(a, a+N, num)-a;        ll high = upper_bound(a, a+N, num)-a;        if (low != high) ans = high-low;        cout &lt;&lt; ans &lt;&lt; \" \";    }    return 0;}Reference백준(10816번) - 숫자카드 2",
        
        "url": "/cs/algorithm/2020/04/24/%EB%B0%B1%EC%A4%80-%EC%88%AB%EC%9E%90%EC%B9%B4%EB%93%9C-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-eb-b0-b1-ec-a4-80-eb-9e-9c-ec-84-a0-ec-9e-90-eb-a5-b4-ea-b8-b0-html": {
        "title": "백준(1654번): 랜선 자르기",
        "tags": "백준, 알고리즘, 이분탐색, Parametric Search",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 이분 탐색 문제이다.생각이분 탐색 문제이다. 이전의 문제들과 마찬가지로, 값을 제시하고 그에 대한 분기를 만드는 것이 중요하다. 이 때, 어느 영역에서 답이 나오는지를 잘 체크하고, 답의 후보를 기록해두는 행위가 중요하다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;ll K, N;ll a[10001];ll f(ll sug){    ll count = 0;    for (int i = 0; i &lt; K; i++) {        count += (a[i]/sug);    }    return count;}int main(){    cin &gt;&gt; K &gt;&gt; N;    for (int i = 0; i &lt; K; i++) {        cin &gt;&gt; a[i];    }    sort(a, a+K);    ll start = 1, end = (1LL &lt;&lt; 31)-1, mid = 0, ans = -1;    while (start &lt;= end) {        mid = (start+end)/2;        ll count = f(mid);        if (count &lt; N) {            end = mid - 1;        } else {            ans = max(ans, mid);            start = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}Reference백준(1654번) - 랜선 자르기",
        
        "url": "/cs/algorithm/2020/04/24/%EB%B0%B1%EC%A4%80-%EB%9E%9C%EC%84%A0-%EC%9E%90%EB%A5%B4%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-eb-b0-b1-ec-a4-80-ea-b3-b5-ec-9c-a0-ea-b8-b0-ec-84-a4-ec-b9-98-html": {
        "title": "백준(2110번): 공유기 설치",
        "tags": "백준, 알고리즘, 이분탐색, Parametric Search",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 파라메트릭 서치 문제이다.생각파라메트릭 서치 문제이다. 일단 완전 탐색이 불가하고, 답을 제시했을 때 분기를 만들 수 있다는 점에서 바로 접근했다.  인접한 집간의 최대 거리를 제시한다.  제시한 거리를 보다 크거나 같은 곳에 공유기를 설치했을 때 몇개를 설치할 수 있는지를 반환한다.  그 반환한 값(즉 내가 제시한 거리로 공유기를 설치했을 때 대수)이 C와 어떤지 비교한다.  C보다 작다면 거리를 너무 크게 잡았으므로 거리를 줄여서 제시한다.  C보다 같거나 크다면 이 값은 후보가 될 수 있는 값이다. 후보인 이유는 지금 제시한 거리보다 큰 값에서 C와 같은 값이 나올 수 있기 때문에 더 탐색한다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;int N, C;int a[200000];int f(int num){    int count = 1;    int before = 0;    for (int i = 1; i &lt; N; i++) {        if (a[i]-a[before] &gt;= num) {            count++;            before = i;        }    }    return count;}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; C;    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    sort(a, a+N);    int start = 1, end = 1e9, ans = 0;    while (start &lt;= end) {        int mid = (start+end)/2;        int count = f(mid);        if (count &lt; C) {            end = mid - 1;        } else {            ans = max(ans, mid);            start = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}Reference백준(2110번) - 공유기 설치",
        
        "url": "/cs/algorithm/2020/04/24/%EB%B0%B1%EC%A4%80-%EA%B3%B5%EC%9C%A0%EA%B8%B0-%EC%84%A4%EC%B9%98.html"
      }
      ,
    
      "cs-algorithm-2020-04-24-eb-b0-b1-ec-a4-80-ea-b0-80-ec-9e-a5-ea-b8-b4-ec-a6-9d-ea-b0-80-ed-95-98-eb-8a-94-eb-b6-80-eb-b6-84-ec-88-98-ec-97-b4-2-html": {
        "title": "백준(12015번): 가장 긴 증가하는 부분 수열(LIS) 2",
        "tags": "백준, 알고리즘, 이분탐색",
        "date": "April 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드2 : 이분 탐색 문제이다.생각기존에 dp로 풀었던 문제가 데이터의 개수만 달라져 새로운 문제가 되었다. 이번 문제는 풀이를 좀 참고하였으며 새로운 공부를 할 수 있었다.이 문제는 먼저, 일반적인 dp문제로 풀수가 없다. dp로 풀기 위해서는, $O(n^2)$알고리즘인데, 그렇게 될 경우 n=1000000이라, 터진다. 따라서 시간 복잡도를 줄여야 한다. 그래서 방법을 달리한다.  현재 index까지 왔을 때, 가장 긴 증가하는 수열의 길이는 얼마인가?이것이 기존 dp로 풀었을 때 정의였다. 그런데 조금 색다르게, 배열을 하나 두고 이걸 만들어보자.a[] : 1 2 4 3#1    1#2    1 2#3    1 2 4$4    1 2 ?이 다음에 우리는 4번째 index에 있는 3을 추가해야 한다. 3까지 포함해 보았을 때, 가장 증가하는 수열의 길이는 1 2 4 혹은 1 2 3 으로 3이다. 여전히 값은 3이지만 지금 하는 과정은 증가하는 수열을 나타내는 배열을 만들어보는 중이다. 어떤 것을 선택하는 것이 바람직 할까?조금 생각해보면 1 2 3을 가지고 있는 것이 보다 현명하다. 결국 3을 1 2 4에서 추가하지 못하는 이유는 3이 4보다 작기 때문이다. 그리고 이 마지막 값은, 다음 요소에 대한 LIS를 구하는 데 있어 가장 핵심적인 숫자이다. 이 숫자가 가장 작은 숫자를 유지하면서 같은 LIS값을 갖는 것이 이후에 배열을 업데이트하는데 있어서 LIS를 구하는 것에 핵심적이다. 그래서 기본적으로는 내 요소를 포함하는 LIS를 만드는 것이 좋다. 따라서 이 상황에서 우리는 3보다 큰 요소 중 가장 첫번째에 나오는 요소와 3을 바꿔야 한다.그렇다면 여기서 만약 이렇게 주어졌다고 생각해보자.a[] : 1 2 3 2#1    1#2    1 2#3    1 2 3$4    1 2 ?여전히 같은 상황이다. 4번째 index인 2는 3보다 작기 때문에 추가할 수 없다. 그렇다면, 위의 논리대로라면 2는 3과 바꿔야 한다. 하지만 그럴 경우 1 2 2로 LIS에 합당하는 배열을 만들지 못한다. 실질적으로 4번째 index에서 LIS는 1 2 3 이다. 즉, 유지되어야 한다. 따라서, 우리는 2를 LIS에서 찾아 자기 자신과 바꾸는 작업을 해야 한다.(위의 작업과의 일관성을 위해 이렇게 설명. 사실은 바꾸지 않는다라는 표현이 맞을지 모름)lowerBound위의 두 문제를 다 만족하는 것이 있다. 바로 lowerBound이다. lowerBound는, 내가 원하는 값의 가장 하한선의 위치를 찾아주고(같은 것을 고를 수 있음), 내가 원하는 값이 없을 경우, 내 값보다 큰 원소 중 가장 첫번째로 나오는 요소의 위치를 반환한다. 이 두 기능은, 위에서 설명한 문제의 해결책과 동일하다. 따라서 우리는 이 함수를 사용할 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;const int MAX = 1000000;int N, ans = 0;int a[MAX+1];vector&lt;int&gt; v;void push(int num){    if (v.back() &lt; num) v.push_back(num);    else {        auto p = lower_bound(v.begin(), v.end(), num);        *p = num;    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];    v.push_back(MAX);    for (int i = 0; i &lt; N; i++) push(a[i]);    cout &lt;&lt; v.size() &lt;&lt; '\\n';    return 0;}Reference백준(12015번) - 공유기 설치",
        
        "url": "/cs/algorithm/2020/04/24/%EB%B0%B1%EC%A4%80-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-23-eb-b0-b1-ec-a4-80-ec-97-ac-ed-96-89-ea-b0-80-ec-9e-90-html": {
        "title": "백준(1976번): 여행가자",
        "tags": "백준, 알고리즘, Union-Find",
        "date": "April 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 유니온 파인드 문제이다.생각이 문제의 핵심은 갈 수 있는지 없는지를 판단하는 것이다. 처음에 그래프라고 생각하고 접근하니, dfs를 수행할 때 depth가 너무 깊어져 터질 것 같아 다른 방법으로 진행했다.갈 수 있는 지 없는 지를 판단하기 위해서 해당 문제에서 가장 중요한 조건은, 그래프의 방향성이 없다는 것이다. 방향성이 없기 때문에 일단 연결된 모든 노드들은 어떻게든 서로의 노드에 방문할 수 있다. 이 점이 핵심이다. 그렇기 때문에 우리는 특정 노드가 어디에 속해있는 지, 어느 그래프 묶음에 속해있는 지를 파악하는 것이 중요하다.유니온 파인드그렇다면 결국 어떠한 집합에 속해있는지를 판단해야 하는 문제로 바뀐다. 그 결과 이 문제는 유니온 파인드로 해결하는 것이 가장 간단해 보인다.(1, 2)이런식으로 연결되어 있다고 가정할 경우, 2의 노드의 조상을 1의 노드의 조상으로 업데이트 하는 방식을 사용했다.Code#include&lt;iostream&gt;using namespace std;int a[201];int find(int x) {   if (x == a[x]) return x;   return a[x] = find(a[x]);}void Union(int x, int y) {   x = find(x);   y = find(y);   a[x] = y;}int main(void) {   int n, m;   cin &gt;&gt; n &gt;&gt; m;   for (int i = 1; i &lt;= n; i++) {      a[i] = i;   }   for (int i = 1; i &lt;= n; i++) {      for (int j = 1; j &lt;= n; j++) {         int input;         cin &gt;&gt; input;         if (input) {            Union(i, j);         }      }   }   int route[1000], par;   for (int i = 0; i &lt; m; i++) {      cin &gt;&gt; route[i];      if (i == 0) {         par = find(route[i]);      }      else {         if (par != find(route[i])) {            cout &lt;&lt; \"NO\";            return 0;         }      }   }   cout &lt;&lt; \"YES\";}Reference백준(1976번) - 여행가자",
        
        "url": "/cs/algorithm/2020/04/23/%EB%B0%B1%EC%A4%80-%EC%97%AC%ED%96%89%EA%B0%80%EC%9E%90.html"
      }
      ,
    
      "cs-algorithm-2020-04-23-eb-b0-b1-ec-a4-80-k-eb-b2-88-ec-a7-b8-ec-88-98-html": {
        "title": "백준(1300번): K번째 수",
        "tags": "백준, 알고리즘, Parametric Search",
        "date": "April 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 유니온 파인드 문제이다.생각어려웠다. 여러가지 배열이 섞이고, 계산하는 방법을 생각하지 못했다. 이 문제를 풀면서 배운 것은, 정말 컴퓨터처럼(센다..) 생각해야 된다는 것.. 그리고 예시를 놓고, 이것을 실제로 써보면서 이상적으로 풀 생각을 하지말고 try &amp; modify 하는 것이다. 너무 뼈저리게 느꼈다..그래서, 지금부터 써보겠다. 이 문제에서 고려해야 하는 점은 크게 2가지 이다.센다.이분 탐색으로 풀린다는 것은 알았으나, K번째 수가 N이라고 제안한 이후에, 어떻게 K번째 수인지를 도출할 것인지에 대한 고민이 많았다. 즉, 제안한 숫자에 대해 이 숫자가 몇번째 수인지를 output으로 내놓을 함수를 짜야한다. 처음에 이것은, 제안한 숫자에 대한 제곱수를 찾아 필요없는 수를 제끼고..이런 방법으로 하려고 했는데, 컴퓨터는 정말 단순하게 생각하는 것이 핵심인 것 같다.   1   2   3   4   5   6   7   8   9  10   2   4   6   8  10  12  14  16  18  20   3   6   9  12  15  18  21  24  27  30   4   8  12  16  20  24  28  32  36  40   5  10  15  20  25  30  35  40  45  50   6  12  18  24  30  36  42  48  54  60   7  14  21  28  35  42  49  56  63  70   8  16  24  32  40  48  56  64  72  80   9  18  27  36  45  54  63  72  81  90  10  20  30  40  50  60  70  80  90 100내가 만약, 25라는 숫자를 제안했다고 하자. 그렇다면, 1번째 행에서 부터, 이 숫자보다 작은 것이 몇개있는 지를 센다. 그렇다면 10이다. 3번째 열에서는 8이다. 이 숫자들은, i번째 행의 숫자로 제시한 숫자를 나눈 몫으로 가능하다. 이 문제가 쉬운 이유이다. 그렇기 때문에 내가 제안한 숫자의 번째 수를 계산하는 것은 $O(N)$에 가능하다.ll f(ll num){    ll count = 0, numbering, current = 0;    for (int i = 1; i &lt;= N; i++) {        if (num/i &gt; N) {            numbering = N;            current = i * N;        } else {            numbering = num/i;            current = num/i * i;        }        count += numbering;    }    return count;}이 과정을 N이 3일 때 정리해보면 다음과 같다. 1 2 3 2 4 6 3 6 9 제시하는 숫자 : 1 2 3 4 5 6 7 8 9 count      : 1 3 5 6 6 8 8 8 9어떤 것이 답인가? 1 2 3 2 4 6 3 6 9 제시하는 숫자 : 1 2 3 4 5 6 7 8 9 count 함수  : 1 3 5 6 6 8 8 8 9 B[]        : 1 2 2 3 3 4 6 6 9 번째 수      : 1 2 3 4 5 6 7 8 9하지만 이렇게 되면 조금 문제가 발생한다. 원하는 K가 8, 즉 8번째 수라면 7을 제안해도 8, 6을 제안해도 8, 8을 제안해도 8이다. 그런데, 7을 제안하면 A배열에 없기 때문에 답이 아니다. 또한, K가 7일 경우, count함수를 통과시켜 나온 리턴 값에는 7이 없다. 하지만 7번째 수는 분명히 존재한다.이 문제는 숫자가 연속적으로 나열된 문제가 아니기 때문에, 특정 숫자에 대한 번째만이 존재한다. 다시 말하면 6이라는 숫자는 실제 B배열에서 7번째, 8번째 숫자이지만, 7이라는 숫자는 A배열에 없기 때문에 N번째 숫자라는 개념 자체가 불가능 하다. 즉, 7이라는 숫자를 제안했을 때, A배열에서 있다고 가정하고 숫자를 세면, 6을 세었을 때와 같은 count가 나오나, 7이라는 숫자가 없기 때문에 답이 아니다.숫자의 범위 때문에, 답을 제시하는 방법을 사용하긴 해야한다. 그렇다면 어떻게 A배열에 있으면서, 원하는 K번째가 있는 수를 제시할 수 있을까?K보다 count가 큰 녀석은 답의 후보이다.이것을 알기 위해서, 일단 이분 탐색이 맞다하고 생각을 해보자.1 2 32 4 63 6 9K = 7제시하는 숫자 : 1 2 3 4 5 6 7 8 9count 함수  : 1 3 5 6 6 8 8 8 9B[]        : 1 2 2 3 3 4 6 6 9번째 수      : 1 2 3 4 5 6 7 8 9start : 1  end : 9  제시 : 5start : 6  end : 9  제시 : 7start : 6  end : 6  제시 : 6K = 7인 상황에서 생각해보자. 먼저 (1+9)/2 = 5를 제안한다. 이 때의 함수 통과 값은 6이므로, K보다 작다. 따라서 값을 올려 제안한다.이번엔 (6+9)/2 = 7을 제안한다. 이 경우 함수 통과 값은 8이다. K보다 작다. 따라서 제시하는 값을 낮춘다.마지막으로 (6+6)/2 = 6를 탐색한다. 이 경우 count는 8이다. 그리고 나서 L, R가 역전되므로 끝난다. 하지만 답은 찾았다. 6이다.즉, count가 굳이 K와 같지 않더라도 답을 구할 수 있다.이 부분을 잘 생각해보자.7을 세었을 때와 6을 세었을 때, 같은 번째 수(8)라는 결론이 나오나, 우리는 8이라는 숫자가 처음 등장하는 숫자를 답으로 제안해야 한다. 7을 제안했을 때, 8이 나오는 이유는, 7이라는 숫자가 A배열에 없기 때문이다. 실제로 있는 수는, count함수를 돌렸을 때, 처음으로 8이라는 숫자가 나오는 경우, 해당 숫자를 A배열에 있는 수라고 생각할 수 있다. (잘 생각해보자.) 그렇기 때문에, 우리는 이분 탐색의 분기를 다음과 같이 정해야 한다.  count가 K보다 작다.          이 구간에는 답이 존재할 수 없으므로 더 큰 값을 탐색한다.        count가 K보다 크다.          이 구간에는 답이 존재할 수 있다. 그렇기 때문에 이 때 제시한 값은 답의 후보로 채택한다.      그리고, count가 K와 같은 구간을 찾기 위해 더 작은 값을 탐색한다.      이 과정을 거치게 되면서 우리가 하는 과정은, 최대한 K와 같은 값을 찾는다 이다.이러한 방법은 곧, 같은 count값이 나오더라도, 그 같은 count값이 처음으로 등장하는 수를 답으로 채택한다. 라는 의미와 일치한다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;using namespace std;typedef long long ll;ll MAX_NUM = 10000000000;ll N, K;ll f(ll num){    ll count = 0, numbering, current = 0;    for (int i = 1; i &lt;= N; i++) {        if (num/i &gt; N) {            numbering = N;            current = i * N;        } else {            numbering = num/i;            current = num/i * i;        }        count += numbering;    }    return count;}int main(){    cin &gt;&gt; N &gt;&gt; K;    ll ans = 0;    ll start = 1, end = min(MAX_NUM, N*N);    while (start &lt;= end) {        ll mid = (start+end)/2;        ll count = f(mid);        if (count &lt; K) {            start = mid+1;        } else {            ans = mid;            end = mid-1;        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';}Reference백준(1300번) - 여행가자",
        
        "url": "/cs/algorithm/2020/04/23/%EB%B0%B1%EC%A4%80-K%EB%B2%88%EC%A7%B8-%EC%88%98.html"
      }
      ,
    
      "dv-c-2020-04-20-testcase-ec-97-90-ec-a2-85-eb-a3-8c-ec-a1-b0-ea-b1-b4-ec-9d-b4-ec-97-86-eb-8a-94-ea-b2-bd-ec-9a-b0-html": {
        "title": "testcase에 종료 조건이 없는 경우",
        "tags": "c++, 입출력",
        "date": "April 20, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "Codeint main(){    while(cin &gt;&gt; a &gt;&gt; b){        // 동작    }    return 0;}cin역시 함수이기 때문에, 입력이 제대로 들어오면 1을 return한다. 그리고 입력이 들어오지 않았을 때는 0을 return한다.",
        
        "url": "/dv/c++/2020/04/20/testcase%EC%97%90-%EC%A2%85%EB%A3%8C%EC%A1%B0%EA%B1%B4%EC%9D%B4-%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-20-eb-b0-b1-ec-a4-80-eb-a1-9c-eb-b4-87-ec-b2-ad-ec-86-8c-ea-b8-b0-html": {
        "title": "백준(4991번): 로봇 청소기",
        "tags": "백준, 알고리즘, Graph",
        "date": "April 20, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 그래프 문제이다.생각현재 시작 위치에서 다음 쓰레기를 치우고, 그 위치에서 다시 다음 경로를 탐색하는 과정으로 문제를 풀려 했다. 하지만 코드를 짜면서도 탐색과정이 계속하여 중복되서 어떻게 풀어야 할지 고민을 많이했다.시간 초과 Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;#define INF 999999999using namespace std;typedef pair&lt;int, int&gt; PI;int W, H;char map[21][21];int check[21][21];int dy[4] = {0, -1, 0, 1}, dx[4] = {1, 0, -1, 0};int ans;vector&lt;PI&gt; trash;PI start;void printMap(){    cout &lt;&lt; \"Map\" &lt;&lt; '\\n';    for (int i = 0; i &lt; H; i++) {        for (int j = 0; j &lt; W; j++) {            cout &lt;&lt; map[i][j];        }cout &lt;&lt; '\\n' &lt;&lt; '\\n';    }}void printCheck(){    cout &lt;&lt; \"Check\" &lt;&lt; '\\n';    for (int i = 0; i &lt; H; i++) {        for (int j = 0; j &lt; W; j++) {            cout &lt;&lt; setw(3) &lt;&lt;check[i][j];        }cout &lt;&lt; '\\n' &lt;&lt; '\\n';    }}void bfs(PI start){    memset(check, -1, sizeof(check));    queue&lt;pair&lt;PI, int&gt;&gt; q;    q.push(make_pair(start, 0));    check[start.first][start.second] = 0;    while (!q.empty()) {        int now_y = q.front().first.first, now_x = q.front().first.second;        int count = q.front().second;        q.pop();        count++;        for (int i = 0; i &lt; 4; i++) {            int next_y = now_y + dy[i], next_x = now_x + dx[i];            if (0 &lt;= next_y &amp;&amp; next_y &lt; H &amp;&amp; 0 &lt;= next_x &amp;&amp; next_x &lt; W &amp;&amp; map[next_y][next_x] != 'x') {                if (check[next_y][next_x] == -1) {                    q.push(make_pair(make_pair(next_y, next_x), count));                    check[next_y][next_x] = count;                }            }        }    }//    printCheck();}void go(int depth, PI start, int count){//    printMap();    if (depth == trash.size()) {        ans = min(ans, count);        return;    }//    memset(check, 0, sizeof(check));    for (int i = 0; i &lt; trash.size(); i++) {        int now_y = trash[i].first, now_x = trash[i].second;        if (map[now_y][now_x] == '*'){            bfs(start);            if (check[now_y][now_x] != 0) {                map[start.first][start.second] = '.';                map[now_y][now_x] = 'o';                go(depth+1, trash[i], count+check[now_y][now_x]);                map[now_y][now_x] = '*';                map[start.first][start.second] = 'o';            }        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    while (true) {        cin &gt;&gt; W &gt;&gt; H;        ans = INF;        trash.clear();        if (W == 0 &amp;&amp; H == 0) {            return 0;        }        for (int i = 0; i &lt; H; i++) {            for (int j = 0; j &lt; W; j++) {                cin &gt;&gt; map[i][j];                if (map[i][j] == 'o') {                    start = make_pair(i, j);                }                if (map[i][j] == '*') {                    trash.push_back(make_pair(i, j));                }            }        }        go(0, start, 0);        if (ans == INF) {            cout &lt;&lt; -1 &lt;&lt; '\\n';        } else {            cout &lt;&lt; ans &lt;&lt; '\\n';        }    }}그 결과 시간초과가 났다. 그래서 다른 방법을 고민했다.그래프o 역시 쓰레기로 본다면 다음과 같은 그림으로 볼 수 있다.결국, 0번 위치에서 시작하여 나머지 노드들을 전부 순회했을 때, 최소이동 거리를 구하는 문제이다. 이렇게 문제를 모델링할 경우 노드간의 거리를 구하는 과정을 1번만 수행하면 되기 때문에 위에 있는 코드보다 연산이 줄어든다.7 5........o...*.........*...*........  0  4  2  6  4  0  6  2  2  6  0  4  6  2  4  0해당 입력에 대해 노드와 간선을 구하면 다음과 같이 구해진다. 이제 부터 해야할 일은 0번 부터 출발하여 어떤 순서로 이를 순회할지에 대한 문제이다.  0  1  2  3  0  1  3  2  0  2  1  3  0  2  3  1  0  3  1  2  0  3  2  1순회하는 방법은 다음과 같이 순열로 구성된다. 0-&gt;1-&gt;2-&gt;3과 같은 방향으로 갔을 때, 이동거리의 최솟값을 구하면 된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;functional&gt;#define INF 999999999using namespace std;typedef pair&lt;int, int&gt; PI;int N, M;char map[21][21];int check[21][21];int node[11][11];int dy[4] = {0, -1, 0, 1}, dx[4] = {1, 0, -1, 0};vector&lt;PI&gt; trash;int ans;void printCheck(){    cout &lt;&lt; \"Check\" &lt;&lt; '\\n';    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt; M; j++) {            cout &lt;&lt; setw(3) &lt;&lt; check[i][j];        }cout &lt;&lt; '\\n' &lt;&lt; '\\n';    }}void printNode(){    for (int i = 0; i &lt; trash.size(); i++) {        for (int j = 0; j &lt; trash.size(); j++) {            cout &lt;&lt; setw(3) &lt;&lt; node[i][j];        }cout &lt;&lt; '\\n';    }}void bfs(PI start){    queue&lt;PI&gt; q;    q.push(start);    check[q.front().first][q.front().second] = 0;    while (!q.empty()) {        int now_y = q.front().first, now_x = q.front().second;        q.pop();        int count = check[now_y][now_x];        for (int i = 0; i &lt; 4; i++) {            int next_y = now_y + dy[i], next_x = now_x + dx[i];            if (0 &lt;= next_y &amp;&amp; next_y &lt; N &amp;&amp; 0 &lt;= next_x &amp;&amp; next_x &lt; M &amp;&amp; map[next_y][next_x] != 'x') {                if (check[next_y][next_x] == -1) {                    check[next_y][next_x] = count+1;                    q.push(make_pair(next_y, next_x));//                    printCheck();                }            }        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    while (true) {        cin &gt;&gt; M &gt;&gt; N;        // 사용하는 배열 초기화        trash.clear();        ans = INF;        memset(node, 0, sizeof(node));        if (M == 0 &amp;&amp; N == 0) return 0; // 종료 조건        for (int i = 0; i &lt; N; i++) {            for (int j = 0; j &lt; M; j++) {                cin &gt;&gt; map[i][j];                if (map[i][j] == 'o') trash.insert(trash.begin(), make_pair(i, j)); // 시작 위치는 0에 고정                if (map[i][j] == '*') trash.push_back(make_pair(i, j));            }        }        for (int i = 0; i &lt; trash.size(); i++) {            memset(check, -1, sizeof(check));            bfs(trash[i]);            for (int j = i; j &lt; trash.size(); j++) {                node[i][j] = check[trash[j].first][trash[j].second];                node[j][i] = check[trash[j].first][trash[j].second];            }        }//        printNode();        vector&lt;int&gt; p; // 순열을 위한 배열 생성        for (int i = 1; i &lt; trash.size(); i++) p.push_back(i);        do{            p.insert(p.begin(), 0); // 시작 위치 추가            int localAns = 0;            for (int i = 0; i &lt; p.size()-1; i++) {                localAns += node[p[i]][p[i+1]];                if (node[p[i]][p[i+1]] == -1) {                    ans = -1;                    break;                }            }            ans = min(ans, localAns);            p.erase(p.begin()); // 시작 위치 삭제        }while(next_permutation(p.begin(), p.end()));        cout &lt;&lt; ans &lt;&lt; '\\n';    }    return 0;}Traveling Salesman problem (TSP)이런 문제는 결국 모든 지점을 지나는데 걸리는 최소 거리를 묻는 문제이다. 이러한 문제는 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 비슷한 문제로는 백준(2098번) - 외판원 순회가 있다.Reference백준(4991번) - 로봇 청소기",
        
        "url": "/cs/algorithm/2020/04/20/%EB%B0%B1%EC%A4%80-%EB%A1%9C%EB%B4%87-%EC%B2%AD%EC%86%8C%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-19-eb-b0-b1-ec-a4-80-ec-b5-9c-ec-86-9f-ea-b0-92-ec-b0-be-ea-b8-b0-html": {
        "title": "백준(11003번): 최솟값 찾기",
        "tags": "백준, 알고리즘, 슬라이딩윈도우",
        "date": "April 19, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플래티넘5 : 슬라이딩 윈도우 문제이다.생각N이 500만이라 세그먼트 트리로 풀면 터진다.  세그먼트 트리를 만드는데 드는 시간          nlogn = 대략 22 * 5000000 = 110000000        쿼리를 보는데 드는 시간          nlogn        2nlogn그런데 재귀이기 때문에 간당간당하다. 실제로 재귀로 풀면 터지고 비재귀로 풀면 들어온다고 한다. 해당 문제는 세그먼트 트리보다 간단한 구현을 원하는 듯하다.문제는 간단하다. N개의 수가 들어왔을 때, L의 윈도우에서 최솟값을 차례대로 구하면 된다.이 때 문제는, 10개의 원소가 있을 때 L이 3이라 가정하면, 순서대로 이 윈도우에 해당하는 최솟값을 구하면 되는데, 계속해서 다음 윈도우와 겹치는 부분이 발생한다는 것이다. 결국 중복이 발생하고, 이부분에서 오래 걸린다.문제를 해결하는 방법은 그리디이다. 즉, 윈도우 내에서 최솟값을 구하는 데에는 어떠한 정답이 존재한다.Sliding Windowinput 배열, deque, result 세개의 구조가 필요하다.위 동영상은 sliding window를 통해 max 값을 찾는 방법을 소개하고 있다. 이 방법의 핵심은 sliding window에서 감소하는 부분 수열을 찾는 것이다. 답은 감소하는 부분 수열에서 나올 수 밖에 없다. 내가 이 수열을 만들 수 있다면, 그 수열에서 가장 첫번째 값이 무조건 답이다.그렇다면 고민해야 하는 부분은, window가 이동할 때, 어떤식으로 업데이트가 이루어져야 하냐는 점이다. 감소하는 부분 수열을 만들기 위해서 우리가 고려해야 하는 부분은 감소하는 부분 수열의 양단이다.입력이 8, 6, 2가 들어왔을 때를 생각해보자. 첫번째 window에서 최대 감소 수열을 구하면 위와 같다.이 상황에서 다음 window로 넘어가는 과정에, 2보다 작은 수가 들어왔다고 생각해보자. 그러면 맨 앞에 있는 8을 빼고, 1을 그냥 뒤에 추가하면 된다. 그리고 이 윈도우에서 최댓값은 여전히 맨 앞에 있는 요소이다.그런데 같은 상황에서 이번에는 5가 들어왔다고 생각해보자. 그렇다면 이 window에서 최대 감소 수열은 변경된다. 맨 앞에 있는 요소는 여전히 빠지지만, window 내의 감소 수열은 위와 같이 변경되야 한다. 여전히 최댓값은 맨 앞의 요소이다.Pop을 하는 과정에서 중요한 것이 있다. 무조건적으로 맨 앞에 있는 요소를 빼면 안된다. deq에 들어가 있는 것은 최대 감소수열을 가리키는 index이다. window가 이동하면서 제거되는 index가 deq에 들어가있는 첫번째 요소의 index와 같을 때 deq안의 원소를 지워줘야 한다. 그렇지 않을 경우 해당 요소는 여전히 넘어가는 window안에 있기 때문에 지워지면 안되는 값이다.결론  window내에서 최대 감소 수열을 만들었을 때 최댓값은 맨 앞 요소이다.  window가 이동 할 때, 업데이트 방식이 존재한다.  이런 방법을 사용했을 때, 시간 복잡도는 N이다.이런 방법을 사용하면 결국 한번의 탐색과정과 동시에 모든 윈도우에서 최댓값을 구할 수 있다. 그렇다면 최솟값 찾기에 이 방법을 도입해보자.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;int N, L;vector&lt;int&gt; v;list&lt;int&gt; deq;void pop_front(int index){    // 증가하는 수열의 맨 첫번째가 지금 윈도우의 시작점과 같다면 이동하면서 빼준다.    // 만약 아니라면 그 값을 빼주면 안된다!    if (!deq.empty() &amp;&amp; deq.front() == index) {        deq.pop_front();    }}void push_back(int index){    // 현재 새로들어온 index보다 작은 이전의 녀석들은 증가하는 수열에서 제거해준다.    while (!deq.empty() &amp;&amp; v[deq.back()] &gt; v[index]) {        deq.pop_back();    }    deq.push_back(index);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; L;    v.resize(N+1);    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; v[i];    for (int i = 1; i &lt;= N; i++) {        push_back(i);        cout &lt;&lt; v[deq.front()] &lt;&lt; ' ';        // 시작할 때 window size보다 작은 index는 pop을 하지않고 넣어준다.        if (i - L &gt;= 0) {            pop_front(i - L + 1);        }    }}Reference백준(11003번) - 최솟값 찾기",
        
        "url": "/cs/algorithm/2020/04/19/%EB%B0%B1%EC%A4%80-%EC%B5%9C%EC%86%9F%EA%B0%92-%EC%B0%BE%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-19-eb-b0-b1-ec-a4-80-eb-b3-bc-eb-a1-9d-ea-bb-8d-ec-a7-88-html": {
        "title": "백준(1708번): 볼록 껍질",
        "tags": "백준, 알고리즘, 기하",
        "date": "April 19, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드1 : 기하 문제이다.생각볼록 껍질, Convex Hull이라 한다. 이 알고리즘에서 유명한 것을 그라함 스캔 알고리즘인데, 해당 동영상을 봐보자.이것과 같은 알고리즘을 구현하기 위해서는 다음과 같은 절차를 거쳐야 한다.  가장 y가 작은 점을 구한다.  그 점을 기준으로 직선의 각을 기준으로 정렬한다.  각이 가장 작은 점부터 조사하면서 볼록 껍질인지 아닌지 확인하고 추가한다.이 때, 각을 기준으로 정렬을 수행해야 하는데, 각은 double 형이라 이를 정렬하는데 좋지 않다. 일단 구하기도 어렵고 같은 선상에 있을 때 골치가 아프다..그래서 이 때 각을 대변해 줄 수 있는 다른 지표로 외적의 부호를 사용한다. 이 부분이 달달한 부분인데, 외적의 값은 x, y축을 기저로 보았을 때, 시계 방향, 반시계 방향을 대변해 준다. 이 때, 특정 두 점과의 외적을 수행하면 서로의 상대적 위치를 알 수 있다.이 연산을 점들을 각 순서로 정렬하는 비교 연산으로 사용하자.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;struct Point{    ll x, y;};vector&lt;Point&gt; p;int N;ll ccw(Point p1, Point p2, Point p3){    return p1.x*p2.y + p2.x*p3.y + p3.x*p1.y - (p2.x*p1.y + p3.x*p2.y + p1.x*p3.y);}bool compareMinelement(Point p1, Point p2){    if (p1.y == p2.y) return p1.x &lt; p2.x;    else return p1.y &lt; p2.y;}bool compareCCW(Point p1, Point p2){    ll cp = ccw(p[0], p1, p2);    if (cp == 0) return (p1.x + p1.y) &lt; (p2.x + p2.y);    return cp &gt; 0;}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    p.resize(N);    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;    }    sort(p.begin(), p.end(), compareMinelement);    sort(p.begin()+1, p.end(), compareCCW);    vector&lt;Point&gt; v;    v.push_back(p[0]);    v.push_back(p[1]);    // 이 for문은 세점 중 가장 바깥쪽 점을 의미    for (int i = 2; i &lt; N; i++) {        // 볼록을 찾을 때까지 계속 진행        while (v.size() &gt;= 2) {            // 두개를 본다.            Point p2 = v.back();            v.pop_back();            Point p1 = v.back();            // ccw이면 중간에 있는 점(p2)를 확인된 점으로 판단하고 스택에 넣는다.            if (ccw(p1, p2, p[i]) &gt; 0) {                v.push_back(p2);                break;            }            // ccw가 아니면 p2를 추가하지 말고 p2이전의 2점과 현재 p[i]와 ccw인지 비교한다. (처음으로 돌아간다)        }        // while문을 통과했다면 점이 추가가 된 것이므로 현재 탐색하는 가장 바깥쪽 점도 넣어준다.        v.push_back(p[i]);    }    cout &lt;&lt; v.size() &lt;&lt;  '\\n';}보다 깔끔한 Convex Hull Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;struct Point {   ll x, y;   Point(ll a, ll b) :x(a), y(b) {};   Point() {};   bool operator&lt;(const Point &amp;rhs) const {      if (x != rhs.x) return x &lt; rhs.x;      return y &lt; rhs.y;   }};vector&lt;Point&gt; point;ll ccw(Point pt1, Point pt2, Point pt3) {   ll ret = pt1.x*pt2.y + pt2.x*pt3.y + pt3.x*pt1.y;   ret -= (pt2.x*pt1.y + pt3.x*pt2.y + pt1.x*pt3.y);   return ret;}ll dist(Point pt1, Point pt2) {   ll dx = pt2.x - pt1.x;   ll dy = pt2.y - pt1.y;   return dx * dx + dy * dy;}int main(){    int N;    cin &gt;&gt; N;    point.resize(N);    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; point[i].x &gt;&gt; point[i].y;    }    vector&lt;Point&gt; hull;    swap(point[0], *min_element(point.begin(), point.end()));    sort(point.begin() + 1, point.end(), [](Point x, Point y) {       ll cw = ccw(point[0], x, y);       if (cw == 0) return dist(point[0], x) &lt; dist(point[0], y);       return cw &gt; 0;    });    for (auto i : point) {        // hull의 뒤에서 2번째 값, 1번째 값, 그리고 point의 3번째 값을 비교하여        // 반시계가 아니면 hull의 맨 뒤의 점을 뺀다.        // 반시계이면 해당 점을 포함한 상태로 다음점을 비교한다.       while (hull.size() &gt;= 2 &amp;&amp; ccw(hull[hull.size() - 2], hull.back(), i) &lt;= 0) {          hull.pop_back();       }       hull.push_back(i);    }    cout &lt;&lt; hull.size() &lt;&lt; endl;}Reference백준(1708번) - 볼록 껍질",
        
        "url": "/cs/algorithm/2020/04/19/%EB%B0%B1%EC%A4%80-%EB%B3%BC%EB%A1%9D-%EA%BB%8D%EC%A7%88.html"
      }
      ,
    
      "cs-algorithm-2020-04-19-eb-b0-b1-ec-a4-80-ea-b0-80-ec-9e-a5-ea-b8-b4-ec-a6-9d-ea-b0-80-ed-95-98-eb-8a-94-eb-b6-80-eb-b6-84-ec-88-98-ec-97-b4-4-html": {
        "title": "백준(14002번): 가장 긴 증가하는 부분 수열 4",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 19, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 동적 계획법 문제이다.생각전형적인 dp 문제이다. 다만 이 문제는, 경로를 추적해야 한다는 점에서 조금 다르다. 경로를 추적하는 방법으로는 dp를 미리 구해놓고, 이것을 역으로 추적하여 구하는 방법이 가장 간단하다.정의  dp[i] = i번째 수까지 포함했을 때 가장 긴 증가하는 부분 수열의 길이점화식  dp[i] = max(dp[i], dp[j] + 1) 단, a[i] &gt; a[j]일 때Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;cmath&gt;#include&lt;functional&gt;using namespace std;int N;int a[1001];int dp[1001];vector&lt;int&gt; trace;void tracing(int index){    trace.push_back(a[index]);    if (dp[index] == 1) return;    for (int i = index-1; i &gt; 0; i--) {        if (dp[index] == dp[i] + 1 &amp;&amp; a[index] &gt; a[i]){            tracing(i);            break;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; a[i];    }    fill(dp, dp+N+1, 1);    for (int i = 1; i &lt;= N; i++) {        for (int j = i; j &gt; 0; j--) {            if (a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + 1);        }    }    int max = dp[N], maxIdx = N;    for (int i = N; i &gt; 0; i--) {        if (max &lt; dp[i]) {            max = dp[i];            maxIdx = i;        }    }    tracing(maxIdx);    cout &lt;&lt; max &lt;&lt; endl;    for (int i = int(trace.size())-1; i &gt;= 0; i--) {        cout &lt;&lt; trace[i] &lt;&lt; ' ';    }    return 0;}Reference백준(14002번) - 가장 긴 증가하는 부분 수열 4",
        
        "url": "/cs/algorithm/2020/04/19/%EB%B0%B1%EC%A4%80-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-4.html"
      }
      ,
    
      "cs-algorithm-2020-04-19-eb-b0-b1-ec-a4-80-1-eb-a1-9c-eb-a7-8c-eb-93-a4-ea-b8-b0-2-html": {
        "title": "백준(12852번): 1로 만들기 2",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 19, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획법 문제이다.생각전형적인 dp 문제이다. 다만 이 문제는, 경로를 추적해야 한다는 점에서 조금 다르다. 경로를 추적하는 방법으로는 dp를 미리 구해놓고, 이것을 역으로 추적하여 구하는 방법이 가장 간단하다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;cmath&gt;#include&lt;functional&gt;using namespace std;int N;int dp[1000001];vector&lt;int&gt; trace;void tracing(int num){    trace.push_back(num);    if (num == 1) return;    int before = num-1;    if (num%3 == 0) {        if (dp[before] &gt; dp[num/3]) before = num/3;    }    if(num%2 == 0) {        if (dp[before] &gt; dp[num/2]) before = num/2;    }    tracing(before);}int main(){    cin &gt;&gt; N;    dp[0] = 987654321;    for (int i = 2; i &lt;= N; i++) {        dp[i] = dp[i-1] + 1;        if (i%3 == 0) {            dp[i] = min(dp[i], dp[i/3]+1);        }        if (i%2 == 0){            dp[i] = min(dp[i], dp[i/2]+1);        }    }    tracing(N);    cout &lt;&lt; dp[N] &lt;&lt; endl;    for (int i = 0; i &lt; trace.size(); i++) {        cout &lt;&lt; trace[i] &lt;&lt; ' ';    }    return 0;}Reference백준(12852번) - 1로 만들기 2",
        
        "url": "/cs/algorithm/2020/04/19/%EB%B0%B1%EC%A4%80-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-2.html"
      }
      ,
    
      "cs-algorithm-2020-04-17-eb-b0-b1-ec-a4-80-ed-8f-89-eb-b2-94-ed-95-9c-eb-b0-b0-eb-82-ad-html": {
        "title": "백준(12865번): 평범한 배낭",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 17, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드5 : 동적 계획법 문제이다.생각결국 무게 제약이 있는 문제이다. 나는 이 문제를 풀 때 감을 잡기 참어려웠는데, 무게에 제약이 있다는 점을 갖고 완전 탐색을 한다는 아이디어를 가지고 생각했다. 완전 탐색을 곧이곧대로 하려면 $O(n!)$ 의 시간 복잡도가 생겨 풀기 어렵다. 그렇기 때문에 이 문제는 다이나믹으로 접근한다.다이나믹으로 접근하면, 작은 문제를 정의하고 이것이 큰 문제에 어떠한 영향을 주는 지를 확인해야 한다.정의  dp[i][j] = i번째 물건까지 포함했을 때 j의 무게를 포함하는 가치의 최댓값말이 좀 어렵다. 예시를 보자4 76 134 83 65 12현재 무게 : 6 현재 가치 : 13  1   2   3   4   5   6   7  0   0   0   0   0  13  13현재 무게 : 4 현재 가치 : 8  1   2   3   4   5   6   7  0   0   0   8   8  13  13현재 무게 : 3 현재 가치 : 6  1   2   3   4   5   6   7  0   0   6   8   8  13  14현재 무게 : 5 현재 가치 : 12  1   2   3   4   5   6   7  0   0   6   8  12  13  1414새로운 아이템이 추가됨에 따라, 그 상태에서 가질 수 있는 가치의 최댓값을 가지고 있으면 문제는 해결된다.점화식  dp[i][j] = max(dp[i][j], dp[i-1]j-a[i][0]]] + a[i][1];위의 예시를 잘 보면, dp[4][7]을 업데이트 하기 위해서는 dp[3번째 무게까지 포함][4의 무게] + 6(3의 가치) 와 dp[3번째 무게까지 포함][7의 무게] 두개를 비교해야 한다. 즉, 8+6, 과 13을 비교한다.잘 생각해보면, 이전 무게까지 포함했을 때 최댓값과, 새로 들어온 무게를 만들었을 때의 가치를 비교하면 되는 문제이다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int N, K;int a[101][2];int dp[101][100001];void print(int i){    cout &lt;&lt; \"현재 무게 : \" &lt;&lt; a[i][0] &lt;&lt; \" 현재 가치 : \" &lt;&lt; a[i][1] &lt;&lt; '\\n';    for (int j = 1; j &lt;= K; j++) {        cout &lt;&lt; setw(3) &lt;&lt; j &lt;&lt; \" \";    }cout &lt;&lt; '\\n';    for (int j = 1; j &lt;= K; j++) {        cout &lt;&lt; setw(3) &lt;&lt; dp[i][j] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; K;    for (int i = 1; i &lt;= N; i++) {        int w, v;        cin &gt;&gt; w &gt;&gt; v;        a[i][0] = w;        a[i][1] = v;    }    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= K; j++) {            // 만들고 싶은 무게에 지금 넣고 싶은 무게를 넣지 못하는 경우            if (j - a[i][0] &lt; 0) {                // 이전 아이템까지 넣었던 최대 가치로 갖고 있는다                dp[i][j] = max(dp[i][j], dp[i-1][j]);                continue;            }            // 현재 만들고 싶은 무게에 지금 넣고 싶은 무게를 넣을 수 있다면            // 이전 아이템까지 넣었을 때 최대 가치를 가졌던 것과, 지금 넣고 싶은 무게를 넣었을 때            // 가치를 비교하여 최대 가치로 업데이트 해준다.            dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i][0]] + a[i][1]);        }        print(i);    }    // 최종적으로 N개의 짐까지 다 넣어보았을 때, 최대 가치가 얼마인지 찾는다.    cout &lt;&lt; *max_element(dp[N], &amp;dp[N][K+1]) &lt;&lt; '\\n';    //dp[i][j] = i번째 물건까지 포함했을 때 j의 무게를 만들었을 때 무게의 최댓값    // dp[i][j] = max(dp[i][j], dp[i-1][j-a[i].first] + a[i].second;    return 0;}공간 복잡도 감소그런데, 지금 dp의 크기를 보면 100*100000 = 10000000이라 많은 메모리를 낭비하고 있다. dp[i]~dp[i+1] 과의 관계에서 값이 도출이 되기 때문에 이전 depth의 dp는 필요가 없다. 따라서 temp라는 배열에 이를 저장하고 그 저장한 배열에서 값을 따오면 공간 복잡도를 줄일 수 있다.#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int N, K;int a[101][2];int dp[100001];int temp[100001];void print(int i){    cout &lt;&lt; \"현재 무게 : \" &lt;&lt; a[i][0] &lt;&lt; \" 현재 가치 : \" &lt;&lt; a[i][1] &lt;&lt; '\\n';    for (int j = 1; j &lt;= K; j++) {        cout &lt;&lt; setw(3) &lt;&lt; j &lt;&lt; \" \";    }cout &lt;&lt; '\\n';    for (int j = 1; j &lt;= K; j++) {        cout &lt;&lt; setw(3) &lt;&lt; dp[j] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; K;    for (int i = 1; i &lt;= N; i++) {        int w, v;        cin &gt;&gt; w &gt;&gt; v;        a[i][0] = w;        a[i][1] = v;    }    for (int i = 1; i &lt;= N; i++) {        memcpy(temp, dp, sizeof(dp));        for (int j = 1; j &lt;= K; j++) {            if (j - a[i][0] &lt; 0) dp[j] = max(dp[j], dp[j]);            else dp[j] = max(temp[j], temp[j-a[i][0]] + a[i][1]);        }    }    cout &lt;&lt; *max_element(dp, dp+K+1) &lt;&lt; '\\n';    return 0;}Reference백준(12865번) - 평범한 배낭",
        
        "url": "/cs/algorithm/2020/04/17/%EB%B0%B1%EC%A4%80-%ED%8F%89%EB%B2%94%ED%95%9C-%EB%B0%B0%EB%82%AD.html"
      }
      ,
    
      "cs-algorithm-2020-04-17-eb-b0-b1-ec-a4-80-ed-8c-8c-ec-8a-a4-ec-b9-bc-html": {
        "title": "백준(2986번): 파스칼",
        "tags": "백준, 알고리즘, 수학",
        "date": "April 17, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 수학 문제이다.생각일단 코드가 처음보는 거라 유심히 보았다. 결국 이런 것을 묻는 문제였다.  가장 큰 약수가 뒤에서 부터 몇번째에 나오니?그렇다면 가장 큰 약수를 구해야 하는데, 가장 큰 약수는 사실 $\\sqrt{n}$ 까지만 조사해도 풀 수 있다. 모든 수는 약수로 1을 가지므로 1을 초기값으로 두고, $\\sqrt{n}$까지 루프를 돌며 가장 큰 약수를 구한 뒤, 그 값까지 오는 count 개수를 출력하면 된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int main(){    int n, divisor = 1;    cin &gt;&gt; n;    for (int i = 2; i*i &lt;= n; i++) {        if (n%i == 0) {            divisor = n/i;            break;        }    }    cout &lt;&lt; n-divisor &lt;&lt; '\\n';}Reference백준(2986번) - 파스칼",
        
        "url": "/cs/algorithm/2020/04/17/%EB%B0%B1%EC%A4%80-%ED%8C%8C%EC%8A%A4%EC%B9%BC.html"
      }
      ,
    
      "cs-algorithm-2020-04-17-eb-b0-b1-ec-a4-80-ec-9d-b4-eb-b6-84-ea-b7-b8-eb-9e-98-ed-94-84-html": {
        "title": "백준(1707번): 이분 그래프(Bipartite Graph)",
        "tags": "백준, 알고리즘, DFS, Graph",
        "date": "April 17, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 그래프 문제이다.생각이분 그래프란 무엇인가? 문제를 읽고는 파악하는 게 힘들었다. 차라리 그림으로 보는 것이 좋다.왼쪽과 같은 그래프가 있을 이걸 오른쪽 그림처럼 바꿀 수 있느냐의 문제이다. 즉 저는 두 개의 집합으로 나눴을 때, 그 집합 내에 소속되는 정점과 인접하지 않는 (서로소 관계를 유지하는) 그래프 라 할 수 있다. 여기서 핵심은 나와 인접한 노드들의 색이 반대라는 것이다.풀이풀이 방법은 생각 보다 간단하다. 물론 처음에는 좀 삽질을 했지만.. 여전히 그래프 문제이기 때문에 탐색 방법론 부터 생각하는 것이 합리적이다.가장 생각하기 어려운 모양 부터 생각해 보겠다. 아래의 예는 그래프가 발생했을 때, 닫힌 그래프로 구성이 되어 정확하게 3개로 쪼개지는 경우에 대해 생각해 본 것이다.  닫힌 그래프는 여러개 존재할 수 있다. (그래프 입력 : a, b, c의 닫힌 그래프로 나뉜다고 가정해보자.)  각각의 닫힌 그래프에서 이분 그래프가 되기 위해서는 나와 인접한 노드의 색이 반대여야 한다. (a 그래프에서 이분 그래프인지 확인한다.)  이렇게 모든 닫힌 그래프에서 이분 그래프인지 확인했을 때 하나라도 이분 그래프가 아니라면 “No”를 출력한다.  모든 닫힌 그래프에서 이분 그래프라면, 이 세 닫힌 그래프를 합쳐도 이분 그래프이기 때문에 “YES”를 출력한다.이번에는 4개의 node에서 2개의 노드만 연결되었을 경우를 생각해 보자. 연결이 되지 않은 노드는 색을 어떻게 칠해주냐에 따라 다르므로, 결국 연결된 그래프에 대해서는 이분 그래프인지를 확인해 주면 된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define MAX 20000#define RED 1#define BLUE 2using namespace std;vector&lt;int&gt; graph[MAX+1];int isVisited[MAX+1];int V, E;// 내 노드에서 부터 시작해서 연결된 친구들을 다른 색으로 바꾼다.// 이미 색이 칠해져 있으면 탐색하지 않는다.void dfs(int voltex, int color){    isVisited[voltex] = color;    for (int i = 0; i &lt; graph[voltex].size(); i++) {        int nextVoltex = graph[voltex][i];        if (!isVisited[nextVoltex]) dfs(nextVoltex, 3-color);    }}// 나랑 연결된 친구들은 다른 색이어야 한다.bool isBipartiteGraph(){    for (int i = 1; i &lt;= V; i++) {        for (int j = 0; j &lt; graph[i].size(); j++) {            int nextVoltex = graph[i][j];            if (isVisited[i] == isVisited[nextVoltex]) return false;        }    }    return true;}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    int T;    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; V &gt;&gt; E;        for (int i = 0; i &lt;= V; i++) graph[i].clear();        memset(isVisited, 0, sizeof(isVisited));        for (int i = 0; i &lt; E; i++) {            int v1, v2;            cin &gt;&gt; v1 &gt;&gt; v2;            graph[v1].push_back(v2);            graph[v2].push_back(v1);        }        for (int i = 1; i &lt;= V; i++) {            if (!isVisited[i]) dfs(i, RED); // 색을 배정 받지 않은 친구들 탐색        }        if (isBipartiteGraph()) cout &lt;&lt; \"YES\" &lt;&lt; '\\n';        else cout &lt;&lt; \"NO\" &lt;&lt; '\\n';    }    return 0;}Reference백준(1707번) - 이분 그래프",
        
        "url": "/cs/algorithm/2020/04/17/%EB%B0%B1%EC%A4%80-%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84.html"
      }
      ,
    
      "cs-algorithm-2020-04-17-eb-b0-b1-ec-a4-80-ec-95-b1-html": {
        "title": "백준(7579번): 앱",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 17, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 동적 계획법 문제이다.생각이 문제는, 백준(12865번): 평범한 배낭과 매우 비슷하다. 한번 푸는 것이 좋다.이 문제는 memory의 범위가 매우 크기 때문에, 이 것을 기준으로 로직을 짜면 메모리가 터진다. 그래서 반대로 cost를 어떤 기준으로 만들 수 있는 지를 고민하여 코드를 짰다.정의  dp[i][j] = i번째 앱까지 비활성화했을 때 j의 비용까지 만들 수 있을 때 메모리의 최댓값메모리의 최댓값이라 잡은 이유는, 최소 Cost로 최대 메모리를 지우는 것이 합리적이기 때문이다.5 6030 10 20 35 403 0 3 5 4현재 비용 : 3 현재 메모리 : 30  0   0   0  30  30  30  30  30  30  30  30  30  30  30  30  30현재 비용 : 0 현재 메모리 : 10 10  10  10  40  40  40  40  40  40  40  40  40  40  40  40  40현재 비용 : 3 현재 메모리 : 20 10  10  10  40  40  40  60  60  60  60  60  60  60  60  60  60현재 비용 : 5 현재 메모리 : 35 10  10  10  40  40  45  60  60  75  75  75  95  95  95  95  95현재 비용 : 4 현재 메모리 : 40 10  10  10  40  50  50  60  80  80  85 100 100 115 115 115 1356새로운 앱이 추가됨에 따라, 그 Cost에서 가질 수 있는 메모리의 최댓값을 가지고 있으면 문제는 해결된다.점화식  dp[j] = max(temp[j], temp[j-nowCost] + nowMem)temp는 i-1개의 앱을 사용했을 때의 정보를 갖고 있는 dp이다. 이전 평범한 배낭 문제에서도 이전 depth의 정보만을 가져다가 사용하기 때문에 메모리가 낭비된다.이 문제는, 새로운 앱이 추가되었을 때, 현재 Cost에서 최대 메모리를 지우는 것을 목표로 코드를 짜면 된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define COSTMAX 10000#define APPMAX 100using namespace std;typedef long long ll;int costLimit = 0;int N, M;ll dp[COSTMAX+1];ll temp[COSTMAX+1];int mem[APPMAX+1];int cost[APPMAX+1];ll ans;void print(int i){    cout &lt;&lt; \"현재 비용 : \" &lt;&lt; cost[i] &lt;&lt; \" 현재 메모리 : \" &lt;&lt; mem[i] &lt;&lt; '\\n';    for (int i = 0; i &lt;= costLimit; i++) {        cout &lt;&lt; setw(3) &lt;&lt; dp[i] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    cin &gt;&gt; N &gt;&gt; M;    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; mem[i];    }    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; cost[i];        costLimit += cost[i];    }    for (int i = 1; i &lt;= N; i++) {        memcpy(temp, dp, sizeof(dp));        int nowCost = cost[i];        int nowMem = mem[i];        for (int j = nowCost; j &lt;= costLimit; j++) {            dp[j] = max(temp[j], temp[j-nowCost] + nowMem);        }        print(i);    }    for (int i = 0; i &lt;= costLimit; i++) {        if (dp[i] &gt;= M) {            ans = i;            break;        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}Reference백준(7579번) - 평범한 배낭",
        
        "url": "/cs/algorithm/2020/04/17/%EB%B0%B1%EC%A4%80-%EC%95%B1.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-ec-86-8c-ec-88-98-html": {
        "title": "백준(2581번): 소수",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버4 : 수학 문제이다.생각소수 구하는 알고리즘인 에라토스테네스의 체를 사용하면 간단히 풀 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define MAX 10000using namespace std;int N, M;bool isPrime[MAX+1];void SeiveofEratosThenes(){    fill(isPrime+2, isPrime+MAX+1, true);    for (int i = 2; i*i &lt;= M; i++) {        if (isPrime[i] == false) continue;        for (int j = i*i; j &lt;= M; j+=i) {            isPrime[j] = false;        }    }}int main(){    cin &gt;&gt; N &gt;&gt; M;    SeiveofEratosThenes();    vector&lt;int&gt; primeArr; int sum = 0;    for (int i = N; i &lt;= M; i++) {        if (isPrime[i]) {            primeArr.push_back(i);            sum += i;        }    }    if (primeArr.size() == 0) {        cout &lt;&lt; -1 &lt;&lt; '\\n';    } else cout &lt;&lt; sum &lt;&lt; '\\n' &lt;&lt; primeArr[0] &lt;&lt; '\\n';    return 0;}Reference백준(2581번) - 소수",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-ec-86-8c-ec-88-98-ea-b5-ac-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1929번): 소수 구하기",
        "tags": "백준, 알고리즘, 에라토스테네스의 체, 수학",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 수학 문제이다.생각소수 구하는 알고리즘인 에라토스테네스의 체를 사용하면 간단히 풀 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define MAX 1000000using namespace std;bool isPrime[MAX+1];int N, M;void SeiveofEratosThenes(){    fill(isPrime+2, isPrime+N+1, true);    for (int i = 2; i*i &lt;= N; i++) {        if (isPrime[i] == false) continue;        for (int j = i*i; j &lt;= N; j+=i) {            isPrime[j] = false;        }    }}int main(){    cin &gt;&gt; M &gt;&gt; N;    SeiveofEratosThenes();    for (int i = M; i &lt;= N; i++) {        if (isPrime[i] == true) cout &lt;&lt; i &lt;&lt; '\\n';    }    return 0;}Reference백준(1929번) - 소수 구하기",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-eb-b2-a0-eb-a5-b4-ed-8a-b8-eb-9e-91-ea-b3-b5-ec-a4-80-html": {
        "title": "백준(4948번): 베르트랑 공준",
        "tags": "백준, 알고리즘, 에라토스테네스의 체, 수학",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 수학 문제이다.생각소수 구하는 알고리즘인 에라토스테네스의 체를 사용하면 간단히 풀 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define MAX 123456*2using namespace std;int N;bool isPrime[MAX+1];void SeiveofEratosThenes(){    fill(isPrime+2, isPrime+MAX+1, true);    for (int i = 2; i*i &lt;= MAX; i++) {        if (isPrime[i] == false) continue;        for (int j = i*i; j &lt;= MAX; j+=i) {            isPrime[j] = false;        }    }}int main(){    SeiveofEratosThenes();    while (1) {        int count = 0;        cin &gt;&gt; N;        if (N == 0) {            break;        }        for (int i = N+1; i &lt;= 2*N; i++) {            if (isPrime[i]) count++;        }        cout &lt;&lt; count &lt;&lt; '\\n';    }    return 0;}Reference백준(4948번) - 베르트랑 공준",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EB%B2%A0%EB%A5%B4%ED%8A%B8%EB%9E%91-%EA%B3%B5%EC%A4%80.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-eb-8f-99-ec-a0-842-html": {
        "title": "백준(2294번): 동전 2",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획법 문제이다.생각다이나믹의 유형 중 중요한 유형이다. 대부분의 동전 문제의 방식과 비슷하다. 1차원 다이나믹이지만 2개의 반복문을 통해 2차원 처럼 생각하는 것이 필요하다.정의  dp[i] = n의 가치를 만들기 위해 필요한 최소 숫자의 개수정의는 매우 간단하다. 하지만 이 것을 구현할 때는 2차원 처럼 생각해야 편하다.점화식  dp[j] = min(dp[j],dp[j-a[i]]+1)위의 점화식이 나오는 과정을 생각해보자.3 152510========동전의 값 : 2========0 - 1 - 2 - 3 - 4 - 5 - 6 - 7========동전의 값 : 5========0 - 1 - 2 1 3 2 4 3 2 4 3 5 4========동전의 값 : 10========0 - 1 - 2 1 3 2 4 3 1 4 2 5 3  2로써 만들 수 있는 것을 업데이트 한다.  5로써 만들 수 있는 것을 업데이트 한다.  10로써 만들 수 있는 것을 업데이트 한다.이 때, 해당 가치가 업데이트 되는 방향은 결정되어 있다. 5의 가치는 3의 가치에서 2의 동전을 더해서 만들 수 있다. 이런 관계를 잘 엮는다면 문제를 해결할 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N, M;int a[101];int dp[10001];const int INF = 987654321;void print(int coin){    cout &lt;&lt; \"========\" &lt;&lt; \"동전의 값 : \"&lt;&lt; coin &lt;&lt; \"========\" &lt;&lt; '\\n';    for (int i = 0; i &lt; M; i++) {        if (dp[i] == INF) {            cout &lt;&lt; '-' &lt;&lt; \" \";        } else cout &lt;&lt; dp[i] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    cin &gt;&gt; N &gt;&gt; M;    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; a[i];    }    fill(dp+1, dp+M+1, INF);    for (int i = 1; i &lt;= N; i++) {        for (int j = a[i]; j &lt;= M; j++) {            dp[j] = min(dp[j],dp[j-a[i]]+1);        }        print(a[i]);    }    if (dp[M] == INF) cout &lt;&lt; -1;    else cout &lt;&lt; dp[M];    cout &lt;&lt; '\\n';    return 0;}Reference백준(2294번) - 동전 2",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EB%8F%99%EC%A0%842.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-eb-8f-99-ec-a0-841-html": {
        "title": "백준(2293번): 동전 1",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획법 문제이다.생각다이나믹의 유형 중 중요한 유형이다. 대부분의 동전 문제의 방식과 비슷하다. 1차원 다이나믹이지만 2개의 반복문을 통해 2차원 처럼 생각하는 것이 필요하다.정의  dp[i] = n의 가치를 만들기 위해 필요한 경우의 수정의는 매우 간단하다. 하지만 이 것을 구현할 때는 2차원 처럼 생각해야 편하다.점화식  dp[j] += dp[j-a[i]];위의 점화식이 나오는 과정을 생각해보자.3 152510========동전의 값 : 2========1 0 1 0 1 0 1 0 1 0 1 0 1 0 1========동전의 값 : 5========1 0 1 0 1 1 1 1 1 1 2 1 2 1 2========동전의 값 : 10========1 0 1 0 1 1 1 1 1 1 3 1 3 1 3  2로써 만들 수 있는 것을 업데이트 한다.  5로써 만들 수 있는 것을 업데이트 한다.  10로써 만들 수 있는 것을 업데이트 한다.이 때, 해당 가치가 업데이트 되는 방향은 결정되어 있다. 5의 가치는 3의 가치에서 2의 동전을 더해서 만들 수 있다. 이런 관계를 잘 엮는다면 문제를 해결할 수 있다. 이 문제는 동전 2의 문제와 같다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N, M;int a[101];int dp[10001];void print(int coin){    cout &lt;&lt; \"========\" &lt;&lt; \"동전의 값 : \"&lt;&lt; coin &lt;&lt; \"========\" &lt;&lt; '\\n';    for (int i = 0; i &lt; M; i++) {        cout &lt;&lt; dp[i] &lt;&lt; \" \";    }cout &lt;&lt; '\\n' &lt;&lt; '\\n';}int main(){    cin &gt;&gt; N &gt;&gt; M;    for (int i = 1; i &lt;= N; i++) {        cin &gt;&gt; a[i];    }    dp[0] = 1;    for (int i = 1; i &lt;= N; i++) {        for (int j = a[i]; j &lt;= M; j++) {            dp[j] += dp[j-a[i]];        }        print(a[i]);    }    cout &lt;&lt; dp[M] &lt;&lt; '\\n';    return 0;}Reference백준(2293번) - 동전 2",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EB%8F%99%EC%A0%841.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-eb-8b-a4-eb-a6-ac-eb-86-93-ea-b8-b0-html": {
        "title": "백준(1010번): 다리놓기",
        "tags": "백준, 알고리즘",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버4 : 메모이제이션 문제이다.생각고등학교 때 많이 풀어본 함수의 개수 구하는 문제와 같다. 결국은 공역단에서 N개의 site를 고르게 되면 자동으로 순서가 결정되기 때문이다. M개의 원소 중에 N개의 원소를 고르면 되는 문제이기 때문에 이것은 결국 조합을 구현하는 문제와 같다. 그 과정에서 중복되는 조합 값이 존재하기 때문에 이것을 따로 저장하게 되면 시간이 매우 많이 단축된다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;ll memo[31][31];ll combination(int M, int N){    if (M == N || N == 0) return 1;    if (memo[M-1][N-1] == 0) memo[M-1][N-1] = combination(M-1, N-1);    if (memo[M-1][N] == 0) memo[M-1][N] = combination(M-1, N);    return memo[M-1][N-1] + memo[M-1][N];}int main(){    int T;    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        int N, M;        cin &gt;&gt; N &gt;&gt; M;        cout &lt;&lt; combination(M, N) &lt;&lt; '\\n';    }}Reference백준(1010번) - 소수",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EB%8B%A4%EB%A6%AC%EB%86%93%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-16-eb-b0-b1-ec-a4-80-ea-b3-a8-eb-93-9c-eb-b0-94-ed-9d-90-ec-9d-98-ec-b6-94-ec-b8-a1-html": {
        "title": "백준(9020번): 골드바흐의 추측",
        "tags": "백준, 알고리즘, 에라토스테네스의 체, 수학",
        "date": "April 16, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 수학 문제이다.생각소수 구하는 알고리즘인 에라토스테네스의 체를 사용하면 간단히 풀 수 있다. 이 때, 시간제한 때문에 구한 소수를 담아두는 것이 좋다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define MAX 10000using namespace std;bool isPrime[MAX+1];void SeiveofEratosThenes(){    fill(isPrime+2, isPrime+MAX+1, true);    for (int i = 2; i*i &lt;= MAX; i++) {        if (isPrime[i] == false) continue;        for (int j = i*i; j &lt;= MAX; j+=i) {            isPrime[j] = false;        }    }}void solve(int N){    vector&lt;int&gt; prime;    for (int i = 2; i &lt;= N; i++) {        if (isPrime[i]) prime.push_back(i);    }    int size = int(prime.size());    int a = -100000, b = 100000;    for (int i = 0; i &lt;= size; i++) {        for (int j = i; j &lt;= size; j++) {            if (prime[i]+prime[j] == N) {                if (prime[j]-prime[i] &lt; b-a) {                    a = prime[i]; b = prime[j];                }            }        }    }    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; '\\n';}int main(){    SeiveofEratosThenes();    int T;    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        int N;        cin &gt;&gt; N;        solve(N);    }    return 0;}Reference백준(9020번) - 골드바흐의 추측",
        
        "url": "/cs/algorithm/2020/04/16/%EB%B0%B1%EC%A4%80-%EA%B3%A8%EB%93%9C%EB%B0%94%ED%9D%90%EC%9D%98-%EC%B6%94%EC%B8%A1.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ec-a0-90-ed-94-84-html": {
        "title": "백준(1890번): 점프",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 동적 계획법 문제이다.생각앞으로 보내는 dp문제이다.정의이 문제는 위치에 따라 개수가 결정되므로 dp의 인자를 좌표의 위치로 잡는 것이 수월하다.  dp[y][x] = (y,x) 위치까지 도착하는 경로의 개수점화식해당 위치까지 도착하는 개수는 이전 위치에서 올 수 있느냐를 판단해야 한다. 이 경우 과거로 부터 현재를 갖고오는 것이 무리가 있으니 오히려 현재 위치에서 다음 위치로 갈 수 있는 경로를 업데이트 하는 것이 옳다.  dp[y+d][x] += dp[y][x]  dp[y][x+d] += dp[y][x]d는 (y,x)위치에서 점프할 수 있는 크기이다. 이 때 dp[y][x]로 업데이트 해주는 이유는, 해당 (y, x) 위치에 도착할 수 있는 경로가 2개라면, 이 지점까지 도달한 경로 모두는 다음 위치로 이동할 수 있기 때문에 그 숫자로 업데이트하는 것이 맞다.42 3 2 11 2 1 32 2 1 13 1 1 0=========(1,1 )==================y 방향=========1 0 0 00 0 0 01 0 0 00 0 0 0=========(1,1 )==================x 방향=========1 0 1 00 0 0 01 0 0 00 0 0 0=========(1,3 )==================y 방향=========1 0 1 00 0 0 01 0 1 00 0 0 0=========(1,3 )==================x 방향=========1 0 1 00 0 0 01 0 1 00 0 0 0=========(3,1 )==================y 방향=========1 0 1 00 0 0 01 0 1 00 0 0 0=========(3,1 )==================x 방향=========1 0 1 00 0 0 01 0 2 00 0 0 0=========(3,3 )==================y 방향=========1 0 1 00 0 0 01 0 2 00 0 2 0=========(3,3 )==================x 방향=========1 0 1 00 0 0 01 0 2 20 0 2 0=========(3,4 )==================y 방향=========1 0 1 00 0 0 01 0 2 20 0 2 2=========(3,4 )==================x 방향=========1 0 1 00 0 0 01 0 2 20 0 2 2=========(4,3 )==================y 방향=========1 0 1 00 0 0 01 0 2 20 0 2 2=========(4,3 )==================x 방향=========1 0 1 00 0 0 01 0 2 20 0 2 44Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int N;int map[101][101];ll dp[101][101];int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= N; j++) {            cin &gt;&gt; map[i][j];        }    }    memset(dp, 0, sizeof(dp));    dp[1][1] = 1;    dp[N][N] = 0;    for (int y = 1; y &lt;= N; y++) {        for (int x = 1; x &lt;= N; x++) {            if (dp[y][x] == 0 || (y == N &amp;&amp; x == N)) continue;            int d = map[y][x];            if (y+d &lt;= N) dp[y+d][x] += dp[y][x];            if (x+d &lt;= N) dp[y][x+d] += dp[y][x];        }    }    cout &lt;&lt; dp[N][N] &lt;&lt; '\\n';}Reference백준(1890번) - 점프",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EC%A0%90%ED%94%84.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ec-9d-b4-eb-8f-99-ed-95-98-ea-b8-b0-html": {
        "title": "백준(11048번): 이동하기",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적 계획법 문제이다.생각DFS나 BFS로는 depth가 깊어져 시간초과가 난다. 이 문제는 동적계획법으로 풀어야 한다. 그저 최대 사탕의 개수만 출력하면 되기 때문이다.정의이 문제는 위치에 따라 개수가 결정되므로 dp의 인자를 좌표의 위치로 잡는 것이 수월하다.  dp[y][x] = (y,x)위치에서 가질 수 있는 사탕 개수의 최댓값점화식이 정의에 부합하는 점화식은 어떤식으로 짤 수 있을까? 점화식은 임의의 좌표 위치에서 이 좌표가 만들어지기 위해 어떤 좌표와의 연관성이 있는지를 확인하면 된다. 문제에서 특정 위치에서 갈 수 있는 방향은 우, 좌, 대각이다. 그렇다면 특정 위치에서의 사탕의 최댓값은 좌, 우, 10시방향 대각선 세 방향의 값으로 부터 도출될 수 있다.  dp[y][x] = max(dp[y-1][x], dp[y][x-1], dp[y-1][x-1]) + input[y][x]주의할 점(1, 1)에서 시작하므로 (1, 1), (1행, 1), (1, 1열)의 위치에서는 3방향에서 업데이트를 할 수 없다. 이 점을 고려하여 분기를 만들어 코드를 짜는 것이 좋다.#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N, M;int map[1001][1001];int dp[1001][1001];int main(){   cin &gt;&gt; N &gt;&gt; M;   for (int i = 1; i &lt;= N; i++) {       for (int j = 1; j &lt;= M; j++) {           cin &gt;&gt; map[i][j];           if (i == 1 &amp;&amp; j == 1) dp[i][j] = map[i][j];       }   }   for (int y = 1; y &lt;= N; y++) {       for (int x = 1; x &lt;= M; x++) {           if (y == 1 &amp;&amp; x == 1) {               continue;           } else if (y == 1){               dp[y][x] = max(dp[y][x], dp[y][x-1]);           } else if (x == 1){               dp[y][x] = max(dp[y][x], dp[y-1][x]);           } else {               dp[y][x] = max(dp[y][x], dp[y-1][x]);               dp[y][x] = max(dp[y][x], dp[y][x-1]);               dp[y][x] = max(dp[y][x], dp[y-1][x-1]);           }           dp[y][x] += map[y][x];       }   }   cout &lt;&lt; dp[N][M] &lt;&lt; '\\n';}Reference백준(11048번) - 이동하기",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ec-8a-a4-ed-83-80-ed-8a-b8-ec-99-80-eb-a7-81-ed-81-ac-html": {
        "title": "백준(14889번): 스타트와 링크",
        "tags": "백준, 알고리즘, DFS",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : dfs 문제이다.생각기본적인 dfs 문제이다. 반으로 나눈 팀에 대한 점수를 더하는 것이므로, true false를 통해 구현할 수 있다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N;int map[21][21];bool check[21];int ans = 987654321;void go(int count, int start){    if (count == N/2) {        int start, link;        start = link = 0;        for (int i = 1; i &lt;= N; i++) {            for (int j = 1; j &lt;= N; j++) {                if (check[i] &amp;&amp; check[j]) start += map[i][j];                if (!check[i] &amp;&amp; !check[j]) link += map[i][j];            }        }        ans = min(ans, abs(start-link));        return;    }    for (int i = start; i &lt;= N-(N/2)+count+1; i++) {        check[i] = true;        go(count+1, i+1);        check[i] = false;    }}int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= N; j++) {            cin &gt;&gt; map[i][j];        }    }    go(0, 1);    cout &lt;&lt; ans &lt;&lt; '\\n';}Reference백준(14889번) - 스타트와 링크",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%99%80-%EB%A7%81%ED%81%AC.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-eb-b0-9c-ec-a0-84-ec-86-8c-html": {
        "title": "백준(1102번): 발전소",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드1 : 동적 계획법 문제이다.생각dp의 정의는 간단하게 생각할 수 있다. 특정한 상태의 발전소로 오는 방법은 몇가지로 정해지기 때문이다. 그래서 정의를 잡으면 다음과 같다.정의  dp[상태] = 발전소의 상태에서의 발전소를 고치는데 발생하는 비용의 최솟값그렇다면 상태는 어떻게 정의할 수 있을까?비트마스크YNN은 100으로 생각할 수 있다. 그렇다면 이 상태에서 다음상태로는 어떻게 갈 수 있을까?  켜져있는 발전소를 확인한다.  해당 발전소에서 꺼져있는 발전소를 확인한다.  꺼져있는 발전소를 킨다.  다른 상태에서 또 같은 상태로 올 때, 최소값으로 업데이트 한다.주의할 점초기값을 모두 -1로 만든 상태에서 값을 출력하는 것이 좋다. 만들지 못하는 경우를 출력하기 위함이다. 또한 0개의 발전소를 키라는 조건에서 -1을 리턴하면 안되고 0을 리턴해야 한다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N;int a[17][17];string str;int dp[1&lt;&lt;16];int p;int main(){    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt; N; j++) {            cin &gt;&gt; a[i][j];        }    }    int start = 0;    for (int i = 0; i &lt; N; i++) {        char temp;        cin &gt;&gt; temp;        if (temp == 'Y') start += (1&lt;&lt;i); // YNN -&gt; 001로 저장한다. 이진수의 shift연산 중에는 이게 편하다.    }    cin &gt;&gt; p;    // 기본 dp의 값을 -1로 해둔다.    // 일단 다 못 만든다고 가정하는 것    memset(dp, -1, sizeof(dp));    dp[start] = 0;    //  start에서 dp값은 0이다. 최소값이 0    for (int i = 0; i &lt; (1&lt;&lt;N); i++) {        if (dp[i] == -1) continue; // 상태에 대한 최소값이 없다면 진행할 수 없다.        for (int j = 0; j &lt; N; j++) {   // 발전소를 순차적으로 체크하며 다음 상태를 만든다.            if (i&amp;(1&lt;&lt;j)){    // 현재 발전소의 상태중 j번째 발전소가 있다면                for (int k = 0; k &lt; N; k++) {                    if ((i&amp;(1&lt;&lt;k)) == 0){   // 현재 발전소의 상태에서 j번째 발전소를 가지고 k위치의 발전소를 키려고 할때 k위치 발전소가 꺼져있다면                        if (dp[i|(1&lt;&lt;k)] == -1 || dp[i|(1&lt;&lt;k)] &gt; dp[i] + a[j][k]) {                            dp[i|(1&lt;&lt;k)] = dp[i]+a[j][k];                        }                    }                }            }        }    }    int ans = -1;    for (int i = 0; i &lt; (1&lt;&lt;N); i++) {        if (dp[i] == -1) continue;        int count = 0;        for (int j = 0; j &lt; N; j++) {            if (i&amp;(1&lt;&lt;j)) count++;        }        if (count &gt;= p) {            if (ans == -1 || ans &gt; dp[i]) ans = dp[i]; // ans를 -1로 했기 때문에 처음에 scope들어오기 위해 조건 추가        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';}Reference백준(1102번) - 발전소",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EB%B0%9C%EC%A0%84%EC%86%8C.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ea-b0-80-ec-9e-a5-ea-b8-b4-eb-b0-94-ec-9d-b4-ed-86-a0-eb-8b-89-eb-b6-80-eb-b6-84-ec-88-98-ec-97-b4-html": {
        "title": "백준(11054번): 가장 긴 바이토닉 부분 수열",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 동적 계획법 문제이다.생각dp의 정의는 간단하게 생각할 수 있다. 이 문제는 가장 긴 감소하는 부분 수열, 가장 긴 증가하는 부분 수열을 합한 문제이다.정의  dp1[i] = i번째 원소를 포함했을 때 발생하는 가장 감소하는 부분 수열의 길이  dp2[i] = i번째 원소를 포함했을 때 발생하는 가장 증가하는 부분 수열의 길이점화식  dp1[i] = dp1[j]+1 단, a[i] &lt; a[j]  dp2[i] = dp2[j]+1 단, a[i] &gt; a[j]  ans = max(ans, dp1[i]+dp2[i]-1)Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N;int a[1001];int dp1[1001];int dp2[1001];int ans = 0;int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; a[i];    fill(dp1+1, dp1+N+1, 1);    fill(dp2+1, dp2+N+1, 1);    for (int i = N; i &gt;= 1; i--) {        for (int j = N; j &gt;= i; j--) {            if (a[i] &gt; a[j]) dp1[i] = max(dp1[i], dp1[j] + 1);        }    }    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= i; j++) {            if (a[i] &gt; a[j]) dp2[i] = max(dp2[i], dp2[j] + 1);        }    }    for (int i = 1; i &lt;= N; i++) {        ans = max(ans, dp1[i]+dp2[i]-1);    }    cout &lt;&lt; ans &lt;&lt; '\\n';}Reference백준(11054번) - 가장 긴 바이토닉 부분 수열",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EB%B0%94%EC%9D%B4%ED%86%A0%EB%8B%89-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4.html"
      }
      ,
    
      "cs-algorithm-2020-04-15-eb-b0-b1-ec-a4-80-ea-b0-80-ec-9e-a5-ea-b0-90-ec-86-8c-ed-95-98-eb-8a-94-eb-b6-80-eb-b6-84-ec-88-98-ec-97-b4-html": {
        "title": "백준(11722번): 가장 감소하는 부분 수열",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 15, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 동적 계획법 문제이다.생각dp의 정의는 간단하게 생각할 수 있다.정의  dp[i] = i번째 원소를 포함했을 때 발생하는 가장 감소하는 부분 수열의 길이점화식현재 상태의 가장 감소하는 부분 수열의 길이는, 이전의 원소들이 가지고 있는 가장 감소하는 부분 수열의 길이에 종속적이다. 이 때, 업데이트하는 규칙이 필요한데, 내가 현재 가지고 있는 원소가 이전 원소의 크기보다 작다면 업데이트 하면 된다.  dp[i] = dp[j]+1 단, a[i] &lt; a[j]Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int N;int a[1001];int dp[1001];int ans = 0;int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++) cin &gt;&gt; a[i];    fill(dp+1, dp+N+1, 1);    for (int i = 1; i &lt;= N; i++) {        for (int j = 1; j &lt;= i; j++) {            if (a[i] &lt; a[j]) dp[i] = max(dp[i], dp[j] + 1);            ans = max(ans, dp[i]);        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';}Reference백준(11722번) - 가장 감소하는 부분 수열",
        
        "url": "/cs/algorithm/2020/04/15/%EB%B0%B1%EC%A4%80-%EA%B0%80%EC%9E%A5-%EA%B0%90%EC%86%8C%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4.html"
      }
      ,
    
      "cs-algorithm-2020-04-14-eb-b0-b1-ec-a4-80-four-squares-html": {
        "title": "백준(17626번): Four Squares",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "April 14, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버5 : 동적 계획법 문제이다.생각생각 보다 힘들게 푼 문제이다. n이 50000이고, 시간 제한이 0.5초이기 때문에 완전탐색으로 풀면 힘들 것이라 생각했다. 그래서 동적 계획법 방법으로 풀이를 채택했다.이 문제는 동전 문제와 비슷하게 생각해야 한다. 결국 몇개의 제곱수가 최소로 필요하냐는 문제인데, 사실 1로 모든 수를 만들 수 있기 때문에 더해지는 숫자의 개수가 늘어남에 따라 최소 개수로 업데이트를 해주는 것이 맞다.정의  dp[i] = i을 만드는데 있어 필요한 최소 숫자의 갯수정의는 1차원 다이나믹이지만, 계속 업데이트를 해주어야 한다. 업데이트를 하게 되면 최종적으로 4번하면 i을 만드는데 있어 필요한 최소 제곱수의 갯수 로 정리될 수 있다. (문제에 이미 증명되었다고 한다)점화식  dp[i] = min(dp[i], dp[j*j]+dp[i-j*j])잘 생각해보자. n이라는 숫자를 만들기 위해 필요한 개수는 dp[n-i*i]로 부터 올 수 밖에 없다. 제곱수를 더하여 해당 수가 만들어지기 때문이다.n = n-1*1 + 1*1  = n-2*2 + 2*2  = n-3*3 + 3*3  ...  = n-sqrt(n)*sqrt(n) + sqrt(n)*sqrt(n)그렇다면, dp역시 이 관계가 적용되나 생각해보자. 9에서 발생하는 최소 개수를 만들기 위해서는 (8에서 발생하는 최소 개수 + 1에서 발생하는 최소 개수) 그리고 (5에서 발생하는 최소 개수 + 4에서 발생하는 최소 개수), (3에서 발생하는 최소 개수 + 0에서 발생하는 최소 개수)를 비교하면 된다. 이 때 뒤에서 발생하는 최소 개수(1, 4, 0)은 모두 제곱수 이다. 하지만 앞은 제곱수가 아니기 때문에 1보다 큰 숫자를 가지고 있을 것이다. 하지만 업데이트 하는 과정에서 계속해서 숫자가 작아지고, 이것은 문제에서 증명된 사실과 같이 4를 초과할 수 없다. 설명이 너무 어렵다                   0      1      2      3      4      5      6      7      8      9                  1      0      1      2      3      1      5      6      7      8      1              2      0      1      2      3      1      2      3      4      2      1              3      0      1      2      3      1      2      3      0      0      1              4      0      1      2      3      1      2      3      0      0      1      1은 한번의 제곱수까지 사용했을 때 표현할 수 있는지를 나타낸 것이다. 5는 제곱수가 아니므로 초기값을 INF로 잡는다. 그 다음으로 2개의 숫자까지 사용했을 때 필요한 개수를 생각해보자. (1, 4), (2, 3)에서 올 수 있는데, dp값을 더했을 때 최솟값이 2이므로 5는 2개의 제곱수를 사용했을 때 2개를 더하면 만들어진다. 이렇게 모두를 업데이트 하면, 2개의 숫자를 사용했을 때 필요한 제곱수의 최소개수를 업데이트 할 수 있다. 3개의 숫자까지 사용한다면, 여전히 방법을 똑같다. 하지만 이미 dp에 있는 값은 그 숫자를 표현하기 위해 필요한 최소 숫자의 개수를 대변하고 있다. 따라서 업데이트를 하면 자동적으로 최소 개수로 업데이트 된다. 여기서 핵심은 m개의 숫자까지를 사용했을 때 최소숫자의 개수라는 것이다. 즉 열 방향으로도 dp의 정의가 적용되고 있다. 마찬가지로 4번째 숫자까지 사용했을때 업데이트를 진행하면 답이다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int INF = 1e9;int N;int dp[50001];int main(){    cin &gt;&gt; N;    fill(dp, dp+N+1, INF);    for (int i = 1; i &lt;= N; i++) {        if (int(sqrt(i))*int(sqrt(i)) == i) dp[i] = 1;        else dp[i] = i;    }    for (int k = 0; k &lt; 3; k++) {        for (int i = 1; i &lt;= N; i++) {            for (int j = 1; j &lt;= int(sqrt(i)); j++) {                dp[i] = min(dp[i], dp[j*j]+dp[i-j*j]);            }        }    }    cout &lt;&lt; dp[N] &lt;&lt; '\\n';}Reference백준(17626번) - Four Squares",
        
        "url": "/cs/algorithm/2020/04/14/%EB%B0%B1%EC%A4%80-Four-Squares.html"
      }
      ,
    
      "cs-algorithm-2020-04-13-eb-b0-b1-ec-a4-80-eb-95-85-eb-94-b0-eb-a8-b9-ea-b8-b0-html": {
        "title": "백준(6171번): 땅따먹기",
        "tags": "백준, 알고리즘, 동적계획법, Convex Hull",
        "date": "April 13, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플레티넘1 : 동적 계획법, Convex Hull 문제이다.생각일단 완전 탐색을 생각해 본다. 음.. 말도 안된다. 몇개를 겹쳐서 만드는지 완전탐색을 한다면 시간 복잡도가 $O(n!)$ 이다. 이 문제는 그냥 직관적으로 동적 계획법 냄새가 난다. 어떠한 조건에서 특정 위치까지의 땅의 최소값이 다음을 구하는데 영향을 줄 것 같기 때문이다.정의  dp[n] = n번째 땅까지 구매했을 때 비용의 최솟값이렇게 정의했다면, 이제는 점화식을 어떻게 세울지 고민해야 한다. n번째 땅까지 구매했을 때 비교해봐야 하는 값들을 나열해 보자.  n번째 땅을 그냥 산다. 그리고 n-1까지의 최소값과 더한다.  n-1번째 땅과 묶어서 계산해본다. 그리고 n-2까지의 최솟값과 더한다.  n-2번째 땅과 묶어서 계산해본다. 그리고 n-3까지의 최솟값과 더한다.…호오. 가능할 것 같은 냄새가 난다. 이렇게 할 경우 $O(n^2)$ 까지 줄일 수 있을 것 같다.dp[i] = min(dp[j-1] + j부터 i까지의 땅을 합쳐 산 금액)이 것을 수식으로 정리해보면, 위와 같다. 그렇다면 j부터 i가지의 땅을 합쳐 산 금액은 어떻게 구할까?j부터 i가지의 땅을 합쳐 산 금액실제로 땅을 사본다고 생각한다. 가장 빨리 직관을 얻는 것은 그림을 그려보는 것이다. 결국 이 문제는, 땅을 구입하는데 있어서 이걸 통짜로 한번에 사버린다는 얘기와 같다.입력이 100 1, 20 20이 들어왔다고 생각하자. 이 부분에 해당하는 땅을 그리면 위와 같다. 그런데, 내가 이 두 땅을 합친다고 생각하면 결국 중요한 것을 최대 너비와 최대 높이이다. 아까 위에서 본 것처럼 결국 dp[i]을 구하기 위해서는 맨 아래 땅부터 포함해서 위쪽 땅을 1개, 2개 3개 … 를 선택하여 합쳐야 한다. 그렇다면, 땅을 합치는 데 있어서 3개를 합친다면, 3개의 땅의 너비와 높이를 다 비교해서 얻어내야 하는데.. 굳이 그래야 할까?정렬하기굳이 그럴 필요 없다. dp[i]을 구하는데 있어서 무조건 포함해야 하는 땅은 i번째 땅이다. 그렇다면 내가 합치고 싶은 범위의 땅은 j번째 땅이다. 이 두땅을 각각 ground[i], ground[j] 라 하겠다.땅을 구하는데 있어서 위의 문제처럼 일일히 최댓값을 구하지말고, 이렇게 하면 좋겠다.  ground[i] = 합칠 땅의 최대 height  ground[j] = 합칠 땅의 최대 width이러면, 시간 복잡도 $O(1)$에 가능하다..!필요없는 땅 제거그런데 정렬을 하다보니 이런 땅도 있다.음.. 이런 땅은 어쩌지? 잘 생각해보면, 이 땅은 필요없다. 이미 땅을 살 때, 포함되는 땅이기 때문이다. 예를 들어 20 20을 구매한다면, 15 15는 합쳐살 경우 자연스레 구매하게 되는 땅이다. 합쳐사지 않는 다면 오히려 비용만 늘기 때문에 결국 이 땅은 최소값을 구하는데 도움이 되지 않는 땅이다. 또한 이 땅을 배열에 갖고 있게 된다면, 우리가 위에서 만들고 싶은 정렬 규칙에 위배되므로써 상수시간 안에 구하는 것이 어려워진다. 따라서 이런 조건에 해당하는 땅은 제거한다.  정렬한 땅에서, 지금 땅의 높이보다 다음 땅의 높이가 크면 추가한다.점화식  dp[i] = min(dp[j-1] + (ground[j].w * ground[i].h)) &gt; (단, i &gt;= j &gt;= 1)Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Square {    ll w, h;};int N;vector&lt;Square&gt; temp;vector&lt;Square&gt; ground;vector&lt;ll&gt; dp;bool compare(Square a, Square b){    if (a.w == b.w) return a.h &lt; b.h;    return a.w &gt; b.w;}int main(){    cin &gt;&gt; N;    temp.resize(N);    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; temp[i].w &gt;&gt; temp[i].h;    }    sort(temp.begin(), temp.end(), compare);    ground.push_back(temp[0]);    ground.push_back(temp[0]);    for (int i = 1; i &lt; N; i++) {        Square next = temp[i];        Square now = ground.back();        if (next.h &gt; now.h) ground.push_back(next);    }    int size = int(ground.size());    dp.resize(size);    for (int i = 1; i &lt; size; i++) {        dp[i] = dp[i-1] + ground[i].w * ground[i].h;        for (int j = i; j &gt; 0; j--) {            dp[i] = min(dp[i], dp[j-1] + (ground[j].w * ground[i].h));        }    }    cout &lt;&lt; dp[size-1] &lt;&lt; '\\n';    return 0;}Convex Hull하지만.. 플레티넘의 위엄이 있다. 이렇게 풀면 시간초과가 난다. 당연히 입력이 1000000이기 때문에 최악의 경우 $O(n^2)$ 이다. 그래서 여기서는 추가적인 최적화가 필요하다.Reference백준(6171번) - 땅따먹기",
        
        "url": "/cs/algorithm/2020/04/13/%EB%B0%B1%EC%A4%80-%EB%95%85%EB%94%B0%EB%A8%B9%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-12-eb-b0-b1-ec-a4-80-ed-81-90-eb-b9-99-html": {
        "title": "백준(5373번): 큐빙",
        "tags": "백준, 알고리즘, 구현, 시뮬레이션",
        "date": "April 12, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드1 : 구현, 시뮬레이션 문제이다.Code#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int T, n;void clockwise(vector&lt;vector&lt;char&gt;&gt;&amp;a){    char temp = a[0][0];    a[0][0] = a[2][0];    a[2][0] = a[2][2];    a[2][2] = a[0][2];    a[0][2] = temp;    temp = a[0][1];    a[0][1] = a[1][0];    a[1][0] = a[2][1];    a[2][1] = a[1][2];    a[1][2] = temp;    return;}void U(vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt;&amp;a){    vector&lt;vector&lt;char&gt;&gt; temp = a[5];    a[5] = a[0];    a[0] = a[4];    a[4] = a[1];    a[1] = temp;    clockwise(a[1]); clockwise(a[1]);    clockwise(a[4]); clockwise(a[4]);    clockwise(a[2]);    clockwise(a[3]); clockwise(a[3]); clockwise(a[3]);    return;}void F(vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt;&amp;a){    vector&lt;vector&lt;char&gt;&gt; temp = a[2];    a[2] = a[5];    a[5] = a[3];    a[3] = a[4];    a[4] = temp;    clockwise(a[2]);    clockwise(a[4]);    clockwise(a[3]);    clockwise(a[5]);    clockwise(a[1]); clockwise(a[1]); clockwise(a[1]);    clockwise(a[0]);    return;}void L(vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt;&amp;a){    // 0 -&gt; 2 -&gt; 1 -&gt; 3    vector&lt;vector&lt;char&gt;&gt; temp = a[0];    for (int i = 0; i &lt; 3; i++)    {        a[0][i][0] = a[3][i][0];        a[3][i][0] = a[1][i][0];        a[1][i][0] = a[2][i][0];        a[2][i][0] = temp[i][0];    }    clockwise(a[4]);    return;}void R(vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt;&amp;a){    // 0 -&gt; 3 -&gt; 1 -&gt; 2    vector&lt;vector&lt;char&gt;&gt; temp = a[0];    for (int i = 0; i &lt; 3; i++)    {        a[0][i][2] = a[2][i][2];        a[2][i][2] = a[1][i][2];        a[1][i][2] = a[3][i][2];        a[3][i][2] = temp[i][2];    }    clockwise(a[5]);    return;}int main(void){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; T;    char command, clock;    for (int tc = 0; tc &lt; T; tc++) {        vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt; cube;        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'w')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'y')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'r')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'o')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'g')));        cube.push_back(vector&lt;vector&lt;char&gt;&gt;(3, vector&lt;char&gt;(3, 'b')));        cin &gt;&gt; n;        for (int i = 0; i &lt; n; i++)        {            cin &gt;&gt; command &gt;&gt; clock;            int k = 1;            if (clock == '-') k = 3;            if (command == 'U')            {                U(cube);                for (int j = 0; j &lt; k; j++) R(cube);                for (int j = 0; j &lt; 3; j++) U(cube);            }            else if (command == 'D')            {                U(cube);                for (int j = 0; j &lt; k; j++) L(cube);                for (int j = 0; j &lt; 3; j++) U(cube);            }            else if (command == 'F')            {                F(cube);                for (int j = 0; j &lt; k; j++) L(cube);                for (int j = 0; j &lt; 3; j++) F(cube);            }            else if (command == 'B')            {                F(cube);                for (int j = 0; j &lt; k; j++) R(cube);                for (int j = 0; j &lt; 3; j++) F(cube);            }            else if (command == 'L')            {                for(int j = 0; j &lt; k; j++) L(cube);            }            else if (command == 'R')            {                for (int j = 0; j &lt; k; j++) R(cube);            }        }        for (int i = 0; i &lt; 3; i++)        {            for (int j = 0; j &lt; 3; j++)                cout &lt;&lt; cube[0][i][j];            cout &lt;&lt; '\\n';        }    }    return 0;}Reference백준(5373번) - 큐빙",
        
        "url": "/cs/algorithm/2020/04/12/%EB%B0%B1%EC%A4%80-%ED%81%90%EB%B9%99.html"
      }
      ,
    
      "cs-algorithm-2020-04-12-eb-b0-b1-ec-a4-80-ec-88-98-ed-95-99-ec-9d-80-eb-84-88-eb-ac-b4-ec-89-ac-ec-9b-8c-html": {
        "title": "백준(2904번): 수학은 너무 쉬워",
        "tags": "백준, 알고리즘, 소인수 분해, 에라토스테네스의 체, 수학",
        "date": "April 12, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 수학 문제이다.생각문제 이름 부터 뭔가 마음에 들지 않았다. 풀이 방법은 바로 떠올랐는데 왜 요즘 이런게 구현이 안되는지… score가 최대공약수를 구하는 것이기 때문에 소인수 분해를 떠올릴 수 있고, 그러기 위해서는 소수를 구해야 한다. 그러니 소수를 구하는 가장 빠른 알고리즘인 에라토스 테네스의 체를 떠올릴 수 있다.규칙의 이해            8      24      9                  $2^3$      $2^3\\cdot 3$      $3^2$      문제의 입력은 다음과 같다. 이 때 A,B를 정해서 문제에서 원하는 규칙에 따라 진행하는 것은, 각각의 수를 이루는 소수들 중 하나를 떼서 준다로 압축할 수 있다.            A : 8-&gt;4      24      B : 9-&gt;18                  $2^2$      $2^3\\cdot3$      $2\\cdot 3^2$      이런 규칙을 가지고 문제에서 원하는 것을 구하기 위해서는 어떠한 상황이여야 하는지 생각해 보자.최대 숫자  내가 가진 소인수의 개수를 서로에게 나눠주는 과정 속에서 최대한 잘 나눠가졌을 때, 공통된 숫자가 무엇이냐?상당히 공리주의적 관점이다. 위의 조건을 만족하려면 각각이 가진 개수를 모두 파악한 후, 인원수로 나눈것이 모두가 고루고루 나누는 최종 숫자이다.            8      24      9      1728      12                  $2^3$      $2^3\\cdot 3$      $3^2$      $2^6\\cdot3^3$      $2^2\\cdot 3$      이 문제에서는 12라는 숫자가 답이 될 수 있겠다.최소 이동 횟수이제 답이 되는 후보를 알았다. 각각의 숫자를 그 숫자를 위해 움직여야 하는 횟수가 있을 것이다.            8      24      9                  $2^3$      $2^3\\cdot 3$      $3^2$              2      1      3        8의 경우 12가 되기 위해서 2를 버리고 3을 얻어야 한다.  24의 경우 2를 버려야 한다.  9의 경우 2를 2개 얻고, 3을 버려야 한다.총 6번의 움직임이 필요하지만, 이것은 하나의 행동이 2번씩 중복되어 나타났다. 이 것을 해소하기 위해서는 최종적으로 답을 내기 위해 2로 나누거나, 하나의 행동만을 제약해서 counting을 하면 된다. (답이 요구하는 개수보다 작을 경우만 센다)구현구현하기 위해 필요한 것을 생각해본다.에라토스테네스의 체에라토스테네스의 체는, 소수를 구하는 방법 중 가장 빠른 방법이다.에라토스테네스의 체  n까지의 소수는 $\\sqrt{n}$ 범위 안에있는 소수를 가지고 구할 수 있다.          소인수 분해를 하면, 해당 수의 제곱근 보다 작은 소인수를 가지고 모든 약수를 구할 수 있다.        소수의 배수는 소수가 아니다.120까지의 소수를 구하기 위해서는 $\\sqrt{120} = 10.9…$즉, 11보다 작은 수, 10까지의 수를 가지고 120까지의 소수를 구할 수 있다.알고리즘void SieveOfEratosthenes(){    for (int i = 2; i &lt;= MAX; i++)        isPrime[i] = true;    for (int i = 2; i*i &lt;= MAX; i++) {        if (!isPrime[i]) continue;        for (int j = i*i; j &lt;= MAX; j+=i)            isPrime[j] = false;    }}이 때, j를 $i^2$ 부터 탐색하는 것에 주목하자. i 이전의 배수들은 그 전의 소수가 이미 걸렀기 때문이다. 해당 알고리즘의 시간 복잡도는 $n\\cdot \\sqrt{n}$ 이다.나머지 필요한 것들  에라토스테네스의 체를 통해 얻은 소수를 저장할 변수가 필요하다.          vector&lt;int&gt; primelist        각각의 입력되는 숫자에 대해 소인수 분해를 하여 담아둘 변수가 필요하다.          vector&lt;vector&lt;int&gt;&gt; input (n, vector&lt;int&gt; (primeNumberSize, 0))      n개의 숫자에 대해 1000000까지 발생하는 소수의 개수 만큼의 배열이 필요하다.      j는 발생하는 소수를 오름차순으로 정렬했을 때의 index이다.        전체 소인수들의 개수를 저장할 변수가 필요하다.          vector&lt;int&gt; whole (primelist.size(), 0)      이제 해야 할 일은 순서도를 작성하는 것이다.알고리즘  에라토스테네스의 체로 1000000까지의 소수를 구한다.  이 소수를 primelist에 저장한다.  primelist의 개수만큼 whole, input 의 크기를 공간을 만든다.  각각의 input이 어떻게 소인수 분해되는지 구한다.  구하는 도중에 전체 배열에 추가한다.  다 구했다면 최종적으로 위에서 구한 방법으로 답을 구한다.Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long ll;#define MAX 1000000bool isPrime[MAX + 1];int whole[MAX + 1];//vector&lt;int&gt; primelist;int N;void SieveOfEratosthenes(){    for (int i = 2; i &lt;= MAX; i++)  isPrime[i] = true;    for (int i = 2; i*i &lt;= MAX; i++) {        if (!isPrime[i]) continue;//        primelist.push_back(i); // 여기다 추가하면 1000 범위내의 소수만 들어간다..        for (int j = i*i; j &lt;= MAX; j+=i) isPrime[j] = false;    }}int main(){    SieveOfEratosthenes();    cin &gt;&gt; N;    vector&lt;int&gt; primelist;    for (int i = 1; i &lt;= MAX; i++) if (isPrime[i]) primelist.push_back(i);    vector&lt;vector&lt;int&gt;&gt; input(N, vector&lt;int&gt;(primelist.size(), 0));    for (int i = 0; i &lt; N; i++) {        int num;        cin &gt;&gt; num;        for (int j = 0; j &lt; primelist.size(); j++) {            if (num == 1) break;            while (num % primelist[j] == 0) {                num /= primelist[j];                whole[primelist[j]]++;                input[i][j]++;            }        }    }    int ans = 1, count = 0;    for (int i = 0; i &lt; primelist.size(); i++) {        int currentWholePrimeCount = whole[primelist[i]]/N;        for (int j = 0; j &lt; N; j++) {            if (currentWholePrimeCount &gt; input[j][i])                count += (currentWholePrimeCount-input[j][i]);        }        ans *= pow(primelist[i], currentWholePrimeCount);    }    cout &lt;&lt; ans &lt;&lt; \" \" &lt;&lt; count &lt;&lt; '\\n';    return 0;}Reference백준(2904번) - 수학은 너무 쉬워",
        
        "url": "/cs/algorithm/2020/04/12/%EB%B0%B1%EC%A4%80-%EC%88%98%ED%95%99%EC%9D%80-%EB%84%88%EB%AC%B4-%EC%89%AC%EC%9B%8C.html"
      }
      ,
    
      "dv-c-2020-04-11-eb-b0-b0-ec-97-b4-ea-b3-bc-ed-8f-ac-ec-9d-b8-ed-84-b0-html": {
        "title": "2차원 배열과 더블 포인터",
        "tags": "c++, pointer",
        "date": "April 11, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "c++에서 2차원 배열과 더블 포인터의 관계에 대해 알아본다.2차원 배열과 더블 포인터",
        
        "url": "/dv/c++/2020/04/11/%EB%B0%B0%EC%97%B4%EA%B3%BC-%ED%8F%AC%EC%9D%B8%ED%84%B0.html"
      }
      ,
    
      "dv-c-2020-04-11-file-ec-9e-85-ec-b6-9c-eb-a0-a5-html": {
        "title": "파일을 사용한 입출력",
        "tags": "c++, 입출력",
        "date": "April 11, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "필요성알고리즘 문제를 푸는데, 예제 입출력이 너무 적다. 어떠한 랜덤 값을 만들어서 넣고싶다. 그런데 이 값이 매우 많아서 일일히 치는 것이나 어디다가 저장해놓고 콘솔에 복붙하는 건 너무 간지가 안난다. 그래서 이 과정을 파일 입출력으로 바꿔서 해본다. 이럴 경우 랜덤으로 값을 뽑기도 쉽고 뭔가더 간지가 난다.입력 (input.txt)510 40 30 50 1010 200출력 (output.txt)600Code#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;int main(){    freopen(\"input.txt\", \"r\", stdin);    freopen(\"output.txt\", \"w\", stdout);    int a, b;    cin &gt;&gt; a &gt;&gt; b;    ...    cout &lt;&lt; ans;}#define _CRT_SECURE_NO_WARNINGSscanf 대신 scanf_s를 사용하는 것은 어떠한 보안상의 문제 때문에 사용한다. 엄밀히 말하면 버퍼 때문인데, 이것은 다른 글을 참고하자. 이럴 때, 컴파일러는 오류를 내는데, 이런 오류를 무시하라는 명령이다.freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);  파일 이름  쓰기, 읽기 모드  어떤 것으로 처리할 것인지위와 같이 쓰면, 파일을 읽은 뒤에, 이것을 cin, cout으로 처리하여 읽도록 만들어 준다.",
        
        "url": "/dv/c++/2020/04/11/file-%EC%9E%85%EC%B6%9C%EB%A0%A5.html"
      }
      ,
    
      "cs-algorithm-2020-04-11-eb-b0-b1-ec-a4-80-ed-8a-b8-eb-a6-ac-ec-9d-98-eb-86-92-ec-9d-b4-ec-99-80-eb-84-88-eb-b9-84-html": {
        "title": "백준(2250번): 트리의 높이와 너비",
        "tags": "백준, 알고리즘, Tree, Union-Find",
        "date": "April 11, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드2 : 트리, 유니온파인드 문제이다.Root 찾기흠.. 입력으로 들어오는 node들이 순차적이지 않다는 점을 알아야 한다.이거 때매 시간 엄청 날렸다 즉, 랜덤으로 들어오는 그래프 정보를 가지고, 어떤 녀석이 tree의 root가 될 것인지 알아내야 한다. 이 과정에서 unionfind 방법을 사용한다. 트리의 자식은 부모를 따른다. 이 점을 사용하여 모든 자식이 따르는 부모을 적어둔 뒤, 최종적으로 갖는 부모가 무엇인지를 찾는다면, 해당 그래프의 root를 찾을 수 있다.트리 그리기그냥 보기에는 해당 문제는 헷갈린다.. 하지만 트리의 기본을 생각한다면 어렵지 않다. 트리는 전위탐색, 후위탐색, 중위(?)탐색이 있다. 용어보다는 의미가 중요하다.위와 같은 트리가 있다고 할 때, 전위 탐색은 좌-중-우, 후위 탐색은 우-중-좌, 중위 탐색은 중-좌-우 와 같은 방식으로 탐색하는 방법이다.이 점을 기억하고 있다면, 세가지 탐색 방법중 전위탐색을 위 문제에 적용해보자. 무조건 왼쪽 먼저 탐색한다면 오른쪽으로 가는 numbering을 하는데 있어 순차적이다.물론 나는 처음에 각 node의 좌우 node 개수를 가지고 부모 노드의 위치를 결정하려 했으나, 이 방법이 보다 효과적이었다.예외문제는 10000개의 정보가 들어올 때 발생하는 트리의 크기를 잘 정해주어야 한다는 것이다. 나는 이 부분을 생각 못하고, 그냥 세그먼트 트리의 level을 구하는 것처럼 level = ceil(log2(N))+1 과 같이 두고 문제를 풀었는데, 당연히 컴파일 에러였다.멍청이최악의 경우를 항상 생각해야 한다. 최악의 경우 10000개의 level을 가질 수 있으므로 이부분을 잘 고려해야 한다. 또한 이 정보를 저장하는 짓은 미친짓이다. 두번째 멍청이짓 10000*10000 배열이 너무 sparse 하다. 그러니, 문제에서 원하는 정보만 뽑아서 제출하는 것이 가장 좋다.Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;vector&gt;using namespace std;struct node {    int left;    int right;};int N;int a[10010] = {0};node b[10010] = {0};vector&lt;vector&lt;int&gt;&gt; map;int col = 1;vector&lt;pair&lt;int, int&gt;&gt; width;// Root 찾기int find(int num){    if (num == a[num]) return num;    return a[num] = find(a[num]);}// Tree 채우며 정보 넣기void fillTree(int num, int level){    if (num == -1) return;    fillTree(b[num].left, level+1);    map[level].push_back(col);    col++;    fillTree(b[num].right, level+1);}// 마지막 정답 찾는 과정에서 정렬 규칙bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b){    if (a.second == b.second) return a.first &lt; b.first;    return a.second &gt; b.second;}int main(){    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N;    vector&lt;int&gt; temp;    for (int i = 0; i &lt;= N; i++) map.push_back(temp);    // unionfind를 위해 초기 부모를 자신으로 업데이트한다.    for (int i = 1; i &lt;= N; i++) a[i] = i;    for (int i = 0; i &lt; N; i++) {        int value, left, right;        cin &gt;&gt; value &gt;&gt; left &gt;&gt; right;        if (left != -1) a[left] = value;        if (right != -1) a[right] = value;        b[value].left = left;        b[value].right = right;    }    int root = find(1);    fillTree(root, 1);    pair&lt;int, int&gt; ans = {0,0};    for (int i = 1; i &lt;= N; i++) {        int size = int(map[i].size());        if (size == 0) break;        sort(map[i].begin(), map[i].end());        int width = map[i][size-1]-map[i][0]+1;        if (ans.second &lt; width) {            ans.first = i;            ans.second = width;        }    }    cout &lt;&lt; ans.first &lt;&lt; \" \" &lt;&lt; ans.second &lt;&lt; '\\n';    return 0;}Reference백준(2250번) - 트리의 높이와 너비",
        
        "url": "/cs/algorithm/2020/04/11/%EB%B0%B1%EC%A4%80-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EB%86%92%EC%9D%B4%EC%99%80-%EB%84%88%EB%B9%84.html"
      }
      ,
    
      "cs-algorithm-2020-04-11-eb-b0-b1-ec-a4-80-ec-a2-8c-ed-91-9c-ec-95-95-ec-b6-95-html": {
        "title": "백준(18870번): 좌표 압축",
        "tags": "백준, 알고리즘, 정렬, 집합, Parametric Search",
        "date": "April 11, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 파라메트릭 서치 문제이다.Root 찾기처음에 또다시 해시로 풀려고 하다가, 중간에 입력값의 범위가 후덜덜한 것을 보고 풀이 방법을 바꾸었다. 이 문제를 그냥 linear하게 풀려고 하면 100000번을 linear하게 탐색해야 하기 때문에 터져버린다.그래서! 이 문제는 파라메트릭 서치로 풀이한다. 하나의 질문에 대해 몇번이 필요한지 사실 결정되어 있다. 입력되는 것들을 집합화 하고, 이것들을 정렬하면, index가 곧 해당 입력의 압축된 좌표이다.  입력52 4 -10 4 -9            집합화      2      4      -10      -9                  정렬      -10      -9      2      4              index      0      1      2      3      잘 보면, 집합화 한 원소를 정렬한 뒤, 이것들을 배열에 넣었을 때, index가 곧 해당 원소의 압축된 좌표이다.따라서, 이제는 입력된 순서대로 이 index를 찾아주기만 하면 된다. 이 때, 찾는 방법으로 이진 탐색을 사용하면 된다.Code#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int N;set&lt;int&gt; s;int arr[1000001];int net[1000001];int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; arr[i];        s.insert(arr[i]);    }    int idx = -1;    for (auto iter = s.begin(); iter != s.end(); iter++) {        idx++;        net[idx] = *iter;    }    for (int i = 0; i &lt; N; i++) {        int start = 0, end = idx;        int now = arr[i];        while (start &lt;= end) {            int mid = (start+end)/2;            if (net[mid] &gt; now) {                end = mid-1;            } else if (net[mid] &lt; now){                start = mid+1;            } else {                cout &lt;&lt; mid &lt;&lt; \" \";                break;            }        }    }    return 0;}Reference백준(18870번) - 좌표 압축",
        
        "url": "/cs/algorithm/2020/04/11/%EB%B0%B1%EC%A4%80-%EC%A2%8C%ED%91%9C%EC%95%95%EC%B6%95.html"
      }
      ,
    
      "cs-algorithm-2020-04-11-eb-b0-b1-ec-a4-80-eb-b0-b0-html": {
        "title": "백준(1092번): 배",
        "tags": "백준, 알고리즘, Greedy, 정렬",
        "date": "April 11, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드2 : 그리디, 정렬 문제이다.생각실제로 운송물을 움직인다고 생각해보자. 그렇다면 가장 무거운 하중을 움직일 수 있는 크레인이 가장 많이 움직여야 최단 시간에 짐을 움직일 수 있다. 이부분이 핵심이다. 그리고 짐을 움직일 수 없는 경우는, 가장 무거운 하중을 움직일 수 있는 크레인이 가장 무거운 하중을 못옮길 때이다.알고리즘  가장 무거운 하중을 옮길 수 있는 순서로 정렬한다.  하중도 무거운 하중부터 정렬한다.  가장 무거운 하중을 옮길 수 있는 크레인이 가장 무거운 하중을 옮길 수 있는지 확인한다.  옮길 수 없다면 -1을 출력한다.  옮길 수 있다면 가장 무거운 하중을 옮기는 크레인 부터 무거운 하중 부터 옮긴다.  이 과정을 모든 하중을 옮길 때까지 반복하고 그 때까지 걸리는 시간을 출력한다.Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;using namespace std;int N, M;int crane[51];vector&lt;int&gt; box;int main(){    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; crane[i];    }    cin &gt;&gt; M;    for (int i = 0; i &lt; M; i++) {        int temp;        cin &gt;&gt; temp;        box.push_back(temp);    }    sort(crane, crane+N, greater&lt;&gt;());    sort(box.begin(), box.end(), greater&lt;&gt;());    if (box[0] &gt; crane[0]) {        cout &lt;&lt; -1 &lt;&lt; '\\n';        return 0;    }    int loaded = 0, index = 0, count = 0;    while (loaded != int(box.size())) {        for (int i = 0; i &lt; M; i++) {            if (crane[index] &gt;= box[i] &amp;&amp; box[i] != 0) {                box[i] = 0;                loaded++;                index++;            }            if (index == N) break;        }        count++;        index = 0;    }    cout  &lt;&lt;  count &lt;&lt; '\\n';    return 0;;}Reference백준(1092번) - 배",
        
        "url": "/cs/algorithm/2020/04/11/%EB%B0%B1%EC%A4%80-%EB%B0%B0.html"
      }
      ,
    
      "cs-network-2020-04-09-ec-bb-b4-ed-93-a8-ed-84-b0-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-03-http-html": {
        "title": "03: HTTP",
        "tags": "Network, HTTP",
        "date": "April 9, 2020",
        "author": "",
        "category": "CS/Network",
        "content": "HTTP Protocol 특징 (간략)  HyperText Transport Protocol  Message 종류 두 가지          Request &amp; Response        TCP 사용          Transport Layer 위에 Application Layer 존재        stateless protocol          상대방 상태정보를 저장하지 않음      그냥 request, response후 아무것도 저장 안한다.      Non-Persistent HTTPRequest Message 를 서버로 보내기 위해선 우선 TCP Connection이 선행되어야 한다. 그리고 request msg 에 대해서 response msg 를 받게되면 TCP Connection 은 끊기며 다시 웹사이트의 리소스를 들고오기 위해선 TCP Connection 을 재차 맺어야한다. Connection 이 지속적인 상태가 아니다.  HTTP client가 IP/PORT에 TCP 연결을 시작한다.  HTTP server의 host는 80번 포트에서 TCP 연결을 기다리다가 문제가 없으면 “accept” 라고 client에게 알린다.  HTTP client는 HTTP request 메시지를 TCP 연결 Socket에 보낸다.  HTTP server는 요청을 받고 response를 socket에 넣는다.  HTTP sever는 TCP 연결을 끊는 준비를 한다.  HTTP client는 응답을 받고 화면에 보여준다.  HTTP client가 다 받았다면 다 받았다는 메시지를 보낸다.  함께 Connection을 끊는다.Persistent HTTP웹클라이언트 (브라우저) 는 보통 같은 사이트에 여러 개의 TCP 커넥션을 맺는다. 예를 들어 웹 페이지에 첨부된 이미지들 대부분은 같은 웹사이트에 있으며, 여러 하이퍼링크도 같은 사이트를 가리키는 경우가 있다. 여기서 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹 페이지의 다른 이미지 등을 가져오기 위해서 그 서버에 또 다시 요청하는 경우가 생기는데, 이 속성을 사이트 지역성(Site Locality)이라고 부른다. 하지만 이러한 TCP 커넥션을 계속 유지하여 앞으로도 있을 HTTP 요청에 재사용할 수 있도록 하는 것이다. 처리가 완료된 이후에도 계속 연결된 상태로 있는 TCP 커넥션을 Persistent Connection 이라고 한다.ReferenceKOCW 이석복 교수님 - 컴퓨터네트워크",
        
        "url": "/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-03-HTTP.html"
      }
      ,
    
      "cs-network-2020-04-09-ec-bb-b4-ed-93-a8-ed-84-b0-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-02-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-eb-84-93-ea-b2-8c-eb-b3-b4-ea-b8-b0-2-html": {
        "title": "02: 네트워크 넓게 보기 Part 2",
        "tags": "Network, TCP, Socket, overview",
        "date": "April 9, 2020",
        "author": "",
        "category": "CS/Network",
        "content": "기본 용어 정리네트워크  프로그램을 동작시키는 프로세스의 일종, 메시지 교환, 송수신Net + Work 의 합성어이다. 메세지를 교환하며 송수신을 한다. 좀 더 추가하자면 두 대 이상의 디바이스가 논리적 혹은 물리적으로 연결되어 통신이 가능한 상태임을 말한다.IPC(Inter Process Communication)프로세스는 완전히 독립된 실행객체이다. 서로 독립되어 있다는 것은 다른 프로세스의 영향을 받지 않는다는 장점이 있다. 그러나 독립되어 있기 때문에 별도의 설비가 없이는 서로 간에 통신이 어렵다는 문제가 있으며, 이를 위해 커널 영역에서는 IPC라는 내부 프로세스간 통신(Inter Process Communication)을 제공한다. 이 기능을 사용하여 프로세스는 프로세스간 통신이 가능케 한다.Socket  프로세스간 통신 interfaceIPC를 가능케하는 interface이다. 서로 다른 process에서 접속을 하려 할 때, 이 socket을 사용하여 접근하게 되고, 해당 socket은 접속하는 process가 제대로 왔는 지와 같은 검사를 수행하게 된다. 은행에서 창구를 생각하면 된다.사용자 입장에서 소켓을 통해 메시지를 내려받을 때, 원하는 요구사항  timing          빠른 시간내에 데이터가 도착했으면 좋겠다. (음성)        security          안전하게 나한테만 왔으면 좋겠다.        data integrity          모든 데이터가 순서에 맞게 제대로 왔으면 좋겠다.        Throughput          특정 시간안에 도착하는 데이터의 양이 많았으면 좋겠다. (영화 다운로드)      등이 있지만, 실질적으로 TCP를 사용한다고 가정했을 때 제공받을 수 있는 것은 3번 뿐이다. UDP를 사용할 경우 3번도 지켜지지 않는다. 결과적으로 내가 위의 3가지에 해당하는 기능을 원한다면, 애플리케이션 계층에서 구현하여야 한다.IP  인터넷 공간 상에서 해당 단말기의 고유 주소Socket을 통해 통신한다는 것은 알았다. 근데 우리가 전화를 걸더라도, 어디에 전화를 걸것인지 알아야 한다. 그걸 대표하는 것이 전화번호이다. 마찬가지로 통신을 하려면, 어디에 통신할 것인지 알려주는 과정이 필요하다. 그 어디에 해당하는 것이 IP 주소 이다.Port  IP 주소를 갖고 있는 컴퓨터에서 Process에 접근하기 위한 번호해당 컴퓨터에 들어가더라도, 어떤 process에 접근하는지를 알아야 한다. 그걸 대표하는 것이 포트 번호이다. 특정 프로토콜은 특정한 포트번호로 설정되어 있다.예를 들어 웹 서버의 포트 번호는 기본적으로 80번 포트로 약속되어 있다.DNS  도메인이름을 치면 IP주소로 바꿔주는 서비스naver.com -&gt; 192.168.03.2 OR 192.168.03.2:80TCP 특징 (간략)  Transmission Control Protocol  Reliable Transport          신뢰성 있는 전송 (패킷 유실없이 감 : 패킷이 유실되지 않는다는 것이 아니다.)        Flow Control          수신 호스트의 데이터 처리속도를 고려하여 속도를 조절        Congestion Control          네트워크 상황에 맞게 속도 조절      UDP 특징 (간략)  User Datagram ProtocolTCP와 완전 반대이다. 어떠한 규약없이 server가 그냥 보낸다.ReferenceKOCW 이석복 교수님 - 컴퓨터네트워크",
        
        "url": "/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-02-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%93%EA%B2%8C-%EB%B3%B4%EA%B8%B0-2.html"
      }
      ,
    
      "cs-network-2020-04-09-ec-bb-b4-ed-93-a8-ed-84-b0-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-01-eb-84-a4-ed-8a-b8-ec-9b-8c-ed-81-ac-eb-84-93-ea-b2-8c-eb-b3-b4-ea-b8-b0-1-html": {
        "title": "01: 네트워크 넓게 보기 Part 1",
        "tags": "Network, Router, Protocol, Bandwidth, Traffic, Delay, overview",
        "date": "April 9, 2020",
        "author": "",
        "category": "CS/Network",
        "content": "기본 용어 정리프로토콜  서로 다른 개체들이 서로 간의 의사소통을 하기 위해 만들어놓은 규약사람이 대화를 하는 과정에도 일정한 흐름과 규약이 존재한다. 어떠한 객체가 소통하기 위해서는 서로의 방식을 맞추어야 한다.패킷  한번에 전송할 데이터의 크기편지를 내가 썼다. 그 편지를 누군가한테 보내는데, 글자하나하나를 보내지 않는다. 이 때 편지는 우체부 아저씨가 누군가한테 배달하는 단위가 된다. 이와 같은 개념이 패킷이다. 패킷은 데이터를 보내는 데 있어 발생하는 단위이다. 이 패킷의 구조에 대해서는 나중에 알아보자.대역폭  수도관의 크기결국 데이터는 흐름이다. 그렇기 때문에 어떤 관을 따라간다고 생각할 수 있다. 이 때 관의 지름이 대역폭이다. 한번에 보낼 수 있는 데이터의 양이라 생각하면 된다. 이 크기가 클수록 많은 데이터를 초 당 전송할 수 있는 양이 늘어난다. 인터넷 속도와 직결된다.트래픽  어떤 통신장치나 시스템에 걸리는 부하(전송량)요청에 대해 전송해주는 시간 대비 데이터의 총량을 말한다.네트워크 구조네트워크 엣지(Network Edge)  말단 device, 우리가 사용하는 대부분의 기기에 해당한다.네트워크 코어(Network Core)  엔드 시스템을 연결하기 위한 중간의 매개들을 말한다.물리적 링크  코어와 엣지 사이에 존재하는 데이터 전송 선과 같은 것들을 의미한다.네트워크의 내부라우터네트워크 내부에 존재하는 장치(네트워크 코어)들로써, 라우터는 사용자들이 보낸 메세지를 목적지까지 전달하는 역할을 가지고 있다. 결국 라우터는 데이터를 전달하는 장치이다.라우터의 데이터 전달방식      Circuit Switching          출발지부터 목적지까지의 대역폭을 예약해놓은 상태로써, 한번에 데이터를 전달하는 것이다. 하나의 회선을 할당받아 (회선을 독점하여) 데이터를 전달하기 때문에 아무런 방해없이 한번에 전달할 수 있다. 예시로 전화망이 있다. 전화를 걸게되면 전화를 건 송신자로부터 수신자의 전화기에 이르기까지의 경로를 찾아내고, 한번 설정된 송신자와 수신자의 경로는 데이터(음성) 이 전송되는 동안 계속 유지되는 것이다. 이 예로 부터 Circuit Switching은 언제든지 계속 사용하는 시스템에 적합하다는 것을 알 수 있다.                  장점      단점                  대역폭이 결정되므로, delay가 발생할 수 없다.      일정 사용자에게 할당해주므로 낭비가 발생한다.            Packet Switching          사용자가 보내는 데이터가 패킷단위로 잘게 나뉘어서 전달되는 것이다. 패킷은 출발지에서 다음 라우터로 전송하기 이전에 저장하고 어느 경로로 갈지 결정하는 Store and Forward 방식을 취한다. 패킷의 헤더에는 출발지(source) 와 목적지(destination) 에 대한 정보가 들어있다. 대부분의 경우는 이 사용법을 택한다. 인터넷을 사용하는 패턴이 Packet Switching 에 적합하기 때문이다. 연속된 요청이 필요없기 때문에 대역폭을 할당할 필요가 없다.                  장점      단점                  짧게 사용하는 다수의 사용자도 커버가 가능하다.      짧은 시간에 많은 요청이 들어올 경우 delay가 발생한다.      Packet Delay패킷스위칭을 시 라우터는 패킷단위의 데이터를 전달받고 목적지로 전달하는 역할을 수행한다. 이 과정에서 라우터가 보낼 수 있는 대역폭보다 더 많은 유저가 더 빠른 속도로 데이터를 보낸다면 딜레이가 생길 수 밖에 없다. 톨게이트에 사람이 마구 몰리는 상황을 상상해보자.Delay의 구분Processing Delay  패킷 자체를 평가한다.필연적인 딜레이 중 하나로써, 목적지에 따른 어느 라우터로 전송할 지 결정하는 것에 대한 지연이다. 이 과정에서는 패킷의 형식을 검사하고, 목적지를 판단하는 과정을 수행한다.Queueing Delay  들어온 패킷들을 줄세운다.데이터를 전달하는 라우터의 큐에 들어가서 앞서서 도착해 큐에 대기중인 패킷들이 모두 나갈때까지 걸리는 지연이다. (큐에 얼마나 많이 들어가있는지에 따라서 큐잉 딜레이는 가변적)Transmission Delay  패킷하나가 모두 전송되기 까지 걸리는 시간라우터의 큐 제일 앞에 배치되어서 패킷 하나가 온전하게 마지막 비트까지 최종 목적지로 가는데까지의 지연이다. 패킷은 전송의 한 단위이기 때문에, 하나의 패킷이 모두 전송이 되어야 sender는 전송이 되었다고 판단한다. 예를 들면 패킷의 bit가 100bits이고 대역폭이 1bps 이면 1초당 1bit만 전송할 수 있기 때문에 100초 후에 이 패킷은 전송되었다고 판단할 수 있다.Propagation Delay  실제로 비트가 선을 따라 전송되는데 걸리는 시간마지막 비트까지 대역폭에 올라오고, 이후에 마지막 비트가 최종 목적지까지 도달하는 물리적 시간이다. 이 속도는 전자기파의 속도라 사실 많은 영향을 주지는 않는다. ( 가까우면 빨리, 거리가 멀면 오래 걸림)결과적으로 라우터에서 패킷을 받을 때 걸리는 nodal delay 는 위 4가지의 지연의 합으로 표현된다.Delay 줄이기Processing Delay라우터에 좋은 처리장치를 달아서 패킷에 대해 판단하는 속도를 향상시킨다.Queueing Delay사용자의 패턴에 의존하기 때문에 불가능하다. 통계적 기법을 사용해야 한다.Transmission Delay패킷하나가 빠져나가는 시간을 줄인다. 초당 선송할 수 있는 양을 늘리면 된다. 마치 톨게이트에서 5차선이었던 것을 10차선으로 바꾸면 한번에 빠져나갈 수 있는 차량의 수가 증가한다. 이 때, 이 차선에 대응되는 개념이 대역폭이다.Propagation Delay빛의 속도는 세상에서 가장 빠르다.. 불가능하다.Packet Loss  큐에 패킷이 가득차있는 경우 버려진다.라우터의 큐에 삽입되기 이전에 큐에 패킷이 가득차있는 경우 큐의 저장공간이 없기 때문에 Packet Loss 가 발생하며, 패킷은 버려진다.TCP 작동이런 경우 안전한 전송을 담당하는 Client 쪽의 TransportLayer 계층의 TCP 프로토콜이 해당 패킷을 재전송한다. 잘 몰라도 된다. 나중에 배운다.ReferenceKOCW 이석복 교수님 - 컴퓨터네트워크",
        
        "url": "/cs/network/2020/04/09/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-01-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%93%EA%B2%8C-%EB%B3%B4%EA%B8%B0-1.html"
      }
      ,
    
      "cs-algorithm-2020-04-08-eb-b0-b1-ec-a4-80-ea-b8-b0-ed-83-80-eb-a0-88-ec-8a-a8-html": {
        "title": "백준(2343번): 기타 레슨",
        "tags": "백준, 알고리즘, Parametric Search, 이분탐색",
        "date": "April 8, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 이분 탐색, Parametric Search 문제이다.생각처음에 이 문제를 풀 때, 세그먼트 트리로 풀려고 했다. 그런데, 문제가 생겼다. 그렇게 구현하려면, 100000개 를 50000개의 블루레이에 담으려고 한다면 계속해서 재귀 함수를 타고 들어가며 구해야 한다. 시간 제한이 2초이고, 또한 재귀함수의 depth가 너무 깊어져 이 방향으로 문제를 해결하면 안된다고 판단했다.고민을 하던 중, 답을 먼저 제안하고, 이 답을 기반으로 역으로 추적하면 어떨까하는 생각이 들었다. 이 방법을 파라메트릭 서치(parametric Search)라 한다.Parametric Search  최적화 문제를 결정 문제로 바꾸어 해결한다.이진 탐색과 비슷한 방법이다. 그런데 어떤 상황에서 사용하는지 알아야 한다. 위의 문제는 결국, N개의 입력이 들어왔을 때, 이걸 M개로 나누고, M개로 나눈 각각의 뭉텅이들 사이에서 최댓값들을 뽑아 그것의 최솟값을 구하는 문제이다. (응?)  입력 N을 M개의 집합으로 자른다. 다양한 가지수로 자를 수 있다. 이 가지수를 K라 하자.  그 집합들의 합을 갖고 있는다.  그 요소들을 가지는 집합 L를 만든다. (K의 요소 개수는 M개, 발생하는 집합 L의 개수는 K개)  발생한 모든 L 집합에 대해 요소들의 최댓값을 구한다. 그 최댓값을 모은 집합을 P라 하자. (P의 요소 개수는 K개)  P집합의 요소들 중 최소값을 구한다.완전 탐색을 한다면 위와 같이 할 수 있을 것이다. 그런데, 결국 이 문제는 최적의 디스크 크기를 구하는 문제이다. 이런 문제에서 새로운 발상을 할 수 있는데, 답은 제안하는 것이다.방법이 문제에서 내가 원하는 것은 disk 크기를 구하는 것이다. 이 disk 크기가 될 수 있는 최솟값과 최댓값을 계산해보자. N = 100000 이고, 각각의 동영상 용량은 10000이 최대이므로, 이 동영상 모두를 한 disk에 넣는다면 1000000000크기가 최대이다. 일단 이해를 하는 과정이기에 최댓값을 100이라 가정하겠다.과정은 이분 탐색과 비슷하다. 답이 될 수 있는 최소, 최대에서 반이 답이 되는지 되지 않는지 판단한다.너무 디스크 크기가 작다면 오른쪽을 탐색한다.너무 디스크 크기가 크다면 왼쪽을 탐색한다.위의 과정을 반복하여 답을 도출한다.결국 위 방법의 핵심은, 원하는 답의 범위를 설정하고 이 값이 되는지 안되는지를 파악한다. 이다. 이러한 방법을 사용하기로 마음 먹었다면, 어떠한 조건에서 탐색의 방향을 바꿀 수 있는지, 해당 문제의 특징은 무엇인지 확인해야 한다.문제의 특징  M개의 disk를 사용했을 때, disk 크기가 가장 줄어들 수 있다.  만약 10개의 disk를 사용할 수 있다고 하자. 그렇다면 답은 N을 10개로 나누었을 때 가장 작게 나눌 수 있다.  물론 10개보다 적은 수의 disk를 사용해서 나누었을 때 10개를 사용했을 때의 답과 같게 나올 수는 있다.  따라서 10개보다 적은 수의 disk를 사용할 경우에도 답을 업데이트 해주는 대상이 된다.  또한 M개의 disk를 사용할 수 있는 모든 경우의 수를 비교해야 한다. 처음에 M개로만 나뉘면 답이라 해서 틀렸다. ㅠ탐색 조건  제시한 블루레이 Size를 가지고 만들었을 때 나온 값이 M보다 크면 Size를 키운다.제시한 Size를 가지고 N를 최대한 나눈 결과 가지고 있는 블루레이 갯수(M)보다 disk가 더 필요하다는 결론이 나오면, 현재 disk 사이즈가 너무 작아 더 필요로 한다는 결론이다. 따라서 disk 크기를 키워야 한다.  제시한 블루레이 Size를 가지고 만들었을 때 나온 값이 M보다 작으면 지금 제시한 값을 업데이트 한다.나온 값과 이전에 탐색한 답 중 최솟값으로 업데이트 한다.  제시하는 답은 video의 값보다는 항상 같거나 커야한다.1 2 3 4 5 라는 video가 들어온다고 가정하자. 이 때, 내가 제시하는 답은 5보다 항상 같거나 커야 한다. 만약 3이라는 답을 제시한다면 4와 5는 disk에 들어갈 수도 없으므로 논리에서 벗어난다.Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int video[100000];int N, M, ans = 1e9;bool isOk(int value){    int sum = 0, count = 1;    for (int i = 0; i &lt; N; i++) {        if (value &lt; video[i]) return false;        if (sum + video[i] &gt; value) {            sum = video[i];            count++;        }        else sum += video[i];        if (count &gt; M) return false;    }    return true;}int main(){    cin &gt;&gt; N &gt;&gt; M;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; video[i];    }    int left = 0, right = 1e9;    while (left &lt;= right) {        int mid = (left+right)/2;        if (isOk(mid)) {            ans = min(ans, mid);            right = mid - 1;        } else {            left = mid + 1;        }    }    cout &lt;&lt; ans &lt;&lt; '\\n';}Reference백준(2343번) - 기타 레슨",
        
        "url": "/cs/algorithm/2020/04/08/%EB%B0%B1%EC%A4%80-%EA%B8%B0%ED%83%80-%EB%A0%88%EC%8A%A8.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-20-eb-94-94-ec-8a-a4-ed-81-ac-ec-8a-a4-ec-bc-80-ec-a4-84-eb-a7-81-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "20: 디스크 스케쥴링 알고리즘",
        "tags": "OS, Disk, Disk Scheduling",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "하드 디스크의 구조를 바탕으로 스케쥴링을 하는 방법에 대해 알아본다.1. 디스크 스케줄링보조기억장치는 현재 여러 가지 존재하지만 아직까지는 하드 디스크가 주로 사용된다.하드 디스크의 구조는 앞서 살펴봤듯이 위 그림과 같다. 디스크에 접근하는 시간은 Seek time(탐색 시간) + rotational delay + transfer time 으로 계산할 수 있는데, 이 중에서 seek time(head를 움직이는 시간)이 가장 크다.현재 컴퓨터 환경은 대부분 다중 프로그래밍 환경이다. 그러므로 여러 프로세스가 메인 메모리에서 실행 중에 있는데, 이러한 여러 프로세스가 동시에 디스크를 읽으려는 요청이 올 수 있다. 이와 같은 요청이 오면 디스크 역시 CPU와 같이 디스크 큐(dist queue)에서 요청을 저장해두고 이를 처리해야 한다.여기서 컴퓨터의 성능을 위해 여러 요청들을 효율적으로 처리해야 한다. 디스크를 읽는 시간은 매우 오래 걸리는 작업이고 특히 탐색 시간이 오래걸리므로 최대한 이 시간을 줄이는 것이 중요하다. 이러한 방법들을 디스크 스케줄링 알고리즘이라 한다.1.1 FCFS(First-Come First-Served)이 방법은 어느 스케줄링 알고리즘에서도 존재하는 가장 간단하고 가장 공평한 방법이다. 바로 예제를 살펴보자.1.1.1 예제200 cylinder dist: 0, 1, 2, ..., 199Disk queue: 98, 183, 37, 122, 14, 124, 65, 67현재 헤드가 가리키는 실린더(cylinder) 위치: 53예제를 그림으로 나타내면 위 그림과 같다. 가로축은 0번부터 199번까지 실린더의 위치를 나타낸다. 여기서 파란색 선이 dist queue를 FCFS 방법으로 처리한 결과이다.  헤드가 움직인 총 거리          = (98 - 53) + (183 - 98) + (183 - 37) + (122 - 37) + (122 - 14) + (124 - 14) + (124 - 65) + (67 - 65) = 640 cylinders      위 그림의 결과를 본 것처럼 큐에 들어온 순서가 큰 값, 작은 값이 반복한다면 헤드가 움직이는 거리가 매우 커짐을 알 수 있다.1.2 SSTF(Shortest-Seek-Time-First)SSTF 스케줄링 알고리즘은 가장 짧은 탐색 시간을 먼저 선택하는 것이다. 다시 말하면 현재 헤드가 다음 요청을 처리하기 위해 움직여야 하는 거리가 가장 짧은 것을 선택하는 것이다.1.2.1 예제200 cylinder dist: 0, 1, 2, ..., 199Disk queue: 98, 183, 37, 122, 14, 124, 65, 67현재 헤드가 가리키는 실린더(cylinder) 위치: 53위 예제는 FCFS 스케줄링에서 본 예제와 같은 것이다. 처음 헤드 위치 53을 시작으로 dist queue에 있는 실린더 번호 중 53과 가장 가까운 65번 실린더를 선택한다. 65번에서는 가장 가까운 67번을 선택하고 같은 과정을 반복한다.  헤드가 움직인 총 거리          = (65 - 53) + (67 - 65) + (67 - 37) + (37 - 14) + (98 - 14) + (122 - 98) + (124 - 122) + (183 - 124) = 236 cylinders      SSTF 스케줄링 알고리즘의 결과는 위 예제에서 FCFS 스케줄링보다 훨씬 적은 수의 실린더를 움직이는 것을 볼 수 있다. 하지만 SSTF 스케줄링의 큰 단점은 기아(starvation)가 발생할 수 있다. dist queue에는 지속적으로 새로운 프로세스의 요청이 들어오기 때문에 헤드와 멀리 떨어져 있는 실린더는 끝내 수행하지 못하는 현상이 발생하는데, 이를 starvation이라고 한다.그리고 SSTF 스케줄링이 현재와 가장 가까운 실린더를 선택한다고 해서 최적의 알고리즘은 아니다. 위 예제에서도 가장 처음 위치인 53번 실린더에서 65번이 아닌 37번으로 이동한 후에 SSTF 알고리즘을 수행하면 208 cylinders 가 나온다.그리디가 아니다1.3 ScanScan 스케줄링은 말그대로 헤드가 지속적으로 디스크를 앞뒤로 검사하는 것이다. 그래서 헤드가 앞으로 스캔할 때(번호가 작은 실린더 방향)와 뒤로 스캔할 때(번호가 큰 실린더 방향) 선택하는 실린더가 서로 다르다. 즉 관성을 고려하여 한방향으로 쭉 가다가 끝이면 반대 방향으로 돈다.1.3.1 예제200 cylinder dist: 0, 1, 2, ..., 199Disk queue: 98, 183, 37, 122, 14, 124, 65, 67현재 헤드가 가리키는 실린더(cylinder) 위치: 53스캔 방향: 0번 방향으로 움직임(번호가 작은 실린더 방향)위 결과에서 볼 수 있듯이 스캔 방향이 0번 실린더 방향이므로 53번에서 작은 번호의 실린더로 향한 후에 큰 번호 실린더로 움직인 것을 볼 수 있다.  헤드가 움직인 총 거리          = (53 - 37) + (37 - 14) + (14 - 0) + (65 - 0) + (67 - 65) + (98 - 67) + (122 - 98) + (124 - 122) + (183 - 124) = 236 cylinders      여기서 한 가지 생각해 볼 점은 일반적으로 프로세스들이 디스크에 요청할 때 그 위치를 종합해보면 실린더에 골고루 퍼져있다. 그러므로 Scan 스케줄링 알고리즘처럼 앞뒤로 움직이는 것이아니라 처음부터 한 방향으로 끝까지 움직이고 다시 처음으로 되돌아가서 같은 방향으로 끝까지 움직이는 것이 더욱 효과적이다.이러한 아이디어에서 나온 것이 Circular Scan 스케줄링 알고리즘이다.1.4 C-Scan이 방식은 위에서 말한 Circular Scan 스케줄링 알고리즘이다. 즉 한 방향으로 계속 움직이는 것이다. Scan 방식은 끝에 다다랐을 때 반대방향으로 가는데, 굳이 그럴 필요가 없다. 물론 오른쪽에서 왼쪽 끝으로 갈 때 한바퀴를 돌기 때문에 움직이는 거리는 더 길어질 수 있지만 다시 처음 위치로 되돌아갈 때는 데이터를 읽지 않으므로 더 빠른 속도로 움직일 수 있다. (그냥 모터로 슝 긁으면 된다.)1.5 Look이 알고리즘은 위 Scan 스케줄링 예제에서 0번 실린더가 존재하지 않지만 0번까지 가는 모습을 보았다. (찍턴하기 위해서) 이러한 비효율적인 움직임을 없애기 위해 존재하는 실린더의 최소와 최대 범위만 움직이는 알고리즘을 Look 스케줄링 알고리즘이라고 한다. 하지만 이 범위를 알기 위해서 미리 큐를 검사해야한다. (어디가 가장 근접한 끝인지 알아야 하기 때문)1.6 C-LookC-Look은 Circular Look 을 말한다. Look은 위에서 Scan 스케줄링이 0번 부터 끝 실린더까지 움직이지 않고 존재하는 실린더의 최소에서 최대 범위를 움직인다고 하였는데, C-Look은 이 범위에서 C-Scan과 같이 한 방향으로만 움직이는 것을 말한다. 즉, 최대 실린더에서 최소 실린더 방향으로 움직인다고 할 때 최소 범위에 도달하면 다시 최대 범위로 되돌아가서 같은 방향으로 움직인다.1.7 Elevator AlgorithmElevator Algorithm은 Scan과 파생되어 나온 알고리즘(C-scan, Look, C-Look)을 부르는 다른 용어이다. 위 Scan 스케줄링 알고리즘 예제 그림을 90도로 회전하면 엘리베이터의 모습과 유사하여 붙여진 이름이다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-20-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-19-ed-8c-8c-ec-9d-bc-ed-95-a0-eb-8b-b9-html": {
        "title": "19: 파일 할당 (Allocation of file)",
        "tags": "OS, Memory, frame allocation",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "보조 기억 장치에 저장되는 파일의 할당에 대해 알아본다.컴퓨터 시스템 자원 중 가장 중요한 것은 CPU이다. CPU 자원 관리에 대해서는 맨 처음 부분에서 다루었으며 CPU 스케줄링, 프로세스 동기화 등에 대해서 배웠다. CPU 다음으로 중요한 자원은 메인 메모리와 같은 주기억장치이다. 메인 메모리 관리에 대한 주요 이슈는 페이징, 가상 메모리(요구 페이징) 등이 있었다.CPU, 주기억장치 다음 중요한 컴퓨터 시스템 자원은 하드디스크와 같은 보조기억장치이다. 하드디스크가 데이터를 관리하는 방식은 파일 시스템이다. 파일은 컴퓨터에서 운영체제를 사용해본 사용자라면 매우 익숙한 단어일 것이다. 대표적인 windows 운영체제를 보면 폴더(디렉토리) 내부에 또 다른 폴더 또는 어떠한 파일이 존재한다. 이러한 폴더 및 파일은 트리 구조로 관리할 수 있다.이번 장에서는 보조기억장치 중 컴퓨터에서 주로 사용하는 하드디스크의 파일이 할당되는 방법에 대해서 살펴볼 것이다.1. HDD 구조위 그림은 하드디스크의 구조이다.  platter          실제 데이터를 기록하는 자성을 가진 원판이다. platter는 그림과 같이 여러 개가 존재하고 앞뒤로 사용할 수 있다. 한 platter는 여러 개의 track으로 이루어져 있다.        track          platter의 동심원을 이루는 하나의 영역이다.        sector          하나의 track을 여러 개로 나눈 영역을 sector라 한다. sector size는 일반적으로 512 bytes이며 주로 여러 개를 묶어서 사용한다.        cylinder          한 cylinder는 모든 platter에서 같은 track 위치의 집합을 말한다.      앞서 sector는 여러 개로 묶어서 사용한다고 했는데, 이를 블록(block)이라 한다. 하드디스크는 블록 단위로 읽고 쓰기 때문에 block device 라고 불리기도 한다.하드디스크가 블록 단위로 읽고 쓰는 것을 확인할 수 있는 간단한 방법은 메모장 프로그램에서 알파벳 a만을 적고 저장해보자. a는 character로 1byte 크기를 갖는데, 실제 저장된 텍스트 파일의 속성을 확인하면 디스크에 4KB(하나의 block size) 가 할당되는 것을 확인할 수 있다.(실제 디스크 할당 크기는 운영체제마다 다르다.)따라서 디스크는 비어있는 블록들의 집합이라고 볼 수 있다.(pool of free blocks) 그렇다면 운영체제는 각각의 파일에 대해 free block을 어떻게 할당할까?2. 파일 할당위 그림은 pool of free blocks를 논리적인 그림으로 나타낸 모습이고 블록마다 인덱스 번호를 설정하였다. 블록들이 위와 같이 있을 때 파일을 할당하는 방법은 크게 연속 할당, 연결 할당, 색인 할당 세 가지가 존재한다.2.1 연속 할당 (Contiguous Allocation)연속 할당은 말그대로 연속된 블록에 파일을 할당 하는 것이다. 예를 들어, 블록 크기가 1KB이고, 할당할 파일은 f1, f2, f3 3개가 있고 각각의 크기는 5KB, 3KB, 4KB이다.앞선 예제로 연속 할당을 수행하면 위의 그림과 같은 모습이 나온다.2.1.1 연속할당의 장점연속 할당에는 세 가지 특징이 있다.  연속 할당의 장점은 디스크 헤더의 이동을 최소화 할 수 있다.          I/O 성능을 높일 수 있다. 이 방식은 예전의 IBM에서 사용하던 방법이며 주로 동영상, 음악, VOD 등에 적합하다.        순차 접근(Sequential Access)이 가능하다.          이는 말그대로 순서대로 파일을 읽을 수 있다는 의미이다.        직접 접근(Direct Access)이 가능하다.          운영체제는 파일의 정보를 디렉토리(directory) 라는 테이블에 저장한다. 디렉토리에서 사용자가 접근가능한 정보는 파일의 이름, 크기, 날짜 등이 있고, 운영체제 내부에서 접근하는 정보는 해당 파일의 시작 블록 번호와 같은 것이 있다. 예를 들어, 위 예제의 f1 파일의 디렉토리 정보는 아래와 같다.      file name: f1file size: 5 bytes...-----------------block number: 0연속 할당은 순차적으로 저장되어 있으므로 운영체제는 디렉토리에서 얻은 시작 블록 번호로 원하는 블록에 바로 접근할 수 있다. 예를 들어, 위 예제에서 f1 파일의 3번째 블록에 접근하고 싶다고 가정하자. 운영체제는 f1의 시작 블록 번호가 0번인 것을 알고 있기 때문에 2번 블록에 접근하면 f1의 3번째 블록이라는 것을 알 수 있다.2.1.2 연속할당의 단점연속 할당은 현재에는 거의 사용하지 않는 방식인데, 이 방법에는 큰 단점이 존재하기 때문이다.  외부 단편화 문제가 발생한다.          파일을 할당하고 지우고를 반복하다보면 중간 중간에 빈 공간(hole)이 생기는데 연속 할당은 연속된 공간을 찾아야 하기 때문에 이전 메인 메모리 할당에서 살펴본 것과 같이 외부 단편화 문제가 발생한다.      외부 단편화로 인해 디스크 공간의 낭비가 매우 심해진다. 이전 메모리 할당에서 외부 단편화로 인해 메모리의 약 1/3을 낭비한다고 하였는데, 디스크의 연속 할당도 같은 낭비가 발생한다.        파일을 저장할 때 실제 크기를 알 수 없다.          특히, 계속해서 사용하는 파일의 경우 크기가 계속 증가 할 수 있기 때문에 이를 지속해서 연속적으로 할당하기에는 매우 부적절하다.      2.2 연결 할당 (Linked Allocation)연결 할당은 연속 할당의 문제점을 해결하기 위해 나온 방법으로, 연속적으로 할당하는 것이 아니라 링크드 리스트(linked list) 와 같은 방식으로 파일을 할당한다위 그림은 block 크기가 1 byte, 파일 f1의 크기가 5 bytes 일 때 연결 할당을 수행한 모습이다. 각 블록의 마지막에 주소를 저장하는 포인터 공간(4bytes)이 존재하며, 여기서 다음 블록을 가리키고 있다. 마지막 블록의 포인터 공간에는 끝임을 나타내는 값이 저장되어 있다.이러한 파일을 linked list of data blocks 라고 하며, f1의 파일 디렉토리 정보는 아래와 같다.file name: f1file size: 5 bytes...-----------------block number: 62.2.1 연결할당의 장점  위치와 상관없이 할당이 가능하므로 외부 단편화 문제가 없다. (= 디스크 낭비가 없다.)          연결 할당을 사용해서 새로운 파일을 할당할 때는 비어있는 임의의 블록을 첫 블록으로 선택하며, 만약 파일이 커지는 경우 다른 블록을 할당해서 기존의 블록과 연결만 해주면 된다.      2.2.2 연결할당의 단점하지만, 연결 할당 역시 여러 문제점을 가지고 있다.  순차 접근은 가능하지만 직접 접근은 불가능하다.          파일의 블록들은 모두 흩어져 있으므로 시작 블록 번호를 가지고는 원하는 위치의 블록에 바로 접근할 수는 없다.        포인터를 저장하는 4 bytes 이상의 손해가 발생한다.  낮은 신뢰성          중간 블록의 포인터가 끊어지면 그 이후의 모든 블록에 접근하지 못한다.        느린 속도          블록이 모두 흩어져 있으므로 디스크 헤더의 움직임이 그 만큼 많이 발생한다.      2.2.3 FAT(File Allocation Table) 시스템위 문제점을 개선하기 위해 나온 것이 같은 연결 할당 방식인 FAT(File Allocation Table) 시스템이다. FAT 시스템은 다음 블록으르 가리키는 포인터들만 모아서 하나의 테이블(FAT)을 만들어 한 블록에 저장한다.위 그림은 앞선 예제의 f1 파일을 FAT 파일 시스템 방식으로 저장한 모습이다. 0번 블록에 저장된 FAT를 보면 테이블의 인덱스는 전체 디스크의 블록 번호이며, 각 인덱스마다 다음 블록 번호를 저장하고 있다.FAT 시스템을 사용하면 기존의 연결 할당의 문제점 대부분을 해결할 수 있다. FAT를 한 번만 읽으면 직접 접근이 가능하고, FAT만 문제가 없다면 중간 블록에 문제가 생겨도 FAT를 통해 그 다음 블록은 여전히 읽을 수 있다. 그리고 FAT는 일반적으로 메모리 캐싱을 사용하여 블록 위치를 찾는데는 빠르지만 실제 디스크 헤더가 움직는 것은 블록이 흩어져 있으므로 여전히 느리다고 볼 수 있다. 마지막으로 FAT는 매우 중요한 정보이므로 손실 시 복구를 위해 이중 저장을 한다.FAT의 각 인덱스 크기는 전체 블록의 개수를 저장할 만큼의 크기를 가지고 있어야 하는데, 현재는 일반적으로 32bit 크기를 사용($2^{32}$)한다. 이를 FAT32라고 부른다.(이전에는 FAT16, FAT12 등이 있었다.)2.3 색인 할당 (Indexed Allocation)색인 할당 역시 연결 할당과 같이 데이터를 랜덤한 블록 번호에 할당하지만 할당된 블록 번호(포인터)를 하나의 블록에 따로 저장한다. 이러한 블록을 인덱스 블록이라고 부르며, 파일 당 하나의 인덱스 블록이 존재한다. 색인 할당은 디렉토리 정보가 다른 할당과 다른데, 시작 블록 번호를 저장하는 것이 아니라 인덱스 블록 번호를 저장한다.2.3.1 예제            block size      f1      f2                  1byte      5byte      2byte      file name: f1file size: 5 bytes...-----------------index block number: 11file name: f2file size: 2 bytes...-----------------index block number: 27그림을 보면, 블록 하나를 지정하여, 파일의 인덱스를 저장하는 인덱스 블록으로 사용한다.색인 할당은 인덱스 블록에 할당된 블록을 순서대로 저장하기 때문에 직접 접근이 가능하다. 그리고 연속적으로 할당할 필요가 없으므로 외부 단편화 문제 또한 발생하지 않는다. 색인 할당은 Unix/Linux에서 주로 사용한다.색인 할당의 단점은 작은 크기의 파일인 경우에도 하나의 블록을 인덱스 블록으로 사용하기 때문에 저장 공간이 손실된다. 그리고 하나의 인덱스 블록을 가지고는 크기가 큰 파일을 저장할 수 없다.예를 들어, 하나의 블록 크기가 512 bytes인 블록은 최대 저장할 수 있는 블록의 인덱스 개수가 512 / 4 bytes(포인터 크기) = 128개이다. 즉 파일의 최대 크기는,128(인덱스 블록에서 저장할 수 있는 블록의 포인터 개수의 최대값) x 512bytes(블록 하나의 크기) = 64KB로 아주 작은 크기이다. 블록 크기가 1KB이라 하더라도 최대 인덱스 개수는 256개(1000/4)이고 최대 파일의 크기는 256KB이다.2.3.2 해결 방법이를 해결하기 위한 여러 가지 방법이 있다.2.3.2.1 Linked이 방식은 인덱스 블록을 여러 개 만들어 연결 할당을 하는 것과 같다. 즉, 각 인덱스 블록의 마지막은 다음 인덱스 블록을 가리키는 포인터가 저장되어 있다.2.3.2.2 Multilevel index이 방식은 계층을 두는 방법으로 하나의 인덱스 블록의 모든 포인터가 다른 인덱스 블록을 가리킨다. 만약 이것으로 부족하면 계층을 더 만들어 간다.2.3.2.3 Combined이 방식은 Linked와 Multilevel index를 합친 방법으로 한 인덱스 블록의 포인터들은 데이터 블록과 또 다른 인덱스 블록 둘 다 가리킬 수 있다.(리눅스는 combined 방식을 사용한다.)ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-19-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-18-ed-94-84-eb-a0-88-ec-9e-84-ed-95-a0-eb-8b-b9-html": {
        "title": "18: 프레임 할당 (Allocation of frame)",
        "tags": "OS, Memory, frame allocation",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "page를 메모리에 할당하는 프레임 할당에 대해 알아본다.1. Global VS Local Replacement  Global Replacement          메모리 상의 모든 프로세스 페이지에 대한 교체 작업을 수행한다.      앞에서 배운 FIFO, OPT, LRU 등은 Victim을 정할 때, 모든 메모리에 올려져 있는 frame을 다 확인 후에 교체를 수행했다.        Local Replacement          메모리 상의 자기 자신의 프로세스 페이지에 대해서만 교체 작업을 수행한다.      지금 요청이 들어온 page가 p1이라면, 메모리상에 올라가 있는 frame 중 p1 frame만 교체의 대상으로 간주한다.      메모리 사용 효율은 일반적으로 Global Replacement가 좋다.2. 프레임 할당(Allocation of Frames)어떻게 할당하는 것이 좋은지에 대한 고민을 해본다.2.1. 쓰레싱(Thrashing)일반적으로 메모리에 올라가는 프로세스 개수가 증가할수록 CPU의 이용률은 올라갈 것이라 예상한다. 왜냐하면 프로세스가 많을 수록 CPU의 할 일 역시 증가하기때문이다. 이는 일정 범위까지는 맞는 예상이지만, 그 범위를 넘어서면 오히려 CPU 이용률이 감소하는 현상이 나타난다.위 그림은 이러한 현상을 그래프로 나타낸 것이다. 이와 같은 현상이 발생하는 이유는 프로세스가 증가할수록 메인 메모리의 비어있는 프레임 개수는 줄어들게 되고 결국 모든 프레임이 가득 차게 된다. 그 후에도 계속 프로세스가 증가한다면 메모리와 backing store 사이에 page in/out 작업이 발생하는데, 프로세스가 많아질수록 이 작업 역시 증가한다. page in/out은 디스크 I/O 작업으로 CPU를 사용하지 않는 작업이다. 그러므로 이 작업이 많아질수록 CPU는 그동안 아무것도 하지 않게 된다.위 그래프에서도 나와있듯이, I/O 작업이 증가하여 CPU 이용률이 떨어지는 현상을 Thrashing 이라 한다.2.1.1 해결 방법쓰레싱을 해결하는 방법은 크게 두 가지가 있다.  Global Replacement보다 Local Replacement를 사용하는 것이다.          하지만 이 경우에는 메모리 사용 효율이 떨어지는 단점이 있다.        프로세스당 충분한/적절한 수의 프레임(메모리)을 할당한다.그렇다면, 적절한 프레임의 수는 어떻게 정하는 것일까?2.2 프레임 할당의 방법프레임 할당은 크게 정적 할당과 동적 할당으로 나뉜다.2.2.1 정적 할당(Static Allocation)  동일 할당(Equal Allocation)          모든 프로세스에게 똑같은 수의 프레임을 할당한다. 이 방식은 프로세스의 크기에 따라 매우 비효율적이다.        비례 할당(Proportional Allocation)          프로세스의 크기에 따라 프레임을 할당한다. 이 방식 역시 단점이 있다. 프로세스 크기가 크더라도 모든 기능을 사용하지 않기 때문에 이 방식 또한 비효율적이다.      이처럼 정적 할당은 한계가 뚜렷하다. 따라서 동적 할당의 방법을 사용하는 것이 좋다.2.2.2 동적 할당(Dynamic Allocation)2.2.2.1 Working Set Model프로세스가 실행 중일 때 어느 페이지를 사용하는지 실험한 결과에서 Locality 성질이 성립한다는 것을 발견할 수 있었다. 즉, 특정 시간 대에 참고하는 부분은 일부분이다.위 그래프는 프로세스가 실행 중에 어떤 프로세스를 사용하는지 표시한 것으로, 특정 시간에는 일정 범위의 페이지를 주로 참조하는 것을 알 수 있다. 이러한 성질은 캐시에서도 볼 수 있다. 이를 통해 특정 시간에 따라 사용하는 페이지의 개수만큼 프레임을 할당해줄 수 있다.그런데 어떻게 locality를 조사할 수 있을까? 여기서 치명적인 단점이 있다. 바로 프로세스를 미리 수행해봐야 할 수 있다는 것이다. 그리고 프로세스를 수행할 때마다 사용하는 기능이 달라질 수 있으므로, Locality를 이용하는 방법은 비현실적이다.이를 해결하기 위해 나온 것이 working set 이다. working set은 위의 locality의 방식과 유사한데, 미래가 아닌 과거를 보는 것이다.위 그림은 working set을 사용하는 모습이다. working set은 현재 시간에서 일정 시간($\\Delta$) 이전동안 사용되었던 페이지의 집합이다. $\\Delta$(델타)는 운영체제 내부에서 정하는 기준에 따라 다르며, 이를 working set window 라 한다. 마지막으로 working set의 개수만큼 프레임을 할당한다.만약 현재 시간이 t1이라면 working set = {1, 2, 5, 6, 7}이다. 이 때 working set의 개수는 총 5개이므로 프레임 역시 5개를 할당해주면 된다.2.2.2.2 Page-Fault Frequency(PFF)페이지 부재의 비율은 프로세스에 할당된 프레임의 수에 반비례한다. 즉, 할당된 프레임의 수가 적을수록 페이지 부재 비율은 늘어난다.위 그림은 이와 같은 현상을 그래프로 나타낸 것이다. 세로축은 페이지 부재 비율이고, 가로축은 할당된 프레임의 수이다. 여기서 운영체제 내부에서 해당 프로세스의 페이지 부재 횟수를 계속 검사한다. 그러면 위와 같은 그래프처럼 나오는데, 여기서 상한선(upper bound)과 하한선(lower bound)를 설정한다.만약 상한선보다 많은 페이지 부재가 발생하면 프레임을 더 많이 할당해주고, 하한선보다 적게 페이지 부재가 발생하면 할당된 프레임 개수를 줄여준다.3. 페이지 크기(Page Size)현재 페이지의 일반적인 크기는 4KB ~ 4MB 이다. 이는 과거에서부터 점점 커져왔고, 현재에도 메모리 크기가 증가하면서 커지고 있다.페이지 크기에 따라 성능에는 어떤 영향을 미치는지 알아보자.3.1 페이지 크기에 따른 성능  내부단편화          내부단편화를 줄이려면 페이지 크기는 작은 것이 좋다.        Page-in, page-out 시간          페이지의 in/out 시간을 결정하는 가장 큰 요인은 하드디스크 기준으로 하드디스크의 헤더가 움직이는 시간이다.(seek time) 페이지 크기가 크면 클수록 한 번의 seek time마다 큰 페이지를 읽을 수 있으므로, 페이지 부재 빈도가 줄어든다.(데이터를 읽는 시간은 크기에 따라 차이가 매우 적다.)        페이지 테이블 크기          페이지 크기가 클수록 페이지 개수가 줄어들기 때문에 그만큼 페이지 테이블 크기도 줄일 수 있다.        Memory resolution(해상도)          Memory resolution은 해당 메모리에 필요한 데이터가 있는 확률이다. 이는 페이지 크기가 작을수록 resolution을 높일 수 있다. 만약 페이지 크기가 크면 다른 필요없는 부분이 있을 확률이 크기 때문이다.        Page fault 발생 확률          Page fault 발생 확률을 줄이려면 페이지 크기가 큰 것이 좋다. 이는 locality 성질과도 관련이 있는데, 대부분 프로세스는 필요한 부분이 일정 범위 이내인 경우가 많으므로 페이지 크기가 클수록 필요한 부분이 있을 확률이 크다.                  big      small                  Page fault 발생 확률 ▼      내부 단편화 ▼              페이지 테이블 크기 ▼      Page-in, page-out 시간 ▼                     Memory resolution(해상도) ▲      3.2 페이지 테이블반도체 기술의 발달로 TLB 역시 CPU의 내장 칩 형태로 만들어져있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-18-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-17-ed-8e-98-ec-9d-b4-ec-a7-80-ea-b5-90-ec-b2-b4-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "17: 페이지 교체 알고리즘",
        "tags": "OS, Memory, FIFO, paging",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "페이지 교체 알고리즘에 대해 알아본다.1. Page reference string페이지 교체 알고리즘을 살펴보기 전에 Page reference string 이라는 용어를 알아야 한다. CPU가 내는 주소는 이진수 단위이지만, 페이지 교체 알고리즘을 계산하기 위해서는 이진수 주소 단위가 아닌 페이지 단위로 계산해야한다.            CPU 논리 주소      요청할 페이지 번호                  100      1              101      1              432      4              612      6              103      1              104      1              611      6              612      6      예를 들어, CPU가 내는 주소를 위와 같이 표현해보자. 편의를 위해 주소는 십진수로 표현했다. 만약 페이지 크기를 100이라 하면, 우측과 같이 된다. 주소 100번지는 1번 페이지에서 offset이 0인 위치이고, 101은 1번 페이지의 offset 1인 위치라고 볼 수 있다.마지막으로 페이지 번호로 나타낸 것을 page reference string으로 나타내면 {1, 4, 6, 1, 6}이다. 이는 간단히 말하면 연속된 페이지는 생략하고 하나의 페이지 번호만 나타낸 것으로 볼 수 있다. 이 이유는 연속된 페이지를 참조할 때는 한 번 page fault가 발생하면 같은 페이지를 사용하는 동안에는 절대 page fault가 발생할 수 없기 때문이다. 즉, CPU가 가리키는 page의 번호가 연속적으로 동일하다면, disk로 가서 page를 가져올 필요가 없으므로, 위의 번호들만 가지고 판단하는 것이 바람직하다.2. First-In First-Out(FIFO)FIFO은 가장 간단한 알고리즘이다. 가장 먼저 page-in 한 페이지를 먼저 page-out 시킨다. 이를 사용한 이유는 초기화 코드가 더 이상 사용되지 않을 것이라는 아이디어에서 시작되었다.2.1 예제  페이지 참조열(page reference string)          {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}        사용가능한 프레임 개수(number of frame): 3  최초의 메모리는 비어있는 상태이다.            1      2      3      4      5      6      7      8      9      10      11      12      13      14      15      16      17      18      19                  7      0      1      2      0      3      0      4      2      3      0      3      2      1      2      0      7      0      1                  order      page-in      frame states      Page fault count      page-out      first page                  1      7      {7}      1             7              2      0      {7, 0}      2             7              3      1      {7, 0, 1}      3             7              4      2      {2, 0, 1}      4      7      0              5      0      {2, 0, 1}      4             0              6      3      {2, 3, 1}      5      0      1              7      0      {2, 3, 0}      6      1      2              8      4      {4, 3, 0}      7      2      3              9      2      {4, 2, 1}      8      3      1              10      3      {4, 2, 3}      9      1      4              11      0      {0, 2, 3}      10      4      2              12      3      {0, 2, 3}      10             2              13      2      {0, 2, 3}      10             2              14      1      {0, 1, 3}      11      2      3              15      2      {0, 1, 2}      12      3      0              16      0      {0, 1, 2}      12             0              17      7      {7, 1, 2}      13      0      1              18      0      {7, 0, 2}      14      1      2              19      1      {7, 0, 1}      15      2      7      결과는 최종 page fault 수는 15이다. 예제를 수행하면서, 이전에 page-out한 페이지를 그 다음 바로 page-in을 하려한다면 다시 page fault가 발생하기 때문에 비효율적인 모습을 볼 수 있다.2.2 Belady’s Anomaly프레임 수가 증가하면(= 메모리 용량이 증가하면) page fault 수가 줄어드는 것이 정상적이다.하지만 위의 FIFO를 사용했을 때, 그래프를 그려보면 다음과 같은 결과가 나온다.이와 같이 특정한 페이지 참조열에 대해서는 프레임 수가 증가해도 page fault 수가 오히려 증가하는 이상 현상이 발생한다. 이를 Belady’s Anomaly라 한다.3. Optimal(OPT)OPT는 말그대로 가장 효율적인 페이지 교체 알고리즘이다. 이 알고리즘은 가장 오랫동안 사용되지 않을 페이지를 희생양 페이지로 선택한다.3.1 예제  페이지 참조열(page reference string)          {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 7, 0, 1}        사용가능한 프레임 개수(number of frame): 3  최초의 메모리는 비어있는 상태이다.여기서 가장 오랫동안 사용되지 않을 페이지를 계산하기 위해 현재 시점 에서 그 이후에 최초로 나타나는 시점의 거리 를 dist로 둔다. 이 값이 가장 큰 페이지가 가장 오랫동안 사용되지 않은 페이지로 정한다.(해당 페이지가 이후에 나오지 않는 경우는 INF로 가장 큰 값으로 한다.)            1      2      3      4      5      6      7      8      9      10      11      12      13      14      15      16      17      18      19                  7      0      1      2      0      3      0      4      2      3      0      3      2      1      2      0      7      0      1                  order      page-in      frame states      Page fault count      page-out      dist                  1      7      {7}      1             {15}              2      0      {7, 0}      2             {14, 3}              3      1      {7, 0, 1}      3             {13, 2, 11}              4      2      {2, 0, 1}      4      7      {5, 1, 10}              5      0      {2, 0, 1}      4             {4, 2, 9}              6      3      {2, 0, 3}      5      1      {3, 1, 4}              7      0      {2, 0, 3}      5             {2, 4, 3}              8      4      {2, 4, 3}      6      0      {1, INF, 2}              9      2      {2, 4, 3}      6             {4, INF, 1}              10      3      {2, 4, 3}      6             {3, INF, 2}              11      0      {2, 0, 3}      7      4      {2, 5, 1}              12      3      {2, 0, 3}      7             {1, 4, INF}              13      2      {2, 0, 3}      7             {2, 3, INF}              14      1      {2, 0, 1}      8      3      {1, 2, 5}              15      2      {2, 0, 1}      8             {INF, 1, 4}              16      0      {2, 0, 1}      8             {INF, 2, 3}              17      7      {7, 0, 1}      9      2      {INF, 1, 2}              18      0      {7, 0, 1}      9      1      {INF, INF, 1}              19      1      {7, 0, 1}      9      2      {INF, INF, INF}      OPT의 결과는 총 9번의 page fault가 발생했다. 이는 FIFO의 15번보다 크게 줄어든 모습을 볼 수 있다. 하지만 OPT의 방법은 현실적으로 불가능하다. 실제 컴퓨터에서는 미래에 어떤 프로세스가 사용되는지 알 수 없다. 그러므로 어느 프로세스가 가장 오래 사용안되는 지를 계산할 수 없다.4. Least-Recently-Used(LRU)OPT는 최적해를 구할 수 있지만 미래를 알 수 없으므로 현실적으로 불가능한 방법이었는데, 최적의 해는 아니더라도 근사의 해를 구하기 위해서 LRU가 나왔다. LRU는 최근에 사용되지 않으면 나중에도 사용되지 않을 것이라는 개념으로 과거의 페이지 기록을 통해 희생양 페이지를 선택한다.4.1 예제LRU는 근사 해를 구하므로 OPT보다는 page fault가 많이 발생하지만, FIFO보다는 일반적으로 적게 일어난다. 그러므로 현재 대부분 환경에서는 LRU를 사용하고 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-17-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-16-ea-b0-80-ec-83-81-eb-a9-94-eb-aa-a8-eb-a6-ac-html": {
        "title": "16: 가상 메모리 (Virtual Memory)",
        "tags": "OS, Memory, Virtual Memory",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "가상 메모리(Virtual Memory)에 대해 알아본다.가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 즉, 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다. 예를 들어, 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행할 수 있도록 하는 것이다.1. Demanding Paging이러한 방식이 어떻게 가능할까? 앞서 메모리 낭비 방지의 동적 할당에서도 봤듯이, 필요한 부분만 메모리에 적재하는 것이다. 프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올리는 것이다. 이러한 프로세스의 일부분은 페이지 단위일 수도 있고, 세그먼트 단위일 수도 있지만 현재 대부분은 페이지 단위를 사용한다.이처럼 현재 필요한(요구되어지는) 페이지만 메모리에 올리는 것을 Demanding Paging(요구 페이징) 이라고 한다.1.1 동작  CPU가 page table에 가서 해당 page에 접근한다.  이 때, Memory에 올라온 상태가 아니면(invaild), Interupt를 발생한다.  OS 내부의 ISR에서 이 인터럽트를 처리하러 Disk에서 page를 찾는다.  찾은 Page를 Memory에 올려 Frame화 한다.  page table을 업데이트 한다.  CPU에게 다시 수행하라고 명령한다.가상 메모리를 만드는 방법은 대표적으로 두 가지가 존재하지만, 대부분 요구 페이징을 사용하므로 가상 메모리와 요구 페이징을 같은 용어로 사용하는 경우가 많다.1.2 Page Fault(페이지 부재)페이지 부재는 위에서 살펴본 CPU가 접근하려는 페이지가 메모리에 없는 경우이다. 즉, 페이지 테이블의 valid bit값이 0인 경우이다.위에서 이러한 경우를 처리하는 방법을 알아보았다. 실질적으로 이 부분이 가상 메모리의 핵심적인 기능이라 할 수 있다.1.2.1 Pure Demanding PagingPure Demanding Paging은 프로세스가 최초로 실행될 때는 어떤 페이지가 필요한지 알 수 없으므로, 아무 페이지도 올리지 않는다. 그러므로 프로그램을 실행하자마자 page fault가 발생한다. 즉, 순수하게 필요한 페이지만 올리는 것을 말한다. Pure Demanding Paging의 장점은 메모리를 최대한 효율적으로 사용할 수 있다. 하지만 시작부터 page fault가 발생하므로 속도면에서 느리다.1.2.2 PrepagingPrepaging은 pure demanding paging과 반대대는 개념이다. 프로그램을 실행할 때 필요할 것이라 판단되는 페이지를 미리 올리는 것이다. 이것의 장점은 page fault가 발생할 확률이 적으므로 속도면에서 빠르지만, 단점으로 미리 올라간 페이지를 사용하지 않는다면 메모리가 낭비된다.1.2.3 Swapping VS Demanding PagingSwapping와 Demanding Paging의 공통점은 둘 다 메모리와 backing store 사이를 서로 오고 가는 기능을 수행하지만, Swapping은 프로세스 단위로 이동하고 Demanding Paging은 페이지 단위로 이동하는 차이점이 있다.1.2.4 유효 접근 시간(Effective Access Time)Demending Paging은 페이지 테이블에 해당 페이지가 없으면 backing store에서 메모리로 가져오는 과정이 있다. 그렇기 때문에 페이지 테이블에 해당 페이지가 있을 때와 없을 때 시간 차이가 발생한다. 이러한 시간 차이를 고려하여 평균적으로 어느정도 소요되는지 계산하는 것을 유효 접근 시간이라 한다.  p          페이지 부재 확률(probability of a page fault = page fault rate)        Tm          메모리를 읽는 시간(DRAM)        Tp          Page fault가 발생했을 때 소요되는 시간(대부분 backing store(하드디스크)를 읽는 시간이 차지한다. (seek time + rotational delay + transfer time)      p = 1/1,000            용어      정의      값                  p      페이지 부재 확률      1/1000              Tm      메모리를 읽는 시간      200nsec              Tp      Disk 탐색 시간      8msec      메모리를 읽는 시간에 비해 40배 정도 느리다.p = 1/399,990            용어      정의      값                  p      페이지 부재 확률      1/399,990              Tm      메모리를 읽는 시간      200nsec              Tp      Disk 탐색 시간      8msec      메모리를 읽는 시간에 비해 10% 느리다.지역성의 원리(Locality of reference)위의 예제를 보았을 때, page fault는 매우 적은 확률로 발생해야 효율적이다. 그러면 현실적으로 페이지 부재는 어느정도로 발생할까? 이는 지역성의 원리(Locality of reference)로 인해 페이지 부재 확률은 매우 낮다. 지역성의 원리는 ‘메모리 접근은 시간적 지역성과 공간적 지역성을 가진다‘는 의미이다.  시간적 지역성          CPU는 어느 메모리 공간을 읽은 후, 시간이 지나도 그 공간을 다시 읽을 확률이 매우 높다는 것을 말한다.      대표적인 예로 반복문이 있다. 반복문은 하나의 코드 공간을 여러 번 읽는다.        공간적 지역성          CPU가 메모리 공간을 읽을 때는 인접한 범위 내에서 읽는다는 의미이다.      프로그램은 대부분 절차적인 순서로 구현되어 있어 순서대로 읽는 경우가 빈번하다.      이와 같이 페이지 부재가 현실적으로 발생할 확률은 매우 낮으므로 예제와 같이 40배로 느려지는 일을 거의 없다. 여기서 더 효율적으로 사용하기 위해서는 페이지 부재일 때 소요되는 시간을 줄일 수 있는데, backing store로 HDD를 사용하기 보다는 더욱 빠르게 동작하는 SSD나 저가 DRAM과 같은 것을 사용하는 방법이 있다.1.3 페이지 교체(Page Replacement)Demanding Paging은 요구되어지는 페이지만 backing store에서 가져온다. 하지만 프로그램들이 계속 실행함에 따라 요구 페이지도 계속 늘어나고, 언젠가는 메모리가 가득 차게 될 것이다.(memory full) 여기서 다른 프로그램이 새로 실행되거나 실행중인 프로세스가 다른 페이지를 요구한다면 이미 메모리에 있는 페이지 중 하나를 다시 backing store에 보내고(page-out), 새로운 페이지를 메모리에 올려야한다.(page-in) 이를 페이지 교체라고 한다. 여기서 backing store로 page-out이 된 페이지를 victim page 라고 한다.1.2.1 Victim Page(희생양 페이지)희생양 페이지는 어떤 페이지로 하는 것이 좋을까? 먼저 생각할 수 있는 것은 메모리에 올라가 있는 페이지 중 CPU에 수정(modify)되지 않는 페이지를 고르는 것이 효율적으로 보인다. 즉, 읽기만 수행하는 페이지를 고르는 것이 이상적이다. 수정되지 않은 페이지는 page-out이 될 때 backing store에 쓰기(write) 연산을 할 필요가 없기 때문이다. backing store는 읽는 시간도 느리지만, 거기에 더해 쓰기 작업까지 한다면 더욱 비효율적일 것이다.그러면 해당 페이지가 수정되었는지 안되었는지를 판단할 수 있어야 하는데, 이를 위해 페이지 테이블에 modified bit(=dirty bit)를 추가하여 이를 검사한다. 해당 페이지가 수정되었다면 이 비트를 1로 두고, 수정되지 않으면 0으로 둔다. 이를 이용해서 victim page는 최대한 수정되지 않은 페이지를 선택한다.위 그림은 modified bit를 추가한 페이지 테이블의 모습이다. 여기서 수정되지 않은 페이지는 0, 2, 3번 3개의 페이지가 존재하는데 이 중에서는 어떤 페이지를 선택해야 할까?제일 간단한 방법은 랜덤하게 선택하는 것이지만, 이는 성능을 보장할 수 없다. 그 다음은 가장 먼저 메모리에 올라온 페이지를 희생양 페이지로 선택하는 것이다. 이는 아주 유명한 FIFO(First-In First-Out) 방식이다. 이 외에도 여러가지 방법이 존재한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-16-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-15-ec-84-b8-ea-b7-b8-eb-a9-98-ed-85-8c-ec-9d-b4-ec-85-98-html": {
        "title": "15: 세그멘테이션 (Segmentation)",
        "tags": "OS, Memory, Segmentation",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프르세스를 논리적 내용을 기반으로 나누는 세그멘테이션(Segmentation)에 대해 알아본다.Segmentation지금까지 살펴본 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하였다. 여기서 물리적이라 함은 말 그래도 프로세스를 일정한 크기로 자른 것이다. 반면에 세그먼테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치하는 것을 말한다. 논리적 내용은, 어떤 의미론적 단위를 의미한다. 돼지고기를 그냥 1cm 간격으로 나누는 것이 Paging, 목살, 삼겹살, 갈비와 같이 나누는 것이 Segmentation이다. 따라서 각 세그먼트의 크기는 일반적으로 같지 않다.세그먼테이션은 프로세스를 세그먼트(segment)의 집합으로 생각한다. 앞에서도 말했듯, Process는 Code, Data, Stack 과 같은 구조로 나뉜다. 물론 code, data, stack 각각 내부에서 더 작은 세그먼트로 나눌 수도 있다.1. Segment Table이번에는 page size가 동일하지 않기 때문에, frame 번호로 논리 주소와 물리 주소를 연결할 수 없다. 이번에는 table이 bound를 가지고 있어야 한다. 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limit)를 엔트리로 갖는다. 페이징과 마찬가지로 논리 주소의 규약을 가지며, 이번에는 p가 아니고 s로 표기한다.한 가지 주의할 점은 세그먼트의 크기는 일정하지 않기 때문에, 테이블에 limit 정보가 주어진다. 그리고 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다.위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습이다. 페이징 주소변환과 동일하게 d는 논리주소와 물리주소가 동일하다. 물리주소 a는 base[s] + d 로 계산된다.  논리주소 (2, 100)          2(4300) + 100 = 4400 &lt; 4700(base+limit)        논리주소 (1, 500)          1(6300) + 500 = 6800 &gt; 6700(base+limit)                  =&gt; 인터럽트로 인해 프로세스 강제 종료(범위를 벗어남)                    2. 세그먼테이션에서 보호와 공유먼저, 결론부터 말하면 페이징보다 세그먼테이션에서의 보호와 공유는 더 효율적이다.보호에서는 세그먼테이션 역시 r, w, x 비트를 테이블에 추가하는데, 세그먼테이션은 논리적으로 나누기 때문에 해당 비트를 설정하기 매우 간단하고 안전하다. 페이징은 code + data + stack 영역이 있을 때 이를 일정한 크기로 나누므로 두 가지 영역이 섞일 수가 있다. 그러면 비트를 설정하기가 매우 까다롭다.공유에서도 마찬가지다. 페이징에서는 code 영역을 나눈다해도 다른 영역이 포함될 확률이 매우 높다. 하지만 세그먼테이션은 정확히 code 영역만 나누기 때문에 더 효율적으로 공유를 수행할 수 있다.3. 세그먼테이션과 페이징세그먼테이션은 페이징과 유사하고 보호와 공유에서는 더 나은 성능을 보여주었지만, 현재 대부분은 페이징 기법을 사용한다. 그 이유는 세그먼테이션에는 치명적인 단점이 있기 때문이다.3.1 외부 단편화메모리 할당을 처음 시작할 때 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다. 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 했었다.세그먼테이션도 똑같은 문제점이 발생한다. 왜냐하면 세그먼테이션은 논리적인 단위로 나누기 때문에 세그먼트의 크기가 다양하다. 이로 인해 다양한 크기의 hole이 발생하므로 외부 단편화의 문제가 발생한다.3.2 Paged segmentation결론적으로 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다. 그러므로 두 가지를 합쳐서 사용하는 방법이 나왔다. 두 장점을 합치기 위해서는 세그먼트를 페이징 기법으로 나누는 것이다.(Paged segmentation)하지만 이 역시 단점이 존재한다. 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두 번해야한다. 즉 CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-15-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98.html"
      }
      ,
    
      "cs-os-2020-04-06-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-14-ed-8e-98-ec-9d-b4-ec-a7-95-html": {
        "title": "14: 페이징 (Paging)",
        "tags": "OS, Memory, Paging",
        "date": "April 6, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "외부 단편화를 해결하는 방법인 페이징(Paging)에 대해 알아본다.1. 페이징(Paging)외부 단편화로 인한 메모리 낭비는 매우 심하다는 것을 살펴보았다. Compaction을 사용하면 외부 단편화는 해결할 수 있지만, 그로 인해 발생하는 오버헤드와 비효율적인 성능으로 사용하기는 어렵다. 그 이후에 연구를 통해 나온 것이 페이징이다. 페이징은 hole을 가지고 해결하려 한 것이 아니라 프로세스를 작은 크기로 나눠서 외부 단편화를 해결하려고 하였다.페이징은 프로세스를 일정한 작은 크기로 나누는데, 프로세스뿐아니라 hole도 같은 크기로 나눈다. 이러한 작은 조각들의 크기를 맞춰서 메모리에 할당한다. 하지만, 하나의 프로세스는 연속적인 동작을 수행하는데 이를 작은 조각으로 나누어서 여기저기 흩어진다면 프로세스가 정상적으로 동작할까?메모리상에 여러 곳에 흩어진 프로세스를 수행하기 위해 CPU를 속여야한다. 이전 다중프로그래밍을 살펴봤을 때 MMU를 통해 논리 주소와 물리 주소를 나눠서 사용한다고 했었다. 이 역시 CPU를 속이는 행동이다. 실제 메모리는 전혀 연속적이지 않는데, CPU는 연속적으로 사용하고 있다는 것을 보장받으며 정상적으로 수행한다.페이징으로 작은 크기로 나눈 것도 위와 같은 방법으로 할 수 있다. 만약 50byte 크기의 프로세스가 있다고 하자. 페이징의 크기는 각 10byte로 나눈다.위 그림과 같이 프로세스 P1은 5개의 페이지로 나눌 수 있다. 이를 메인 메모리 5곳에 나눠서 할당하였다. CPU는 논리 주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기전에 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경되어야 한다.프로세스를 나눈 조각을 page 라 하고, 메모리를 나눈 조각을 frame 이라 한다. 프로세스는 페이지의 집합이고, 메모리는 프레임의 집합이다. 프로세스를 정상적으로 사용하기 위해 MMU의 재배치 레지스터를 여러개 사용해서 위의 그림과 같이 각 페이지의 실제 주소로 변경해준다. 이러한 여러 개의 재배치 레지스터를 페이지 테이블(Page Table) 이라 한다.1.1. 주소 변환(Address Translation)페이징 기법을 사용하기 위해서는 여러 개로 흩어진 페이지에 CPU가 접근하기 위해서 페이지 테이블을 통해 주소를 변환해야 한다.1.1.1 논리 주소(Logical address)CPU가 내는 주소는 2진수로 표현된다. 이 주소가 m비트로 표현된다고 가정하자. 여기서 하위 n비트는 오프셋(offset) 또는 변위(displacement)라고 한다. 그리고 상위 m-n 비트는 페이지의 번호에 해당한다.(n = d, m-n = p)논리주소를 물리주소(physical address)로 변환하기 위해서 페이지 번호(p)는 페이지 테이블의 인덱스 값이고, p에 해당되는 테이블 내용은 메모리의 프레임 번호이다. 변위(d)는 변하지 않는 값이다. d는 페이지 크기에 따라 달라진다. 만약 현재 페이지 크기를 16byte이라고 한다면, 이는 2^4이므로 d = 4 이다.만약 논리주소가 50번째로 주어진다면, 50=110010 이고, page size가 16byte라 주어졌을 때, 4자리를 제외한 p=11이고 d=0010 이다.1.1.2 동작 예시위 그림을 보면, 어떻게 동작하는 지 한눈에 확인 할 수 있다. 우리가 해야할 일은, 논리 주고가 들어왔을 때, 이것을 page, displacement로 나누고, page 변수를 frame 변수로 바꿔주는 page table을 통과하여 나온 값을 가지고 물리 주소를 찾으면 된다.위 그림으로 부터 따라해 볼 수 있다. p와 d만 잘 생각하면 쉬운 아이디어임을 알 수 있다. 이 페이징으로부터 연속 메모리 할당을 하면서 외부 단편화가 발생하는 문제는 해결했다. 하지만..1.2 내부단편화(Internal Fragment)페이징은 외부 단편화가 아닌 내부 단편화가 발생한다. 내부단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채울 수 없다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다.예를 들어, 15bytes 크기의 프로세스 P가 있다. 페이지 크기(프레임 크기)를 4bytes라 하면, P를 페이지로 나눈 결과인 4, 4, 4, 3 의 크기로 총 4개의 페이지가 만들어진다. 여기서 마지막 3bytes 페이지는 프레임 크기보다 1byte작으므로, 이 만큼 메모리 공간이 비게 된다. 이렇게 비어진 공간은 프로세스 P에서도 쓰지 않고, 다른 프로세스에서도 쓰지 못하는 낭비되는 공간이 된다.내부단편화는 해결할 방법이 없다. 하지만 내부단편화는 외부단편화에 비해 낭비되는 메모리 공간은 매우 적다. 내부단편화의 최대 낭비되는 크기는 page size - 1 이 된다.(외부 단편화는 최대 전체 메모리의 1/3이 낭비된다고 이전에 살펴봤다.) 이는 무시할 정도로 작은 크기이다.1.3 페이지 테이블 만들기페이지 테이블을 만드는 방법은 여러 가지가 있다. 먼저, CPU 내부에 페이지 테이블을 만들 수 있다. CPU 내부의 기억장치는 레지스터로, 여러 개의 레지스터로 페이지 테이블을 만드는 것이다. CPU 내부에 페이지 테이블을 만들면, 장점은 주소 변환 속도가 빠르다. 하지만 단점은 CPU 내부에 사용할 수 있는 레지스터는 한정되어 있으므로 페이지 테이블의 크기가 매우 제한된다.  CPU          장점 : 주소 변환 속도가 빠르다.      단점 : CPU 내부에 사용할 수 있는 레지스터는 한정되어 테이블의 크기가 제한된다.      반대로, 페이지 테이블을 메모리 내부에서 만들 수도 있다. 메모리 내부에 만드는 것의 장단점은 CPU와 정 반대이다. 즉, 장점은 페이지 테이블의 크기에 제한이 없는 것이고, 단점은 주소 변환 속도가 느리다는 것이다. CPU는 프로세스의 주소에 접근하기 위해서 메모리에 위치한 페이지 테이블에 한 번, 실제 주소로 접근하는데 한 번해서 메모리에 총 2번 접근해야하므로 속도 역시 2배로 느려진다.  Memory          장점 : 페이지 테이블의 크기에 제한이 없다.      단점 : 주소 변환 속도가 느리다.      1.3.1 TLB(Translation Look-aside Buffer)페이지 테이블을 CPU에 만들 때나 메모리에 만들 때 둘 다 장단점이 확실하기 때문에, 이를 해결하기 위해 페이지 테이블도 캐시로 만들어 해결하였다. 페이지 테이블을 별도의 칩(SRAM)으로 만들어서 CPU와 메모리 사이에 위치시키는 것이다. 이러한 테이블을 TLB(Translation Look-aside Buffer) 라고 부른다. 이는 CPU보다 변환 속도는 느리고 메모리보다 테이블 크기는 작지만, CPU보다 테이블 크기가 크고 메모리보다 변환 속도가 빠르다.TLB는 캐시와 역할이 동일하므로, 실제 전체 페이지 테이블은 메모리에 위치해 있고 테이블의 일부를 TLB에 가져와서 사용한다. 그러므로 TLB에 유효한 페이지가 있을 때와 없을 때의 속도 차이가 발생한다.1.3.2 TLB의 효율그렇다면, TLB의 효율을 알아보기 위해 Effective Memory Access Time을 계산해보자.            용어      정의      값                  Tm      메모리를 읽는 시간      100ns              Tb      TLB를 읽는 시간      20ns              hit ratio      TLB에 유효한 페이지 엔트리가 있을 확률      80%      먼저, EMAT의 정형화된 식을 보자. 가중 평균의 식이다. h는 hit ratio이다.실제 유효한 메모리에 접근하는 시간은 위와 같다. 없을 경우 2번 읽어야 하여 Tm을 두번 더해주었다. TLB에 유효한 페이지가 있다면 TLB를 읽는 시간과 실제 메모리를 읽는 시간만 있으면 된다. 하지만, TLB에 유효한 페이지가 없다면 이를 다시 메모리에서 가져와야 하므로 메모리를 총 2번 읽어야 한다.예제를 계산해보면, 0.8 * (20 + 100) + 0.2 * (20 + 100 + 100) = 140ns 이다. hit ratio는 실제로 평균 95%이상이므로 충분히 효율적으로 동작한다고 볼 수 있다.1.4 보호(Protection)모든 주소는 페이지 테이블을 경유하므로, 테이블을 이용해서 보호 기능을 수행할 수 있다. 접근이 유효한지 그렇지 않은지를 구분하는 bit를 추가하여 켜져있을 때 수행하도록 한다. 대표적으로 페이지 테이블마다 r(read), w(write), x(execute) 비트를 두어, 해당 비트가 켜져있을 때 그 수행이 가능하도록한다.위 그림은 페이지 테이블에 r,w,x 비트를 추가한 모습이다. 만약, 1번 페이지 엔트리처럼 쓰기 비트가 꺼져있는 페이지에 쓰기 작업을 시도하면 CPU에 인터럽트가 발생하여 ISR에서 강제로 해당 프로세스를 종료시킨다.1.5 공유(Sharing)공유는 메모리 낭비를 방지하기 위함이다. 같은 프로그램을 쓰는 복수 개의 프로세스가 있다면, 프로세스의 메모리는 code + data + stack 영역으로 나뉘는데 프로그램이 같다면 code 영역은 같을 것이다. 그러므로 하나의 code 영역을 복수 개의 프로세스가 공유하여 메모리 낭비를 줄이는 것이다. 단, code가 공유되려면 code가 변하지 않는 프로그램이어야 한다. 이를 non-self-modifying code = reentrant code(재진입가능 코드) = pure code 라고 한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-14-%ED%8E%98%EC%9D%B4%EC%A7%95.html"
      }
      ,
    
      "dv-c-2020-04-05-ec-a0-95-ec-a0-81-eb-b3-80-ec-88-98-html": {
        "title": "정적 변수 (static)",
        "tags": "c++, static",
        "date": "April 5, 2020",
        "author": "",
        "category": "DV/C++",
        "content": "필요성  지역이 사라져도 변수는 유지되어야 해!지역 변수, 전역 변수 말고 c++에는 이상한 녀석이 하나 더 있다. 정적 변수라는 것이 그것인데, 아니 이게 왜 필요하지..?함수를 호출했는데, 이 함수를 몇 번 호출했는지 알고 싶다. 그러면, 사실 가능한 방법은 전역변수로 이 함수가 호출되었을 때 값을 증가시키면 된다.int count = 0;void call(){    count++;    cout &lt;&lt; conut &lt;&lt; '\\n';}int main(){    call();    call();    call();    call();    call();    return 0;}하지만, 이렇게 되면 프로그램의 안정성이 너무 떨어진다. 이름이 겹치는 문제도 생기고, 해당 변수의 역할은 함수의 호출 횟수만을 체크하는 것인데, 너무 범위가 크게 잡혀있기 때문이다. 결국 Scope를 줄이고 싶은 것이다.이런 경우 static을 적어주면, 전역변수처럼 행동하되, 이 녀석의 Scope는 해당 함수를 호출했을 때로 줄어들게 된다.void call(){    static int count = 0;    count++;    cout &lt;&lt; conut &lt;&lt; '\\n';}int main(){    call();    call();    call();    call();    call();    return 0;}특징 정리  메모리 공간에서 정적 변수는 전역 변수가 저장되는 Data 영역에 저장된다.          프로세스 구조        초기값을 주지 않을 경우 항상 0으로 초기화 되며 프로그램을 실행시킬 때 한번만 초기화 된다.          이 부분은 매우 중요한데, 실제로 함수가 실행될 때, 값이 변하는 것 같지만, 영향을 주지 않는다. 그렇기 때문에 원하는 결과인 1, 2, 3, 4 ,5가 출력된다.      ",
        
        "url": "/dv/c++/2020/04/05/%EC%A0%95%EC%A0%81%EB%B3%80%EC%88%98.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-13-ec-a3-bc-ea-b8-b0-ec-96-b5-ec-9e-a5-ec-b9-98-ea-b4-80-eb-a6-ac-html": {
        "title": "13: 주기억 장치 관리",
        "tags": "OS, Memory, MMU",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제에서 중요한 부분인 메모리 관리 기능에 대해 알아보자.메모리는 CPU 자원만큼 컴퓨터를 사용하는데 매우 중요한 자원 중 하나이다. 이전에는 운영체제에서 CPU 자원을 관리하는 프로세스 관리에 대해 살펴보았고, 지금부터는 메인 메모리를 관리하는 기능에 대해 살펴볼 것이다. 특히, 과거에는 메모리가 매우 비싼 자원이었고 크기 또한 작았기 때문에, 운영체제에서 메모리에 대한 관리가 지금보다 더 중요하였다.현재에는 과거보다 훨씬 큰 메모리를 저렴하게 사용하지만, 지금도 메모리는 부족하다. 메모리가 커져온 만큼 프로그램의 크기와 처리하는 데이터의 크기는 그보다 더욱 빠른 속도로 커져왔다. 그러므로 현재에도 여전히 메모리를 최대한 효율적으로 사용하기 위해 여러 방법들이 연구되고 있고, 운영체제 기능에서도 매우 중요한 위치를 차지하고 있다.1. 메모리에 프로그램 할당하기메모리는 기본적으로 주소(Address)와 데이터(Data)로 구성되어 있다.CPU와 메모리는 양방향으로 위 그림과 같이 주고 받는다. CPU는 주소를 가지고 메인 메모리에 요청을하거나 해당 주소에 계산 결과를 저장하고, 메모리는 요구하는 주소에 저장되어 있는 데이터를 CPU에게 전달한다.1.1 프로그램을 빌드하는 과정프로그램을 빌드하는 과정은 소스파일, 목적파일, 실행파일 순서로 생성된다.  소스파일(Source file)          고수준언어 또는 어셈블리어        목적파일(Object file)          컴파일 또는 어셈블 결과        실행파일(Executable file)          링크 결과      위 그림은 프로그램이 만들어지는 과정을 그림으로 표현한 것이다.  소스파일은 컴파일러(compiler)에 의해 컴파일 수행 결과로 목적 파일을 생성한다.          어셈블리어는 어셈블러가 어셈블을 수행하여 기계어로 변환한다. 프로그래밍을 하면서 외부의 라이브러리를 사용할 때가 빈번한데, 컴파일 단계에서는 이를 추가하지 않기 때문에 목적파일에는 이에 대한 정보가 없다.        링크 단계에서 하드디스크에서 프로그래머가 추가한 라이브러리를 찾아 정보를 추가하여, 실행 파일을 만든다.          링크 단계는 링커(linker)가 수행한다. 이 프로그램을 실행하면 로더(loader)에 의해 메인 메모리에 할당된다.      그리고 생성된 프로그램은 code, data, stack 영역으로 나뉘어져 있다. 단순히 생성된 프로그램에는 code와 data영역만 존재한다. 실제로 실행을 하는 과정에서는 함수를 실행하기 때문에, 돌아올 return address 등을 저장하는 stack도 필요하다.1.2 MMU(Memory Management Unit)  메모리 관리를 효율적으로 해주는 OS 서비스그렇다면, 프로그램을 실제로 메모리에 올리기 위해서는 좀 더 복잡한 과정이 필요하다. 먼저, 이 프로그램은 메모리에 몇 번지에 할당될까? 만약 운영체제가 없다면, 프로그래머가 직접 이를 처리해주어야 할 것이다. 하지만 운영체제가 존재하므로 실제 프로그래머는 이를 신경쓸 필요가 없다. 그러므로 프로그래밍을 할 때 주소를 사용하는 경우가 있는데, 프로그램이 메모리에 올라가는 주소를 고려하지 않고 프로그래밍이 가능한 것이다.(고수준언어에서는 직접 주소를 다루지 않는 경우가 많다.)또한, 다중 프로그래밍 환경에서는 여러 프로그램이 메모리에 올라가고 내려가고를 반복하기 때문에, 한 프로그램은 고정적인 공간을 사용할 수 없다. 이러한 여러 고려 사항을 해결해주는 것이 전에도 살펴봤던 MMU(Memory Management Unit)이다. 그리고 MMU에는 프로그램이 메모리에 할당될 때마다 다른 주소공간을 사용하기 때문에 재배치 레지스터(Relocation register)가 별도로 존재한다.위 그림은 MMU의 모습이다. 프로그램은 메인 메모리에 해당 주소를 사용할 수 있는지 여부를 생각하지 않고 주소를 사용한다. 만약 해당 프로그램이 사용하는 시작주소가 0번지라고 할 때, 실제 메인 메모리에서는 할당되는 주소가 유동적이기 때문에 0번지이라는 주소를 실제 할당된 주소로 변경해주어야 한다. 이때 재배치 레지스터를 이용한다.만약, 프로그램이 메인 메모리 500번지에 할당되어 재배치 레지스터값이 500으로 설정되었다면, CPU에서 프로그램의 0번지를 사용할 때 MMU를 통과하면 재배치 레지스터에 의해 500번지로 변경된다. 그 결과 CPU는 0번지를 사용하는 것으로 알고 있지만, 실제 메모리에서는 MMU에 의해 500번지를 사용하고 있는 것이다. CPU를 속인다.MMU(Memory Management Unit)의 기능을 살펴보면, 이전에 메모리 보호를 위해 base와 limit 레지스터가 있었다. 이는 CPU에서 주소를 사용하는데 이 주소가 해당 프로그램의 base나 limit 범위를 벗어나면 인터럽트가 발생하여 그 프로그램을 강제로 종료시킨다.MMU는 이 기능 이외에도 재배치 레지스터를 사용해서 프로그램이 어느 주소를 사용하더라도 실제 메인 메모리에 할당된 주소를 찾아갈 수 있도록 address translation 동작을 수행한다. 즉, CPU는 프로그램에 설정된 주소를 계속 사용하고 메모리에 명령을 보내지만, MMU에 의해 실제로 프로그램이 할당된 메모리 주소로 변환해서 사용할 수 있는 것이다. 그 결과, 프로그램의 실제 메모리 주소 공간의 위치는 CPU에 전혀 영향을 미치지 않고 정상적으로 사용할 수 있는 것이다.MMU에 의해 위 그림과 같이 주소는 두 가지로 구분된다. CPU에서 사용하는 주소는 논리 주소(logical address)라고 하고, 메모리가 사용하는 주소는 물리 주소(physical address)라고 한다.2. 메모리 낭비 방지운영체제는 메모리를 효율적으로 사용하기 위해 메모리 공간을 낭비하지 않는 것이 중요하다.2.1. 동적 적재(Dynamic Loading)  프로그램이 실행하는데 반드시 필요한 루틴/데이터만 적재(load)하는 것프로그램의 전체 코드에서 모든 루틴이 다 사용되는 것은 아니다. 대표적으로 오류 처리 구문이다. 오류 처리 구문은 if문과 같이 오류가 발생할 때만 해당 내부 코드가 실행되는 것을 말한다. 그러므로 동적 적재를 수행하면 프로그램의 실제 메모리에는 이러한 오류 구문을 제외하고 적재한다. 이러한 상태에서 실행하다가 오류가 발생하면 그 때 해당 오류 구문을 찾아 메모리에 올린다.데이터도 마찬가지다. 모든 데이터가 반드시 사용되는 것이 아니기 때문에, 특히 배열과 클래스의 경우는 필요한 부분만 메모리에 올려두고, 실행 도중 필요할 때마다 해당 부분을 찾아 메모리에 올려준다.반대로, 모든 루틴과 데이터를 적재하는 것을 정적 적재(static loading)이라고 한다. 현대 운영체제는 대부분 동적 적재를 사용한다.2.2. 동적 연결(Dynamic Linking)  공통으로 사용하는 라이브러리는 하나만 올리자.동적 연결은 여러 프로그램에 공통으로 사용되는 라이브러리를 중복으로 메모리에 올리는 것이 아니라 하나만 올리도록 하는 것이다.예를 들어, 아래와 같은 코드의 P1, P2 프로세스가 있다고 하자.// P1int a = 1;int b = 2;printf(\"%d\\n\", a + b);// P2int a = 1;int b = 2;printf(\"%d\\n\", a * b);이 두 소스파일을 컴파일하면 목적파일이 생성되고, 여기서 사용된 라이브러리를 링크하여 실행파일을 만든 다음 메모리에 적재한다. 두 프로세스가 적재되었을 때, printf() 를 사용하는 라이브러리는 메모리에 중복되어서 적재되어있다.이와 같이, 똑같은 라이브러리를 사용하는 프로그램은 흔히 볼 수 있다. 이러한 같은 라이브러리를 하나만 메모리에 올린 후, 이를 사용하는 프로그램이 하나의 메모리에 접근하도록 하면 메모리 낭비를 줄일 수 있다.동적 연결은 같은 라이브러리가 중복으로 메모리에 올라가는 것을 방지하기 위해 프로그램이 메모리에 적재된 후에 링크(link) 작업을 수행한다. 기존에는 실행 파일이 만들어지기 전에 링크 과정을 수행하였는데, 이를 정적 연결이라고 한다.위 그림은 예제에서 살펴 본 P1, P2 프로세스가 동적 연결을 통해 공통 라이브러리(printf() 라이브러리)를 연결한 모습을 볼 수 있다. 이러한 라이브러리를 Linux에서는 공유 라이브러리(Shared Library), Windows에서는 동적 연결 라이브러리(Dynamic Linking Library, DLL)라고 부른다.2.3 SwappingSwapping은 메모리에 적재되어 있는 프로세스 중에서 오랫동안 사용하지 않은 프로세스를 프로세스 이미지 형태로 만든 후 하드디스크(Backing store)에 내려보낸다. 메모리에서 Backing store로 가는 것을 swap-out, 다시 Backing store에서 메모리로 가는 것을 swap-in이라고 한다.여기서, 프로세스 이미지는 해당 프로그램이 메모리에 적재된 후 실행되면서 데이터를 추가하거나 변경하는 등의 과정을 거치는데, 현재 데이터의 상태를 프로세스 이미지라고 부른다. 그러므로 이는 단순히, 하드디스크에 존재하는 프로그램(exe파일)과는 전혀 다른 데이터이므로, 따로 저장해야한다. 이와 같은 swapping 과정으로 인한 프로세스 이미지를 저장하기 위해 하드디스크의 일부분을 분리하여 사용하는데, 이를 backing store 또는 swap device라고 부른다.Backing store의 크기는 대략 메인 메모리 크기 정도로 예상할 수 있다. 메모리의 모든 프로세스가 쫓겨난다고 해도 메인 메모리 크기를 넘지 않기 때문이다. 메인 메모리 크기가 크지 않는 PC나 스마트폰은 하드디스크의 일부를 backing store로 사용하지만, 메모리 크기가 크다면 따로 하드디스크 자체를 backing store로 사용하는 경우도 있다.Swap-out된 프로세스는 다시 swap-in을 할 때, 이전의 메모리 주소 공간이 아닌 새로운 주소 공간으로 갈 수도 있다. 이는 해당 프로세스가 backing store에 있는 동안 다른 프로세스가 해당 주소 공간을 사용할 수 있기 때문에다. 하지만 이는 MMU의 재배치 레지스터로 인해 어디에 적재되는지 상관없이 정상적으로 수행할 수 있다.현재는 프로세스의 크기가 커지고, 하드디스크는 메인 메모리보다 속도면에서 매우 느리므로 swapping 동작의 오버헤드는 크다고 볼 수 있다. 하지만 이로 인해 얻는 이득이 더 많으므로 대부분 운영체제는 이를 사용하고 있고, 속도가 중요한 서버 컴퓨터나 슈퍼 컴퓨터는 backing store를 하드디스크가 아닌 좀 더 빠른 저장 장치를 사용하기도 한다.3. 연속 메모리 할당(Contiguous Memory Allocation)과거에는 메모리에 프로세스가 하나만 올라가는 형태였다. 하지만 현재에는 메모리에 여러 프로세스가 할당되는 다중 프로그래밍 환경이 되었다.부팅 직후에 메모리 상태를 살펴보면, 운영체제만 할당되어 있고 비어있는 상태일 것이다. 이러한 비어있는 공간을 hole 이라 부른다. 즉, 부팅 직후에는 운영체제와 big single hole이 있는 상태이다. 시간이 지나면서 프로세스가 생성되고 종료하고를 반복하면, 여러 곳에 서로 다른 크기의 홀(hole)이 존재할 것이다. 이러한 상태를 scattered holes라고 한다.{}:.center}위 그림은 부팅 직후 상태에서 시간이 경과하면서 프로세스들이 생성, 종료를 반복한 후의 상태이다. 이와 같이 hole들이 불연속하게 흩어져 있는 상태를 메모리 단편화(Memory fragmentation) 라고 한다.메모리 단편화로 인해서 여러 곳에 hole이 흩어져 있는 상태에서 하나의 프로세스가 메모리에 할당되려하면 문제가 발생할 수 있다. 예를 들어, hole이 3개가 있고 각 크기는 50byte, 50byte, 80byte이다. 그런데 할당하려는 프로세스의 크기는 150byte이다. 각 hole들을 하나로 합치면 230byte로 이 프로세스를 할당할 수 있는데 실재로는 나누어져 있으므로 할당되지 못한다. 이러한 현상을 외부 단편화(External fragmentation) 라고 한다. 외부 단편화를 줄이기 위해서는 어떤 해결 방법이 있을까?3.1. 연속 메모리 할당 방식외부 단편화의 해결방법을 살펴보기 전에 연속 메모리 할당 방식을 먼저 살펴보자. 연속 메모리 할당 방식에는 3가지가 있다. First-fit, Best-fit, Worst-fit 이 있다.  First-fit(최초 적합)          최초 적합은 할당할 프로세스 크기보다 크거나 같은 hole을 탐색하는 순서 중에서 가장 먼저 찾은 hole에 프로세스를 할당하는 것이다.        Best-fit(최적 적합)          최적 적합은 할당할 프로세스 크기와 hole 크기의 차이가 가장 작은 hole에 프로세스를 할당하는 것이다.(hole크기는 프로세스 크기보다 반드시 커야 한다.)        Worst-fit(최악 적합)          최적 적합과 반대로, 할당할 프로세스 크기와 hole 크기의 차이가 가장 큰 hole에 프로세스를 할당하는 것이다.      예제            Hole id      HoleSize      Process Name      Size                  1      100kb      P1      212kb              2      500kb      P2      417kb              3      600kb      P3      112kb              4      300kb      P4      426kb              5      200kb                    First-fitBest-fitWorst-fit각 3가지 방식대로 프로세스를 할당한 모습을 볼 수 있다. 예제의 결과를 보면 Best-fit은 4개의 프로세스를 모두 할당할 수 있었고, 나머지 2개는 마지막 P4를 할당하지 못했다. 모든 hole을 합치면 P4를 할당할 수 있지만, hole들은 각각 나눠져 있기 때문에 할당할 수 없다.(외부 단편화)각 할당 방식의 일반적인 성능을 비교해보면, 속도면에서는 first-fit이 가장 빠르다. 메모리 이용률면에서는 first-fit, best-fit이 비슷한 성능을 낸다고 알려져있다. 하지만 여러 실험을 통해 best-fit을 사용하더라도 외부 단편화로 인해 전체 메모리의 1/3 정도를 낭비한다고 한다. 이는 거의 사용이 불가능한 수준이다.이를 해결하는 방법 중 하나는 Compaction 이다. compaction은 여러 곳에 흩어져있는 hole들을 강제로 하나로 합치는 것이다. 하지만 hole을 옮기는 오버헤드가 너무 크고, hole과 process 두개를 하기 때문에 어떻게 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않는 큰 단점이 존재한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-13-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-12-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-5-html": {
        "title": "12: 프로세스 동기화 Part 5",
        "tags": "OS, Synchronization, monitor",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "현재 사용하는 동기화 도구인 모니터(Monitor)에 대해서 알아본다.세마포는 실제로 매우 오래된 동기화 도구이다. 현재에는 모니터(monitor)라는 동기화 도구를 주로 사용하며, 이는 좀 더 고수준의 동기화 기능을 제공한다.1. 모니터 구조Semaphore의 구조는 위와 같았다. 그렇다면 monitor는 무엇이 다를까?위는 모니터의 구조를 간단히 나타낸 그림이다. 모니터는 공유 자원 + 공유 자원 접근함수로 이루어져 있고, 2개의 큐를 가지고 있다. 각각 mutual exclusion(상호배타) queue, conditional synchronization(조건동기) queue이다.  상호배타 큐는 말그대로 공유 자원에 하나의 프로세스만 진입하도록 하기 위한 큐이다.  조건동기 큐는 이미 공유자원을 사용하고 있는 프로세스가 특정한 호출 wait()을 통해 조건동기 큐로 들어갈 수 있다.조건동기 큐에 들어가 있는 프로세스는 공유자원을 사용하고 있는 다른 프로세스에 의해 깨워줄 수 있다. 이 역시 깨워주는 프로세스에서 특정한 호출 notify()을 해주며, 깨워주더라도 이미 공유자원을 사용하고 있는 프로세스가 해당 구역을 나가야 비로소 큐에 있던 프로세스가 실행된다.2. monitor in java자바는 모니터를 제공하는 대표적인 언어이며, 자바의 모든 개체는 모니터가 될 수 있다. 그렇다면 자바를 통해 모니터에 대한 예제를 살펴보자.class C {  private int value, ...;     // 공유 변수  synchronized void Foo() {   // 배타동기    // ...  }  synchronized void Goo() {    // ...  }  void H() {    // ...  }}위 코드는 모니터를 사용하고 있는 클래스이다. value와 같은 변수들은 여러 쓰레드가 공유하고 있는 변수로 볼 수 있고, synchronized 키워드는 배타동기를 수행하는 함수를 말한다. 즉, 해당 함수에는 단 하나의 쓰레드만 접근할 수 있다.Foo() 함수와 Goo() 함수는 synchronized 키워드를 통해 상호배타 함수로 선언하였는데, 이는 “둘 다 같은 임계구역을 갖는다”는 의미이다. 다시 말해서, Foo() 함수에 한 쓰레드가 수행 중이라면, Foo() 함수뿐 아니라 Goo() 함수에도 다른 쓰레드는 접근할 수 없다. 반면에 H() 함수는 일반 함수인데, 이 함수에서는 공통 변수에 대한 업데이트를 하지 않는다는 것을 예상할 수 있다. (여러 쓰레드가 동시에 접근가능하다.)조건동기는 특정한 메서드 호출로 사용할 수 있다.wait(): 호출한 쓰레드를 조건동기 큐에 삽입한다.notify(): 조건동기 큐에 있는 하나의 쓰레드를 깨워준다.notifyAll(): 조건동기 큐에 있는 모든 쓰레드를 깨워준다.모니터 역시, 세마포에서 할 수 있는 기능인 Mutual exclusion, Ordering을 모두 할 수 있다. 예제를 통해 이를 살펴보자.3. Problem Solving by Monitormonitor를 사용하여 지금까지 배운 문제들을 해결하는 방법에 대해 알아보자.3.1 BankAccount Problem이전에 세마포에서 살펴본 은행계좌 문제를 통해 세마포 대신 모니터를 사용해서 Mutual exclusion, Ordering을 구현해보자.3.1.1 Mutual Exclusionclass Test {\tpublic static void main(String[] args)\tthrows InterruptedException {\t\tBankAccount b = new\t\tBankAccount();\t\tParent p = new Parent(b);\t\tChild c = new Child(b);\t\tp.start();\t\tc.start();\t\tp.join();\t\tc.join();\t\tSystem.out.println( \"\\nbalance = \" + b.getBalance());\t}}class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tsynchronized void withdraw(int amt) {\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}class Parent extends Thread {\tBankAccount b;\tParent(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;100; i++)\t\t\tb.deposit(1000);\t}}class Child extends Thread {\tBankAccount b;\tChild(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;100; i++)\t\t\tb.withdraw(1000);\t}}코드가 매우 간단해졌다..!{:.center-text}위 코드에서 볼 수 있듯이, 세마포를 사용할 때보다 모니터를 사용하면 매우 간결하게 코드를 구현할 수 있다. 세마포를 선언하고 number of permit 값을 설정하는 대신, synchronized 키워드 하나로 이를 대체한 것을 볼 수 있다.+++++++++++++++++++++++------------------------------------------+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------balance = 0실행 결과는 위와 같고, balance값이 정상적으로 0을 출력한다.3.1.2 Mutual Ordeing은행계좌 문제를 살펴보기전에, ordering을 하기 위해 모니터를 어떻게 사용하는지 보자.            P1      P2                         wait()              section 1      section 2              notify()             위 구조는 프로세스 순서를 P1, P2 순서로 실행하기 원하는 경우이며, 이는 세마포와 매우 유사한 것을 알 수 있다. 그러면 은행계좌 문제를 모니터로 구현하는데, 입금 먼저 수행, 출금 먼저 수행, 입금 출금 반복 수행 3가지를 각각 구현해보자. 그리고 위 코드에서 수정하는 부분은 순서를 정하는 입금, 출금함수이므로 이 부분을 대변하는 BankAccount만 수정하자.입금 먼저 수행하기먼저 입금시작하면 기다리라고 하면된다.class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tnotify();\t}\tsynchronized void withdraw(int amt) {\t\twhile (balance &lt;= 0)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------------------------------------------------balance = 0출금 먼저 수행하기먼저 출금시작하면 기다리라고 하면된다.class BankAccount {\tint balance;\tsynchronized void deposit(int amt) {\t\twhile (balance == 0)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tsynchronized void withdraw(int amt) {\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tnotify();\t}\tint getBalance() {\t\treturn balance;\t}}----------------------------------------------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++balance = 0입금 출금 반복 수행하기입금 넣고 기다리고 출금 넣고 기다리고를 반복하면 된다!class BankAccount {\tint balance;\tboolean p_turn = true;\tsynchronized void deposit(int amt) {\t\tint temp = balance + amt;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tnotify();\t\tp_turn = false;\t\ttry {\t\t\twait();\t\t} catch (InterruptedException e) {}\t}\tsynchronized void withdraw(int amt) {\t\twhile (p_turn)\t\t\ttry {\t\t\t\twait();\t\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amt;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tnotify();\t\tp_turn = true;\t}\tint getBalance() {\t\treturn balance;\t}}+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-balance = 03.2 전통적 동기화 문제10: 전통적인 동기화 문제들을 수정해본다!2.1 Producer-Consumer ProblemSemaphore를 사용하면 상호 배제 sem, 가득 차있을 때 block하는 sem, 비어있을 때 block하는 sem 총 3개를 사용했어야 했다. 하지만 이번에는 코드가 간단해진다!class Buffer {    int[] buf;    int size, count, in, out;    Buffer(int size) {        buf = new int[size];        this.size = size;        count = in = out = 0;    }    synchronized void insert(int item) {        while (count == size)            try {                wait();            } catch (InterruptedException e) {}        buf[in] = item;        in = (in+1)%size;        notify();        count++;    }    synchronized int remove() {        while (count == 0)            try {                wait();            } catch (InterruptedException e) {}        int item = buf[out];        out = (out+1)%size;        count--;        notify();        return item;    }}class Producer extends Thread {    Buffer b;    int N;    Producer(Buffer b, int N) {        this.b = b; this.N = N;    }    public void run() {        for (int i=0; i&lt;N; i++)            b.insert(i);    }}class Consumer extends Thread {    Buffer b;    int N;    Consumer(Buffer b, int N) {        this.b = b; this.N = N;    }    public void run() {        int item;        for (int i=0; i&lt;N; i++)            item = b.remove();    }}class Test {    public static void main(String[] arg) {        Buffer b = new Buffer(100);        Producer p = new Producer(b, 10000);        Consumer c = new Consumer(b, 10000);        p.start();        c.start();        try {            p.join();            c.join();        } catch (InterruptedException e) {}        System.out.println(\"Number of items in the buf is \" + b.count);    }}Number of items in the buf is 02.2 The Dining Philosopher Problemclass Philosopher extends Thread {    int id; // philosopher id\tChopstick lstick, rstick;    Philosopher(int id, Chopstick lstick, Chopstick rstick) {        this.id = id;        this.lstick = lstick;        this.rstick = rstick;    }    public void run() {        try {            while (true) {                lstick.acquire();                rstick.acquire();                eating();                lstick.release();                rstick.release();                thinking();            }        }catch (InterruptedException e) { }    }    void eating() {        System.out.println(\"[\" + id + \"] eating\");    }    void thinking() {        System.out.println(\"[\" + id + \"] thinking\");    }}class Chopstick {    private boolean inUse = false;    synchronized void acquire() throws InterruptedException {        while (inUse)            wait();        inUse = true;    }    synchronized void release() {        inUse = false;        notify();    }}class Test {    static final int num = 5; // number of philosphers &amp; chopsticks    public static void main(String[] args) {        int i;        /* chopsticks */        Chopstick[] stick = new Chopstick[num];        for (i=0; i&lt;num; i++)            stick[i] = new Chopstick();        /* philosophers */        Philosopher[] phil = new Philosopher[num];        for (i=0; i&lt;num; i++)            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);        /* let philosophers eat and think */        for (i=0; i&lt;num; i++)            phil[i].start();    }}이 코드는 교착상태를 해결하지 않은 상태이다. 해결 하기 위해서는 circular wait 조건을 불만족하도록 만들면 된다. 이 부분에서는 쉽게 동기화 문제를 해결할 수 있음을 보고가면 된다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-12-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-5.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-11-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-4-html": {
        "title": "11: 프로세스 동기화 Part 4",
        "tags": "OS, Synchronization, Deadlock",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스 동기화에서 발생하는 논리적 오류인 교착 상태(Deadlock)에 대해 알아본다.Deadlock (교착 상태)교착 상태는 어떠한 자원을 갖고 있는 상황에서 문제가 발생한다. 자동차 교차로를 생각해보자. A자동차도 신호를 받았고, B 자동차도 신호를 받았다. 그래서 두 자동차가 움직이는 것에 논리적 오류가 없지만, 두 자동차가 갈 수 없는 상황이 발생한다. 바로 출근 시간 길 막힘이다. 길이 막혀 아무런 동작도 수행할 수 없다. 이런 상황을 교착상태라 한다.프로세스는 실행을 위해 CPU, 메모리, 파일 등 여러 하드웨어 자원이 필요하다. 이를 운영체제에서 프로세스가 요구하는 자원을 적절히 분배해준다. 예를 들어, 한 프로세스가 A 자원을 가지고 있는 상태에서 B 자원을 요구하고 있다. 하지만 B 자원은 다른 프로세스 역시 요구하고 있는 자원인데, 이러한 상황에서 자원을 분배하는 순서가 잘못되면 교착상태에 빠지게 된다.1. 교착상태 필요 조건(Necessary Conditions)교착상태가 일어나기 위한 필요 조건이 네 가지가 존재한다. 이는 필요 조건이므로, 네 가지가 모두 해당된다고 해서 반드시 교착상태가 일어나는 것은 아니다. 단지 일어날 가능성이 발생한다.하지만 네가지 조건 중 하나라도 해당되지 않으면 교착 상태는 일어나지 않는다. 즉, 4가지 조건에 모두 해당되면 Deadlock의 가능성이 있으나, 그렇지 않다면 Deadlock은 일어나지 않는다.  Mutual exclusion (상호배타)          한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다.                  젓가락은 한 철학자가 사용하고 있으면 이 젓가락은 사용할 수 없으므로 상호배타적이다.                      No Preemption (비선점)          한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.                  한 철학자가 젓가락을 집은 상태에서 다른 철학자가 이 젓가락을 뺏을 수 없다.                      Hold and wait (보유 및 대기)          한 프로세스가 자원을 가지고 있는 상태에서 대기한다.                  철학자는 왼쪽 젓가락을 가지고 있는 상태에서 오른쪽 젓가락을 집기 위해 대기한다.                      Circular wait (환형대기)          프로세스가 요구하는 자원의 방향이 원형을 이룬다.                  모든 철학자는 왼쪽 젓가락부터 집을 수 있다.                    교착상태는 위 네 가지 조건을 모두 만족하더라도 매우 드물게 일어나는 현상이지만, 한 번 교착상태에 빠지면 프로세스가 무한 루프에 빠져 수행하지 못하고 해당 프로세스가 가지고 있는 자원은 아무도 사용하지 못한다. 이는 전체 컴퓨터 환경에 매우 치명적이다. 그리고 교착상태에 의한 오류를 해결하기는 매우 힘들다.2. 자원(Resources)교착 상태가 발생하는 가장 큰 원인은 결국 자원의 문제이다. 따라서 이 자원을 어떻게 이용하고 있는 지 파악하는 것이 중요하다.하드웨어 자원은 여러 개가 존재하고 동일한 형식(type)의 자원이 존재할 수 있다. 예를 들어, 같은 CPU가 2개있는 환경이 있다. 이러한 자원 하나하나를 instance라고 한다.자원은 프로세스가 직접적으로 사용할 수 없고, 운영체제에 요청(request)하면 운영체제가 제공해준다. 그 후 프로세스는 이 자원을 사용(use)하고 모든 사용이 끝나면 이를 반납(release)한다.요청(request) -&gt; 사용(use) -&gt; 반납(release)2.1 자원 할당도(Resource Allocation Graph)자원 할당도는 어떤 자원이 어떤 프로세스에 할당되었는지 또는 어느 프로세스가 어느 자원을 할당 받으려고 기다리는지를 그림으로 나타낸 것이다.            용어      모양                  Resource(자원)      사각형              Instance(인스턴스)      점              Process(프로세스)      원              할당      화살표      R1은 P1에 할당되어 있는 상태이고, P2는 R1을 요청하고 있는 상태이다.자원 할당도를 사용하는 이유는 교착상태의 필요조건을 한 눈에 볼 수 있기 때문이다. 자원 할당도를 분석할 때 mutual exclusion(한번에 하나)과 no-preemption(강제로 못 뺏는다.)은 기본으로 적용된다.Hold and wait는 화살표를 통해 한 프로세스가 인스턴스를 할당받았고 다른 자원을 가리키고 있다면, 이 상황은 Hold and wait인 상태이다.Circular wait 역시 화살표 방향이 원형을 이루고 있다면 이는 환형대기인 상태이다.이런 그림을 보면 Circular wait 조건을 가지고 있어 교착 상태의 가능성을 가지고 있다.위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.4. 교착상태 처리4.1 교착상태 방지 (Deadlock Prevention)교착상태 방지는 교착상태 필요조건 네 가지 중 최소 한 가지를 만족시키지 않도록 만드는 것이다.  상호배타(Mutual exclusion)          상호배타를 없애기 위해서는 자원을 공유 가능하게 만들어야 한다. 하지만 현실적으로 이러한 방법이 불가능한 경우가 많다.        비선점(No preemption)          비선점을 없애러면 반대로 선점이 가능하도록 만들어야 한다. 이 역시 대부분의 자원에게는 불가능한 방법이다. CPU는 강제로 스위칭하는 것이 가능한 경우가 있지만, 대부분의 경우에는 불가능하다. 가령 프린터를 수행하는 중간에 다른 프로세스가 이를 선점하는 것은 불가능하다고 볼 수 있다.        보유 및 대기(Hold &amp; Wait)          이 조건을 없애려면 자원을 가지고 있는 상태에서 다른 자원을 기다리지 않도록 만든다. 만약 여러 개의 자원이 필요하다면 필요한 모든 자원을 얻을 수 있는 경우에만 해당 자원을 요청한다. 또는 필요한 자원 중 일부만 가지는 경우 할당받은 자원을 모두 운영체제에 반납한다. 하지만 이와 같은 방법은 자원의 활용률을 저하시키고, starvation 현상이 발생하는 단점이 있다.      왼쪽 젓가락을 가진 상태에서 오른쪽 젓가락을 요청했는데, 이미 할당되어 있다면, 왼쪽 젓가락도 할당해제 한다.        환형대기(Circular wait)          이 조건을 없애는 것은 위 세 가지 조건보다는 할 수 있는 확률이 높다. 대표적인 예는 모든 자원에 번호를 부여하여 이 번호에 대한 오름차순으로 자원을 요청하는 것이다. 이 역시 자원의 활용률을 저하시키는 단점이 있다.      네 가지 방법을 살펴본 결과 가장 현실적인 방법은 hold &amp; wait나 circular wait 조건을 없애는 것이다. 하지만 둘 다 자원을 비효율적으로 사용하게 되는 단점을 가지고 있다. 그래서 이와 같이 교착상태 방지 방법은 군사, 우주, 의료와 같은 크리티컬한 곳에서 사용하는 것이 좋다.철학자 문제에 적용위 그림은 식사하는 철학자 문제를 자원 할당도로 표현한 것이다. 그림을 보면 한 눈에 Circular wait 조건을 만족한 것을 알 수 있다. 그리고 모든 철학자(프로세스)는 한 젓가락(자원)을 할당(파란색 화살표)받고, 다른 젓가락을 요청(검은색 화살표)하고 있으므로 Hold and wait 조건 역시 만족한다.Circular wait 조건을 없애기 위해 짝수 번호 철학자는 왼쪽 젓가락, 오른쪽 젓가락 순서로, 홀수 번호 철학자는 반대 순서인 오른쪽 젓가락, 왼쪽 젓가락 순서로 집는다고 하자.위 그림은 circular wait 조건을 없앤 식사하는 철학자 문제의 자원 할당도이다. 화살표가 원형을 만들지 않는 것을 볼 수 있다.// Philosopher Thread run functionpublic void run() {    try {        while (true) {            if (id % 2 == 0) {                lstick.acquire();                rstick.acquire();            }            else {                rstick.acquire();                lstick.acquire();            }            eating();            lstick.release();            rstick.release();            thinking();        }    }catch (InterruptedException e) { }}이전 글에서 있던 철학자가 젓가락을 집는 코드를 수정했다. 위와 같이 코드를 변경하고 실제로 수행하면 무한 반복문이 끝나지않고 정상적으로 계속되는 것을 확인할 수 있다.4.2 교착상태 회피 (Deadlock Avoidance)교착상태 회피와 방지의 차이점은 교착상태를 다르게 접근하는 것이다. 교착상태 회피에서는 교착상태를 자원 요청에 대한 잘못된 승인으로 판단한다. OS단에서 요청에 대해 잘 관리를 해주었다면 해결할 수 있다고 생각하는 것이다.이러한 접근은 은행과 비슷하다. 은행이 투자를 할 때, 안전한 곳과 안전하지 않은 곳을 잘 분리하여 투자해야, 위기 상황에서 부도가 나지 않을 것이다. 마찬가지로, OS에서 deadlock이 나지 않는 방법으로 할당해주는 방법이 교착 상태 회피이다.따라서, 교착상태 회피에서는 안전한 할당(Safe allocation)과 불안정한 할당(Unsafe allocation) 두 가지로 나뉜다.안전한 할당현재 운영체제에는 magnetic tape 자원이 총 12개가 있고, 이를 요청하는 3개의 프로세스가 있다.            process      Max needs      Current needs                  P0      10      5              P1      4      2              P2      9      2        Current needs          한 프로세스가 한 번 요청을 할 때 요구하는 개수        Max needs          프로세스를 정상적으로 끝내기 위해 필요한 총 개수      운영체제 입장에서 3개의 프로세스가 모두 수행될 때까지 자원을 분배해보자.  order : 순서  process : 프로세스 이름  needs : 프로세스가 필요로 하는 tape의 개수  possible : 할당이 가능한지 판단하는 변수  state : 해당 프로세스의 진행 상태  dealloc : 할당 해제 되었는지 확인하는 변수  tapeSize : 현재까지 할당되어 사용할 수 있는 tape의 개수  wait : 할당 받지 못해 대기하는 지 유무            order      process      needs      possible      state      dealloc      tapeSize      wait                  1      P0      5      O      5/10      X      12-&gt;7      X              2      P1      2      O      2/4      X      7-&gt;5      X              3      P2      2      O      2/9      X      5-&gt;3      X              4      P0      5      X      5/10      X      3      O              5      P1      2      O      4/4      O      3-&gt;1-&gt;5      X              6      P0      5      O      10/10      O      5-&gt;0-&gt;10      X              7      P2      2      O      4/9      O      10-&gt;8-&gt;12      X              8      P2      2      O      6/9      O      12-&gt;10-&gt;12      X              9      P2      2      O      8/9      O      12-&gt;10-&gt;12      X              10      P2      2      O      9/9      O      12-&gt;11-&gt;12      X        P0에게 5개를 할당한다.(5/10) =&gt; 현재 magnetic tape 개수: 7  P1에게 2개를 할당한다.(2/4) =&gt; 현재 magnetic tape 개수: 5  P2에게 2개를 할당한다.(2/9) =&gt; 현재 magnetic tape 개수: 3  다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 3개이므로 할당해줄 수 없다.  P1에게 2개를 할당한다.(4/4) =&gt; 현재 magnetic tape 개수: 1          P1은 필요한 4개의 magnetic tape을 받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 5        대기하고 있던 P0에게 5개를 할당한다.(10/10) =&gt; 현재 magnetic tape 개수: 0          P0 역시 필요한 자원을 모두 할당받았으므로, 종료 후 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 10        P2는 현재 필요한 magnetic tape 개수가 7개이고, 현재 남아있는 magnetic tape 개수 10개이므로 정상적으로 수행가능하다. (7~10)이 예제에서는 3개의 프로세스가 모두 정상적으로 자원을 할당받고 종료할 수 있었다. 이를 안전한 할당이라 한다. 다음 예제를 보자.불안전한 할당            process      Max needs      Current needs                  P0      10      5              P1      4      2              P2      9      3      이 예제 역시 운영체제가 보유하고 있는 총 magnetic tape 개수는 12개이고, 3개의 프로세스가 존재한다. 자원을 분배해보자.            order      process      needs      possible      state      dealloc      tapeSize      wait                  1      P0      5      O      5/10      X      12-&gt;7      X              2      P1      2      O      2/4      X      7-&gt;5      X              3      P2      3      O      3/9      X      5-&gt;2      X              4      P0      5      X      5/10      X      2      O              5      P1      2      O      4/4      O      2-&gt;0-&gt;4      X              6      P0      5      X      5/10      X      4      O              7      P2      3      O      6/9      X      4-&gt;1      X              8      P0      5      X      5/10      X      1      O              9      P2      3      X      6/9      X      1      O              10      P0      5      X      5/10      X      1      O              11      P2      3      X      6/9      X      1      O              $\\vdots$                                                         P0에게 5개를 할당한다.(5/10) =&gt; 현재 magnetic tape 개수: 7  P1에게 2개를 할당한다.(2/4) =&gt; 현재 magnetic tape 개수: 5  P2에게 3개를 할당한다.(3/9) =&gt; 현재 magnetic tape 개수: 2  다시 P0가 5개를 요구하지만 현재 magnetic tape 개수는 2개이므로 할당해줄 수 없다.  P1에게 2개를 할당한다.(4/4) =&gt; 현재 magnetic tape 개수: 0          P1은 필요한 자원을 모두 할당받았으므로, 정상적으로 프로세스를 종료하고 사용한 자원을 반납한다. =&gt; 현재 magnetic tape 개수: 4        대기하고 있던 P0는 아직 할당받으르 수 없다.  P2에게 3개를 할당한다.(6/9) =&gt; 현재 magnetic tape 개수: 1  현재 남아있는 magnetic tape 개수는 1개이고, P0가 요구하는 개수는 5개, P2는 3개이므로 두 프로세스 모두 할당받을 수 없다. (8~)이 예제에서 남은 magnetic tape 개수가 요구하는 개수보다 적으므로 자원을 할당해줄 수 없다. 그러므로 P0, P2 프로세스는 자원을 하염없이 기다리게 된다. 이를 불안전한 할당이라 하고, 그 결과 교착상태에 빠지게 된다.교착상태 회피는 마치 대출전문 은행과 유사하게 동작하므로, 해결 방법을 Banker’s Algorithm이라 한다. 돈이 있어야 값지4.3 교착상태 검출 및 복구 (Deadlock Detection &amp; Recovery)교착상태 검출 및 복구는 교착상태 자체가 매우 드문 현상이므로 자유롭게 자원을 분배하다가 교착상태가 발생하면 이를 정상적인 상태로 복구하는 것이다.1번과 2번 방법은 사전에 교착상태를 일어나지 않도록 하는 방법이지만, 교착상태 검출 및 복구 방법은 교착상태가 일어나는 것을 허용한다. 그 대신, 교착상태가 일어났을 때 이를 인지하고 복구를 해야 한다.교착상태가 일어나는 것을 감지하기 위해 운영체제 내부에서 주기적으로 교착상태가 발생하였는지 검사해야한다. 그 주기의 길이가 짧으면 그 만큼 오버헤드가 크고, 주기가 길면 오버헤드는 줄일 수 있지만 복구 가능성이 낮아진다.복구하는 방법은 교착상태가 발생하는지 주기적으로 검사하듯이 메모리의 상태를 주기적으로 메모리에 저장해놓고 만약 교착상태가 발생하면 그 이전 상태로 되돌리는 방법이 있다. 그 외에도 일부 프로세스를 강제로 종료하거나 자원을 강제로 선점하여 프로세스에게 할당해주는 방법 등이 있다.정상적인 상태로 복구한다는 장점이 있지만, 복구를 제대로 하지 못할 수도 있고, 검출을 위해 추가적인 오버헤드가 발생한다는 단점이 있다.3.4 교착상태 무시교착상태의 필요조건 네 가지를 모두 만족하더라도 교착상태가 반드시 일어나는 것이 아니라고 했듯이, 교착상태는 매우 드문 상황이다. 그러므로 이를 위해 오버헤드를 감수하는 것이 비효율적인 환경도 존재한다. 그러한 환경은 교착상태에 대한 아무런 조치를 하지 않는 방법도 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-11-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-4.html"
      }
      ,
    
      "cs-os-2020-04-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-10-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-3-html": {
        "title": "10: 프로세스 동기화 Part 3",
        "tags": "OS, Synchronization, Deadlock",
        "date": "April 5, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "전통적인 동기화 문제에 대해서 알아본다.현실적으로 찾아보았을 때, 동기화가 잘 되지 않으면 발생하는 문제들이 많다. 은행 계좌 문제와 같은 전통적으로 알려진 동기화 문제들에 대해서 알아본다.1. Producer-Consumer Problem생산자-소비자 문제는 생산자가 데이터를 생산하면 소비자는 그 데이터를 소비하는 형태의 문제이다. 컴퓨터 환경에서 예를 보면, 컴파일러 -&gt; 어셈블러, 웹 서버 -&gt; 웹 클라이언트 등이 있다. 컴파일러에서 생성한 어셈블리어는 어셈블러에서 이를 소비하여 기계어를 만든다.생산자-소비자 관계를 간단히 그림으로 나타내면 위와 같다. 이 관계의 대부분은 생산자에서 생산한 데이터 양을 소비자가 한 번에 소비하는 경우는 드물다. 생산한 데이터는 중간의 buffer 라는 저장 공간(메모리 공간)에 저장해두고 소비자는 여기서 필요한 만큼 가져간다. 창고와 같다.버퍼의 크기는 현실적으로 유한하다. 그러므로 생산자는 버퍼 공간이 가득 차면 더 이상 저장할 수 없다. 소비자는 버퍼가 비어 있으면 가져올 수 없다. 이러한 유한한 버퍼 크기를 bounded buffer 라고 한다.정리  생산자 소비자 문제          생산자 : 데이터 생산, 소비자 : 데이터 소비      컴파일러 -&gt; 어셈블러, 파일 서버 -&gt; 클라이언트, 웹서버 -&gt; 웹 클라이언트        Bounded Buffer          Buffer란 생산자와 소비자 사이에 존재하는 창고와 같음      생산자와 소비자 사이의 속도 차이를 보완하기 위해 필요함      버퍼 크기는 유한하다.                  생산자는 가득 차면 넣을 수 없다.          소비자는 버퍼가 비면 뺄 수 없다.                    1.1 CodeMainclass Test {\tpublic static void main(String[] arg) {\t\tBuffer b = new Buffer(100);\t\tProducer p = new Producer(b, 10000);\t\tConsumer c = new Consumer(b, 10000);\t\tp.start();\t\tc.start();\t\ttry {\t\t\tp.join();\t\t\tc.join();\t\t} catch (InterruptedException e) {}\t\tSystem.out.println(\"Number of items in the buf is \" + b.count);\t}}Buffer Class이 부분을 주목해서 봐야 한다.class Buffer {\tint[] buf; // buf: Bounded buffer\tint size;\t// size: 버퍼 크기\tint count; // count: 버퍼에 저장된 데이터 개수\tint in; // in: 생산한 데이터를 담을 버퍼 인덱스\tint out; // out: 소비할 데이터를 가리키는 버퍼 인덱스\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t}\tvoid insert(int item) {\t\t/* check if buf is full */\t\twhile (count == size)\t\t\t;\t\t/* buf is not full */\t\tbuf[in] = item;\t\tin = (in+1)%size; //  Circular Queue\t\tcount++;\t}\tint remove() {\t\t/* check if buf is empty */\t\twhile (count == 0)\t\t\t;\t\t/* buf is not empty */\t\tint item = buf[out];\t\tout = (out+1)%size; //  Circular Queue\t\tcount--;\t\treturn item;\t}}Buffer 클래스의 멤버 변수를 보면  buf: Bounded buffer  size: 버퍼 크기  count: 버퍼에 저장된 데이터 개수  in: 생산한 데이터를 담을 버퍼 인덱스  out: 소비할 데이터를 가리키는 버퍼 인덱스Producer/****** 생산자 ******/class Producer extends Thread {\tBuffer b;\tint N;\tProducer(Buffer b, int N) {\t\tthis.b = b; this.N = N;\t}\tpublic void run() {\t\tfor (int i=0; i&lt;N; i++)\t\t\tb.insert(i);\t}}Consumer/****** 소비자 ******/class Consumer extends Thread {\tBuffer b;\tint N;\tConsumer(Buffer b, int N) {\t\tthis.b = b; this.N = N;\t}\tpublic void run() {\t\tint item;\t\tfor (int i=0; i&lt;N; i++)\t\t\titem = b.remove();\t}}만약 생성자가 데이터를 계속 생성하여 버퍼의 마지막 인덱스로 가면 그 다음은 처음으로 되돌아간다. (circular buffer) 소비하는 것도 마찬가지이다.main을 보면 크기가 100인 버퍼를 생성하고 2개의 쓰레드가 각각 생산자와 소비자 역할을 하여 각각 10000번씩 생산하고 소비한다. 정상적인 결과는 count값이 0이 출력되야 한다.하지만 실제 코드를 수행하면 무한 루프에 빠지거나, count값에 전혀 예상하지 않은 값이 출력된다.이 문제 당연하게도 동기화 문제이다. 생산자와 소비자가 동시에 접근하는 공통 변수인 buf, count 를 두 프로세스가 동시에 업데이트하기 때문이다. 다시 말하면 임계구역에 동시에 접근한 것이다.1.2 동기화 해결해결방법은 앞서 배웠던 세마포를 사용하여 mutual exclusion을 보장하는 것이다. 임계구역을 동시에 접근하는 것을 방지하고 하나의 프로세스만 허용해야한다. sem이라고 선언하지 않고 mutex라 선언한다. 지금 만드는 semaphore는 mutual exclusion을 막는 역할을 하기 때문이다.Buffer Classclass Buffer {\tint[] buf;\tint size;\tint count;\tint in;\tint out;\tSemaphore mutex;   // 세마포 선언\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t\tmutex = new Semaphore(1);\t}\tvoid insert(int item) {\t\t/* check if buf is full */\t\twhile (count == size)\t\t\t;\t\t/* buf is not full */\t\ttry {            mutex.acquire();            buf[in] = item;            in = (in+1)%size;            count++;            mutex.release();\t\t} catch(InterruptedException e) {}\t}\tint remove() {\t\t/* check if buf is empty */\t\twhile (count == 0)\t\t\t;\t\t/* buf is not empty */\t\ttry {\t\t\tmutex.acquire();\t\t\tint item = buf[out];\t\t\tout = (out+1)%size;\t\t\tcount--;\t\t\tmutex.release();\t\t\treturn item;\t\t} catch(InterruptedException e) {}\t\treturn -1;\t}}위는 임계구역에 세마포를 추가한 코드이다. 임계구역은 위에서 말했듯이 buf, count 에 접근하는 영역이므로 insert(), remove() 함수 내부에 선언한 것을 볼 수 있다.1.3 Busy waiting여기서 한 가지 더 문제점이 있다. 바로 busy waiting 이다. 위에서 busy waiting은 생산과 소비하기 전에 버퍼가 가득 찼는지 비어 있는지 확인하는 무한 반복문을 말한다. 이는 아무 일도 하지 않으면서 무한으로 반복하여 CPU를 점유하고 있으므로 매우 비효율적이다. 이를 해결할 수 있는 것도 세마포이다.class Buffer {\tint[] buf;\tint size;\tint count;\tint in;\tint out;\tSemaphore mutex, full, empty;\tBuffer(int size) {\t\tbuf = new int[size];\t\tthis.size = size;\t\tcount = in = out = 0;\t\tmutex = new Semaphore(1);\t\tfull = new Semaphore(0);\t\tempty = new Semaphore(size);\t}\tvoid insert(int item) {\t\ttry {            empty.acquire();    // 버퍼의 비어있는 공간을 1 감소시킨다.(비어있는 공간이 없으면 block)            mutex.acquire();            buf[in] = item;            in = (in+1)%size;            count++;            mutex.release();            full.release();    // 버퍼의 찬 공간을 1 증가시킨다.          } catch(InterruptedException e) {}\t}\tint remove() {\t\ttry {            full.acquire();    // 버퍼의 찬 공간을 1 감소시킨다.(버퍼가 모두 비어있으면 block)            mutex.acquire();            int item = buf[out];            out = (out+1)%size;            count--;            mutex.release();            empty.release();   // 버퍼의 비어있는 공간을 1 증가시킨다.            return item;          } catch(InterruptedException e) {}\t\treturn -1;\t}}busy waiting을 없애기 위해 두 개의 세마포를 더 추가하였다.  empty: 버퍼에서 비어있는 공간의 개수(초기값 size)  full: 버퍼에서 차있는 공간의 개수(초기값 0)추가한 세마포 변수는 위와 같고, empty는 초기화할 때 버퍼는 모두 비어있으므로 버퍼의 크기로 초기화하고 full은 초기 버퍼에는 아무런 데이터가 없으므로 0으로 초기화한다.데이터를 생성하기 전에 비어있는 공간이 있는지 확인한다. 없다면 empty세마포의 value값이 -1이 되므로 block이 되고, 있다면 임계구역 내부로 진입하여 데이터를 생성한다. 생성이 완료되면 full세마포의 value값을 1 증가시킨다.(소비자는 반대로 동작한다고 볼 수 있다. 코드참고) 이 코드를 실행시켜보면 정상적으로 결과값이 0이 출력되는 것을 확인할 수 있다.2. Readers-Writers ProblemReaders-Writers 문제는 대표적으로 공통 데이터베이스에 접근하는 경우가 있다. 하나의 데이터베이스에 여러 프로세스(readers, writers)가 접근하므로, 데이터베이스는 임계구역으로 설정해야한다. 즉, 한 번에 한 개의 프로세스만 접근가능하도록 해야하는데 이는 매우 비효율적이다.비효율을 해결하기 위해 데이터베이스에 접근하는 프로세스 종류를 reader와 writer로 나눈다. 그리고 reader는 데이터베이스 내의 정보를 바꾸지 않고 읽기만 하는 프로세스이므로, 여러 reader 프로세스가 동시에 데이터베이스를 접근하는 것을 허용한다. writer는 데이터베이스 내용을 바꾸는 프로세스이므로 당연히 mutual exclusion 을 보장해야한다.2.1 분류Readers-Writers 문제는 우선순위에 따라 여러 경우로 나눌 수 있다.  The first R/W problem (readers-preference): 이 방법은 reader 프로세스에 우선권을 주는 것이다. 만약, 한 reader 프로세스가 데이터베이스를 읽고 있는 동안 writer 프로세스가 오면 당연히 접근하지 못하고 기다린다. 이 상황에서 다른 reader 프로세스가 들어온다면, writer 프로세스가 기다리는 것을 무시하고 데이터베이스에 접근하여 읽는다. 그 결과, 두 reader가 동시에 데이터베이스를 읽는 상황이 된다.  The second R/W problem (writers-preference): 위 방법과 반대로 writer 프로세스가 기다리는 상황에서 다른 reader 프로세스가 들어온다면, 기존의 writer 프로세스 다음 순서로 기다려야한다.  The third R/W problem: 아무에게도 우선순위를 주지 않는다.3. Dining Philosopher Problem식사하는 철학자 문제는 원형 테이블에 5명의 철학자와 5개의 젓가락이 있는 상황이 있다고 하자. 각 철학자는 생각하고 식사하고 생각하고 식사하고를 반복한다. 단, 식사를 하기 위해서는 2개의 젓가락이 필요하다.이 상황을 프로그래밍을 해보자. 젓가락은 한 철학자가 가져가면 다른 철학자는 이 젓가락을 사용할 수 없다. 즉, 한 젓가락에 동시에 접근할 수 있는 철학자는 한 명뿐이므로 젓가락은 세마포로 만들 수 있다.(number of permit = 1) 한 철학자가 식사를 하려고 하면, 왼쪽 젓가락과 오른쪽 젓가락 순서로 가져가고, 식사가 끝나면 동일하게 왼쪽 젓가락, 오른쪽 젓가락 순서로 내려놓는다.3.1 Codeimport java.util.concurrent.Semaphore;class Philosopher extends Thread {\tint id; // philosopher id\tSemaphore lstick, rstick; // left, right chopsticks\tPhilosopher(int id, Semaphore lstick, Semaphore rstick) {\t\tthis.id = id;\t\tthis.lstick = lstick;\t\tthis.rstick = rstick;\t}\tpublic void run() {\t\ttry {\t\t\twhile (true) {\t\t\t\tlstick.acquire();\t\t\t\trstick.acquire();\t\t\t\teating();\t\t\t\tlstick.release();\t\t\t\trstick.release();\t\t\t\tthinking();\t\t\t}\t\t}catch (InterruptedException e) { }\t}\tvoid eating() {\t\tSystem.out.println(\"[\" + id + \"] eating\");\t}\tvoid thinking() {\t\tSystem.out.println(\"[\" + id + \"] thinking\");\t}}class Test {\tstatic final int num = 5; // number of philosphers &amp; chopsticks\tpublic static void main(String[] args) {        int i;        /* chopsticks */        Semaphore[] stick = new Semaphore[num];        for (i=0; i&lt;num; i++)            stick[i] = new Semaphore(1);        /* philosophers */        Philosopher[] phil = new Philosopher[num];        for (i=0; i&lt;num; i++)            phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);        /* let philosophers eat and think */        for (i=0; i&lt;num; i++)            phil[i].start();      }}5개의 젓가락 세마포와 5명의 철학자 쓰레드를 생성한다. 각 철학자 쓰레드에는 무한 반복문으로 왼쪽 젓가락과 오른쪽 젓가락을 순서대로 집은 후 식사를 하고(몇 번 철학자가 식사했다는 것을 화면에 출력), 다시 왼쪽 젓가락, 오른쪽 젓가락 순으로 내려놓고 생각을 한다.단순히 코드를 봐서는 문제점이 없어보인다. 하지만 이를 수행하면 중간에 멈추고 더이상 실행되지 않는다.이는 대표적인 starvation 문제중 하나이다. 모든 철학자가 식사를 하지 못하고 굶어죽는 상황이라고 할 수 있다.이는 매우 드문 상황으로 모든 철학자가 동시에 식사를 하려고 왼쪽 젓가락을 집었다고 하자. 그러면 5명의 철학자가 5개의 젓가락을 모두 집어든 상황이다. 그 결과, 남아있는 젓가락은 더 이상없고 모든 철학자가 반대편 젓가락을 들기 위해 기다리고 있다. 하지만 식사할 수 있는 철학자는 없으므로 아무도 젓가락은 내려놓지 않고 하염없이 기다리고 있다.이러한 상황을 교착상태(deadlock) 라고 한다. 오오미ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-10-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-3.html"
      }
      ,
    
      "cs-algorithm-2020-04-03-eb-b0-b1-ec-a4-80-ec-b5-9c-ec-86-8c-ea-b0-92-html": {
        "title": "백준(10868번): 최소값",
        "tags": "백준, 알고리즘, SegmentTree",
        "date": "April 3, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플래티넘5 : 세그먼트 트리 문제이다.생각            0      1      2      3      4      5      6                  4      1      7      5      2      9      8      입력값이 이렇게 주어진다고 생각해보자. 이 상태에서 3~6까지의 최소값을 구하는 것은, 단순한 방법으로 구해도 $O(n^2)$으로 풀 수 있다. 하지만 이러한 확인(쿼리)가 많아진다면, 급격하게 시간 복잡도가 올라간다. 따라서 이 문제에서 제시하는 m(100000) 개에 대해서 n(100000)을 모두 확인하는 방법으로 간다면 문제를 풀 수 없다.($O(n^2)$)문제의 원인그렇다면 어느 부분에서 연산이 많이 걸리는 지 생각해보자. 가장 큰 부분을 판단을 중복으로 한다는 것이다. 0~3까지의 최소값을 구하는 것과, 1~4까지의 최소값을 구하는 과정에는 1~3까지의 최소값을 비교하는 과정이 중복된다. 그렇다면, 처음에 주어진 index를 나누어, 그 나눈 구간에 대해 최소값을 구해놓으면 어떨까?어떻게 나눌까?나누겠다는 생각이 들고 난 후에는, 어떻게 하면 잘 나눌 수 있을 지에 대해 고민했다. 이 부분은 트리가 가장 용이하다. 정보를 저장하는 자료구조 중, 탐색에 있어 시간복잡도가 log이다. 나누는 방법은 생각 보다 간단하다.Tree 구조트리의 구조는 모양의 변화를 가지는 것이다. 우리가 보통 가지는 선형 리스트를 조금 바꾸어 생각하면 쉽게 트리 구조를 만들 수 있다.이렇게 2의 제곱수만큼의 개수를 아래쪽으로 옮기면서 쌓으면 트리 구조가 된다. 이 때, 중요한 것은 가장 위층으로 부터 아래로 내려오는데 그 index들의 관계를 아는 것이다. 잘 보면, 1에서 2, 3은 $2\\times 1$, $2\\times 1 + 1$ 과 같다. 왼쪽 트리, 오른쪽 트리로 가는 관계는 계속 일관성을 가진다.Segment Tree그렇다면 이번에는 이 트리 구조를 이 문제에 맞는 모양으로 바꾸어 보자. 우리는 최소값을 미리 저장하기 위해 트리구조를 사용하기로 했는데, 그 구조를 아래와 같이 만들어서 생각해보자.기본적인 트리구조는 같지만 추가된 변수가 있다. 그것은 index의 시작과 끝을 나타내는 start~end 변수이다. 이렇게 나누었다고 가정하고, 2~5까지의 최소값을 얻기위해 조사해야 하는 Node의 개수를 파악해보자.이렇게 3개의 값만 조사하면 최소값을 얻을 수 있다! 이 때 발생하는 시간 복잡도는 $log(N)$ 이다. depth가 내려갈 수록 반씩 조사를 덜 할 수 있기 때문이다.tree에 필요한 node 수위 예시에서 총 7개의 원소를 넣기 위해 필요한 node의 개수는 총 13개 이다. 이 13개를 다 넣기 위해 필요한 트리의 깊이는 총 4이다. 이 값을 얻기 위한 수식은 다음과 같다.보통의 tree는 input으로 들어오는 요소의 개수와 트리의 node번호가 일치하지만, 이 경우는 depth가 1개 추가되므로 1을 더해주어야 한다. 이것을 코드로 구현하면 다음과 같다.h = ceil(log2(n))+1;treeSize = (1 &lt;&lt; h);&lt;&lt;은 shift 연산자로, 2진 연산을 할 때, 자리수를 올려주는 역할을 한다.init (초기화)처음에 input을 받고서, 가장 먼저 해야하는 일은, input을 tree안에 넣는 것이다. 그런데 우리가 설계한 세그먼트 트리를 생각해보면, 이 친구는 아래 node가 결정된 뒤에 상위 노드가 결정될 수 있다. 재귀로 짜면 해결될 것이다.void init(vector&lt;int&gt;&amp; input, vector&lt;int&gt;&amp; tree, int node, int start, int end){    if (start == end) {        tree[node] = input[start];        return;    }    init(input, tree, 2*node, start, (start+end)/2);    init(input, tree, 2*node+1, (start+end)/2+1, end);    tree[node] = min(tree[2*node], tree[2*node+1]);    return;}init 함수의 argument로는 input 벡터, tree 벡터, 내가 기록할 node의 index, 처음 node가 커버하게 될 index의 시작과 끝이 필요하다. 그 뒤로는 아까 트리 구조에서 본 왼쪽, 오른쪽 노드로 가는 함수 관계에 따라 init함수를 계속 수행하면 된다. 종료조건은, 그림에서 보았듯이 start와 end과 같아지는 지점에서 input에 start 해당하는 index의 값을 넣어준다.find저장된 자료구조에서 찾는 과정이다. 내가 찾으려고 하는 범위을 left, right 라 하고, 내가 처음에 탐색을 시작할 노드의 번호를 node, 그 노드가 커버하는 index의 범위를 start, end라 하자. tree의 가장 위부터 탐색을 시작할 때, 범위에 걸리는 녀석들만 비교의 대상이 되어야 한다. 이런 범위를 따져보면 총 3가지로 나눌 수 있다.  left, right 사이에 현재 노드의 커버범위가 들어온다.          후보로 선정한다.        left, right 와 현재 노드의 커버범위가 전혀 겹치지 않는다.          버린다.        애매하게 걸친다.          더 깊이 들어가서 조사한다.      이 과정을 구현하면 다음과 같다.int findMin(vector&lt;int&gt;&amp; tree, int node, int start, int end, int left, int right){    if (left &gt; end || right &lt; start) {        return INF;    } else if (left &lt;= start &amp;&amp; end &lt;= right){        return tree[node];    }    int a = findMin(tree, 2*node, start, (start+end)/2, left, right);    int b = findMin(tree, 2*node+1, (start+end)/2+1, end, left, right);    return min(a, b);}Code#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int INF = 1111111111;void init(vector&lt;int&gt;&amp; input, vector&lt;int&gt;&amp; tree, int node, int start, int end){    if (start == end) {        tree[node] = input[start];        return;    }    init(input, tree, 2*node, start, (start+end)/2);    init(input, tree, 2*node+1, (start+end)/2+1, end);    tree[node] = min(tree[2*node], tree[2*node+1]);    return;}int findMin(vector&lt;int&gt;&amp; tree, int node, int start, int end, int left, int right){    if (left &gt; end || right &lt; start) {        return INF;    } else if (left &lt;= start &amp;&amp; end &lt;= right){        return tree[node];    }    int a = findMin(tree, 2*node, start, (start+end)/2, left, right);    int b = findMin(tree, 2*node+1, (start+end)/2+1, end, left, right);    return min(a, b);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    int n, m;    cin &gt;&gt; n &gt;&gt; m;    int h = int(ceil(log2(n)))+1;    int treeSize = (1 &lt;&lt; h);    vector&lt;int&gt; tree(treeSize, INF);    vector&lt;int&gt; a(n);    for (int i = 0; i &lt; n; i++) {       cin &gt;&gt; a[i];    }    init(a, tree, 1, 0, n-1);    for (int i = 0; i &lt; m; i++) {        int left, right;        cin &gt;&gt; left &gt;&gt; right;        cout &lt;&lt; findMin(tree, 1, 0, n-1, left-1, right-1) &lt;&lt; '\\n';    }}Reference백준(10868번) - 최소값",
        
        "url": "/cs/algorithm/2020/04/03/%EB%B0%B1%EC%A4%80-%EC%B5%9C%EC%86%8C%EA%B0%92.html"
      }
      ,
    
      "cs-algorithm-2020-04-03-eb-b0-b1-ec-a4-80-ea-b5-ac-ea-b0-84-ed-95-a9-ea-b5-ac-ed-95-98-ea-b8-b0-html": {
        "title": "백준(2042번): 구간 합 구하기",
        "tags": "백준, 알고리즘, SegmentTree",
        "date": "April 3, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "플래티넘5 : 세그먼트 트리 문제이다.생각전형적인 세그먼트 트리 문제이다. 구간에 대한 합을 연속된 쿼리로 물어보는 경우인데, 이런 경우 단순하게 짜면 그냥 펑!이다. 이 문제 같은 경우는 추가적으로 수가 변형되는데, 이전 백준(10868번): 최소값에서 한 단계 업그레이드 되었다고 보면된다.update업데이트는 별 것 없다. 내가 바꾸고 싶은 녀석의 트리 하위 노드에 접속하여, 그 노드가 영향을 주는 노드만 쏙쏙 업데이트 해주면 된다. 만약 2번 값을 바꾸고 싶다면 2번이 영향을 주는 노드는 파란색 노드들 이다.void update(int changed_index, ll changed_value, int index, int start, int end){        if (start == end) {           nodes[index] = changed_value;           return;        }        int mid = (start+end)/2;        if (start &lt;= changed_index &amp;&amp; changed_index &lt;= mid) {            update(changed_index, changed_value, 2*index, start, mid);        } else {            update(changed_index, changed_value, 2*index+1, mid+1, end);        }        nodes[index] = nodes[2*index] + nodes[2*index+1];    }사실 이 부분을 생각할 때, 위 방법 말고, 차이를 다 더해주는 방법을 생각했는데 좋지 않아 적지 않는다.Code이번에는 클래스로 구현했다. 그런데, 클래스로 구현하면 속도가 매우 느리다고 한다. private 키워드도 느리니 쓰지 말라한다. 흥. 구조체로 구현하라고 한다.#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;int n, m, k;ll arr[1000001];class SegmentTree{private:    ll* nodes;    ll* input;public:    SegmentTree(int size, ll* input){        int h = ceil(log2(size))+1;        int treeSize = (1 &lt;&lt; h);        nodes = new ll[treeSize];        this-&gt;input = input;        init(1, 0, size-1);    }    ~SegmentTree(){        delete[] nodes;    }    void init(int index, int start, int end){        if (start == end) {            nodes[index] = input[start];            return;        }        int mid = (start+end)/2;        init(2*index, start, mid);        init(2*index+1, mid+1, end);        nodes[index] = nodes[index*2] + nodes[index*2+1];    }    ll findSum(int index, int start, int end, int left, int right){        if (left &gt; end || right &lt; start){            return 0;        } else if (left &lt;= start &amp;&amp; end &lt;= right){            return nodes[index];        }        int mid = (start+end)/2;        return findSum(2*index, start, mid, left, right) + findSum(2*index+1, mid+1, end, left, right);    }    void update(int changed_index, ll changed_value, int index, int start, int end){        if (start == end) {           nodes[index] = changed_value;           return;        }        int mid = (start+end)/2;        if (start &lt;= changed_index &amp;&amp; changed_index &lt;= mid) {            update(changed_index, changed_value, 2*index, start, mid);        } else {            update(changed_index, changed_value, 2*index+1, mid+1, end);        }        nodes[index] = nodes[2*index] + nodes[2*index+1];    }};int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for (int i = 0; i &lt; n; i++) {        cin &gt;&gt; arr[i];    }    SegmentTree st(n, arr);    int changeCount = 0, printCount = 0;    while (!(changeCount == m &amp;&amp; printCount == k)) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        if (a == 1) {            ll c;            cin &gt;&gt; c;            changeCount++;            st.update(b-1, c, 1, 0, n-1);        } else {            int c;            cin &gt;&gt; c;            printCount++;            cout &lt;&lt; st.findSum(1, 0, n-1, b-1, c-1) &lt;&lt; '\\n';        }    }    return 0;}#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;int N, M, K;void init(vector&lt;ll&gt;&amp; input, vector&lt;ll&gt;&amp; tree, int node, int start, int end){    if (start == end) {        tree[node] = input[start];        return;    }    int mid = (start+end)/2;    init(input, tree, 2*node, start, mid);    init(input, tree, 2*node+1, mid+1, end);    tree[node] = tree[node*2] + tree[node*2+1];}ll findSum(vector&lt;ll&gt;&amp; tree, int node, int start, int end, int left, int right){    if (end &lt; left || start &gt; right) return 0;    else if (start &gt;= left &amp;&amp; end &lt;= right) return tree[node];    int mid = (start+end)/2;    ll a = findSum(tree, 2*node, start, mid, left, right);    ll b = findSum(tree, 2*node+1, mid+1, end, left, right);    return a+b;}void update(vector&lt;ll&gt;&amp; tree, int loc, ll value, int node, int start, int end) {    if (start == end) {        tree[node] = value;        return;    }    int mid = (start+end)/2;    if (start &lt;= loc &amp;&amp; loc &lt;= mid) {        update(tree, loc, value, 2*node, start, mid);    } else {        update(tree, loc, value, 2*node+1, mid+1, end);    }    tree[node] = tree[2*node] + tree[2*node+1];}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;    int h = int(ceil(log2(N)));    int treeSize = (1 &lt;&lt; (h+1));    vector&lt;ll&gt; a(N);    vector&lt;ll&gt; tree(treeSize, 0);    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; a[i];    }    init(a, tree, 1, 0, N-1);    for (int i = 0; i &lt; M+K; i++) {        int action;        cin &gt;&gt; action;        if (action == 1){            int loc;            ll value;            cin &gt;&gt; loc &gt;&gt; value;            update(tree, loc-1, value, 1, 0, N-1);        } else {            int left, right;            cin &gt;&gt; left &gt;&gt; right;            cout &lt;&lt; findSum(tree, 1, 0, N-1, left-1, right-1) &lt;&lt; '\\n';        }    }    return 0;}Reference백준(2042번) - 구간 합 구하기",
        
        "url": "/cs/algorithm/2020/04/03/%EB%B0%B1%EC%A4%80-%EA%B5%AC%EA%B0%84-%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-04-03-eb-b0-b1-ec-a4-80-ea-b3-b5-ed-95-ad-html": {
        "title": "백준(10775번): 공항",
        "tags": "백준, 알고리즘, Union-Find",
        "date": "April 3, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드2 : 유니언 파인드 문제이다.생각이런 문제는 정말 비행기가 온다고 생각하고 푸는 것이 가장 좋은 것 같다. 그러니까 모든 문제는 시뮬레이션을 제대로 하는 것이 중요.. 총 5개의 게이트가 있다고 하자. 그 때, 4번으로 비행기가 들어온다. 그럼 4번에 배정하는 것이 맞다. 그런데 또 4번으로 들어온다. 이 문제는 4번 보다 작은 게이트에만 비행기가 들어올 수 있으므로 들어갈 수 있는 게이트는 1, 2, 3이다. 그런데, 문제 특징 상 원하는 게이트보다 작은 부분에만 들어갈 수 있으므로 가장 많은 비행기를 넣기 위해서는 원하는 게이트에서 작은 숫자를 가진 게이트 중, 숫자가 가장 큰 게이트에 들어가는 것이 최선이다.(응?) 이해를 위해 표를 그려보자.            gate      1      2      3      4      5                         0      0      0      1      0      이 상황에서 3번 게이트로 들어올 경우 두가지 그림이 가능하다.            gate      1      2      3      4      5                         1      0      0      1      0                  gate      1      2      3      4      5                         0      0      1      1      0      1번 표의 경우, 만약 1번으로 들어오는 비행기가 있다고 하면, 이 비행기는 이미 게이트가 차 있으므로 들어가지 못한다. 그래서 총 숫자는 2이다. 2번 표에서는 1번 게이트가 비어있으므로 비행기를 댈 수 있다. 그 결과 정답은 3이다. 이렇게, 비행기가 들어오는 방법은 원하는 게이트보다 작거나 같은 게이트 중 비어있는 게이트에서 가장 큰 숫자를 가진 게이트 순서로 도킹해야한다.유니온 파인드위에서 생각한 것은, 대안 게이트를 찾는 방법이다. 그런데 생각해보면, 이 대안 게이트는 그래프로 볼 수 있다.gate     : 1, 2, 3, 4, 5airplain : 4, 4, 3, 1위와 같은 순서로 비행기가 들어온다고 했을 때의 그림을 보자.airplain 4airplain 4airplain 3airplain 1이 과정에서, 신경써주어야 하는 것은, 해당 게이트의 대안 게이트의 번호가 무엇인지이다! 무조건 처음에는 비행기가 왔을 때, 자신의 게이트에 넣는 것은 확정이므로, 처음 도킹 위치의 초기값은 자기 자신의 게이트 이다. 이제 비행기가 들어오면서, 어떠한 방법으로 이것을 업데이트 해줄지 고민하면 된다.대안 게이트 합치기기본적으로 대안 게이트의 위치는 나보다 하나 작은 녀석의 게이트이다. 하지만 그 위치에도 이미 도킹이 되어 있다면, 그 녀석의 대안 게이트를 또 찾아야 한다. 그러므로 대안 게이트를 찾아서 업데이트 할 때는 나보다 작은 녀석을 기반으로 하되, 그녀석의 최종적인 대안 게이트를 찾아야 한다. 유니온 파인드 알고리즘에서 이 대안 게이트는 조상에 치환되는 개념으로 볼 수 있다. 결국은 조상을 찾아서, 그 조상으로 업데이트를 진행해야 한다.종료조건은 간단하다. 문제에서 보여주듯 원하는 게이트보다 작은 게이트들이 다 도킹이 된 상태면 종료한다. 이 조건은, 알고리즘 상에서 대안 게이트의 번호가 0이 되는 것과 동치이다. 0번 게이트는 없으므로 도킹할 수 없다.알고리즘  초기 게이트의 위치를 대안 게이트의 번호를 자기자신의 게이트를 가리키도록 한다.  비행기가 들어올 때, 대안 게이트를 찾는다.  대안 게이트를 찾으면, 대안 게이트에 비행기가 도킹했다고 생각하고 도킹한 비행기의 숫자를 늘린다.  대안 게이트에 비행기가 들어왔으므로, 방금 도킹한 비행기의 대안 게이트를 찾는다.  만약, 대안 게이트의 번호가 0인 경우 현재까지 도킹한 비행기를 출력하고 종료한다.Code#include &lt;iostream&gt;using namespace std;int n, m;int parent[100001];int ans = 0;int find(int gate){    if (gate == parent[gate]){        return gate;    }    return parent[gate] = find(parent[gate]);     // 탐색하는 과정에서 있었던 대안 게이트를 최종 값으로 업데이트한다.}// 게이트의 최종 대안 게이트로 업데이트 한다.void unite(int x, int y) {    x = find(x);    y = find(y);    parent[x] = y;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        parent[i] = i;    }    for (int i = 0; i &lt; m; i++) {        int command;        cin &gt;&gt; command;        int empty_gate = find(command);        if (empty_gate == 0) {            break;        }        ans++;        unite(empty_gate, empty_gate-1); // 기본적으로 나보다 하나 작은 게이트와 합친다.    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}Reference백준(10775번) - 공항",
        
        "url": "/cs/algorithm/2020/04/03/%EB%B0%B1%EC%A4%80-%EA%B3%B5%ED%95%AD.html"
      }
      ,
    
      "cs-algorithm-2020-04-02-eb-b0-b1-ec-a4-80-ec-a7-91-ed-95-a9-ec-9d-98-ed-91-9c-ed-98-84-html": {
        "title": "백준(1717번): 집합의 표현",
        "tags": "백준, 알고리즘, Union-Find",
        "date": "April 2, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 유니온 파인드 문제이다.생각문제를 이해해보자. 먼저 처음에 아무일도 하지 않을 경우에 입력된 n에 대해서 0 ~ n까지의 바구니가 생긴다. 그 다음, m개의 명령이 들어온다. 명령은 해당 원소가 들어있는 바구니를 합치는 것, 그리고 해당 원소가 같은 바구니에 들어있는 지 확인하는 것이다.그렇다면 핵심은, 현재 어떻게 내가 들어가 있는 바구니를 찾을 것인가? 그리고 찾았다면 어떤식으로 합쳐서 가지고 있을 것인가? 이다. 결국 집합을 만들고, 서로소 인지를 확인하는 문제이다.가장 단순하게 생각해보자. 처음에 모든 바구니는 자기자신만을 원소로 갖는 바구니를 가진다. 이 상태에서 1번 바구니와 3번 바구니를 합치라는 명령이 내려올 때, 우리는 일반적으로 이것을 동등하게 생각하고 연결하려 한다. 하지만 이렇게 생각할 경우에 해당 바구니에 대한 번호를 재정의 해야 한다. 예를 들어, (1, 2)가 들어있는 바구니는 몇번 바구니라 정의해야 할까? 또 추가적으로 3이 들어온 경우 (1, 2, 3)은 몇번 바구니 일까? 바구니에 원소가 추가될 경우 계속하여 바구니의 이름을 재정의 해야 한다.그러니 위계 질서를 줘보자. 1번 바구니와 2번 바구니를 합친다는 명령이 내려왔을 때 2번 바구니는 1번을 따른다. (2-&gt;1) 그리고 3번 바구니는 2번을 따른다고 하면 (3-&gt;2-&gt;1)로 준다. 그리고 이렇게 생성된 바구니의 번호를 1이라 하면, 합치는 과정을 통한다하더라도 합쳐진 집합의 번호는 가장 먼저 합쳐진, 즉 조상 원소의 번호라 지칭할 수 있다. 즉, 위의 바구니는 1번 바구니라 할 수 있고, 다른 합쳐진 집합이 있다하더라도 이 집합의 조상은 독립적으로 유지된다.(3-&gt;2-&gt;1) = 1번 바구니(4-&gt;5) = 5번 바구니5번 바구니와 3번 바구니를 합해라.=&gt; (4-&gt;5-&gt;3-&gt;2-&gt;1) = 1번 바구니문제 발생하지만 이 경우에는 문제가 발생하는데, (2-&gt;1), (5-&gt;4) 인 경우가 있다고 하자. 이 때 5번이 2번 바구니에 속한다고 할 경우 이 논리대로라면 (5-&gt;2-&gt;1)이 된다. 그런데 사실은 4번도 1번 바구니에 속해야 한다. 논리적 오류가 발생한다.이 문제는 바구니가 속하는 기준이 한 방향이기 때문이다. 하지만 속하는 기준을 여러개로 만들지 않아도 해결이 가능하다.해결 방법아까 조상을 만들고, 추가된 집합에 대한 바구니 번호를 가장 위에 있는 조상의 번호를 따르기로 했다. 위에서 발생한 문제에 대해 해당 번호가 어떤 바구니(조상)에 있는지 확인하고 그 바구니끼리 연결한다면 해당 문제는 해결된다.(2-&gt;1) = 1번 바구니(5-&gt;4) = 4번 바구니5번 바구니와 2번 바구니를 합쳐라.5번의 조상 : 4번2번의 조상 : 1번(4-&gt;1)로 바꿔버린다.=&gt; (2-&gt;1), (5-&gt;4-&gt;1)이렇게 된 경우 1번 바구니에 해당한 번호는 2, 4, 5로 원하는 결론이다.구현이것을 구현하는 것이 어려워 보이지만, 단순하다. 위에서 결국 필요한 것은 내 원소의 번호, 그리고 그 원소가 따르는 번호이다. 그리고 그 따르는 것들의 바구니 번호는 가장 위에 기초가 되는 조상 번호가 대표한다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      3      4      5      6      7      7 80 1 31 1 70 7 61 7 10 3 70 4 20 1 11 1 1line 10 1 3 // 1번과 3번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      3      4      5      6      7      1의 조상 번호 : 13의 조상 번호 : 33번이 따르는 바구니를 1로 바꾼다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      6      7      line 21 1 7 // 1번과 7번은 같은 바구니이니?            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      6      7      7의 조상 번호 : 71의 조상 번호 : 1Noline 30 7 6 // 7번과 6번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      6      7      7의 조상 번호 : 76의 조상 번호 : 66번은 7번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      7      line 41 7 1 // 7번과 1번은 같은 바구니이니?            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      7      7의 조상 번호 : 71의 조상 번호 : 1Noline 50 3 7 // 3번과 7번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      7      3의 조상 번호 : 17의 조상 번호 : 77번은 3번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      3      line 60 4 2 // 4번과 2번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      3      4의 조상 번호 : 42의 조상 번호 : 22번은 4번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      4      1      4      5      7      3      line 70 1 1 // 1번과 1번을 합쳐라.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      2      1      4      5      7      3      1의 조상 번호 : 11의 조상 번호 : 11번은 1번을 따른다.            바구니      0      1      2      3      4      5      6      7                  번호      0      1      4      1      4      5      7      3      line 81 1 1 // 1번과 1번은 같은 바구니이니?            바구니      0      1      2      3      4      5      6      7                  번호      0      1      4      1      4      5      7      3      1의 조상 번호 : 11의 조상 번호 : 1Yes결론이런 방식으로 업데이트 하는 과정을 거치면, 묶인 집합을 효과적으로 찾을 수 있다. 결론적으로 구현해야 하는 함수는 find, union 함수이다.findfind 함수같은 경우에는, 특정 원소에 대해 물었을 때, 그 녀석이 속한 바구니를 끝까지 찾아 어떤 바구니인지 반환한다.unionunion 함수는 명령이 들어왔을 때, 각각이 속해있는 바구니를 찾고 그 바구니를 연결한다. 이 때, 중요한 것은 해당 원소의 바구니 번호를 찾아야 한다는 것이다.#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n, m;int box[1000001];int find(int elem){    if (elem == box[elem]) {        return elem;    }    return find(box[elem]);}void merge(int elem1, int elem2){    box[find(elem2)] = find(elem1);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt;= n; i++) {        box[i] = i;    }    for (int i = 0; i &lt; m; i++) {        int command, elem1, elem2;        cin &gt;&gt; command &gt;&gt; elem1 &gt;&gt; elem2;        if (command) {            if (find(elem1) == find(elem2)) {                cout &lt;&lt; \"YES\" &lt;&lt; '\\n';            } else {                cout &lt;&lt; \"NO\" &lt;&lt; '\\n';            }        } else {            merge(elem1, elem2);        }    }    return 0;}시간 복잡도 문제하지만 위의 코드대로 한다면 문제가 발생한다. 그 이유는 원소의 개수가 많아짐에 따라 어떤 바구니에 들어있는지 탐색하는 시간이 오래걸리기 때문이다. 예제 입력에 대한 마지막 상황을 보자.            바구니번호      0      1      2      3      4      5      6      7                  따르는 번호      0      1      4      1      4      5      7      3      이 상황에서, 6은 어느 바구니에 있을까? (6-&gt;7-&gt;3-&gt;1) 로, 1번 바구니에 있다. 만약, 6번을 0번이 속한 바구니와 합치라는 명령이 들어온다면 4번의 연산을 수행해야 한다. 그렇다면, 극단적인 경우에, n개의 원소가 순차적으로 얽혀있고 (n-&gt;n-1-&gt;n-2-&gt;…) n이라는 원소를 특정 바구니에 합치라는 명령이 들어올 경우, $O(n)$ 의 시간 복잡도를 갖는다. 이 때, 수행하는 명령의 개수가 m일 경우 $O(nm)$ 의 시간 복잡도를 갖는다. 현재 문제에서 n = 100000, m = 1000000이므로 시간 초과가 난다.해결이 문제는 해결이 간단한데, find 함수에 찾는 과정에서, 최종 조상의 번호를 아예 해당 원소의 바구니라고 저장해버리는 것이다. 이 상황에서는 원소가 속해있는 바구니 번호가 중요한 것이지, 그 과정에서 발생하는 그래프가 중요한 것이 아니기 때문이다.#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n, m;int box[1000001];int find(int elem){    if (elem == box[elem]) {        return elem;    }    return box[elem] = find(box[elem]);}void merge(int elem1, int elem2){    box[find(elem2)] = find(elem1);}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt;= n; i++) {        box[i] = i;    }    for (int i = 0; i &lt; m; i++) {        int command, elem1, elem2;        cin &gt;&gt; command &gt;&gt; elem1 &gt;&gt; elem2;        if (command) {            if (find(elem1) == find(elem2)) {                cout &lt;&lt; \"YES\" &lt;&lt; '\\n';            } else {                cout &lt;&lt; \"NO\" &lt;&lt; '\\n';            }        } else {            merge(elem1, elem2);        }    }    return 0;}Reference백준(1717번) - 집합의 표현",
        
        "url": "/cs/algorithm/2020/04/02/%EB%B0%B1%EC%A4%80-%EC%A7%91%ED%95%A9%EC%9D%98-%ED%91%9C%ED%98%84.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-09-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-2-html": {
        "title": "09: 프로세스 동기화 Part 2",
        "tags": "OS, Synchronization, Semaphore",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스 동기화 도구에 대해 알아본다.Semaphore(세마포)Semaphoresms 깃발이라는 네덜란드 단어이다. 옛날에는 기찻길에서 공유하는 길이 있을 때, 깃발 표식으로 오고감의 신호를 주고 받았다. 이러한 맥락에서, Critical section을 사용하는 쓰레드에 사용하는 방법의 이름으로 붙게 되었다.위의 그림을 보면 공유하는 기찻길이 하나이다. 이 경우 공유 자원이 1이라 볼 수 있다. 하나의 기차가 지나갈 때 1을 감소시키고, 다 지나간 뒤에 1을 증가시키는 일을 반복한다. 그리고 다른 기차가 지나가려고 할 때, Semaphore가 0인 경우에는 정지하고 1인 경우에 순차적으로 지나가게 하면 해결된다. 이렇게 Semaphore가 0, 1인 경우를 Binary Semaphore라 한다.공유 자원이 꼭 1개일 필요는 없다. 여러개의 자원인 상황도 존재한다. 가령 위의 기차 그림에서 통과해서 갈 수 있는 공유 기찻길이 5개라면, 공유자원은 5이다. 이런 경우를 counting semaphore라 한다.1. 구현위의 예시에서 보듯, 깃발은 총 두가지가 필요하다. 지나가는 경우에는 감소, 지나간 뒤에는 증가이다. 초기에는 P, V로 불렸다.(네덜란드에서 만들어져 네덜란드어의 약자이다.) 현재에는 P는 test를 의미하며 acquire() 로 사용하고, V는 increment를 의미하며 release() 로 사용한다. acquire()는 자원이 사용가능한지 확인하고, 사용가능하다면 사용하고 그렇지 않다면 대기한다. release()는 자원을 내놓고, 다음 자원을 실행시킨다.자바를 통해 세마포 구조를 간단히 살펴보면 아래와 같다.class Semaphore {  int value;      // number of permits  Semaphore(int value) {    // ...  }  void acquire() {    value--;    if (value &lt; 0) {      // add this process/thread to list      // block    }  }  void release() {    value++;    if (value &lt;= 0) {      // remove a process P from list      // wakeup P    }  }}위 코드에서 acquire() 는 value값을 감소시키고 만약 value값이 0보다 작으면(가용자원을 모두 사용함) 이미 해당 임계구역에 어느 프로세스가 존재한다는 의미이므로 현재 프로세스는 접근하지 못하도록 막아야한다. 이를 list라는 기다리는 줄에 추가한 뒤 block을 걸어준다.(list는 일반적으로 큐로 되어있다.)release() 는 value값을 증가시키고, 만약 value값이 0보다 같거나 작으면 임계구역에 진입하려고 대기하는 프로세스가 list에 남아있다는 의미이므로 그 중에서 하나를 꺼내어 임계구역을 수행할 수 있도록 해주어야 한다.세마포를 그림으로 나타내면 위와 같다. list는 실제로 큐로 볼 수 있다. acquire()에 의해 block되는 프로세스는 세마포 내부에 있는 큐에 삽입된 후, 다른 프로세스가 임계구역을 나오면서 release()를 호출하여 세마포 큐에 있는 프로세스를 깨워야 한다.(다시 ready queue로 보낸다.)위에서 살펴본 것처럼 세마포는 일반적으로 Mutual exclusion을 위해 사용된다.운영체제 정리 08: 프로세스 동기화 &lt;1. 발생 이유와 목적&gt;Bank Account Problem(은행 계좌 문제) 해결이전 글에서 보았던 은행 계좌 문제에 세마포를 적용해보자. 위에서 임계구역은 BankAccount 클래스 내부의 입출력하는 부분인 것을 보았다. 여기에 세마포를 적용해보면 아래와 같다.import java.util.concurrent.Semaphore;  // 세마포를 사용하기 위해 파일 가장 위에 추가해야 한다.class BankAccount {\tint balance;\tSemaphore sem;\tBankAccount() {   // BankAccount 클래스의 생성자가 호출되면 세마포를 만든다.\t\tsem = new Semaphore(1);  // value 값을 1로 초기화한다.\t}\tvoid deposit(int amount) {\t\ttry {\t\t\tsem.acquire();   // 임계구역에 들어가기를 요청한다.\t\t} catch (InterruptedException e) {}\t    /* 임계 구역 */\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();   // 임계구역에서 나간다.\t}\tvoid withdraw(int amount) {\t\ttry {\t\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t    /* 임계 구역 */\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tsem.release();\t}\tint getBalance() {\t\treturn balance;\t}}value 값은 임계구역에 몇 개의 프로세스를 접근할 것인지 정하는 것과 같다. 지금은 임계 구역에 하나의 프로세스만 접근가능하기 때문에 1 로 초기화 한다. (위 코드를 제외한 부분은 동일하다.) 이 코드를 수행하면 아래와 같은 결과가 나온다.// +,- 출력 생략balance = 0정상적으로 잔액이 0원이 나온 것을 확인할 수 있다. 이 코드는 임계구역의 문제를 해결하였으므로 몇 번을 수행하여도 같은 결과값이 출력된다.2. Ordering세마포는 mutual exclusion뿐 아니라 ordering을 하기 위해서도 사용한다. 즉, 프로세스의 실행 순서를 원하는 순서로 설정 할 수 있다.예를 들어, 프로세스가 P1, P2 두 개가 있다고 가정하자. 원하는 순서는 P1, P2 순으로 실행하기를 원한다. 그러면 아래와 같이 설정해줄 수 있다.// 초기 semaphore 값 = 0sem value = 0            P1      P2                         sem.acquire()              section 1      section 2              sem.release()             P1이 먼저 실행된 경우  Section 1 이전에 아무런 동작이 없으므로 바로 수행한다.  sem.release() 를 만나면 value값을 1 증가시키고, 세마포 큐에 있는 프로세스를 깨워주는데 현재에는 큐에 프로세스가 없으므로 아무 동작도 하지 않는다.  P2가 실행된다.  P2의 sem.acquire() 를 만나면 현재 value값은 1이고 이를 1감소시키면 0이 된다. value = 0이면 block을 하지 않으므로, 무사히 Section 2가 수행된다.P2가 먼저 실행된 경우  Section 2 이전에 sem.acquire() 가 있으므로 이를 수행하는데, 현재 value값은 0이고 이를 1 감소 시키면 -1 이 된다. value값이 음수면 해당 프로세스를 block시킨다.(세마포 큐에 삽입한다.)  P1이 실행되면 Section 1이 바로 수행된다.  sem.release() 를 만나면 value값을 1 증가시키고, 세마포 큐에 있는 P2 프로세스를 깨워준다.(현재 value = 0)  P2의 Section 2가 수행된다.위에서 두 가지 경우를 살펴보았듯이, P1, P2 둘 중 어느 것을 먼저 실행하여도 결과적으로 P1 -&gt; P2 순서로 수행하는 것을 알 수 있다.입금 출금 순서로 은행계좌 문제 해결하기위에서 계속 살펴봤던 은행계좌 문제에서 ordering을 적용해보자. 프로세스의 실행 순서는 반드시 입금, 출금 순서로 수행해야한다.class BankAccount {\tint balance;\tSemaphore sem, semOrder;\tBankAccount() {\t\tsem = new Semaphore(1);\t\tsemOrder = new Semaphore(0);   // Ordeing을 위한 세마포\t}\tvoid deposit(int amount) {\t\ttry {\t\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();\t\tsemOrder.release();   // block된 출금 프로세스가 있다면 깨워준다.\t}\tvoid withdraw(int amount) {\t\ttry {\t\t\tsemOrder.acquire();   // 출금을 먼저하려고 하면 block한다.\t\t\tsem.acquire();\t\t} catch (InterruptedException e) {}\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t\tsem.release();\t}\tint getBalance() {\t\treturn balance;\t}}위처럼 코드를 수정할 수 있다. Ordering을 위한 semOrder 세마포 변수를 선언하고, 출금하는 동작 앞에 acquire(), 입금하는 동작 뒤에 release() 를 추가하였다.+++++++++++++++++++++++++------------+++++-----+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------------------------------------------------------------balance = 0실행 결과는 위와 같다. +(입금)가 맨 앞에서 실행한 모습을 볼 수 있다.(입금, 출금 횟수는 100번으로 줄였다.)만약, 입금, 출금, 입금, 출금, … 교대로 출력하도록 하려면 세마포를 두 개 사용하여 아래와 같이 구현할 수 있다.void deposit(int amount) {\ttry {\t\tsem.acquire();\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t\tsem.release();\t\tsemWithraw.release();\t\tsemDeposit.acquire();   // 입금후에는 반드시 출금을 해야 하므로 자신을 block한다.\t} catch (InterruptedException e) {}}void withdraw(int amount) {\ttry {\t\tsemWithraw.acquire();  // 입금보다 먼저 수행하는 것을 막는다.\t\tsem.acquire();\t} catch (InterruptedException e) {}\tint temp = balance - amount;\tSystem.out.print(\"-\");\tbalance = temp;\tsem.release();\tsemDeposit.release();  // 출금 수행이 완료되면 block되었던 입금 프로세스를 깨워준다.}int getBalance() {\treturn balance;}+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-balance = 0ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글세마포 사진Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-09-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-2.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-08-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-eb-8f-99-ea-b8-b0-ed-99-94-1-html": {
        "title": "08: 프로세스 동기화 Part 1",
        "tags": "OS, Synchronization, Critical Section Problem",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스 동기화가 발생하는 예시와 목적, 그리고 그것을 해결하기 위한 원칙에 대해 알아본다.1. 프로세스 동기화란?  하나의 자원을 한 순간에 하나의 프로세스(쓰레드)만이 이용하도록 제어하는 것1.1 배경현대 컴퓨터의 메모리에는 여러 프로세스가 존재하는데, 이러한 프로세스들이 하나의 공유 메모리나 또 다른 프로세스에 접근할 때는 매우 신중해야 한다. 이처럼 한 프로세스가 다른 프로세스에게 영향을 받거나 주는 프로세스를 Cooperating process라고 한다. 반대로 아무런 영향을 미치지 않는 독립적인 프로세스는 Independent process이다.현대 컴퓨터 환경에는 cooperating process가 훨씬 많이 존재하고, 이들은 서로 영향을 미치기 때문에 데이터나 흐름에 대한 동기화가 매우 중요하다. 프로세스 사이에 동기화를 하는 것을 프로세스 동기화(Process Synchronization) 라고 한다.(현재에는 대부분 쓰레드 기준으로 스위칭을 하므로, Thread synchronization으로 많이 불린다.)1.2 필요성대표적인 예로 기차표 예매가 있다. 어느 시간에 한 좌석의 기차표는 반드시 하나만 존재해야한다. 그런데 이를 예매하려는 사용자(프로세스)는 여러 명이다. 이 사용자들이 동시에 하나의 좌석 기차표를 구매하려고 하면 어떠한 일이 발생할까? 실제 환경에서는 당연하게도 동기화 문제를 해결한 시스템이므로 한 사람만이 기차표를 예매할 수 있을 것이다. 만약 동기화에 문제가 발생한다면 한 기차표를 여러 사람이 예매하는 불상사가 발생할 수 있다.1.3 목표프로세스 동기화는 여러 프로세스가 공유하는 자원의 일관성을 유지하는 것이다. 가령 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때 이 프로세스들의 순서를 정하여 데이터의 일관성을 유지시켜주어야 한다. 이 부분에 대한 자세한 목적은 아래의 예를 파악하며 문제를 인지한 후에 명확하게 재정의하겠다.2. Bank Account Problem(은행 계좌 문제)동기화의 필요성을 가장 잘 느낄 수 있는 은행 계좌 문제에 대해 알아본다.2.1 문제 설명동기화 문제 중에서 대표적인 은행 계좌 문제를 살펴보자. 은행에는 하나의 계좌에 입금, 출금을 할 수 있다. 여기서 계좌는 공유하는 자원이고, 입금과 출금은 각각 프로세스라고 볼 수 있다. 부모님이 자식에게 입금을 하고, 자식은 출금을 하는 상황을 자바로 구현한 코드는 아래와 같다.// 계좌class BankAccount {\tint balance;\tvoid deposit(int amount) {\t\tbalance = balance + amount;\t}\tvoid withdraw(int amount) {\t\tbalance = balance - amount;\t}\tint getBalance() {\t\treturn balance;\t}}입금, 출금, 잔액조회 함수를 멤버함수로 갖는 클래스를 구현한다.// 입금 프로세스class Parent extends Thread {\tBankAccount b;  // 생성자는 공유하는 계좌를 초기값으로 가진다.\tParent(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {   // run(): 쓰레드가 실제로 동작하는 부분(치환)\t\tfor (int i = 0; i &lt; 100; i++)\t\t  b.deposit(1000);\t}}멤버 변수로 계좌를 가지고, 이것을 생성할 때 인자로 받는 클래스이다. 해당 클래스에서 run()은 입금을 100번 수행한다.// 출금 프로세스class Child extends Thread {\tBankAccount b;  // 생성자는 공유하는 계좌를 초기값으로 가진다.\tChild(BankAccount b) {\t\tthis.b = b;\t}\tpublic void run() {\t\tfor (int i = 0; i &lt; 100; i++)\t\t  b.withdraw(1000);\t}}멤버 변수로 계좌를 가지고, 이것을 생성할 때 인자로 받는 클래스이다. 해당 클래스에서 run()은 출금을 100번 수행한다.// Test.javaclass Test {\tpublic static void main(String[] args) throws InterruptedException {\t\tBankAccount b = new BankAccount();\t\tParent p = new Parent(b);\t\tChild c = new Child(b);\t\tp.start();   // start(): 쓰레드를 실행하는 메서드\t\tc.start();\t\tp.join();    // join(): 쓰레드가 끝나기를 기다리는 메서드\t\tc.join();\t\tSystem.out.println(\"balance = \" + b.getBalance());\t}}main 함수에서는 위에서 만든 클래스들을 사용하여, 계좌를 공유하는 두 개의 쓰레드를 만든다. 그리고 부모, 자식 클래스에서 각각 입금과 출금을 100번씩 수행하고, 결과적으로 남은 잔액을 조회한다. 잔액은 0이 나와야 할 것이다.// Resultbalance = 0이 결과는 정상적이다. 100번 1,000원을 입금하고, 100번 1,000원을 출금하면 잔액은 0원이 남는다. 위 코드는 2개의 쓰레드가 동작하고 있음에도 불구하고 동기화 문제가 발생할 확률은 매우 낮다. 반복이 100번 밖에 안 일어나는 매우 간단한 코드 이기 때문이다.2.2 동기화 문제 발생실제 상황에서는, 입금, 출금 명령을 내리고 이 명령이 전달되는데 까지 시간이 소요된다. 그런 상황을 만들기 위해 출금하는 과정에서 temp라는 필요없는 변수를 추가하고, +,-를 출력하고, 반복 횟수를 1000번으로 늘렸다.// 계좌class BankAccount {\tint balance;\tvoid deposit(int amount) {\t\tint temp = balance + amount;\t\tSystem.out.print(\"+\");\t\tbalance = temp;\t}\tvoid withdraw(int amount) {\t\tint temp = balance - amount;\t\tSystem.out.print(\"-\");\t\tbalance = temp;\t}\tint getBalance() {\t\treturn balance;\t}}// Result++++++++++++++++++++++++++++++++++------------------------------------------------------------------------------------------------------------------------+++++++++----------------------------------------------++++++++++++++++++++++++++++++++----+++++++-+++++----+++--------------------------------------------------------+++++++-++++-+++++++++-------++++++++++++++++++++++++++++++++++++++++++++++++++++++++---------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-++++++++++++-------------------++++++++++++++++++++-++++++++++++++++++++++++++++++++-+-------------------------------------------------------------------------+++++++++++-+++++++----------------------------------------+-------+------------+------+------------------------------------------------------------------------+-------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------+-------+----------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------+--------------------------+-------------------------------------------------------------------------------++---------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++balance = 1000000+는 입금을 한 경우, -는 출금을 한 경우이고, 주목할 점은 balance값이 0이 아닌 1000000이라는 알 수 없는 값이 출력되었다. 또한 여러번 실행할 경우 100000이라는 값이 고정되어 출력되는 것도 아니다. 결과가 불일치하며, 비일관적이다. (비일관적인 이유는 운영체제에서 쓰레드를 스위칭하는 패턴이 매번 다르기 때문이다.)약간의 시간 지연을 준 것만으로도 여러 쓰레드가 하나의 공유 자원을 사용하는 프로그램은 망가지게 된다.2.3 왜 발생할까?이러한 문제가 발생하는 원인은 공통변수(common variable)에 대한 동시 업데이트(concurrent update) 때문이다.위 예제에서 공통 변수는 계좌의 잔액이다. 이에 접근하는 프로세스의 코드를 보면 다음과 같다.balance = balance + amount;   // 입금balance = balance - amount;   // 출금이는 자바 문법에서는 한 줄이라 문제가 없어 보이지만, 로우 레벨(어셈블리어)로 내려가면 여러 줄로 구현된다. 예를 들어, balance를 업데이트 하는 하이 레벨 코드 1줄이 로우 레벨에서 3줄로 구현된다고 하자.  공유 변수인 현재 잔액을 복사한다.  현재 잔액에서 명령을 수행한다.  나온 결과를 가지고 잔액을 갱신한다.그런데, parent가 수행하던 도중에 1000번을 다 수행하지 못한 상황에서 interrupt(이 경우에는 시간 지연을 걸었으므로 timer interrupt가 되겠다.)가 걸려 2번 라인에서 멈췄다고 생각해보자. parent가 1000원을 입금했지만, 업데이트가 되지 않아 여전히 현재 잔액은 0이다.이번에는 child가 부모님이 용돈을 넣은 줄 알고 신나서 돈을 뽑는 상황을 생각해보자. 잔액을 확인했더니, 아직 0이다. 그래서 child는 마이너스 통장을 통해 돈은 인출하고 현재 잔액은 -1000이 된다.따라서 이 경우, 입금과 인출이라는 행위는 프로세스 입장에서 원자성을 갖는 행위이므로 동기화가 필수적이다. 기억이 안난다면 이 글을 보자.가볍게 이해하는 컴퓨터 01: 용어 정리3. 임계구역(Critical section) 문제위의 예에서 보았던 문제를 임계구역 문제라 한다. 임계구역은 여러 개의 쓰레드가 수행되는 시스템에서 각 쓰레드들이 공유하는 데이터(변수, 테이블, 파일 등)를 변경하는 코드 영역을 말한다. 이는 동기화에서 중요한 문제 중 하나이다. 은행계좌 문제에서의 임계구역은 다음과 같다.void deposit(int amount) {  balance = balance + amount;}void withdraw(int amount) {  balance = balance - amount;}3.1 해결 방법임계구역을 해결하기 위해서는 3가지 조건이 만족해야한다.  Mutual exclusion(상호배타)          오직 한 쓰레드만이 진입 가능하다. 한 쓰레드가 임계구역에서 수행 중인 상태에서는 다른 쓰레드는 절대 이 구역에 접근할 수 없다.        Progress(진행)          한 임계구역에 접근하는 쓰레드를 결정하는 것은 유한 시간 이내에 이루어져야한다.      누가 먼저 들어갈 것인지 빠르게 결정해라        Bounded waiting(유한대기)          임계구역으로 진입하기 위해 대기하는 모든 쓰레드는 유한 시간 이내에 해당 임계구역으로 진입할 수 있어야 한다.      기다리는 모든 쓰레드가 진입가능하도록 만들어라.      4. 프로세스/쓰레드 동기화의 목적  원하는 결과값을 도출하도록 임계구역 문제를 해결한다.  프로세스의 실행 순서를 원하는대로 제어한다.  Busy wait 등과 같은 비효율성을 제거한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-08-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-07-ec-93-b0-eb-a0-88-eb-93-9c-html": {
        "title": "07: 쓰레드(Thread)",
        "tags": "OS, CPU, Thread",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "Thread에 대해서 알아본다.쓰레드(Thread)  쓰레드는 프로그램 내부의 흐름(맥)이다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void){  int n = 1;  int m = 10;  cout &lt;&lt; n * m;  while(n &lt; m)    n++;  cout &lt;&lt; \"end\" &lt;&lt; endl;}이런 코드는 하나의 흐름을 가지고 있고 이것을 쓰레드라 부른다. 일반적으로 하나의 프로그램은 하나의 쓰레드를 갖는다.다중 쓰레드(Mulitithreads)하나의 프로그램에 쓰레드가 2개 이상 존재하는 것을 다중 쓰레드라고 한다. 이렇게 한 프로그램에 여러 개의 쓰레드 즉, 흐름이 있을 수 있는 이유는 쓰레드가 빠른 시간 간격으로 스위칭되기 때문이다. 이러한 동작으로 사용자는 여러 쓰레드가 동시에 실행되는 것처럼 보인다.이 때, 동시에 수행되는 것 처럼 보이는 것을 concurrent, 실제 동시에 수행되는 것을 simultaneous라고 한다.  concurrent          CPU가 하나인 환경에서 스위칭에 의해 동시에 수행        simultaneous          여러개의 CPU 환경에서 실제로 동시에 수행되는 경우      예시다중 쓰레드를 사용하는 대표적인 예는 Web browser 이다. 화면을 출력하는 쓰레드와 데이터를 읽어오는 쓰레드가 기본적으로 따로 수행하고 있다. 그 외에도 Word processor, Media player 등 현재 대부분의 프로그램은 다중 쓰레드로 동작한다.현대 운영체제의 Switching 단위이전의 CPU 스케줄링에서 하나의 프로세스가 수행하다가 다른 프로세스로 넘어간다고 하였는데, 이는 예전의 방식이다. 현재 운영체제에서는 대부분 다중 쓰레드를 지원하기 때문에 하나의 프로세스 안에서 여러 쓰레드를 수행하다가 다른 프로세스로 넘어가서 그 프로세스의 쓰레드를 수행한다. 그러므로 현대 운영체제의 context switching 단위는 프로세스가 아닌 쓰레드 단위이다.Thread VS Precess이 부분을 제대로 이해하기 위해 process를 보고오자.가볍게 이해하는 컴퓨터 07: 운영 체제가 하는 일운영체제 정리 05: 프로세스 관리프로세스는 다른 프로세스와 완전히 독립적이다. 해당 프로세스가 가지는 구조로는 Code, Data, Heap, Stack이 있다. 이 때 쓰레드는 자기가 속한 프로세스의 일부 메모리를 공유한다. 집이라면 각 개인 구성원이 거실을 공유하는 셈이다.            공유      독립                  Code      Stack              Data      PC(program counter)              Heap      SP(stack pointer)                     Registers      Thread가 독립적 요소를 가져야 하는 이유현대 운영체제는 결국 Context Switching의 최소단위를 thread로 잡고 있기 때문이다. 결국 CPU가 처리하는 것은 thread이고, 그렇기 때문에 현재 실행 흐름을 독립적으로 기록할 필요가 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-07-%EC%93%B0%EB%A0%88%EB%93%9C.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-06-cpu-ec-8a-a4-ec-bc-80-ec-a5-b4-eb-a7-81-html": {
        "title": "06: CPU 스케쥴링",
        "tags": "OS, CPU, Scheduling",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "CPU 스케쥴링에 대해 알아본다.CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다. 이때 다음 프로세스가 어느 프로세스인지를 선택하는 알고리즘을 CPU Scheduling 알고리즘이라고 한다. 간단히 생각해보면 먼저 온 프로세스가 먼저 실행되는 것이 가장 좋을 것이라 생각할 수 있다. 하지만 여러 상황에서 사용되는 컴퓨터 환경에서 꼭 이러한 방법이 좋다고 할 수 없다. (단순한 환경에서도 이 방법이 반드시 빠른 것도 아니다.) 그러므로 CPU 스케줄링에는 여러가지 방법이 존재한다.1. 스케쥴링의 유형유형으로는 Preemptive 와 Non-preemptive가 있다.1.1 PreemptivePreemptive(선점)은 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생한 것도 아니고 모든 작업을 끝내지도 않았는데, 다른 프로세스가 해당 CPU를 강제로 점유 할 수 있다. 즉, 프로세스가 정상적으로 수행중인 가운데 다른 프로세스가 CPU를 강제로 점유하여 실행할 수 있는 것이다. 급똥 우선순위1.2 Non-preemptiveNon-preemptive(비선점)은 말 그대로 preemptive와 반대이다. 한 프로세스가 한 번 CPU를 점유했다면, I/O나 인터럽트 발생 또는 프로세스 종료가 될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다. 순서대로 들어가자2. Scheduling criteriaScheduling criteria(척도)는 스케줄링의 효율을 분석하는 기준들이다.  CPU Utilization(이용률, %)          CPU가 수행되는 비율        Throughput(처리율, jobs/sec)          단위시간당 처리하는 작업의 수(처리량)        Turnaround time(반환시간)          프로세스의 처음 시작 시간부터 모든 작업을 끝내고 종료하는데 걸린 시간이다.(CPU, waiting, I/O 등 모든 시간을 포함한다.) 반환시간은 짧을 수록 좋다.        Waiting time(대기시간)          CPU를 점유하기 위해서 ready queue에서 기다린 시간을 말한다.(다른 큐에서 대기한 시간은 제외한다.)        Response time(응답시간)          일반적으로 대화형 시스템에서 입력에 대한 반응 시간을 말한다. 사용자와의 상호작용을 중요로 하는 프로세스의 경우이다.      3. CPU Scheduling AlgorithmsCPU에서 프로세스의 순서를 처리하는 알고리즘에 대해 알아본다.3.1 First-Come, First-Served(FCFS)FCFS는 먼저 온 프로세스가 먼저 CPU를 점유하는 방식이다. 이는 매우 단순하고 많이 사용하는 방법이지만, 모든 부분에서 효율적인 것은 아니다.Gantt Chart            Process      Burst Time(msec)                  P1      24              P2      3              P3      3      위의 표를 아래의 그림으로 나타낸 것을 Gantt Chart라 한다. P1, P2, P3 순으로 메모리에 도착했다고 가정했을 때, P1, P2, P3의 총 대기시간의 평균을 구해보자.  Average Waiting Time = ${0+24+27\\over 3} = 17msec$ 이다.그런데 만약 P3, P2, P1 순으로 들어왔다고 생각해보자.  Average Waiting Time = ${6+3+0\\over 3} = 3msec$ 이다.두 예제에서 모든 프로세스가 끝난 시간은 30msec로 같지만, 평균 대기시간으로 봤을 때는 위의 예제는 17msec이고 아래는 3msec로 차이가 난다. 즉, 들어온 순서로 수행한다고 해도 반드시 효율적인 것은 아닌 것을 알 수 있다.이것은 공중화장실을 기다리는 맨날 더럽냐 3명의 사람으로 치환해서 생각할 수 있다. 빠른 맺고 끊음이 가능한 선수가 먼저 입장하는 것이 공공의 이익을 최대화 할 수 있다. 응?위 예제처럼 P1, P2, P3 순서로 들어와 시간이 오래 걸리는 현상을 Convoy Effect 라고 한다. 이는 CPU 시간을 오래 사용하는 프로세스가 먼저 수행하는 동안 나머지 프로세스들은 그 만큼 오래 기다리는 것을 말한다.FCFS의 특징 정리  Convoy Effect가 발생할 수 있다.  Non-preemptive 방식이다. 하나의 프로세스가 끝나기 전에 다른 프로세스가 끼어들 수 없다.3.2 Shortest-Job-First(SJF)SJF는 이름에서도 나타나듯이 가장 짧게 수행되는 프로세스가 가장 먼저 수행되는 것을 말한다. FCFS에서 보았듯이 수행 시간이 짧은 프로세스가 먼저 오는 것이 평균 대기시간이 짧은 것을 알 수 있었다. 이를 이용한 것이 SJF이다.            Process      Burst Time(msec)                  P1      6              P2      8              P3      7              P4      3        Average Waiting Time(AWT) = ${3+16+9+0\\over 4} = 7msec$ 이다.위의 예를 FCFS로 나타냈을 때 평균 대기시간을 계산해보자.  Average Waiting Time(AWT) = ${0+6+14+21\\over 4} = 10.25msec$ 이다.SJF와 FCFS의 평균 대기시간을 살펴보면 당연히 SJF가 더 짧은 것을 볼 수 있다. SJF가 평균 대기시간 기준으로 어떠한 방법보다 짧은 것은 이미 수학적으로 증명되어 있다. 그러므로 어떠한 예제를 보더라도 SJF가 AWT는 가장 짧다.한계이를 보면 SJF가 가장 효율적인 CPU 스케줄링 방법으로 이를 쓰면 될 것 같지만, 사실은 이 스케줄링 방법은 매우 비현실적이다. 왜냐하면 현실적인 컴퓨터 환경에서는 프로세스의 CPU 점유 시간(burst time)을 알 수 없다. 왜냐하면 한 프로세스가 실행 중에는 많은 변수가 존재하기 때문에 CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수 밖에 없다. 실제 측정한 시간으로 예측해서 SJF를 사용할 수도 있지만, 이는 오버헤드가 매우 큰 작업으로 잘 사용되지 않는다.Preemptive &amp; non-preemptive 방식            Process      Arrival Time      Burst Time(msec)                  P1      0      8              P2      1      4              P3      2      9              P4      3      6      non-preemptive가장 먼저 도착한 P1이 수행되는 동안 P2, P3, P4 모두 도착하지만, non-preemptive이므로 이미 수행중인 프로세스가 끝날 때까지 기다려야 한다. 일단 시작한 놈은 그대로 하고 남은 놈들에 대해서 대기시간이 짧은 것에 우선순위를 주자.  Average Waiting Time(AWT) = ${0+7+15+9\\over 4} = 7.75msec$ 이다.​Preemptive이번에는 p]Preemptive이므로 프로세스가 도착할 때마다, 어느 프로세스가 가장 짧은 것인지 선택해야 한다. 주목할 점은 P2 프로세스가 도착했을 때, 현재 남은 burst time 중 가장 짧은 프로세스가 P2이므로 P1을 수행하던 것을 멈추고 P2가 수행을 시작한다.  Average Waiting Time(AWT) = ${9+0+15+2\\over 4} = 6.5msec$ 이다.Preemptive SJF는 예제에서 살펴보았듯이 현재 남아있는 시간 중 가장 짧은 프로세스를 선택하므로 Shortest-Remaining-Time-First(최소잔여시간 우선) 이라 불리기도 한다.SJF의 특징 정리  AWT가 가장 짧다.  프로세스의 실행 시간을 알 수 없기 때문에 비현실적이다. 이를 가능케 하기 쉬해서는 예측이 필요하다.  Preemptive &amp; non-preemptive 둘다 가능하다.          이 중 Preemptive SJF는 Shortest-Remaining-Time-First(최소잔여시간 우선)이라 불린다.      3.3 PriorityPriority 스케줄링은 말그대로 우선순위가 높은 프로세스가 먼저 선택되는 스케줄링 알고리즘이다. 운영체제에서 일반적으로 우선순위는 정수값으로 나타내며, 작은 값이 우선순위가 높다.(Unix/Linux 기준)돈 주며 화장실 앞 줄을 사는 행위            Process      Burst Time(msec)      Priority                  P1      10      3              P2      1      1              P3      2      4              P4      1      5              P5      5      2      표에서 우선순위 값이 가장 낮은 순서대로 수행한 모습을 간트 차트로 나타내었다.  Average Waiting Time(AWT) = ${6+0+16+18+1\\over 5} = 8.2msec$ 이다.우선 순위를 정하는 방법우선순위를 정하는 방법은 크게 내부적인 요소와 외부적인 요소 두 가지로 나뉜다.  Internal          time limit, memory requirement, I/O to CPU burst(I/O작업은 길고, CPU 작업은 짧은 프로세스 우선) 등        External          amount of funds being paid, political factors 등      Priority 스케줄링 역시 preemprive 와 non-preemptive 두 방식 모두 사용할 수 있다.한계Priority 스케줄링의 문제점은 Starvation(기아)이 있다. 못 싸는 놈은 평생 못싸 ㅠㅠ Starvation은 말 그대로 CPU의 점유를 오랫동안 하지 못하는 현상을 말한다. Priority 스케줄링 방식에서 우선순위가 매우 낮은 프로세스가 ready queue에서 대기하고 있다고 가정해보자. 이 프로세스는 아무리 오래 기다려도 CPU를 점유하지 못할 가능성이 매우 크다. 실제 컴퓨터 환경에서는 새로운 프로세스가 자주 ready queue에 들어온다. 이러한 프로세스가 모두 우선순위가 높은 상태라면 이미 기다리고 있던 우선순위가 낮은 프로세스는 하염없이 기다리고만 있는 상태로 남아있을 수 있다.해결 방법이를 해결하는 방법 중 하나는 aging이 있다. 이 방식은 ready queue에서 기다리는 동안 일정 시간이 지나면 우선순위를 일정량 높여주는 것이다. 복지 그러면 우선순위가 매우 낮은 프로세스라 하더라도, 기다리는 시간이 길어질수록 우선순위도 계속 높아지므로 수행될 가능성이 커진다.Priority의 특징 정리  우선 순위가 높은 녀석 부터 처리  그렇기 때문에 평생 처리 못받는 녀석이 생긴다. (Starvation)  이를 방지 하기 위해 Ready 상태에서 일정시간이 지나면 우선 순위를 높여준다. (aging)3.4 Round-Robin(RR)Round-Robin은 원 모양으로 모든 프로세스가 돌아가며 스케줄링하는 것을 말한다. 이는 시분할 시스템에서 주로 사용하는 방식이다. 일정 시간을 정하여 하나의 프로세스가 이 시간동안 수행하고 다시 대기 상태로 돌아간다. 그리고 다음 프로세스가 역시 같은 시간동안 수행한 후 대기한다. 이러한 작업을 모든 프로세스가 돌아가면서 하며, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아와서 반복한다.위에서 말한 일정 시간을 Time Quantum(Time Slice)이라 부른다. Time Quantum은 일반적으로 10 ~ 100msec 사이의 범위를 갖는다. Round-Robin은 기본적으로 preemptive 이다. 한 프로세스가 종료되기 전에 time quantum이 끝나면 다른 프로세스로 CPU를 넘겨주기 때문이다.            Process      Burst Time(msec)                  P1      24              P2      3              P3      3      time Quantum = 4msecRound-Robin 방식에서는 time quantum이 끝나면 CPU는 현재 프로세스를 대기상태로 보내고 다음 프로세스를 수행한다. 예제에서 P1이 0msec에 수행을 시작하여 종료되기 전에 time quantum 시간이 끝나여 P2가 수행되는 모습을 볼 수 있다. 그리고 P2, P3는 time quantum이 끝나기전에 수행이 끝났고, 마지막 남은 P1은 다른 프로세스가 없으므로 time quantum이 끝나더라도 종료될 때까지 계속해서 수행하는 모습이다.  Average Waiting Time(AWT) = ${6+4+7\\over 3} = 5.66msec$ 이다.한계RR방식은 time quantum 크기에 따라 AWT와 같은 스케줄링 척도가 바뀐다. 그러므로 RR 방식은 time quantum에 매우 의존적인 것을 알 수 있다.만약 time quantum 크기가 무한에 가깝게 설정한다면 FCFS와 동일하게 동작한다. 반대로 time quantum 크기를 0에 가깝게 설정하면 switching overhead가 매우 증가하여 비효율적이다. 결과적으로 time quantum 은 적당한 크기로 설정해주어야 하는데, 일반적으로 위에서 말했듯이 10 ~ 100msec 으로 정한다.RR의 특징 정리  모든 프로세스에 일정한 시간(time quantum)을 주어서 관리한다.  따라서 time quantum에 매우 의존적이다. 적당한 값(10 ~ 100msec)이 중요하다.          $\\infty$ ~ FCFS      $0$ ~ switching overhead가 매우 증가      3.5 Multilevel QueueMultilevel Queue를 살펴보기 전에 프로세스 그룹에 대해 살펴보자. 프로세스는 기준에 따라 여러 그룹으로 나눌 수 있다.  System processes          운영체제 커널 수준의 프로세스        Interactive processes          유저 수준의 대화형 프로세스 (게임)        Interactive editing processes          Word Processor        Batch processes          대화형 프로세스의 반대인 것으로 일정량을 한 번에 처리하는 프로세스(Ex, 컴파일러)        Student processes위와 같이 여러 성격에 따라 프로세스 그룹을 나눌 수 있는데 이를 하나의 큐에 사용하는 것은 비효율적이라고 판단하였다. 그래서 각 그룹에 따라 큐를 두어 여러 개의 큐를 사용하는 것이 Muitilevel Queue 방식이다.위 그림은 각 그룹에 따라 큐를 나눈 것이다. 그리고 각 큐마다 다른 규칙을 지정할 수도 있다.먼저, 큐마다 우선순위를 지정해줄 수 있다. 프로세스 그룹을 보면 System process는 커널 수준에서 중요한 작업이므로 우선순위가 높은 그룹이라 볼 수 있다. 위 그림에서 System process, Interactive process, Batch process 순으로 우선순위가 높은 순서이다. Batch 프로세스는 운영체제의 개입이 매우 적으므로 우선순위가 가장 낮다고 볼 수 있다.위의 방식 이외에도 큐에 따라 여러 기준을 둘 수 있다. 큐마다 CPU 시간을 다르게 줄 수도 있고, 큐마다 다른 스케줄링 방식을 사용할 수도 있다.Multilevel Queue의 특징  프로세스를 그룹으로 나눈다.  각각의 Queue에 절대적 우선 순위가 존재한다.  CPU time을 Queue에 차등 배분한다.  각 Queue는 독립된 scheduling 정책을 갖는다.3.6 Multilevel Feedback QueueMultilevel Feedback Queue도 Multilevel Queue와 같이 여러 개의 큐를 사용한다는 점에서 유사하다.위 그림을 보면 먼저 모든 프로세스는 가장 위의 큐에서 CPU의 점유를 대기한다. 이 상태로 진행하다가 이 큐에서 기다리는 시간이 너무 오래 걸린다면 아래의 큐로 프로세스를 옮긴다. 이와 같은 방식으로 대기 시간을 조정할 수 있다. 그리고 Multilevel Feedback Queue에서도 각 큐마다 다른 스케줄링, 다른 우선순위 등을 사용할 수 있다.만약 우선순위순으로 큐를 사용하는 상황에서 우선순위가 낮은 아래의 큐에 있는 프로세스에서 starvation 상태가 발생하면 이를 우선순위가 높은 위의 큐로 옮길 수도 있다.대부분의 상용 운영체제는 여러 개의 큐를 사용하고 각 큐마다 다른 스케줄링 방식을 사용한다. 프로세스의 성격에 맞는 스케줄링 방식을 사용하여 최대한 효율을 높일 수 있는 방법을 선택한다.Multilevel Feedback Queue의 특징  여러개의 Queue를 가진다.  다른 Queue로 점진적 이동한다.          모든 프로세스는 각자의 하나의 Queue로 진입한다.      너무 많은 CPU time 사용시 다른 Queue로 이동한다.      기아 상태 우려시 우선 순위 높은 Queue로 이동한다.      ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-06-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81.html"
      }
      ,
    
      "cs-os-2020-04-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-05-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ed-94-84-eb-a1-9c-ec-84-b8-ec-8a-a4-ea-b4-80-eb-a6-ac-html": {
        "title": "05: 프로세스와 관리",
        "tags": "OS, process, 메모리 구조, 프로세스 구조",
        "date": "April 1, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "프로세스의 정의, CPU 스케쥴러, 멀티 프로그래밍에 대해 알아본다.1. 프로세스(Process)프로세스는 메인 메모리에 할당되어 실행중인 상태인 프로그램을 말한다. 프로그램은 일반적으로 하드디스크(보조기억장치)에 저장되어 아무 일도 하지 않는 상태이다. 프로세스는 실행하면서 stack pointer, data, text, register 등이 끊임없이 변한다. 프로세스는 job, task 등으로 불리기도 한다.1.1 프로세스의 생성과 종료프로세스는 프로세스에 의해 만들어진다. 컴퓨터가 부팅이 되면 운영체제가 메모리에 올라오는데 운영체제가 처음으로 수행하는 일 중에 하나는 최초의 프로세스를 생성하는 것이다. 이렇게 처음 만들어진 프로세스가 다른 프로세스를 만들고 그 프로세스가 또 다른 프로세스를 만드는 과정을 반복한다.위와 같이 최초의 프로세스는 Init이다. 이 이름은 운영체제마다 다르고, init은 UNIX 운영체제 기준 이름이다. 여기서 여러 다른 프로세스들이 생성되면 위와 같은 그림처럼 트리 모양으로 나타낼 수 있다.여기서 프로세스를 생성한 쪽을 부모 프로세스, 만들어진 프로세스를 자식 프로세스라고 한다. 같은 부모를 갖는 자식 프로세스 끼리는 서로 Sibling(형제) 프로세스라고 한다.프로세스는 각각 고유의 번호를 갖는데 이를 PID(Process Identifirer)라고 한다. PID는 일반적으로 정수형(integer)으로 표현한다. PPID는 부모의 PID를 말한다.1.1.1 프로세스 생성새로운 프로세스를 만드는 시스템 콜이 존재하는데, 이는 fork() 라 한다. 만들어진 프로세스에서 어떠한 파일을 실행하려면 exec() 시스템 콜을 사용한다.1.1.2 프로세스 종료프로세스를 종료하는 시스템 콜은 exit() 이다. 한 프로세스가 종료되면 해당 프로세스가 사용한 모든 자원(메모리, 파일, I/O 등)을 회수해야한다. 이러한 회수된 자원과 권한은 모두 운영체제로 되돌아가야한다.1.2 프로세스의 구조출처 : https://mintnlatte.tistory.com/출처 : https://rookieboxsite.wordpress.com1.2.1 Stack  프로그램의 지역 변수, 함수, return 주소를 포함한다.  함수 호출을 하면 해당 주소가 스택영역에 저장되어 있다가 return하면 pop된다.1.2.2 Heap  힙 영역에는 프로그램이 실행되는 동안 동적으로 사용할 데이터들이 저장된다.  c언어의 malloc을 이용해서 메모리를 동적할당하면 힙 영역에 저장된다.(free시키지 않으면 힙 영역에 계속 들어 있음)1.2.3 Data  데이터 영역에는 전역 변수와 정적 지역 변수가 포함되어 있다.데이터 영역은 BSS, Data로 나눠진다.  BSS는 초기화 되지 않은 변수들이 저장초기화 된 변수들이 저장된 영역으로 0으로 자동 초기화해 준다.  Data는 초기값을 설정한 전역 변수와 정적 변수를 위한 영역이다.BSS,Data로 구분하는 이유?  초기화 된 데이터는 초기값을 저장해야 함으로 Data영역에 저장되서 Rom에 저장된다. 하지만 초기화 되지 않은 데이터 까지 Rom에 저장되면 큰 size의 rom이 필요하므로 구분한다 ( 초기화 되지 않은 데이터는 ram에 저장하자)1.2.4 Text  해당 코드가 저장되는 영역이다.  힙과 ,스택영역에서 오버플로우가 발생할 것을 대비해서 힙/스택의 아래부분에 위치한다.  실행 순서등이 저장되어 있다.  읽기 전용이다.  다른 프로세스에서 참조 가능하다.1.2.5 정리            크기 변화      O      X                         Stack      Text                     Heap      Data                            Bss        Text          Program Counter(다음번에 실행될 명령어의 주소를 저장하는 레지스터 : CPU에게 줄 예정)      프로그램 코드        Data          전역 변수 저장      스태틱 변수 저장        Heap          메모리 관리      동적 메모리 할당 (system call로 관리)      메모리에 접근하기 때문에 주의해야 함        Stack          임시 데이터 저장      지역 변수      반환 주소      1.3 프로세스 상태  New: 프로그램이 메인 메모리에 할당된다.  Ready: 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친다.  Running: CPU가 해당 프로세스를 실행한다.  Waiting: 프로세스가 끝나지 않은 시점에서 I/O로 인해 CPU를 사용하지 않고 다른 작업을 한다. (해당 작업이 끝나면 다시 CPU에 의해 실행되기 위해 ready 상태로 돌아가야 한다.)  Terminated: 프로세스가 완전히 종료된다.위 그림은 프로세스 상태 전이도의 모습이다. new에서부터 프로세스가 어떤 작업에 의해 상태가 변하는지 나타낸다. running에서 ready로 변할 때는 time sharing system에서 해당 프로세스가 CPU시간을 모두 소진하였을 때 인터럽트에 의해 강제로 ready상태로 변하고, CPU는 다른 프로세스를 실행시킨다.1.4 PCB(Process Control Block)PCB는 프로세스에 대한 모든 정보가 모여있는 곳으로, Task Control Block(TCB) 이라고도 한다. PCB안에는 프로세스의 상태, 프로세스 번호(PID), 해당 프로세스의 program counter(pc), register값, MMU(Memory Management Unit)정보, CPU점유 시간 등이 포함되어 있다. PCB는 운영체제 내부의 프로세스를 관리하는 코드 부분에 저장되어 있다.CPU는 한 프로세스가 종료될 때까지 수행하는 것이 아니라 여러 프로세스를 중간 중간에 바꿔가면서 수행한다. 그러므로 CPU는 수행중인 프로세스를 나갈 때, 이 프로세스의 정보를 어딘가에 저장하고 있어야 다음에 이 프로세스를 수행할 때 이전에 수행한 그 다음부터 이어서 작업할 수 있다. 이러한 정보를 저장하는 곳이 PCB이다.1.5 프로세스 큐(Queue)프로세스의 생애 주기를 생각해보면, DISK, Memory, cpu등을 거치게 된다. 갈수록 좁아지는 공간과, 한정된 자원 때문에 병목현상이 발생할 수 밖에 없다. 그렇기 때문에 우리는 먼저 실행된 프로세스와 같은 규칙에 따라 이 프로세스들을 줄세워 관리해야 한다. 이러한 순서를 Queue로 관리한다.  Job Queue: 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐이다.  Ready Queue: CPU 점유 순서를 기다리는 큐이다.  Device Queue: I/O를 하기 위한 여러 장치가 있는데, 각 장치를 기다리는 큐가 각각 존재한다.Scheduling(스케쥴링)위와 같이 여러 큐가 존재하는데, 각 큐 내부에 저장된 실제 데이터는 각 프로세스의 PCB가 저장되어 있다. 그리고 이러한 순서를 기다리는 공간이 있다면 이 순서를 정해주는 알고리즘이 있어야 한다. 이러한 알고리즘을 스케줄링(Scheduling)이라 한다.  Job Queue - Job Scheduler(Long-term scheduler)  Ready Queue - CPU Scheduler(Short-term scheduler)  Device Queue - Device SchedulerJob queue의 순서를 정해주는 job scheduler를 long-term scheduler라고도 하는데, 이는 이 스케줄링이 발생하는 시간이 비교적 오래걸리기 때문이다.(대략 초~분) 반면에 ready queue의 스케줄러를 short-term scheduler라고도 하는데, 이는 스케줄링이 발생하는 시간이 매우 짧기 때문이다. CPU scheduling은 말 그대로 프로세스가 CPU를 점유하는 순서를 정해주는데 이는 매우 빠른 시간안에 이루어져야한다. 현대 컴퓨터가 여러 프로그램을 동시에 사용하는 것과 같은 효과를 주는 이유가 이 스케줄링 속도가 매우 빠르게 이루어지기 때문이다.2. 멀티 프로그래밍멀티프로그래밍은 단일 프로세서(CPU) 환경에서 메모리에 다수의 프로세서들을 올려둔 상태로, CPU가 쉬는 동안 다른 프로세서에게 CPU자원을 할당하여 동시에 실행하는 것처럼 보이게 하는 방법이다. 이에 관한 용어에 대해 정리해 보자.2.1 Degree of multiprogrammingDegree of multiprogramming 는 현재 메모리에 할당되어 있는 프로세스 개수를 말한다.2.2. I/O bound process VS CPU bound process프로세스는 I/O bound process 와 CPU bound process 로 나뉜다.  I/O bound process: 해당 프로세스에서 I/O(입출력) 작업이 차지는 비중이 높은 프로세스를 말한다.          Word processor            CPU bound process: 해당 프로세스에서 CPU 작업(계산)이 차지는 비중이 높은 프로세스를 말한다.          Super computer      운영체제, 정확히 말하면 job scheduler 는 이러한 프로세서의 특징을 감안하여 I/O bound process와 CPU bound process를 적절히 분배해서 메모리에 할당해주어야 한다.2.3 Medium-term schedulerMedium-term scheduler는 말그대로 short-term보다는 덜 발생하지만, long-term보다는 자주 발생하는 scheduler이다. 하는 일은 운영체제가 실행하는 동안 주기적으로 메인 메모리에 있는 전체 프로세스를 검사하여 직접적으로 CPU와 일을 하지 않는 프로세스를 찾아 보조기억장치로 옮기는 것이다. 옮기는 기준은 여러가지 있겠지만 대표적으로 장기간 사용하지 않는 프로세스가 있다.Swapping일하지 않는 프로세스를 쫒아내는 행위를 Swapping이라 부르는데, 이는 메인 메모리에서 장시간 사용하지 않는 프로세스를 하드디스크(Swap device = Backing store, 일반적으로 하드디스크는 File system + Backing store 로 구성되어 있다.)로 옮겨주고(Swap out ), 나중에 이 프로세스가 다시 사용되려고 하면 하드디스크에서 해당 프로세스를 다시 메인 메모리에 할당해준다.(Swap in)Swap out을 통해 메인 메모리의 공간이 생기므로 이를 더욱 효율적으로 사용할 수 있다. 만약 swap out된 프로세스가 다시 swap in으로 메인 메모리에 할당하려고 할 때 이전의 공간으로 할당되는 것을 보장하지는 않는다. 왜냐하면 위에 말했듯이 swap out으로 생긴 메모리 공간은 다른 프로세스가 사용할 수 있기 때문이다.2.4 Context Switching(문맥 전환)Context switching은 CPU가 한 프로세스에서 다른 프로세스로 옮겨가는 것을 말한다. 즉, 한 프로세스가 실행중인 것을 멈추고 다른 프로세스가 실행되는 것이다.  Scheduler          여기서 스케줄러는 CPU Scheduler를 말하며, CPU가 어느 프로세스를 선택할지 정한다.        Dispatcher          실제 context switching이 발생하면 CPU의 내부 데이터를 새로 시작되는 데이터로 바꿔준다. 이 과정에서 현재 실행하고 있는 프로세스의 PCB에 현재까지 작업과정으로 갱신하고, 새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원(Restore)하는 작업을 한다.        Context switching overhead          Context switching이 발생할 때마다, dispatcher에서 수행하는 작업을 매번 수행해야하며 이 모든 것은 overhead(부담)이다. 그리고 문맥 전환은 매우 자주 발생하는 작업이므로 overhead를 줄이기 위해서는 dispatcher를 구현하는 코드에 대한 효율을 최대한 높여주어야한다.      ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글프로세스의 구조Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/04/01/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-05-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC.html"
      }
      ,
    
      "cs-algorithm-2020-03-31-eb-b0-b1-ec-a4-80-ed-9a-a8-ec-9c-a8-ec-a0-81-ec-9d-b8-ed-95-b4-ed-82-b9-html": {
        "title": "백준(1325번): 효율적인 해킹",
        "tags": "백준, 알고리즘, DFS, BFS, Graph",
        "date": "March 31, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 그래프 문제이다.생각아.. 정말 쉽겠지 했는데, 되지도 않는 시간 복잡도 줄여보겠다고 확인 되지 않는 것 썼다가 하루 다 날린 문제이다. 문제는 상당히 간단하게 DFS로 풀 수 있다. 그런데, N이 10000개 이고 M이 100000이기에 이 것을 배열로 무식하게 만들 수는 없고 vector를 사용하여 데이터를 저장해야 한다.input5 43 13 24 35 3            컴퓨터      연결된      컴퓨터                  1      3                     2      3                     3      4      5              4                            5                    이런식으로 모양을 맞춘 뒤에, 1번에 들어가서 연결된 컴퓨터를 따라 DFS를 적용하면서 연결된 선을 하나씩 늘려주면 된다. 시간 복잡도는 $O(NM)$ 이다.나는 여기서 괜히 1번을 탐색할 때, 3번을 탐색하게 되므로, 3번의 탐색 결과를 배열에 저장해 둔 뒤, 2번 컴퓨터를 탐색할 때 이 정보를 가져다가 사용했다. 하지만 어떠한 반례가 존재했고 계속 틀렸다..(하아)아마 루프가 생기는 시점에 숫자가 다르게 적힐 것 같다는 생각이 든다. 그래서 그냥 무식하게 하면 된다. 무식한게 최고다 루프가 생길 수 있기 때문에 컴퓨터 한대를 탐색할 때 왔던 경로인지 체크해주는 배열이 필요하다.Code#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int N, M;vector&lt;vector&lt;int&gt;&gt; map;int hack[10001] = {0};bool checkVisit[10001] = {0};int maxNumber = -1;int ans = 0;void go(int start){    checkVisit[start] = true;    int size = int(map[start].size());    if (size == 0) return;    for (int i = 0; i &lt; size; i++) {        int nowNum = map[start][i];        if (!checkVisit[nowNum]) {            ans++;            go(nowNum);        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N &gt;&gt; M;    for (int i = 0; i &lt;= N; i++) {        vector&lt;int&gt; temp;        map.push_back(temp);    }    for (int i = 0; i &lt; M; i++) {        int end, start;        cin &gt;&gt; end &gt;&gt; start;        map[start].push_back(end);    }    for (int i = 1; i &lt;= N; i++) {        ans = 0;        fill(&amp;checkVisit[0], &amp;checkVisit[N+1], 0);        go(i);        hack[i] = ans;        maxNumber = max(maxNumber, ans);    }    for (int i = 1; i &lt;= N; i++) {        if (hack[i] == maxNumber) cout &lt;&lt; i &lt;&lt; \" \";    }    return 0;}Reference백준(1325번) - 효율적인 해킹",
        
        "url": "/cs/algorithm/2020/03/31/%EB%B0%B1%EC%A4%80-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%95%B4%ED%82%B9.html"
      }
      ,
    
      "cs-algorithm-2020-03-31-eb-b0-b1-ec-a4-80-ed-96-89-eb-a0-ac-ea-b3-b1-ec-85-88-html": {
        "title": "백준(10830번): 행렬 곱셈",
        "tags": "백준, 알고리즘, 분할정복",
        "date": "March 31, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 분할 정복 문제이다.생각특정 행렬을 10번 곱하라는 의미는, 곧 이렇게 해석 된다.결국, 10이라는 숫자가 들어왔을 때, 2로 나누어지면 A를 제곱하고 ans에 업데이트, 나누어지지 않으면 A를 한번 곱하고, A제곱을 곱하여 업데이트 한다.typedef vector&lt;vector&lt;int&gt;&gt; matrix;matrix operator * (const matrix &amp;a, const matrix &amp;b) {    int n = int(a.size());    matrix ans(n, vector&lt;int&gt;(n));    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            for (int k = 0; k &lt; n; k++) {                ans[i][j] += a[i][k] * b[k][j];            }            ans[i][j] %= 1000;        }    }    return ans;}matrix go(matrix a, long long b){    int n = int(a.size());    matrix ans(n, vector&lt;int&gt;(n));    if (b == 0) return ans;    if (b % 2) ans = ans * a;    return ans * go(a*a, b/2);}int main(){    int n;    long long b;    cin &gt;&gt; n &gt;&gt; b;    matrix a(n, vector&lt;int&gt;(n));    for (int i = 0; i &lt; n; i++)        for (int j = 0; j &lt; n; j++)            cin &gt;&gt; a[i][j];    matrix ans == calc(a, b);    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            cout &lt;&lt; ans[i][j] &lt;&lt; ' ';        }cout &lt;&lt; '\\n';    }}Reference백준(10830번) - 행렬 곱셈",
        
        "url": "/cs/algorithm/2020/03/31/%EB%B0%B1%EC%A4%80-%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88.html"
      }
      ,
    
      "cs-algorithm-2020-03-31-eb-b0-b1-ec-a4-80-rgb-ea-b1-b0-eb-a6-ac-html": {
        "title": "백준(1149번): RGB 거리",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "March 31, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : 동적계획법 문제이다.생각동적 계획법하면 유명한 문제이다. 나는 동적 계획법을 풀 때 보통 두가지 방법을 많이 사용한다.  상태에 대한 정의와 점화식을 직관으로 때린다. (감..)  순차적으로 완전 탐색 방법으로 그려본다.문제가 잘 안보이면 2번 방법을 선택하는데, 이 문제를 그려보면 다음과 같다.            1      2                  ~~R~~                     G      R              B                     R                     ~~G~~      G              B                     R                     G      B              ~~B~~             1번 집에서 2번 집으로 넘어갈 때, 2번 집의 선택에 따라 1번집의 선택은 2번 집에서 선택한 색을 제외한 두가지 색으로 정해진다. 여기서 Dp의 정의 방법의 특징이 드러나는데, 사실 나는 처음 생각할 때, 1번이 선택을 하고, 2번이 어떻게 바뀌는 지를 생각했다. 하지만 그렇게 코드를 짤 경우 굉장히 귀찮고 어렵다는 것을 깨달았다. dp의 정의는 해당 위치까지에 어떤 의미를 주는 것이 문제를 풀이할 때 훨씬 수월하다. 이것은 수열에서 일반항의 정의와 비슷하다.정의  dp[N][color] = N번 집에 color를 칠했을 때 발생하는 최소 값color 변수를 추가한 이유는, 해당 집에 어떤 색을 칠하냐에 따른 가격을 마지막에 최종적으로 비교해주기 위함이다.점화식  dp[N][color1] = min(dp[N-1][color2], dp[N-1][color3]) + cost[i][color1]color2, color3는 color1이외의 두 색을 의미한다.Code#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;int cost[1001][3];int dp[1001][3] = {0};int main(){    cin &gt;&gt; N;    for (int i = 1; i &lt;= N; i++)        for (int j = 0; j &lt; 3; j++)            cin &gt;&gt; cost[i][j];    // 초기값 세팅    for (int i = 0; i &lt; 3; i++) dp[1][i] = cost[1][i];    // dp    for (int i = 2; i &lt;= N; i++)        for (int j = 0; j &lt; 3; j++)            dp[i][j] = min(dp[i-1][(j+1)%3], dp[i-1][(j+2)%3])+cost[i][j];    // 최종적인 최소값    cout &lt;&lt; *min_element(&amp;dp[N][0], &amp;dp[N][3]) &lt;&lt; '\\n';    return 0;}Reference백준(1149번) - 이친수",
        
        "url": "/cs/algorithm/2020/03/31/%EB%B0%B1%EC%A4%80-RGB%EA%B1%B0%EB%A6%AC.html"
      }
      ,
    
      "dv-html-css-2020-03-30-margin-ea-b2-b9-ec-b9-a8-html": {
        "title": "margin 겹침 현상",
        "tags": "css, margin",
        "date": "March 30, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "css를 먹일 때 요소들이 붙어있는 경우 margin을 주었지만 먹히지 않을 때 해결방법을 알아본다.이 문제는 margin이 겹칠 경우 작은 값을 가지는 요소의 margin을 무시하는 것이다.요소에 display: inline-block;을 걸어주면 된다..class {  display: inline-block;}",
        
        "url": "/dv/html-css/2020/03/30/margin-%EA%B2%B9%EC%B9%A8.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-04-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-84-9c-eb-b9-84-ec-8a-a4-html": {
        "title": "04: 운영체제 서비스",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제의 주요 서비스: 프로세스, 메모리, 파일관리, 시스템 호출에 대해 알아본다.운영체제의 주요 서비스는 하드웨어 자원을 각 사용자 애플리케이션에 적절히 분배해주는 것이다. 하드웨어 자원은 CPU, 메인 메모리, 하드디스크, 키보드, 마우스, 프린터 등이 존재한다. 이러한 하드웨어 자원을 사용자 애플리케이션이 요구하거나 운영체제 내의 규칙에 의해 적절히 분배하여 컴퓨터의 성능을 최대한 효율적으로 사용해야 한다.이를 실현하기 위해 운영체제 내에서는 각 하드웨어를 관리하는 기능을 다음과 같이 나눈다.  프로세스 관리  주기억장치 관리  파일 관리  보조기억장치 관리  입출력 장치 관리  네트워킹  보호  기타…1. 프로세스 관리(Process management)프로세스 관리는 운영체제 기능 중 가장 중요한 기능 중 하나이다. 프로세스와 프로그램은 기본적으로 구분된다. 프로세스는 실제 메인 메모리에서 실행 중인 프로그램(program in execution)을 말한다. 프로그램은 하드디스크와 같은 보조기억장치에서 아무런 동작을 하지 않는 상태이다. 이를 어떠한 요청에 의해 메인 메모리에 할당하여 CPU를 사용하면서 실행하게 되는데 이를 프로세스라 부른다.프로세스 관리의 주요 기능은 다음과 같다.  프로세스의 생성과 소멸(creation, deletion)  프로세스 활동 일시 중지, 활동 재게(suspend, resume)  프로세스간 통신(interprocess communication: IPC)  프로세스간 동기화(synchronization)  교착상태 처리(deadlock handling)2. 주기억장치 관리(Main memory management)주기억장치 즉, 메인 메모리는 프로그램이 실행되기 위한 공간이다. CPU는 오직 메인 메모리에 있는 프로그램(프로세스)하고만 소통할 수 있다. 주기억장치 관리에서는 메인 메모리를 효율적으로 사용하도록 관리한다.  프로세스에게 메모리 공간 할당(allocation)  메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시  프로세스 종료 시 메모리 회수(deallocation)  메모리의 효과적 사용  가상 메모리: 물리적 실제 메모리보다 큰 용량을 사용할 수 있다.3. 파일 관리(File management)디스크는 물리적으로 Track과 sector로 구성되어 있으며, 여기서 파일이라는 논리적 관점으로 데이터를 바라보고 관리하는 것이다.파일은 OS가 실행되는 컴퓨터에서 자주 볼 수 있는데, 이는 복잡한 과정으로 하드디스크에 저장되어 있는 것을 사용자가 편리하게 사용할 수 있도록 파일이라는 논리적 형태로 운영체제에서 관리하여 보여준다.  파일의 생성과 삭제(file creation, deletion)  디렉토리(Directory)의 생성과 삭제  기본 동작 지원: open, close, read, write, create, delete  Track/sector - file 간의 매핑(mapping)  백업(Backup)4. 보조기억장치 관리(Secondary storage management)보조기억장치는 대표적으로 하드 디스크, 플래시 메모리(주로 스마트폰에 사용)가 있다. 하드 디스크를 예로 들면, 하드 디스크에서 아무 것도 저장되어 있지 않는 공간을 block이라 하는데, 보조기억장치 관리는 이를 관리하는 것이다.  빈 공간 관리(Free space management)  저장공간 할당(Storage allocation)  디스크 스케줄링(Disk scheduling)5. 입출력 장치 관리(I/O device management)입출력 장치에는 키보드, 마우스, 프린터, 스피커, 마이크 등이 있다. 입출력 장치 관리는 이와 같은 여러 입출력 장치를 사용하기 위해 존재한다.  장치 드라이브(Device drivers)  입출력 장치의 성능향상: buffering, caching, spooling6. 시스템 콜(System call)시스템 콜은 유저 프로세스에서 운영체제 서비스를 필요로 할 때 이를 받기 위해 사용하는 호출이다.6.1 주요 시스템 콜  Process: end(정상 종료), abort(강제 종료), load, execute, create, terminate, get/set, attributes, wait event, signal event  Memory: allocate, free  File: create, delete, open, close, read, write, get/set attributes  Device: request, release, read, write, get/set attributes, attach/detach devices  Information: get/set time, get/set system data  Communication: socket, send, receiveReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-04-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%9C%EB%B9%84%EC%8A%A4.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-03-ec-9d-b4-ec-a4-91-eb-aa-a8-eb-93-9c-ec-99-80-eb-b3-b4-ed-98-b8-html": {
        "title": "03: 이중모드와 보호",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제의 사용자모드와 관리자모드, 하드웨어 보호 관해서 알아본다.1. 이중 모드 (Dual mode)현재 컴퓨터 환경은 여러 사람이 동시에 한 컴퓨터를 사용하는 경우가 많다.(서버 컴퓨터) 그리고 그 외에도 하나의 컴퓨터 내에서 여러 프로그램을 수행하는 것이 일반적이다. 이 때 특정 컴퓨터나 프로그램에서 잘못된 동작으로 인해 다른 컴퓨터(프로그램)가 영향을 받는다면 이는 매우 위험하다.예를 들어, 어셈블리어에서 사용하는 명령어 중 STOP, HALT, RESET과 같은 명령어는 CPU의 동작과 관계된 명령어이다. 이런 명령어를한 프로그램에서 고의 또는 실수로 입력하여 전체 컴퓨터의 동작이 멈추거나 꺼진다면 이 컴퓨터의 정상적인 동작을 위해서는 재부팅을 할 수 밖에 없다. 이러한 결함을 매우 치명적이다.이런 문제점을 해결하기 위해 일반 사용자가 위와 같은 명령어들을 요청하는 것을 막을 필요가 생겼다. 여기서 이중 모드 라는 것이 나왔다.설명이중 모드는 말 그대로 모드를 아래와 같이 둘로 나누는 것이다.  사용자(User) 모드  관리자(Supervisor) 모드          = 시스템(system) 모드      = 모니터(monitor) 모드      = 특권(privileged) 모드      특권 모드에서만 내릴 수 있는 명령을 특권 명령(privileged instruction) 이라고 하며, STOP, HALT, RESET, SET_TIMER 등이 있다. 만약 사용자 모드에서 특권 명령을 사용하려고 하면 CPU에서 내부 인터럽트를 발생시켜 해당 명령어를 요청한 프로그램을 강제로 종료시킨다.이중 모드는 CPU 내부의 레지스터(register)의 비트(bit)를 활용하여 플래그(flag)로 나타낸다. 예를 들어 특권 모드일 때는 비트 값이 0 이고, 사용자 모드일 때는 비트 값을 1 로 설정하여 구분한다.상태 레지스터 (플레그 레지스터)CPU에서 다양한 산술 연산의 결과의 상태를 알려주는 플래그 비트들이 모인 레지스터이다. flag라는 이름의 어원은 경주할 때, 시작, 정지와 같은 상태를 깃발의 색, 들어올림과 같은 것으로 알렸기 때문이다. CPU에서는 연산을 수행하는데, 제약사항을 갖고 (자리수의 제한 같은) 수행하기 때문에 이를 나타낼 다양한 코드가 필요하다. 이 상태는 비트를 통해 정의되어 있으며 다양한 플래그가 존재한다.상태 레지스터의 종류Mode의 변경 과정컴퓨터가 켜진 뒤에 한 사용자 애플리케이션을 실행시키는 동안 모드가 어떻게 변하는지 살펴보자.  컴퓨터 부팅 과정 - 관리자 모드  애플리케이션 실행 과정 - 관리자 모드  애플리케이션 실행중 - 사용자 모드  인터럽트 발생 후 처리 과정 - 관리자 모드  인터럽트 처리 후 - 사용자 모드사용자가 하드웨어의 자원에 접근하는 것은 매우 위험한 동작이다. 그러므로 이러한 경우에는 모두 관리자 모드로 운영체제에서 처리하도록 한다. (프로그램에서 소프트웨어 인터럽트를 발생시켜 운영체제에 위임한다.)위의 4번 과정을 하드웨어 인터럽트로 가정하고 자세히 살펴보면 아래와 같다.  하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)  CPU에서 모드 플래그를 관리자 모드값으로 설정  해당 하드웨어 인터럽트 서비스 루틴(ISR)으로 이동 (관리자 모드)  인터럽트 처리 (관리자 모드)  인터럽트 처리 완료 후 CPU의 모드 플래그를 다시 6. 사용자 모드값으로 설정  원래의 애플리케이션 위치로 복귀 (사용자 모드)만약 사용자 모드인 상태에서 치명적인 명령어를 사용자 프로그램이 Call했을 경우에 CPU는 모드 비트를 확인하고 관리자 모드가 아닐 경우, 내부 인터럽트를 발생시킨다. (잘못된 명령을 내렸을 때 발생하는 인터럽트) 그 결과, 메모리에 올라와있는 사용자 프로그램을 종료시켜버린다.애플리케이션이 실행하는 동안에는 위와 같은 모드 변경이 반복적으로 일어나는 것을 볼 수 있다. 대부분의 CPU는 이중 모드를 지원한다.2. 하드웨어 보호이중 모드는 사용자의 접근을 제한하여 치명적인 문제가 발생하지 않도록 방지하는 보호 기능에 해당한다. 이러한 보호 기능에 대해 추가적으로 알아본다.2.1 입출력 장치 보호여러 정보들은 입출력 장치를 통해 컴퓨터로 입력되고, 외부 장치로 출력이 된다. 여기서 크게 두 가지의 문제점이 발생한다.  여러 입출력 장치의 사용으로 인한 혼선  사용자가 자신의 데이터가 아닌 다른 사용자의 데이터에 입출력을 하는 일          위와 같이 입출력 장치에 여러 사용자의 데이터가 뒤엉켜서 들어오거나 다른 사용자의 데이터에 접근하려는 경우를 막아야 한다.이를 해결하기 위해 in, out 과 같은 입출력 명령을 특권 명령으로 설정하는 것이다. 즉, 사용자 애플리케이션에서 입출력을 사용하려면 운영체제를 통해서 수행해야한다.(소프트웨어 인터럽트) 여러 프로그램이 동시에 입출력을 사용하려고 하면 운영체제 내부에서 순서를 정하여 혼선을 막아줄 수 있다.즉, 컴퓨터의 하드웨어를 사용하는 과정에서는 모두 운영체제를 거치도록 한다! 라는 대원칙이 사실 숨어있다.      만약 A, B 사용자가 있는 상황에서 A가 B의 데이터를 읽기 위해 운영체제에게 소프트웨어 인터럽트를 발생하였다고 하자. 이 때, A의 데이터와 B의 데이터는 각각 A, B만이 읽기가 가능하다고 가정하자. 그러면 인터럽트가 발생하고, CPU는 RAM에 있는 운영체제 내부의 해당 ISR로 이동하게 된다. ISR은 현재 사용자 A가 해당 데이터 B에 접근할 수 없으므로 해당 요청을 거부한다.다시보는 이 그림..2.2 메모리 보호메모리에는 운영체제뿐만 아니라 여러 개의 사용자 애플리케이션이 존재한다. 한 애플리케이션이 자신의 메모리 영역이 아닌 운영체제나 다른 애플리케이션의 메모리 영역에 침범하려하면 매우 위험하다.메모리는 일반적으로 위와 같이 구성되어 있을 것이다. 여기서 user1이 OS나 user2, user3에 접근하는 것을 막아야 한다. CPU는 address bus를 통해 메모리 주소에 접근하게 되는데, user1 프로그램이 실행되는 동안에는 user1이 할당되어 있는 메모리 주소 범위 안인 경우에만 접근하면 될 것이다. 이를 address bus에서 검사하는 것이 가장 효율적일 것이다.위의 생각으로 나온 것이 MMU(Memory Management Unit) 이다. MMU는 위의 그림처럼 address bus 중간에 설치된 하드웨어 칩으로서 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다.예를 들어, User1의 시작 주소는 1024, 끝 주소는 4048이라고 하자. User1이 수행되는 동안 운영체제는 해당 프로그램의 주소 범위를 MMU에 설정(특권 명령)하는데, base는 1024, limit는 4048이 될 것이다. 결과적으로 user1이 수행되는 동안에는 이 범위 안의 주소값인 경우에만 address bus를 통과시킨다.만약 해당 프로그램의 주소 범위 밖의 주소값이 MMU에 들어온다면, MMU에서 내부 인터럽트 를 발생시켜 CPU에 신호를 준다. 그러면 CPU는 그에 맞는 ISR로 이동하여 해당 프로그램을 강제로 종료시킨다. 이과 같은 잘못된 메모리 접근을 Segment violation 이라 한다.2.3 CPU 보호CPU 보호는 사용자의 실수 또는 고의로 인한 CPU 독점을 방지해야 한다. 하나의 프로그램이 CPU를 독점하게 되면 다른 프로그램은 수행되지 못한다.while(true){}CPU를 독점하는 가장 대표적인 예는 무한 반복이다. 위의 코드를 보면 while문의 조건문이 잘못된 것을 볼 수 있다. 비교 연산자가 아닌 대입 연산자를 사용하여 n값이 1이 되므로 while문의 조건은 TRUE가 된다. 이는 n값이 변하지 않는 이상 무한으로 반복된다.이를 해결하는 방법은 Timer를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킨다. 인터럽트가 발생하면 반드시 운영체제 내의 ISR로 이동하므로, 해당 ISR에서 각 프로그램의 CPU 점유 시간을 측정하여 적절히 분배되도록 조정한다.예를 들어, 한 프로그램의 CPU 점유 시간이 비정상적으로 오래 걸리는 경우, 강제로 다른 프로그램으로 CPU를 전환시켜 줄 수 있다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-03-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-02-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-9d-98-ec-97-ad-ec-82-ac-html": {
        "title": "02: 운영체제의 역사",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "일괄처리부터 시분할시스템, 최근의 고급운영체제, 인터럽트에 기반한 현대 운영체제까지 변천 역사를 알아본다.1. 초기 컴퓨터  노가다, 사람 손도 많이가, 장치도 엄청커, 비싸기도 비싸운영체제는 컴퓨터가 발전하면서 같이 발전하게 되었다. 초기 컴퓨터는 크게 3가지로 구성되었다. 카드 리더, 프로세서, 프린터이다. 카드 리더는 입력기이다. 입력은 종이에 입력할 코드에 맞는 구멍을 뚫어서 넣어주는 방식이었다. 프로세서는 현재와 비슷한 계산하는 역할이었고, 프린터는 입력에 대한 결과를 종이에 찍어서 보여주었다. 이 시기에는 운영체제도 존재하지 않았으므로, 오퍼레이터(operator)라는 컴퓨터를 사용하는 직업이 따로 있었고, 컴퓨터의 크기 또한 너무 커서 건물 전체를 사용해야할 정도였다.2. Batch processing system(일괄 처리 시스템)  코드로 반복되는 거 좀 자동화 하자!위에서 초기 컴퓨터의 상황을 살펴보았는데, 프로그램을 수행할 때마다 컴파일-&gt;링크-&gt;로딩 순서를 오퍼레이터가 직접 입력해주었다. 이러한 과정을 자동화한 것이 batch processing system 이다. 위 과정을 하나의 프로그램으로 작성하여 프로세서의 메모리안에 할당해주었는데, 이 프로그램을 resident monitor라고 불렀다.resident는 “거주” 라는 의미로 이 프로그램이 항상 프로세서안에서 거주한다는 의미로 이러한 이름을 사용하였다. 그리고 이것이 최초의 운영체제로 알려져 있다.3. Multiprogramming system(다중 프로그래밍)  CPU가 노는 시간이 너무 많은데? 쉴 동안 다른일을 시켜버리자.과거에는 컴퓨터가 매우 비싼 장비였다. 그리고 초창기 메모리의 상태는 resident monitor를 제외하고 단 하나의 애플리케이션만을 할당하여 사용하였다. 하지만 이는 매우 비효율적인 방법이었다.프로그램을 수행하는 도중에는 계산을 하는 CPU 외에도 입출력을 담당하는 I/O장치가 수행한다. 즉, CPU와 I/O장치가 교대로 동작하는데 I/O장치가 수행하는 동안에는 CPU가 아무것도 할 일이 없었다. CPU가 아무일도 안하는 상태를 idle 상태라고 말한다. 그리고 I/O장치는 CPU에 비해 매우 느리기때문에 idle 상태의 비율이 너무 높았다. 이러한 비효율적인 수행을 해결하기 위해 multiprogramming system이 나왔다. 즉 CPU를 못놀게 하자방법Multiprogramming system은 메모리에 여러 애플리케이션(프로그램)을 올리는 시스템이다. 예를 들어 a, b 두 개의 애플리케이션이 있을 떄, 처음에는 a에서 CPU 수행을 하다가 I/O장치 수행으로 넘어간다. 이 순간 CPU는 idle 상태에 있지 않고 b가 있다는 것을 보고 b의 CPU 수행을 시작한다. 이렇게 idle상태의 시간을 최대한 줄이고자 하였다. 이런 동작을 가능하게 하려면 앞서 말했듯, 메모리에 여러 어플리케이션을 올린 상태여야만 한다.한계 및 문제하지만 메모리에 여러 프로그램을 올리면서 많은 문제점이 발생했다. 가장 큰 문제점은 CPU가 어느 프로그램을 수행해야하는지 선택하는 것이다. 이러한 작업을 CPU 스케줄링이라고 하며, 이는 운영체제의 중요한 역할 중 하나이다. 그리고 여러 어플리케이션의 공간을 할당한다는 전제 조건 때문에, 새롭데 들어온 어플리케이션에 대해 어느 메모리 공간에 할당해야하는지도 큰 문제였다. 이러한 문제도 운영체제가 다뤄야 하는 중요한 과제로 남았다.4. Time-sharing system(시분할 시스템)  하나 다 끝날 때까지 기다리지 말고 Interval을 주자!시간이 지나 모니터와 키보드를 사용하면서 사용자와 컴퓨터 사이에 대화 형식이 가능해졌다. 하지만 여전히 컴퓨터 자체가 너무 비쌌기 때문에 아래와 같이 단말기(terminal) 형태로 사용하였다.각 사용자(User)들은 모니터와 키보드만을 가지고, 실제 프로세서는 하나의 단말기에 존재하여 이를 공유하여 사용하였다. 멀티 프로그래밍에서는 이와 같은 단말기 형태에서 문제가 생긴다.예를 들어, 단말기 메모리에 User1 프로그램, User2 프로그램, User3 프로그램이 할당되어 있고 User1이 먼저 CPU를 사용한다고 하자. 멀티프로그래밍에서는 User1이 CPU를 수행하고 있는 도중에는 다른 사용자는 CPU자체를 사용할 수 없다. (CPU가 하나인 환경) 그러므로 다른 사용자들은 User1이 CPU수행을 모두 마칠 때까지(또는 I/O를 만날 때까지) 기다려야한다. 하지만 이는 매우 비효율적이다.해결이를 해결하기 위해 나온 것이 time-sharing system이다. 시분할 시스템은 CPU가 하나의 프로그램을 수행하는 시간을 제한하는 것이다. 예를 들어, User1 프로그램을 일정 시간 수행하면 반드시 다음 프로그램으로 넘어가서(스위칭, switching) 또 다시 일정 시간을 수행한다. 이렇게 일정 시간을 두어 프로그램들을 번갈아 수행하면서 모든 프로그램이 공평하게 수행이 되도록 한다. 그리고 이 일정 시간은 매우 짧은 시간(ms)이므로 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 가져온다. 가장 대표적인 시분할 시스템은 Unix가 있었다.한계 및 문제시분할 시스템을 사용하면서 여러 사용자(프로세스)간에 통신이 가능해졌다. 하지만 여기서도 여전히 멀티프로그래밍에서와 같은 스케줄링과 메모리 문제가 있었다. 이를 해결하기 위해 동기화 기술, 가상 메모리 등이 이후에 나왔다.5. 고등 운영체제5.1 다중 프로세서 시스템 (Multiprocessor system)  CPU가 여러개  병렬 시스템 (parallel system)          여러개의 CPU가 동시에 처리할 수 있다.        강결합 시스템 (tightly-coupled system)          메모리에 여러 CPU가 연결되어 있다.        3가지 장점: performance, cost, reliability          여러 일꾼을 쓰니 빠르다.      싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.      하나가 망가져도 작동할 수 있다. 신뢰도가 높다.        다중 프로세서 운영체제 (Multiprocessor OS)          CPU가 늘어났기 때문에, 다른 처리 방법이 필요하다.      5.2 분산 시스템 (Distributed system)]  컴퓨터가 여러대, 근데 묶여있다.  다중 컴퓨터 시스템 (multi-computer system)여러대의 컴퓨터로 만든 시스템이다.  소결합 시스템 (loosely-coupled system)          메모리가 느슨하게 연결되어 있다.        3가지 장점: performance, cost, reliability          여러 일꾼을 쓰니 빠르다.      싸지만 여러개를 사용하는게 같은 성능대비 가격이 싸다.      하나가 망가져도 작동할 수 있다. 신뢰도가 높다.            분산 운영체제 (Distributed OS)          다른 컴퓨터들을 관리해야 하기 때문에 새로운 처리 방법이 필요하다.      5.3 실시간 시스템 (Real-time system)  시간 제약: Deadline  공장 자동화 (FA), 군사, 항공, 우주  실시간 운영체제 (Real-time OS = RTOS)6. 인터럽트 기반 시스템(Interrupt based system)현대 운영체제는 인터럽트 기반 시스템이다. 그렇다면 인터럽트는 무엇인가?6.1 인터럽트컴퓨터에 전원이 들어오면 위에서 말했듯이 부팅이 시작된다. 먼저, POST과정이 시작되고 그 후에 부트 로더가 하드 디스크에 있는 운영체제 프로그램을 RAM에 가져와 할당한다. 할당된 운영체제는 컴퓨터의 전원이 꺼질 때까지 상주(resident)한다.부팅이 끝나고 운영체제가 동작하는 동안 수 많은 인터럽트가 발생할 수 있다. 예를 들어, 사용자가 마우스를 움직인다고 가정하자. 이 동작을 컴퓨터는 어떻게 알 수 있을까? 바로 인터럽트를 통해 알 수 있다. 마우스를 움직이는 순간, 마우스에서 인터럽트 전기 신호가 발생하여 이를 CPU에게 보낸다. CPU는 이를 감지하고, 자신이 하던 일을 멈춘 후에 이 인터럽트 신호를 처리하기 위해 운영체제 내부에 있는 인터럽트를 처리하는 코드(interrupt service routine, ISR)로 이동한다. 이 곳에 마우스가 움직일 때 어떻게 동작해야하는지가 내포되어 있어 이를 수행한다.6.2 인터럽트의 종류와 동작방법이러한 하드웨어에서 발생한 인터럽트를 하드웨어 인터럽트(Hardwore Interrupt) 라고 한다. 인터럽트라고 하면 기본적으로 하드웨어 인터럽트를 말하지만, 소프트웨어에서도 인터럽트를 요청을 할 수 있다. 이를 소프트웨어 인터럽트(Software Interrupt) 라고 한다. 소프트웨어 인터럽트는 명령어로 직접 인터럽트 전기 신호를 CPU에게 보낼 수 있다. 즉, 프로그램에서 swi, int 와 같은 어셈블리어 명령어를 수행하는 것이다. (명령어는 운영체제마다 다르다. 위의 명령어는 CPU에서 어셈블리어 코드 중 일종으로, interupt를 처리하라는 명령어이다.)예를 들어, 마우스로 워드 작성 프로그램을 실행시킨다고 하자. 워드 작성 프로그램을 실행시키는 것까지는 하드웨어 인터럽트가 수행된다.(마우스가 이동하여 더블 클릭으로 실행하는 경우이다.) 이 프로그램에서 사용자가 하드디스크에 있는 다른 워드 파일을 읽고 싶은 경우, 소프트웨어 인터럽트를 발생시킨다. 소프트웨어 인터럽트 역시 하드웨어 인터럽트와 동일하게 운영체제 내부에 해당 인터럽트를 처리하는 코드(ISR)가 존재하여 이 곳으로 이동한다. 여기서 하드디스크에서 읽을 파일을 찾아서 반환해주는 수행을 처리하는 것이다.마지막으로 내부 인터럽트(Internal Interrupt)가 있다. 내부 인터럽트는 프로그램을 수행하는 도중에 발생하는 예외 상황을 처리한다. 대표적인 예로 0으로 나누는 동작이다. 프로그램의 내부에 result = a / 0; 이와 같은 코드가 있을 때, CPU는 내부 인터럽트를 발생시켜 운영체제안에 있는 ISR로 이동한다. 이 경우에는 DividedByZero 라는 ISR로 이동한다. 여기서 잘못된 동작을 수행한 프로그램을 강제로 종료시킨다.운영체제는 평소에는 대기 상태에 있으면서 인터럽트가 발생하는 순간 작업을 수행한다. 그 인터럽트의 종류에 따라 운영체제 내부에 위치한 ISR로 이동하여 그에 맞는 처리를 한다. 위에서 설명한 하드웨어 인터럽트 과정을 그림으로 간단히 표현하면 아래와 같다.위 그림은 사용자 애플리케이션을 실행하기 위해 하드웨어를 사용하는 모습이다. 애플리케이션이 실행하는 중에도 계속해서 인터럽트는 발생한다. 워드 작성 프로그램을 예를 들면 키보드로 글을 작성하는 경우, 하드디스크에 있는 파일을 불러오는 경우 모두 인터럽트가 발생한다. 그러므로 CPU는 애플리케이션과 운영체제 내부를 교대로 수행하는 모습을 볼 수 있다.정리정리하면, 인터럽트는 CPU에게 보내는 전기 신호로서 인터럽트가 발생하면 CPU는 하던 일을 중지하고 해당 인터럽트를 처리하기 위해 운영체제 내부에 있는 ISR로 이동하여 수행한다. 그리고 수행이 끝나면 원래 위치로 돌아간다. 인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부 인터럽트로 총 세 가지가 존재한다.ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-02-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%EC%82%AC.html"
      }
      ,
    
      "cs-os-2020-03-30-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ec-a0-95-eb-a6-ac-01-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-eb-9e-80-eb-ac-b4-ec-97-87-ec-9d-b8-ea-b0-80-html": {
        "title": "01: 운영체제란 무엇인가?",
        "tags": "OS, Booting",
        "date": "March 30, 2020",
        "author": "",
        "category": "CS/OS",
        "content": "운영체제에 대한 정의, 역할에 대해 알아본다.운영체제는 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어이다. 일반적으로 사용하는 모든 프로그램은 운영체제에서 그 자원을 관리한다.목적운영체제를 사용하는 가장 큰 목적은 하드웨어의 관리이다. 컴퓨터를 나타내는 가장 상징적인 장치는 CPU이지만, 추가적으로 많은 장치와 상호작용하며 동작한다. 그렇기에 이러한 하드웨어를 관리하는 소프트웨어가 있어야 효율적으로 컴퓨터를 사용할 수 있다. 하드웨어를 직접적으로 사용하는 것이 아니기 때문에, 이를 효율적으로 사용하기 위해서는 운영체제의 성능이 좋아야 한다.두번째로는 사용자에게 편의를 제공하는 것이다. 운영체제가 없을 경우, 우리는 하드웨어 단에서 하드 코딩으로 원하는 작업을 실행해야 한다. 이는 매우 생산성이 떨어지는 방법이다. 그렇기 때문에 이런 자원 관리 측면을 자동으로 해주는 소프트웨어를 통해, 원하는 작업에만 몰두할 수 있는 환경을 제공한다.정리운영체제는 컴퓨터의 성능을 높히고(performance), 사용자에게 편의성을 제공(Convenience)을 목적으로 하는 컴퓨터 하드웨어 관리 프로그램이다.부팅 (Booting)컴퓨터를 사용하기 위해서 가장 먼저하는 행동은 전원버튼을 누르는 것이다. 그렇다면, 전원을 눌렀을 때, 시작해야 하는 작업들이 있을 것이다. 우리가 실제로 사용할 수 있는 운영체제가 실행되기 이전에 다양한 작업을 해야하는데, 이 작업을 부팅 이라 한다.어떻게 실행할 수 있을까?기본적인 컴퓨터 구조는 위와 같다. 이 상황에서 부팅을 한다고 생각해보자. 컴퓨터는 원하는 작업을 실행할 때, Disk, RAM, CPU, RAM, Disk 순의 과정을 거치며 작동하게 된다. 그런데, 부팅을 하는 경우에는 어떻게 해야할까? 사실 Disk는 컴퓨터 입장에서는 보조 장치이다. 컴퓨터라고 부를 수 있는 실질적인 부분은 CPU, RAM이 전부이기 때문에 처음 부팅을 시작하면 CPU 에 부팅시 필요한 작업을 넘겨줄 수 없다.따라서 우리는 일반적으로 프로그램이 동작하는 방식인 Disk, RAM, CPU 과정을 거칠 수 없기 때문에, 부팅에 한해서 RAM에 항상 저장된 공간을 필요로하게 되었는데, 그것이 ROM이다.RAM과 ROM을 함께 Main Memory라 부른다.  ROM: 비휘발성 으로 메모리에서 극히 일부를 차지한다.(수 KB)  RAM: 휘발성 으로 메모리의 대부분을 차지하며 실제 프로그램이 할당되는 곳이다.(수 MB ~ 수 GB)부팅시 하는 작업(엄밀한 정의의 부팅)  ROM의 정보를 읽는다.  ROM안에 있는 POST(Power-On-Self-Test), 부트 로더(Boot-Loader)를 실행한다.POST는 전원이 켜지면 가장 처음에 실행되는 프로그램으로, 현재 컴퓨터의 상태를 검사한다. 이 것에는 장치가 연결되어 있는지, 멀쩡한 지 등의 상태를 뜻한다.부트 로더는 하드디스크에 저장되어 있는 운영체제를 찾아서 메인 메모리(RAM)에 가지고 온다. 이러한 부트 로더의 과정을 부팅이라고 한다.이렇게 메모리에 올라온 OS는 컴퓨터를 종료하기 전까지 계속 메모리에 상주한다.구조운영체제는 크게 커널(Kernel)과 명령어 해석기(Command interpreter, shell)로 나뉜다.커널(Kernel)은 운영체제의 핵심인 하드웨어를 다루는 코드를 말한다. 이 부분이 핵심이 때문에, Kernel에 따라 운영체제가 달라진다. 예를 들어 페도라, 우분투 등이 리눅스 운영체제라 부르는 것은, 이 운영체제가 리눅스 커널을 사용하기 때문이다.명령어 해석기(Command interpreter, shell)는 이 커널로 만들어진 코드를 동작하기 위해 만들어진 부분이다. Interface라고 볼 수 있다. GUI(Graphical User Interface)나 CLI(Command Line Interface) 같은 방식으로 운영체제에 명령을 요청할 수 있다.위치사용자 프로그램(Application)은 특정 운영체제에 맞춰서 만든다. 그러므로 한 애플리케이션은 서로 다른 운영체제에서 수행할 수 없다. (하드웨어가 같은 것은 전혀 상관이 없다.) 예를 들면 Windows에서 수행하는 프로그램을 그대로 Linux에 옮기면 수행되지 않는다. 이전 글에서 보았듯이 사용자 프로그램은 자원을 OS를 통해 요청한다. 그렇기 때문에 해당 운영체제의 Interface를 따라야 하고, 그렇기 때문에 운영체제가 다를 경우 동작할 수 없다.추가적으로 국가에 비유하여 생각해 볼 수도 있다.영토, 정부, 가족, 개인 비유ReferenceKOCW 양희재 교수님 - 운영체제양희재 교수님 블로그(시험 기출 문제)codemcd 님의 정리글Operating System Concepts, 9th Edition - Abraham Silberschatz",
        
        "url": "/cs/os/2020/03/30/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-01-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80.html"
      }
      ,
    
      "cs-structure-2020-03-27-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-9a-b4-ec-98-81-ec-b2-b4-ec-a0-9c-ea-b0-80-ed-95-98-eb-8a-94-ec-9d-bc-html": {
        "title": "07: 운영 체제가 하는 일",
        "tags": "컴퓨터 구조, 운영체제",
        "date": "March 27, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "운영 체제가 하는 일을 간단하게 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.운영체제가 하는 일  접근 제어 + 동기화 + 관리전산 자원을 관리한다. 대표적인 전산 자원은 CPU, RAM 등이 있다. 스타판 프로게이머프로그램’들’ 관리하기  Process를 관리한정된 자원으로 많은 프로그램들이 동작해야 한다. 어쩔 수 없이 나눠서 사용해야 한다.아래 단어들의 의미를 모른다면, 용어를 알고 다시 읽자.하드웨어, 운영체제, 프로세스, 스레드 용어 정리Scheduling  멀티 프로세스 운영체제에서 하나의 CPU가 복수의 프로세스를 실행하기 위해 CPU를 사용하는 순서를 정해주는 작업이렇게 다양한 프로세스를 동시에 작업하게 되면, 스레드가 CPU를 사용하고 있을 떄, 사용하고 있다고 알려주는 동기화가 매우 중요하다.Virtual Memory System  RAM과 HDD를 하나의 논리적 메모리로 추상화시킨 메모리 관리 방법프로세스가 운영체제로 부터 메모리를 할당 받는 일은 시간이 많이 걸리는 일이다. 그렇기 때문에 최대한 RAM 공간에 할당 받은 채로 존재하는 것이 속도를 높일 수 있는 방법이다. 또한 여러개의 프로세스를 사용할 경우, RAM 공간을 초과하여 프로세스가 동작하지 않는다. 이런 부분들을 해결하기 위해 HDD 공간을 활용한 것이 가상 메모리 시스템이다.단위이 곳에서 모든 메모리는 Page라는 단위로 관리된다. HDD와 RAM을 왔다갔다 하는 단위이다. 이 중에는 Paged 될 수 있는 페이징 풀 영역과 절대로 Paged 되면 안되는 비 페이징 풀 영역이 있다.Virtual Memory의 구성집의 공간을 가족 구성원들이 나눠쓰듯이 프로세스의 가상 메모리 공간을 thread가 나눠서 사용한다. 이 나눠서 사용하는 공간을 Stack이라 한다. 이 thread에 할당된 메모리 공간이 stack을 사용하여 관리되기 때문에 Stack이라 불린다.프로세스는 Heap과 실행 코드 영역을 갖는다.운영체제 정리 05: 프로세스 관리동작 방법  RAM이 꽉찼는 지 확인한다.  꽉찼다면 현재 RAM 공간 중에 사용하지 않는 프로세스가 할당된 공간이 있다면 이것을 HDD 공간에 복사해둔다. Page Out(Swap Out)  RAM 공간이 비게 될 경우 복사해 둔 공간을 다시 RAM으로 복사한다. Page in(Swap in)프로세스 별 가상 메모리의 크기이러한 가상 메모리 시스템이 있기 때문에, 프로세스가 실행 되고 할당 받는 메모리 공간은 4GB로 할당한다. 이 크기는 현실적으로 RAM만 사용한다면 말이 안되는 소리지만, 가상 메모리를 사용하게 되면 문제없다.",
        
        "url": "/cs/structure/2020/03/27/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C%EA%B0%80-%ED%95%98%EB%8A%94-%EC%9D%BC.html"
      }
      ,
    
      "dv-javascripts-2020-03-26-javascript-window-event-html": {
        "title": "window resize event",
        "tags": "development, javascript, resize",
        "date": "March 26, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "자바스크립트의 window 이벤트를 알아본다.resizewindow.addEventListener(\"resize\", changeContent);function changeContent(event) {  const cat = document.getElementById(\"js-cat\");  const cv = document.getElementById(\"category-cv\");  const math = document.getElementById(\"category-math\");  const ds = document.getElementById(\"category-ds\");  const cs = document.getElementById(\"category-cs\");  const dv = document.getElementById(\"category-dv\");  const about = document.getElementById(\"category-about\");  if (event.target.innerWidth &lt; 710) {    cv.innerText = \"📜\";    math.innerText = \"✖\";    ds.innerText = \"📈\";    cs.innerText = \"💾\";    dv.innerText = \"📱\";    about.innerText = \"😎\";    cat.style.justifyContent = \"space-around\";  } else {    cv.innerText = \"CV\";    math.innerText = \"Math\";    ds.innerText = \"Data Science\";    cs.innerText = \"Computer Science\";    dv.innerText = \"Development\";    about.innerText = \"About\";    cat.style.justifyContent = \"center\";    console.log(cat);  }}이 코드는 내 블로그 카테고리를 수정할 때 만든 코드이다.",
        
        "url": "/dv/javascripts/2020/03/26/javascript-window-event.html"
      }
      ,
    
      "dv-html-css-2020-03-26-safari-longline-scroll-html": {
        "title": "Safari: long line scroll 작동 안함",
        "tags": "Browser, Safari, css",
        "date": "March 26, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "근본적인 문제는 Safari pre태그의 초기값 때문이다.이것을 해결하기 위해서는 다음의 코드를 추가하면 된다..site-content pre {  overflow-wrap: normal;}Reference참고",
        
        "url": "/dv/html-css/2020/03/26/Safari-longline-scroll.html"
      }
      ,
    
      "cs-structure-2020-03-26-ec-9e-90-eb-a3-8c-ea-b5-ac-ec-a1-b0-ec-99-80-ec-95-8c-ea-b3-a0-eb-a6-ac-ec-a6-98-html": {
        "title": "06: 자료구조와 알고리즘",
        "tags": "컴퓨터 구조, 자료구조, 알고리즘",
        "date": "March 26, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "컴퓨터에서 사용하는 자료구조와 알고리즘을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.자료를 정리해야 하는 이유  정리를 잘 해둬야 필요할 때 빨리 꺼내 쓸 수 있다!처음엔 몰랐지만.. 갈 수록 유지 보수를 위해 정리하는 것이 중요함을 느낀다.. ㅠㅠ어떻게 정리할까?  정리 는 상황에 맞는 적절한 규칙이 존재한다.일련번호도 아무런 규칙이 없어보이지만, 그 숫자들에 규칙이 존재한다.자료구조선형 구조배열  물리적으로 순차적인 자료구조장점  단순하다.  한 자료에서 다음 자료 넘어갈 때 생각할 것이 없다. 인덱스가 단순 증가한다.단점  크기를 늘리거나 줄이려면 구조를 변경해야 한다.  중간에 새로운 자료를 넣거나 빼는 경우 문제가 발생한다.Linked List  화살표룰 가지고 원하는 요소를 가리키는 구조장점  순서를 바꾸기 매우 쉽다.  중간에 새로운 자료를 넣거나 뺴기가 쉽다.단점  한 자료 접근 후 다음으로 넘어가기 위해서 위치정보를 활용해 찾아가야한다.  찾아간다는 점에서 배열에 비해 복잡하다.Stack  뚜껑식 김치 냉장고 : 출입구가 하나다!사용처  되돌아 가기 위한 구조한 스텝 전진하고, 전으로 가기 위해서는 pop 한다.  가장 최근 값을 가져온다  대칭 구조Queue  줄을 선다!버스에서 줄을 서는 것이나 은행의 대기열을 생각하면 된다. 이 때 버스는 순차적으로 처리가 진행이 되고, 은행은 병렬적으로 처리된다. 각각을 순차 처리, 병렬 처리라 한다.비선형 구조Binary Tree선형 구조, 정렬이 안된 상황에서 특정 값을 찾는다고 생각해보자. 이런 경우 해당 배열의 크기만큼 탐색을 진행해야 한다. 결과적으로 선형 구조에서 값을 찾는 것은 상대적으로 효과적이지 않다.그래서 새로운 구조가 필요했는데 그 중 가장 효과적으로 사용한 구조가 이진 트리이다.이진 트리에 대한 내용 정리선형 구조, 비선형 구조 비교                   비선형      선형                  구조      복잡      간단              접근효율      좋다      나쁘다      물론 데이터 개수에 따라 판단을 달라질 수 있다. 상황 판단을 잘해야 한다.알고리즘Sort선형 구조에서 정렬하는 방법에 대해 생각해본다. 이 부분은 나열만 해두겠다.정렬에 대한 기초적 내용 정리선형 구조에서의 정렬 알고리즘  Bubble  Quick  Merge  Selection  Insertion  Heap  Radix",
        
        "url": "/cs/structure/2020/03/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"
      }
      ,
    
      "dv-tips-2020-03-25-latex-align-html": {
        "title": "Latex equation 예쁘게 맞추기",
        "tags": "Tips, LaTex",
        "date": "March 25, 2020",
        "author": "",
        "category": "DV/Tips",
        "content": "수식 전개를 하다보면, 계속해서 등호를 사용하여 수식의 변경요소를 보여줄 필요가 있다.으으 못생겼다이런 경우 Latex 수식을 시작할 떄 align 속성을 걸어주면 예쁘게 사용할 수 있다.\\begin{align}A &amp; = B \\\\&amp; = C \\\\&amp;= \\cdots \\\\&amp;= Z.\\end{align}",
        
        "url": "/dv/tips/2020/03/25/Latex-align.html"
      }
      ,
    
      "cs-structure-2020-03-25-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-88-ab-ec-9e-90-eb-a1-9c-eb-aa-a8-eb-93-a0-ea-b2-83-ec-9d-84-eb-8b-a4-eb-a3-a8-eb-8a-94-eb-b0-a9-eb-b2-95-html": {
        "title": "05: 숫자로 모든 것을 다루는 방법",
        "tags": "컴퓨터 구조, ASCII",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "컴퓨터가 모든 것을 숫자로 다루는 방식을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.컴퓨터로 글자를 나타내는 방법ASCII Code  숫자와 글자에 대한 함수관계를 정의한다.출처바이너리 코드(binary Code)실제로 담고 있는 정보를 Text 형태로 보여주면 ASCII Code 형태가 되고, 이것을 컴퓨터가 이해하는 방식인 숫자(보통 16진수)로 표현해 놓으면 이것을 바이너리 코드라 한다.결과적으로 사람이 읽을 수 있는 텍스트 파일 이외에 컴퓨터 저장이나 처리 목적을 위해 코드를 숫자로 변경해 놓은(인코딩) 데이터를 말한다.컴퓨터가 사진을 다루는 방법  특정 화소 하나를 숫자로 표시하고 이를 모아 사진으로 그린다.이미지 파일 형식  해당 화소를 표현하는 방식(규칙)에 대한 것.Rendering  숫자로 되어 있는 것을 글자와 사진으로 그려내는 것!이 속도가 중요하다! 렌더링이라는 것이 정확히 무엇인지 몰랐는데… 휴우",
        
        "url": "/cs/structure/2020/03/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%88%AB%EC%9E%90%EB%A1%9C-%EB%AA%A8%EB%93%A0%EA%B2%83%EC%9D%84-%EB%8B%A4%EB%A3%A8%EB%8A%94-%EB%B0%A9%EB%B2%95.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-9d-b4-ec-b9-9c-ec-88-98-html": {
        "title": "백준(2193번): 이친수",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 동적계획법 문제이다.생각이 문제의 핵심은, 최고자리 숫자가 0 또는 1일 때의 상황을 분리해서 생각해보는 것이다. 이유는 나열하면 금방 알아차릴 수 있다.            N      1             2             3                                0      X      00      X      000      X                     1      O      01      X      001      X                                   10      O      010      X                                   11      X      011      X                                                 100      O                                                 101      O                                                 110      X                                                 111      X                            1             1             2      여기서 N이 2 일 때를 생각해보면, 앞자리에 1이 있어야 하고, 그 뒤는 0으로 시작해야 한다. 0으로 시작한 이후에는 이친수가 와야한다. 그럴 경우에 새로운 이친수가 만들어진다. 따라서 N이 증가함에 따라 다음 자리수의 이친수를 만들기 위해서는 최고자리가 0인 상황에서 다음 숫자부터 가지는 이친수를 저장할 필요가 있다.정의  dp[N][0] : N자리수의 최고자리가 0일 경우 이후 자리수에서 가질 수 있는 이친수의 개수  dp[N][1] : N자리수의 최고자리가 1일 경우 가질 수 있는 이친수의 개수점화식  dp[N][0] = dp[N-1][0] + dp[N-1][1];최고자리수가 0일 때, 위의 정의에 맞는 개수를 구하기 위해서는 그 다음 자리의 수가 1인 경우와, 0인 경우가 있다. 따라서 그 두 경우를 모두 더해주어야 내가 원하는 수를 구할 수 있다.  dp[N][1] = dp[N-1][0];1인 경우에는 무조건 다음 자리수가 0으로 시작하는 이친수를 구해야 하므로 위와 같다.Code// 실버3 : 백준 2193번 이친수#include &lt;iostream&gt;using namespace std;int main(){    int N;    long long dp[91][2];    cin &gt;&gt; N;    dp[1][0] = 1;    dp[1][1] = 1;    for (int i = 2; i &lt;= N; i++) {        dp[i][0] = dp[i-1][0] + dp[i-1][1];        dp[i][1] = dp[i-1][0];    }    cout &lt;&lt; dp[N][1] &lt;&lt; '\\n';}피보나치 수열그런데 위의 점화식을 잘 정리하면 우리가 알고있는 피보나치 수열의 형태가 나온다.다이나믹은 끝이 없다.Reference백준(2193번) - 이친수",
        
        "url": "/cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%9D%B4%EC%B9%9C%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-8b-9c-eb-a6-ac-ec-96-bc-eb-84-98-eb-b2-84-html": {
        "title": "백준(1431번): 시리얼 넘버",
        "tags": "백준, 알고리즘, 정렬",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 정렬 문제이다.생각문제에서 하라는 대로 비교만 하면 된다.Code// 실버3 : 백준 1431번 시리얼 번호#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;string arr[1002];bool compare(string a, string b){    int sizeA = int(a.size()), sizeB = int(b.size());    if (sizeA &gt; sizeB) return false;    else if (sizeA &lt; sizeB) return true;    else {        int sumA = 0, sumB = 0;        for (int i = 0; i &lt; sizeA; i++) {            if (0 &lt;= a[i]-'0' &amp;&amp; a[i]-'0' &lt;= 9) sumA += a[i]-'0';        }        for (int i = 0; i &lt; sizeA; i++) {            if (0 &lt;= b[i]-'0' &amp;&amp; b[i]-'0' &lt;= 9) sumB += b[i]-'0';        }        if (sumA &lt; sumB) return true;        else if (sumA &gt; sumB) return false;        else {            return a &lt; b;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; N;    for (int i = 0; i &lt; N; i++) {        cin &gt;&gt; arr[i];    }    sort(&amp;arr[0], &amp;arr[N], compare);    for (int i = 0; i &lt; N; i++) {        cout &lt;&lt; arr[i] &lt;&lt; '\\n';    }    return 0;}Reference백준(1431번) - 시리얼 넘버",
        
        "url": "/cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%8B%9C%EB%A6%AC%EC%96%BC-%EB%84%98%EB%B2%84.html"
      }
      ,
    
      "cs-algorithm-2020-03-25-eb-b0-b1-ec-a4-80-ec-83-89-ec-a2-85-ec-9d-b4-eb-b6-99-ec-9d-b4-ea-b8-b0-html": {
        "title": "백준(17136번): 색종이 붙이기",
        "tags": "백준, 알고리즘, 구현, 완전탐색, DFS, 삼성 역량 테스트",
        "date": "March 25, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드3 : 완전탐색 문제이다. 삼성 A형 기출이다.생각시간이 1초라, 제한 시간에 들어올 수 있는지 시간 복잡도 계산부터 진행했다. 최악의 경우 100개의 공간에 모두 1이 차있는 경우 한 개의 공간에서 색종이를 5번 검사해야 한다.백트래킹을 해야 하나 고민했지만, 다행히 이 문제의 경우 한 개의 공간에서 5개의 경우의 수가 무조건적으로 발생하지 않는다는 점을 고려하여 풀이를 진행했다. 구현에 앞서 중요하게 생각한 것들은 다음과 같다.  종이의 수는 5장이다. 이 부분을 업데이트 해준다.  칠했다는 것을 표현하고, 이 부분은 탐색을 하지 않는다.  칠할 수 없는 곳은 칠하지 않고 다음 옵션으로 넘어간다.  끝나는 조건은 모든 1이 색칠이 되었을 때이다.설계main입력을 받는다.    이 때, 입력이 1인 경우 이 위치만 저장한다.1의 개수를 저장해 둔다.탐색한다.탐색 후 값을 출력한다.탐색 함수만약 현재까지 칠한 개수가 1의 개수와 같다면 answer를 업데이트 한다.현재 depth의 1의 위치를 가져온다.이 위치에 색종이가 붙어있지 않다면    5개의 색종이를 순차적으로 비교한다. 이 때 큰 색종이 부터 탐색한다.        만약 현재 색종이가 남아있다면            만약 해당 색종이를 붙일 수 있다면                색종이를 칠한다                색종이의 개수를 하나 감소시킨다                색종이를 붙이고, 다음 위치에서 탐색한다.                색종이의 개수를 하나 증가시킨다                색종이를 뗀다            색종이를 붙일 수 없다면                다음 색종이를 탐색한다        현재 색종이가 남아있지 않다면            다음 색종이를 탐색한다이 위치에 색종이가 붙어있다면    다음 위치에서 탐색한다.Code// 골드3 : 백준 17136번 색종이 붙여넣기#include &lt;iostream&gt;#include &lt;vector&gt;#define INF 2000000000using namespace std;int globalAns = INF, N = 0;int map[10][10] = {0};vector&lt;pair&lt;int, int&gt;&gt; position;pair&lt;int, int&gt; action[5] = {make_pair(5, 5),                            make_pair(4, 5),                            make_pair(3, 5),                            make_pair(2, 5),                            make_pair(1, 5)};void fillSquare(int y, int x, int num, int value){    for (int i = y; i &lt; y+num; i++)        for (int j = x; j &lt; x+num; j++)            map[i][j] = value;}bool isFillPossible(int y, int x, int num){    for (int i = y; i &lt; y+num; i++) {        for (int j = x; j &lt; x+num; j++) {            if (!(0 &lt;= i &amp;&amp; i &lt; 10 &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; 10)) return false;            if (map[i][j] == 0 || map[i][j] == 2) return false;        }    }    return true;}void go(int depth, int localAns, int paint){    if (paint == N) {        globalAns = min(globalAns, localAns);        return;    }    int y = position[depth].first, x = position[depth].second;    if (map[y][x] == 1) {        for (int i = 0; i &lt; 5; i++) {            int squareSize = action[i].first, &amp;squareCount = action[i].second;            if (squareCount != 0) {                if (isFillPossible(y, x, squareSize)) {                    fillSquare(y, x, squareSize, 2);                    squareCount--;                    go(depth+1, localAns+1, paint+(squareSize*squareSize));                    squareCount++;                    fillSquare(y, x, squareSize, 1);                }            } else continue;        }    } else go(depth+1, localAns, paint);}int main(){    for (int i = 0; i &lt; 10; i++) {        for (int j = 0; j &lt; 10; j++) {            cin &gt;&gt; map[i][j];            if (map[i][j] == 1) position.push_back(make_pair(i, j));        }    }    N = int(position.size());    go(0, 0, 0);    if (globalAns == INF) {        if (position.size() == 0) cout &lt;&lt; 0;        else cout &lt;&lt; -1;    }    else cout &lt;&lt; globalAns;    cout &lt;&lt; '\\n';    return 0;}Reference백준(17136번) - 시리얼 넘버",
        
        "url": "/cs/algorithm/2020/03/25/%EB%B0%B1%EC%A4%80-%EC%83%89%EC%A2%85%EC%9D%B4-%EB%B6%99%EC%9D%B4%EA%B8%B0.html"
      }
      ,
    
      "dv-c-2020-03-24-cin-cout-eb-b9-a0-eb-a5-b4-ea-b2-8c-html": {
        "title": "입출력 빠르게 받는 방법",
        "tags": "c++, iostream, 입출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "DV/C++",
        "content": " 출처 : https://coding-insider.tistory.com확연하게 cin, cout이 느리다는 것을 알 수 있다.적용ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);main 함수안에 위의 코드를 적어주면 빠른 입출력이 가능하다.설명  ios_base::sync_with_stdio(false)C 입출력 함수와 C++ 입출력 스트림의 동기화를 해제하는 것이다. 이걸 쓰면 C, C++ 입출력 함수를 섞어 쓰면 안된다.  cin.tie(NULL); cout.tie(NULL);cin과 cout 의 tie를 해제하는 것이다. 자세한 설명을 모르겠다.  std::endl -&gt; '\\n'endl도 역시 불러오는 것이기 때문에 속도가 매우 느리다.주의 사항하지만 이 방법은 일종의 편법이기 때문에, 사용시 주의가 필요하다.  scanf, printf와 함께 사용하면 안된다.  싱글 쓰레드 환경에서만 사용 가능하다. (알고리즘 문제풀이시에 사용, 실무에서는 사용 X)",
        
        "url": "/dv/c++/2020/03/24/cin-cout-%EB%B9%A0%EB%A5%B4%EA%B2%8C.html"
      }
      ,
    
      "cs-structure-2020-03-24-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ea-b8-b0-ec-96-b5-ec-9e-a5-ec-b9-98-ec-97-90-eb-8c-80-ed-95-9c-ec-9d-b4-ed-95-b4-html": {
        "title": "04: 기억장치에 대한 이해",
        "tags": "컴퓨터 구조, 기억장치",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "기억 장치의 동작방법에 대해 이해해보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.Memory Device계층 구조출처 : https://programmer-student.tistory.com쉬운 이해를 위한 도표            기억장치      분류                  캐시      책상              RAM      책꽂이              HDD      도서관      컴퓨터가 관리하는 방법 - 관리 체계  컴퓨터는 모든 것이 숫자이다.그래서 기억 공간도 번호를 붙여 관리한다. 이와 같은 관리 체계는 아파트 단지를 동, 호로 관리하는 것과 비슷하다.  RAM에 있는 n번 번호에 있는 정보를 가져와  그 정보를 CPU에서 사용할 연산 저장 공간에 저장해  연산을 수행해  RAM의 m번 공간에 저장해여기서 CPU에서 저장하는 공간의 명칭이 register이다.레지스터  개별 기억 공간마다 고유 이름을 붙인다.기본적으로 레지스터는 많은 저장 공간을 갖고 있지 않다. 그래서 이 각각에 이름을 붙여 관리한다.주기억장치(RAM)  일련 번호를 붙인다.위에서 언급했던 번호에 해당하는 것이 보통 RAM에 대한 설명이다.  신발장 번호 : 주소신발 : 정보이 신발장을 컴퓨터는 약 43억 개 갖고 있는데, 이 숫자는 $2^32$ 가지에 해당하는 숫자이다. 저 숫자를 표시하기 위해서 32비트가 필요하다.보조 기억장치(HDD, SDD)  트랙 번호와 섹터 번호를 붙여 관리한다.Track중심부로 부터 밖으로 나가는 원들 중 하나를 말한다.Sector원을 균등하게 부채꼴 모양으로 나눈 것들중 하나를 섹터라 말한다.Format 이란?하드디스크의 섹터와 트랙을 구성하는 작업을 말한다. Format을 하면 데이터가 다 날아가는 이유는, 하드디스크에 정보를 저장하는 체계인 트랙과 섹터를 재구성하기 때문이다.파일 시스템하드 디스크에 내가 가진 파일의 위치를 Track, Sector로 나타낸 표            파일이름      Track      Sector                  a.mp3      1      1      이런 파일 시스템은 File Allocation Table (FAT), NTFS.. 등등 엄청 많다. 내가 파일을 삭제하면, 이 파일 시스템의 Delete Field에 True로 체크가 되고, 이 공간은 운영체제에서 쓰기 가능한 공간으로 바뀐다. 그래서 디스크 복구같은 것이 가능한 것.디스크 조각 모음하드디스크는 기본적으로 원의 형태를 띈 모양으로 구성되어 있고, 이것을 Arm을 사용해 읽는다. 그래서 갖는 특징이 있는데, 같은 track에 내가 사용하는 데이터가 모여있는 경우 입출력 속도가 빠르다. 하지만 만약에 데이터가 다른 트랙, 다른 섹터에 분산되어 있다면 이 파일을 읽기 위해서 Arm이 여러번 움직어야 한다. 관성 때문에 Arm의 속도가 느려지고 결과적으로 입출력 속도의 감소가 이루어진다.이렇게 흩어져 있는 파일을 같은 track이나 그 근처로 모으는 작업을 디스크 조각 모음이라 한다.전체 흐름  HDD에 몇번 트랙, 몇번 섹터에서 정보를 읽어와  그걸 RAM의 몇번 주소에 저장해라  그리고 그걸 다시가져와서 CPU에 EAX라는 이름을 가진 레지스터에 저장해라컴퓨터가 연산하는 과정이제 메모리가 어떻게 구성되어 있는 지를 대충 알았다면, 실제 연산과정을 들여다 보자.  캐시 메모리는 CPU 그 자체다.RAM은 CPU의 연산을 돕기위한 연습장이다.맨 위에서 보았듯이 메모리가 정보를 불러오는 데에는 속도가 존재한다. 전체적인 과정은 HDD, RAM, Resister 순으로 입출력이 일어나는데, 이 때 속도차이가 나므로 CPU가 빠르게 연산을 처리하는데 문제가 생긴다.그래서 이 병목구조를 탈피하기 위해서 CPU, RAM 등에 캐시 메모리를 두어 이 부분을 해소한다. 캐시 메모리는 CPU가 연산을 수행하는 동안 다음에 필요한 정보를 RAM에서 미리 가져와 저장하는 역을 한다. 그 결과 CPU는 RAM에서 정보를 가져올 때 걸리는 시간을 캐시에서 가져오므로써 시간적 이득을 가질 수 있다.CPU ALUALU는 가산기를 뜻한다. CPU에 대해서 배울 때, 이는 연산 처리 장치이고 모든 연산은 가산기 하나로 가능하다고 배웠다. 결과적으로 Core 하나에는 ALU하나가 들어있다고 생각하면 된다. 쿼드코어 컴퓨터는 가산기가 4개 존재한다.64bit 컴퓨터CPU가 연산을 처리할 때 발생하는 input, output의 단위가 64bit 만큼의 정보를 단위로 연산을 수행한다는 의미이다.전체 과정  RAM에서 정보를 가져온다  캐시 메모리에서 정보를 읽는다.  레지스터로 해당 값을 옮긴다.  ALU에서 연산을 수행한다.  결과를 레지스터로 복사한다.  그 값을 RAM으로 옮긴다.이런 작업을 코드라 한다. 그런데 CPU(기계)에게 명령하는 코드이므로 기계어 코드라 한다.",
        
        "url": "/cs/structure/2020/03/24/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-b2-b4-ec-8a-a4-ed-8c-90-eb-8b-a4-ec-8b-9c-ec-b9-a0-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1018번): 체스판 다시 칠하기",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현, 완전탐색",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버5 : 완전 탐색 문제이다.대표적인 완전 탐색 문제이다.체스판이 될 수 있는 모든 경우에 대해서 몇번의 flip을 해야하는지 세고, 이를 갱신해주면 풀린다.이 때, 체스판의 규칙을 잘 파악하는 것이 중요하다.Example                   1      2      3      4      5      6      7      8                  1      W      B      W      B      W      B      W      B              2      B      W      B      W      B      W      B      W              3      W      B      W      B      W      B      W      B              4      B      W      B      B      B      W      B      W              5      W      B      W      B      W      B      W      B              6      B      W      B      W      B      W      B      W              7      W      B      W      B      W      B      W      B              8      B      W      B      W      B      W      B      W      1행에서, 맨 마지막인 8열은 B이고, 그 다음 행의 첫번째는 B이다. 계속해서 엇갈려서 발생하는 것이 아니고, 행이 끝날 때, 마지막 요소가 다음 요소가 된다. 또한 추가적으로 체스판은 시작 위치의 표식이 어떤 것이냐에 따라 모양이 정해진다. 이 부분에서 생각할 수 있는 것은, 같은 모양이나 시작 위치의 표식만 바뀐다. 라는 것이다.구현이 것을 구현하기 위한 단계를 생각해보자.  우리는 체스판의 크기에 따라 몇 개의 작은 체스판을 조사해야 하는지 정해야 한다.  그 안에 들어갔을 때, 시작 위치의 표식을 설정해 주어야 한다.  체스판을 만들 수 있는 방법을 진행하며 다른 부분을 체크하고 count 해야한다.Code// 실버5 : 백준 1018번 체스판 다시 칠하기#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool map[50][50];int N, M;int ans = 2000000000;void go(int y, int x){    // 각각의 작은 체스판에서 시작 위치의 표식을 W, B으로 설정한다.    // bool으로 잡았기 때문에 0 또는 1로 모델링이 가능하다.    for (int mode = 0; mode &lt;= 1; mode++) {        int localAns = 0;        for (int i = y; i &lt; y+8; i++) {            // 이 부분이 행이 끝났을 떄 표식을            // 다음행에 가져가도록 하는 코드이다.            mode = !mode;            for (int j = x; j &lt; x+8; j++) {                if (mode != map[i][j]) {                    localAns++;                }                mode = !mode;            }        }        // 각각에 대해 ans를 업데이트 해준다.        ans = min(ans, localAns);    }}int main(){    cin &gt;&gt; N &gt;&gt; M;    // 1, 0으로 바꿔서 넣어주었다. W = 1, B = 0    for (int i = 0; i &lt; N; i++) {        for (int j = 0; j &lt; M; j++) {            char temp;            cin &gt;&gt; temp;            if (temp == 'W') map[i][j] = 1;            else map[i][j] = 0;        }    }    // 체스판 모양에 따라 발생할 수 있는    // 작은 체스판의 시작 위치를 결정한다.    for (int i = 0; i &lt;= N-8; i++) {        for (int j = 0; j &lt;= M-8; j++) {            go(i, j);        }    }    cout &lt;&lt; ans &lt;&lt;'\\n';}Reference백준(1018번) - 체스판 다시 칠하기",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%B2%B4%EC%8A%A4%ED%8C%90-%EB%8B%A4%EC%8B%9C-%EC%B9%A0%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-88-a8-eb-b0-94-ea-bc-ad-ec-a7-88-html": {
        "title": "백준(1697번): 숨바꼭질",
        "tags": "백준, 알고리즘, BFS, Graph",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 그래프 문제이다.이 문제의 핵심은, 해당 위치에서 3가지의 선택을 할 수 있다는 점이다. 이 3가지의 선택 각각에 해당하는 위치에서 또 3가지의 선택을 할 수 있다. 그 선택을 연이어한 결과 문제의 답이 있다.하지만 이 문제는 DFS로 접근할 수 없는데, 그 이유는, 각각의 선택을 깊이 기준으로 탐색했을 때, 답에 다다르지 못하는 상황이 있을 수 있기 때문이다. 따라서 무한 루프에 빠지거나, 혹은 이 부분을 거르는 코드를 작성해야 하는데 상당히 번거롭다.이런 경우 오히려 BFS로 생각했을 때, 문제가 확 와닿는 경우가 많다. BFS로 탐색할 경우, 시간의 기준으로 완전 탐색하기 때문에 이 문제의 의도와 정확히 맞아 떨어진다. 최대한 짧은 시간에 답과 일치할 경우 반복문을 빠져나오면 되기 때문이다. 따라서 위치에 따른 시간을 저장할 필요가 있다.이 때, 선택지에 $+1, -1$이 있고 중간중간 $\\times2$ 도 있어 중복되는 위치에 방문할 가능성이 있다. 이 부분의 시간 복잡도를 줄이기 위해 메모리를 사용하여 코드를 짰다.Code// 실버1 : 백준 1697번 숨바꼭질#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int N = 0, K = 0;bool map[100001] = {0};int main(){    cin &gt;&gt; N &gt;&gt; K;    queue&lt;pair&lt;int, int&gt;&gt; q;    int ans = 0;    q.push(make_pair(N, 0));    while (!q.empty()) {        int now = q.front().first, time = q.front().second;        q.pop();        if (map[now] == true) continue;        map[now] = true;        if (now == K) {            ans = time; break;        }        if (now-1 &gt;= 0) q.push(make_pair(now-1, time+1));        if (now+1 &lt;= 100000) q.push(make_pair(now+1, time+1));        if (now*2 &lt;= 100000) q.push(make_pair(now*2, time+1));    }    cout &lt;&lt; ans &lt;&lt; '\\n';}Reference백준(1697번) - 숨바꼭질",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-ec-86-8c-ec-9a-a9-eb-8f-8c-ec-9d-b4-ec-98-88-ec-81-98-ea-b2-8c-ec-b6-9c-eb-a0-a5-ed-95-98-ea-b8-b0-html": {
        "title": "백준(1022번): 소용돌이 예쁘게 출력하기",
        "tags": "백준, 알고리즘, 시뮬레이션, 구현, 출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "골드4 : 구현 문제이다.상당히 갑갑했다. 일단 무한개의 소용돌이가 생길 수 있다는 점에서 기존의 달팽이 문제처럼 생각하면 안된다라는 판단이 들었다. 발생하는 모든 숫자를 저장한다면 메모리 초과가 날 것이 분명했기 때문이다.그래서 이 부분을 꼭 저장해야 하나? 하는 생각이 들었고, 문제에서 제시하는 규칙에 따라 소용돌이 를 만들어가면서 제시하는 좌표 내에 위치했을 때, 이를 저장해주는 방식으로 문제를 해결하기로 했다.이 과정에서 생각해야 하는 중요 문제는 다음과 같았다.  소용돌이를 만드는 규칙  들어왔을 때, 저장하는 배열과의 관계  출력시 공백 처리소용돌이 규칙            num      direction      linecount                  1      ➡      1              2      ⬆      1              3      ⬅      2              4      ⬇      2              5      ➡      3              6      ⬆      3              7      ⬅      4              8      ⬇      4              9      ➡      5      출처 : https://jksk0115.tistory.com/총 4번의 방향전환 속에 고려해야 하는 점은 몇 칸 전진? 이다. 잘 보게 되면, 방향과 방향에 따른 count와 방향과의 관계가 나온다.배열과의 관계  map[y-r1][x-c1] = num;현재 좌표는 음수를 갖고 있는 상태이다. index는 음수일 수 없으므로 우리는 이것을 평행이동 하여 (0,0) 의 상태에 저장해야 한다. 이 때, r1, c1 만큼 평행이동 한다면 정확하게 원하는 위치에 저장할 수 있다.출력시 공백 처리내가 원하는 위치에 있는 것들을 배열에 넣을 때, 가장 긴 숫자가 무엇인지 알아야 한다. 이 때, C++에 integer의 길이는 알아내기 어려우므로 string으로 바꾸어 길이를 알아내는 방법을 사용하도록 하자.이 길이보다 작은 숫자에 대해서는 그 차만큼 공백을 출력하여 문제가 원하는 답을 도출하자.입출력이 많으므로 ios_base::sync_with_stdio(false); 를 사용하자.C++ - 입출력 빠르게 받는 방법Code// 골드4 : 백준 1022번 소용돌이 예쁘게 출력하기#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int r1, r2, c1, c2;int map[50][5] = {0};int y = 0, x = 0, dir_count = 0;int linecount = 1, step = 0, num = 1, dir = 0;int map_count = 0, max_num = -1, maxLength = -1;int dy[4] = {0, -1, 0, 1}, dx[4] = {1, 0, -1, 0};int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    cin &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2;    while (true) {        // 현재 위치가 원하는 위치인지 확인        if (r1 &lt;= y &amp;&amp; y &lt;= r2 &amp;&amp; c1 &lt;= x &amp;&amp; x &lt;= c2) {            max_num = max(max_num, num);            map[y-r1][x-c1] = num;            map_count++;            if (map_count == (r2-r1+1)*(c2-c1+1)) {                break;            }        }        // 소용돌이 좌표 등 속성 갱신        y += dy[dir];        x += dx[dir];        step++;        num++;        // 방향 갱신        if (step == linecount) {            dir_count++;            step = 0;            dir = (dir+1)%4;            if (dir_count == 2) {                dir_count = 0;                linecount++;            }        }    }    // map 안에서 갖는 최고 길이    maxLength = int(to_string(max_num).size());    for (int i = 0; i &lt; r2-r1+1; i++) {        for (int j = 0; j &lt; c2-c1+1; j++) {            string stringOut = to_string(map[i][j]);            if (stringOut.size() &lt; maxLength) {                for (int i = 0; i &lt; maxLength-stringOut.size(); i++) {                    cout &lt;&lt; \" \";                }            }            cout &lt;&lt; stringOut &lt;&lt; \" \";        }cout &lt;&lt; '\\n';    }}Reference백준(1022번) - 소용돌이 예쁘게 출력하기",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EC%86%8C%EC%9A%A9%EB%8F%8C%EC%9D%B4-%EC%98%88%EC%81%98%EA%B2%8C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html"
      }
      ,
    
      "cs-algorithm-2020-03-24-eb-b0-b1-ec-a4-80-eb-a1-9c-eb-98-90-html": {
        "title": "백준(6603번): 로또",
        "tags": "백준, 알고리즘, 완전탐색, 재귀, 출력",
        "date": "March 24, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버2 : 재귀를 통한 완전탐색 문제이다.단순한 문제였다. 재귀를 통해 만들 수 있는 모든 경우를 출력하면 되는 문제였다. 나 같은 경우 재귀를 통해 들어갈 때, 탐색하지 않아도 되는 부분을 거르는 코드를 작성했다. 아마 다른 분들도 작성했을 것이다.이 문제에서 고려해야 되는 점은 다음과 같다.  어떻게 출력하게 만들 것인가?  어느 상황에서 탐색을 하지 않게 가지를 칠 것인가?출력 방법checkbox라는 배열을 만들어 깊이가 6이 되었을 때 모두 출력하였다.백트래킹이 문제는 간단한 백트레킹이지만, 써보면, 현재 위치에서 나머지 공을 선택할 수 있는 가지수와 지금 부터 선택해야 하는 가지수를 비교했다.  현재 위치로 부터 남은 공의 개수 &lt; 앞으로 선택해야 하는 공의 개수이와 같은 경우는 탐색이 불가능 하므로 함수를 콜하지 않았다.Code// 실버2 : 백준 6603번 로또#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int K = 6;int arr[14];bool checkbox[14] = {0};int N = -1;void go(int start, int count){    int restOfBallFromStart = N-(start+1);    if (count == 6) {        for (int i = 0; i &lt; N; i++)            if (checkbox[i]) cout &lt;&lt; arr[i] &lt;&lt; \" \";        cout &lt;&lt; '\\n';        return;    }    for (int i = start+1; i &lt; N; i++) {        if (restOfBallFromStart &lt; K-(count+1)) break;        else {            checkbox[i] = 1;            go(i, count+1);            checkbox[i] = 0;        }    }}int main(){    ios_base::sync_with_stdio(false);    cin.tie(NULL);    cout.tie(NULL);    while (N != 0) {        fill(&amp;arr[0], &amp;arr[13], 0);        cin &gt;&gt; N;        for (int i = 0; i &lt; N; i++) {            cin &gt;&gt; arr[i];        }        go(-1, 0);        cout &lt;&lt; '\\n';    }    return 0;}Reference백준(6603번) - 로또",
        
        "url": "/cs/algorithm/2020/03/24/%EB%B0%B1%EC%A4%80-%EB%A1%9C%EB%98%90.html"
      }
      ,
    
      "cs-structure-2020-03-23-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-cpu-html": {
        "title": "03: CPU 작동 원리",
        "tags": "컴퓨터 구조, CPU",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "CPU의 동작방법을 알아보자.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.디지털 회로기본적으로 연산을 수행하도록 가능하게 하는 것은 이 디지털 회로가 있기 때문이다. 이 디지털 회로는 반도체의 특징을 이용하면 가능하다. 반도체는 조건에 따라 도체가 될 수도, 부도체가 될 수도 있다. 이 성격을 이용하여 우리는 연산을 가능하게 만들 수 있다. 출처 : https://www.shutterstock.com연산 방법CPU의 핵심 기능인 연산은 어떻게 구현할까?가산기  2진수를 더하는 방법에 대한 방법이다.기본적으로 우리가 덧셈을 한다고 생각해보자. 그렇다면 우리가 덧셈을 하기 위해서 필요한 파라미터는 3개이다. 각 자리에 표현되는 a, b, 그리고 그 두 수를 더했을 때 자리올림이 발생하는지를 판단해줄 c이다.3개의 input의 결과로 자리올림을 나타내는 변수, 더한 뒤 값을 나타내는 변수 이렇게 두개의 값을 뽑아낸다. 위의 4자리 2진수의 덧셈을 수행하기 위해서는 전가산기 4개가 필요하며, 각 연산을 수행한 결과는 다음 자리수의 input으로 들어가게 된다. $C_0$는 0이다.뺄셈은..?  컴퓨터는 덧셈으로 끝난다.뺄셈은 보수의 덧셈 후 자리버림을 통해 구현이 가능하다.일반 뺄셈보수 덧셈 후 자리버림2진수에서 보수는 $0^c = 1$, $1^c=0$ 이다. 그런데 신기하게도 이 보수는 NOT연산으로 구현이 가능하다.보수란보수는 해당 숫자를 진법의 숫자에서 뺀 것을 말한다. 예를 들어 2의 보수는 $10-2=8$이다.곱셈은..?  곱셈은 더하기의 연속적인 과정이다.계속해서 더하면 곱셈구현이 가능하다. 혹은 비트 연산 중 왼쪽 shift를 사용하면 가능하다.나눗셈은?  나눗셈은 뺄셈의 연속적 과정에서 나오는 결과이다.세번 수행했고, 뺄셈이 불가능할 경우에 정지하면 몫과 나머지를 구할 수 있다.혹은 오른쪽 shifting을 하면 가능하다.0으로 나누기이런 방법이기 때문에 0으로 나누는 경우 무한루프에 진입할 수 밖에 없다. 따라서 CPU가 과열되서 터진다…. 펑!결론  CPU는 연산이 핵심이다. 그리고 그 연산은 더하기만으로 구현이 가능하다.",
        
        "url": "/cs/structure/2020/03/23/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-CPU.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-ed-94-84-eb-a1-9c-ea-b7-b8-eb-9e-98-eb-a8-b8-ec-8a-a4-ea-b0-80-ec-9e-a5-ed-81-b0-ec-a0-95-ec-82-ac-ea-b0-81-ed-98-95-ec-9d-98-eb-84-93-ec-9d-b4-html": {
        "title": "프로그래머스: 가장 큰 정사각형 찾기",
        "tags": "백준, 알고리즘, 동적계획법, 구현",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "level2 : 구현, 또는 동적 계획법을 사용하는 문제이다.프로그래머스 - 가장 큰 정사각형 찾기처음 풀이로는 빠르게 풀기 위해서 그냥 단순히 구현을 했다. 입력이 1000 x 1000 이라, 완전 탐색을 수행하더라도 로직을 최대한 덜 쓰도록 짜야된다는 생각을 하면서 짰다. 그 결과 나는 최대 넓이를 구하는 것이 목표이므로, board가 가질 수 있는 최대 변의 길이로 부터 하나씩 줄이며 가능한 정사각형을 구했을 때 return 했다.Code1#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool go(int y, int x, int len, vector&lt;vector&lt;int&gt;&gt; board){    for (int i = y; i &lt; len+y; i++){        for (int j = x; j &lt; len+x; j++){            if (board[i][j] == 0) return false;        }    }    return true;}int solution(vector&lt;vector&lt;int&gt;&gt; board){    int now = min(int(board.size()), int(board[0].size()));    int sizeY = int(board.size());    int sizeX = int(board[0].size());    while(now &gt; 0){        for (int i = 0; i &lt;= sizeY-now; i++){            for (int j = 0; j &lt;= sizeX-now; j++){                if (go(i, j, now, board)) return now*now;            }        }        now--;    }    return now;}하지만 근본적으로 최악의 경우 연산 횟수가, n^4 이다. (완전한 n^4는 아니다. 하지만 연산이 중복되는 것이 너무 많다.)  정사각형 판단 (n^2)  가능한 시작 점의 개수 (n^2)연산이 중복된다는 생각과, 또, 정사각형의 모양을 보니 작은 정사각형이 만들어져야 다음 정사각형이 만들어진다는 생각을 했다. 두 생각은 다이나믹 프로그래밍의 핵심적인 발상이기 때문에 해당 문제를 다이나믹으로 다시 구상해보기 시작했다.정의            dp적용전                           dp적용후                                       0      1      1      1      0      1      1      1              1      1      1      1      1      1      2      2              1      1      1      1      1      2      2      3              0      0      1      0      0      0      1      0        dp[y][x] = (y, x)의 위치를 포함하여 만들 수 있는 정사각형의 최대 변의 길이이렇게 정의를 하게 되면, 다음 정사각형의 변의 길이는, 상, 좌, 좌상향 대각 방향의 요소의 최소값+1에 해당하는 변의 길이로 밖에 만들 수 없다.  dp[y][x] = min(dp[y-1][x-1], dp[y][x-1], dp[y-1][x])dp는 항상 초기값을 세팅해주어야 하는데, 이 경우 y = 0일 때, x = 0 일 때 값을 고정한 상태로 점화식을 적용하면 된다. 이 때, 초기값으로 부터 answer가 도출될 수 있다는 점을 주의하자. 예외에 걸릴 수 있다. (내가)Code2#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;vector&lt;int&gt;&gt; board){    int ans = -1;    int sizeY = int(board.size());    int sizeX = int(board[0].size());    for (int i = 0; i &lt; sizeY; i++) ans = max(board[0][i], ans);    for (int i = 0; i &lt; sizeX; i++) ans = max(board[i][0], ans);    for (int i = 1; i &lt; sizeY; i++) {        for (int j = 1; j &lt; sizeX; j++) {            if (board[i][j] == 0) continue;            else {                int minNum = min(board[i-1][j], board[i-1][j-1]);                minNum = min(minNum, board[i][j-1]);                if (minNum != 0) {                    board[i][j] = minNum+1;                    ans = max(ans, board[i][j]);                }            }        }    }    return ans*ans;}Reference백준(11057번) - 오르막 수",
        
        "url": "/cs/algorithm/2020/03/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%EC%9D%98-%EB%84%93%EC%9D%B4.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ed-94-bc-eb-b3-b4-eb-82-98-ec-b9-98-ed-95-a8-ec-88-98-html": {
        "title": "백준(1003번): 피보나치 함수",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버3 : 동적 계획법을 사용하는 문제이다.Code// 백준 1003번 피보나치 함수#include &lt;iostream&gt;using namespace std;int N = 0, T = 0;int dp[50] = {0};// dp[n] = an 까지의 호출되는 1의 개수// dp[n] = dp[n-2] + dp[n-1];// 호출되는 0의 개수는, dp[n-1]과 동일하다.int main(){    dp[0] = 0;    dp[1] = 1;    for (int i = 2; i &lt; 41; i++) {        dp[i] = dp[i-1] + dp[i-2];    }    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; N;        if (N == 0) cout &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; dp[N] &lt;&lt; '\\n';        else        cout &lt;&lt; dp[N-1] &lt;&lt; \" \" &lt;&lt; dp[N] &lt;&lt; '\\n';    }}Reference백준(1003번) - 피보나치 함수",
        
        "url": "/cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ec-9c-a0-ea-b8-b0-eb-86-8d-eb-b0-b0-ec-b6-94-html": {
        "title": "백준(1012번): 유기농 배추",
        "tags": "백준, 알고리즘, Graph, DFS",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1 : dfs를 사용하는 기초적인 문제이다.이런 문제를 풀 때, 생각보다 실수를 많이하는 부분은, testcase가 있을 때, 초기화를 하지 않는 것이다. 항상 testcase가 있는 문제는, 이 부분을 유념해야 한다. 또 초기화를 할 때, 연산이 수반되기 때문에, 어떠한 방식으로 초기화하는 것이 좋은지 생각하며 코드를 짜는 것이 바람직하다. 무조건적인 초기화는 안전성을 장담할 수 있지만 자칫하면 불필요한 연산을 수반할 수 있다.인접한 녀석들에 대해 1마리의 지렁이가 있으면 된다.1을 발견하면, dfs를 통해 인접한 것들의 값을 변경하고 globalAns의 값을 1증가시킨다.이 때, 정사각 지형을 다 탐색할 필요는 없다.나는 1이 있는 위치에서 시작해서 탐색만 하면 된다.따라서 입력 받을 때, 해당 위치만을 기억하는 배열을 하나 잡고, 이 것을 모두 확인하면 된다.Code// 백준 1012번 유기농 배추#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; baechuLoc;int T = 0;int N = 0, M = 0, baechuNum = 0, ans = 0;int map[51][51];int dy[4] = {0, 1, 0, -1}, dx[4] = {1, 0, -1, 0};void go(int now_y, int now_x){    map[now_y][now_x] = 2;    for (int i = 0; i &lt; 4; i++) {        int next_y = now_y + dy[i], next_x = now_x + dx[i];        if (map[next_y][next_x] == 1) {            go(next_y, next_x);        }    }}int main(){    cin &gt;&gt; T;    for (int tc = 0; tc &lt; T; tc++) {        cin &gt;&gt; N &gt;&gt; M &gt;&gt; baechuNum;        fill(&amp;map[0][0], &amp;map[N][M-1], 0);        baechuLoc.clear();        ans = 0;        for (int i = 0; i &lt; baechuNum; i++) {            int tempY, tempX;            cin &gt;&gt; tempY &gt;&gt; tempX;            map[tempY][tempX] = 1;            baechuLoc.push_back(make_pair(tempY, tempX));        }        for (int i = 0; i &lt; baechuNum; i++) {            if (map[baechuLoc[i].first][baechuLoc[i].second] == 1) {                go(baechuLoc[i].first, baechuLoc[i].second);                ans++;            }        }        cout &lt;&lt; ans &lt;&lt; '\\n';    }}Reference백준(1012번) - 유기농 배추",
        
        "url": "/cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%EC%9C%A0%EA%B8%B0%EB%86%8D%EB%B0%B0%EC%B6%94.html"
      }
      ,
    
      "cs-algorithm-2020-03-23-eb-b0-b1-ec-a4-80-ec-98-a4-eb-a5-b4-eb-a7-89-ec-88-98-html": {
        "title": "백준(11057번): 오르막 수",
        "tags": "백준, 알고리즘, 동적계획법",
        "date": "March 23, 2020",
        "author": "",
        "category": "CS/Algorithm",
        "content": "실버1: 동적 계획 법을 사용하는 문제이다.대표적인 동적계획법 문제이다.기초적인 동적 계획법 문제를 풀 때에는 펜을 갖고 쓰는 것이 중요해보인다. 기본적으로 점화식을 갖고 해결하는 방식이기 때문에, 수열 문제를 푸는 것도 같은 사고로 접근해야 한다. 수열 문제가 눈에 들어오지 않으면 쓰면서 규칙을 찾아내듯, 이것도 손아프다고 징징대지말고 쓰면서 찬찬히 푸는 것이 문제를 가장 효과적이고 간결하게 풀 수 있는 방법이다.N : 1, N : 2            숫자      오르막 수 개수      숫자      오르막 수 개수                  0      1      공란      공란              1      1      10~19      1~9 : 9              2      1      20~29      2~9 : 8              3      1      30~39      3~9 : 7              4      1      40~49      4~9 : 6              5      1      50~59      5~9 : 5              6      1      60~69      6~9 : 4              7      1      70~79      7~9 : 3              8      1      80~89      8~9 : 2              9      1      90~99      9~9 : 1      규칙을 보게 되면, 최고 자리 수가 어떤 수이냐에 따라 그 다음 자리수는 결정이 되게 된다. 그런데 여기서 잘 보면, N : 2일 때, 최고자리수가 1인 경우, 오르막 수의 개수는 1의 자리 숫자가 1~9까지 오는 경우가 모두 오르막 수가 될 수 있다.추가적으로 최고자리수가 2인 경우는, 일의 자리 숫자가 2인 경우부터 발생하는 모든 오르막 수를 더함으로서 만들어진다.이 규칙을 자세히 보면, 변화하는 파라미터는 총 두개이다.  최고자리의 수  최고자리에 위치하는 숫자이 두가지 특징을 가지고 dp를 정의하고, 점화식을 세워보자.  dp[N][m] = N 자리수를 가지는 수가 M의 숫자를 가질 때 가질 수 있는 오르막 수의 개수  dpdp[N] = N 자리수를 가지는 수가 가질 수 있는 오르막 수의 개수이렇게 정의했을 때, dp 점화식의 정의는 다음과 같다.이걸 가지고 dpdp 점화식을 세우면 다음과 같다.수식도 세웠으니 이제 구현만 하면 된다. 이때, dp를 수행하기 위해서는 초기값을 설정해 줘야 하는데, 이 경우에는 N : 1 인 경우에 해당하는 모든 숫자에 1의 값을 준 뒤에 시작해야 한다.Code// 백준 11057번 오르막 수#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N = 0;int dp[1001][10] = {0};int dpdp[1001] = {0};int mod = 10007;int main(){    cin &gt;&gt; N;    // 초기값 세팅    for (int i = 0; i &lt; 10; i++) {        dp[1][i] = 1;    }    dpdp[1] = 10;    for (int i = 2; i &lt;= N ; i++) {        // dp[N][M]을 구하는 코드        for (int j = 1; j &lt; 10; j++) {            for (int k = j; k &lt; 10; k++) {                dp[i][j] += dp[i-1][k];                dp[i][j] %= mod;            }        }        // dpdp[N]을 구하는 코드        for (int j = 0; j &lt; 10; j++) {            dpdp[i] += dp[i][j];        }        dpdp[i] += dpdp[i-1];        dpdp[i] %= mod;    }    // 정답    cout &lt;&lt; dpdp[N] &lt;&lt; '\\n';}Reference백준(11057번) - 오르막 수",
        
        "url": "/cs/algorithm/2020/03/23/%EB%B0%B1%EC%A4%80-%EC%98%A4%EB%A5%B4%EB%A7%89%EC%88%98.html"
      }
      ,
    
      "cv-projects-2020-03-22-react-movie-app-clone-html": {
        "title": "02: Movie App Clone",
        "tags": "project, toy-project, clone-coding",
        "date": "March 22, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "React를 사용하여 동적인 느낌이 나는 movie app을 만들어보았다.React-Movie-App",
        
        "url": "/cv/projects/2020/03/22/react-movie-app-clone.html"
      }
      ,
    
      "cv-projects-2020-03-22-html-css-kakaotalkclone-html": {
        "title": "01: KaKaoTalk Clone",
        "tags": "project, toy-project, clone-coding",
        "date": "March 22, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "카카오톡 디자인을 클론 코딩해보았다.카카오톡 클론 코딩",
        
        "url": "/cv/projects/2020/03/22/html-css-kakaotalkClone.html"
      }
      ,
    
      "cs-structure-2020-03-22-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-bit-ec-a7-84-eb-b2-95-eb-b3-80-ed-99-98-html": {
        "title": "02: bit, 진법 변환",
        "tags": "컴퓨터 구조, 진법",
        "date": "March 22, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "bit와 진법 변환에 대해 알아본다.최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.bit  1bit는 전기 스위치 1개이고, ON/OFF 두가지 상태를 표시할 수 있다.1bit는 2진수 한자리 숫자를 표현할 수 있다.결국 두가지 상태의 조합으로 우리는 숫자를 표시할 수 있다. 이 조합을 표현하는데 있어 가장 작은 단위를 bit라 한다.4bit  4bit로는 16진수 한자리를 표현할 수 있다.16진수는 0~F(0~15) 까지 한 자리에 쓴다.            2진수(4bit)      16진수                  1010      A(10)              1011      B(11)              1100      C(12)              1101      D(13)              1110      E(14)              1111      F(15)      byte  8bit : 영문자 한 글자를 저장할 수 있는 기억 공간의 최소단위가장 작은 단위가 bit라면, 기억공간을 관리하는데 가장 작은 단위는 1byte이다.연습            16진수      2진수      10진수      용량                  0x73      0111 0011      $16^1\\times7+16^0\\times3=115$      1byte      ",
        
        "url": "/cs/structure/2020/03/22/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-bit-%EC%A7%84%EB%B2%95%EB%B3%80%ED%99%98.html"
      }
      ,
    
      "cs-structure-2020-03-21-ec-bb-b4-ed-93-a8-ed-84-b0-ea-b5-ac-ec-a1-b0-ec-9a-a9-ec-96-b4-ec-a0-95-eb-a6-ac-html": {
        "title": "01: 용어 정리",
        "tags": "컴퓨터 구조",
        "date": "March 21, 2020",
        "author": "",
        "category": "CS/Structure",
        "content": "최호성님의 유튜브 강의를 보며 기본적인 컴퓨터 구조를 이해하고 정리하자.PC 조립 과정 보며 구조 이해하기컴퓨터 하드웨어 구성 요약다나와다나와이곳에 가면 컴퓨터 용어에 대한 간단한 설명들을 쉽게 알 수 있다.컴퓨터란?CPU가 가장 중요하다. 컴퓨터의 기본 정체성은 연산을 하는 기계이기 때문에, 이 연산을 담당하는 CPU가 컴퓨터를 거의 대표한다고 볼 수 있다. 요리에 비유한다면 좋은 칼, 좋은 도구 등이 될 수 있겠다.하지만 재료가 없으면 요리를 할 수 없다. 따라서 우리는 CPU가 연산을 수행할 수 있도록 재료에 해당하는 메모리를 주어야 한다. 그 과정에서 보조 기억 장치인 RAM, HDD, SDD 등이 필요하다.Interface  주변기기와 연결되는 지점기본적으로 컴퓨터는 CPU, RAM으로 동작한다. 이 때 추가적인 기억 장치인 HDD, SDD들이 이 컴퓨터에 연결할 때 사용하는 것이 interface이다. 현재는 SATA라는 interface를 사용한다. SATA는 interface 중 하나이며, 어떤 장치를 연결하느냐에 따라 필요한 interface는 달라질 수 있다.운영체제에서 사용하는 용어기본적인 용어에 대해 이해하고 넘어가자.동시성  여러 일을 여러 사람이 각자 동시에 하는 것행위도 여러개, 주체도 여러개병렬성  같은 일을 여러 사람이 동시에 하는 것군대 삽질 분대가 다같이행위는 하나, 주체는 여러개병렬성은 동시성에 포함된다.원자성  쪼개어 나눌 수 없는 연속된 일어떤 일을 최대한 쪼갰을 때의 가장 작은 단위의 행위원자성은 병렬성을 가지는 상태에서 동기화 라는 작업이 중요하다.의존성  전제조건행위에 대한 의존, 존립에 대한 의존출근(행위)출근 하기 위한 방법이 버스를 타야 가능하다고 생각해보자. 그렇다면 출근이라는 행위는 버스에 의존적이다.자동차 부품(존립)자동차를 구성하는 다양한 부품은 자동차라는 객체가 사라지면 그 부품들의 존재도 사라진다. 그렇다면 부품이라는 존립은 자동차에대해 의존성을 가진다.동기화  원자성을 가지는 행위에 대해 시작과 끝을 알리는 행위화장실 들어갈 때 문잠구는 거규칙 준수의 개념과도 비슷하다.예를 들어, 100개의 인형에 눈을 다는 작업이 있다고 하자. 그렇다면 이 작업은 동시성을 가진다. 그리고 같은 작업을 여럿이 달려들어 수행할 수 있기 때문에 병렬성도 가진다. 이 때, 하나의 인형에 눈을 다는 작업은 원자성을 가진다고 가정하자. 즉, 눈을 다는 작업은 한 사람만이 수행할 수 있고 눈을 다는 작업은 연속적이기 때문에 방해받을 수 없다. 이런 경우에 사람이 1000명이 있더라도 작업에 투입될 수 있는 최대 인원은 100명이다. 그런데 만약 하나의 작업을 수행하고 있는 인원에게 일이 없는 다른 사람이 방해한다면, 해당 작업은 충돌이 발생한다. 이런 과정을 막기 위해서 작업을 수행하는 인원은, 작업을 수행하기 전에 나 작업시작한다! 처럼 알려주는 행위가 필수적으로 요구된다. 이러한 알림을 동기화 라고 한다.교착상태(Deadlock)  이러지도 저러지도 못하는 상태화장실에 휴지 없어서 못나오는 상태원자성을 보장 받는 행위에 대해서 행위가 끝나야 다음 처리가 이루어지는 상황에서 특정 조건 때문에 행위가 끝나지 않아 멈춰버리는 상태를 말한다. 심각한 논리적 오류 때문에 발생한다.예외처리 잘해라하드웨어, 운영체제, 프로세스, 스레드  컴퓨터가 ‘영토’라면 운영체제는 ‘정부조직’스레드는 ‘개인’이고 프로세스는 ‘가족’컴퓨터라는 하드웨어를 가지고 System software인 운영체제와, User software인 프로세스가 돌아가게 된다.Kernel  운영체제의 근간을 이루는 핵심 코드어떠한 방식으로 자원을 나눠주고, 프로세스를 관리하는지, 프로그램이 요구하는 시스템 콜 같은 중요한 작업을 수행하는 코드를 말한다. 그렇기에 어떤 커널을 사용하느냐에 따라 OS의 정체성이 규정된다. 이 부분이 손상될 경우 OS가 사용 불가능해 진다.Virtual Memory가족들은 보통 집에서 생활한다. 이 집은 컴퓨터에 대응해서 생각하면, 메모리 공간이다. 각각의 프로세스는 이러한 전용 공간, 즉 가상 메모리를 갖는다.Thread가족 안에 구성원들이 있고, 이 구성원들은 각자 자유로이 활동하듯이 프로세스 내에서 작동하는 개별 흐름(thread)이다. 해당 스레드는 속한 프로세스에 할당된 자원을 공유한다.스레드는 프로그램의 흐름(연산의 흐름)에 있어서 가장 작은 단위를 뜻한다.",
        
        "url": "/cs/structure/2020/03/21/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC.html"
      }
      ,
    
      "dv-html-css-2020-03-20-transition-display-none-html": {
        "title": "opacity를 사용하여 display none animation 만들기",
        "tags": "css, transition, opacity",
        "date": "March 20, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "Html&lt;div class=\"chat__write--container\"&gt;  &lt;input    type=\"text\"    class=\"chat__write\"    placeholder=\"Send message\"    class=\"chat__write-input\"  /&gt;  &lt;div class=\"chat__icon-left chat__icon\"&gt;    &lt;i class=\"far fa-plus-square\"&gt;&lt;/i&gt;  &lt;/div&gt;  &lt;div class=\"chat__icon-right chat__icon\"&gt;    &lt;span class=\"chat__write-icon\"&gt;      &lt;i class=\"far fa-smile-wink\"&gt;&lt;/i&gt;    &lt;/span&gt;    &lt;span class=\"chat__write-icon\"&gt;      &lt;i class=\"fas fa-microphone\"&gt;&lt;/i&gt;    &lt;/span&gt;  &lt;/div&gt;&lt;/div&gt;  위의 상황에서 문자를 보내는 것을 클릭했다고 생각해보자. 그 경우, 주변에 있는 아이콘이 사라졌으면 좋겠다. 그런데, 그 아이콘의 속성을 display: none;으로 할 경우, 애니메이션 효과를 넣을 수 없게 된다.그래서 속성의 값중 실수 값을 가질 수 있으면서 같은 효과를 내는 opacity 속성을 사용한다.CSS.chat__write:focus ~ .chat__icon {  opacity: 0;}.chat__icon {  font-size: 23px;  transition: opacity 0.5s ease-in-out;}여기서 ~ 선택자는, 형제 선택자이다.중요여기서, 중요한 것은, 내가 없애고 싶은 아이콘은, input 태그 뒤에 있어야 한다는 점이다. 만약 그렇지 않다면 애니메이션이 적용되지 않는다. 결과적으로 CSS로 어떤 효과를 주고 싶을 때는, 내가 액션을 취할 태그를 html 문서의 앞에 적어주어야 동작한다.",
        
        "url": "/dv/html-css/2020/03/20/transition-display-none.html"
      }
      ,
    
      "dv-html-css-2020-03-20-navbar-fixed-html": {
        "title": "navbar, footer 고정하기",
        "tags": "css, position, fixed",
        "date": "March 20, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "상단 navbar나 footer 같이 고정할 필요성이 있는 html 요소를 어떻게 빠르게 만들지 정리했다.이 부분을 생각할 때 조금 어려웠던 것은, navbar 같은 경우, 어떻게 html 구조를 짜야되는 지 였다. 하지만 조금만 생각해보니, 굳이 떼어내서 구조화할 필요 없이 그냥 필요한 요소들을 만들고, 이를 보여주는 방식, css에서 display만 변화시키면 되는 문제였다.물론, 이 과정에서 class 이름을 바꾸고 body를 해당 nav의 높이 만큼 padding 혹은 margin을 주어야 하지만, html 구조에 있어 navbar는 그대로 두어도 상관없다.",
        
        "url": "/dv/html-css/2020/03/20/navbar-fixed.html"
      }
      ,
    
      "dv-html-css-2020-03-19-span-height-is-not-block-html": {
        "title": "span의 height는 block 속성이 아니다.",
        "tags": "css, span, height, block",
        "date": "March 19, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "text는 span 태그에 넣어서 관리한다.div안에 text를 넣으면 좋지 않다.이번에 겪은 문제로는 box-shadow가 먹지 않았다.그렇다고 div에 있던 텍스트를 span으로 교체하면 문제가 생긴다.span 태그는 기본적으로 inline 속성을 강하게 띈다.그렇기 때문에 다음 그림과 같이 margin을 먹였음에도 불구하고 내가 원하는 모양대로 속성이 먹히지 않는다.div와 span의 가장 큰 차이는 display: block, inline따라서 만약에 다 뒤집어 엎고 교체하기 싫다면, display: block 속성을 추가해주면 된다.결론가장 좋은 방법은, text를 쓰는 공간에는 span을 써주고, 이 공간 자체를 box처럼 쓰고 싶다면 display block을 써주자.또는 아예 box와 textbox를 구분해서 만들어주는 것도 좋은 방법이다.",
        
        "url": "/dv/html-css/2020/03/19/span-height-is-not-block.html"
      }
      ,
    
      "dv-html-css-2020-03-19-position-fixed-center-ec-a0-95-eb-a0-ac-html": {
        "title": "position fixed에서 중앙 정렬하기",
        "tags": "css, center-arrangement, position, fixed",
        "date": "March 19, 2020",
        "author": "",
        "category": "DV/HTML-CSS",
        "content": "position : fixed에서 중앙 정렬하는 방법.class {  position: fixed;  /* fixed를 쓸 때에는 width, height를 명시해줘야 한다. */  width: 80%;  /* left, right는 해당 요소의 위치 시작점을 결정한다. 그런데, 이때, margin의 양 값을 auto로 줌으로써 마진을 주어 해당 요소의 양 끝 위치를 각각 0으로 만들어준다. */  margin: 0 auto;  left: 0;  right: 0;  /* 다른 것들 */  display: flex;  background-color: red;  padding: 20px 50px;  border-radius: 40px;}",
        
        "url": "/dv/html-css/2020/03/19/position-fixed-center-%EC%A0%95%EB%A0%AC.html"
      }
      ,
    
      "dv-javascripts-2020-03-18-ea-b0-9c-eb-b0-9c-ed-99-98-ea-b2-bd-ec-84-b8-ed-8c-85-html": {
        "title": "개발 환경 초기 세팅",
        "tags": "development, setting",
        "date": "March 18, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "개발을 시작하기 전에 환경 설정해야 하는 것들을 적어둔다.      gitignore        git setting : 이 부분은, terminal에서 clone 후, vscode로 여는 것이 가장 깔끔했다. 그 경우 remote 설정도 안해줘도 순탄하다.  왜 잘 작동을 안하는가ㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹ ㅇㄹ. ㄴㅇㄹㄴㅇㄹ.ㄴㅇㄹㄴㅇㄹ안녕하세요.ㄴㅇㄹㄴㅇ.ㄴㅇ란우라ㅣㄴㅇㄹㄴ앙ㄴㄹㄴㅇㄹ.ㄴ일ㄴㅇㄹㄴㅇ룬ㅇ린ㅇㄴㅇㄹ ㄴㅇ룬ㅇㄴㅇ라ㅣㄴ울ㄴㅇ룬ㅇㄹsdfsdf;sdfsdf",
        
        "url": "/dv/javascripts/2020/03/18/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%84%B8%ED%8C%85.html"
      }
      ,
    
      "dv-javascripts-2020-02-28-js-html": {
        "title": "개발 시 고려해야 하는 점",
        "tags": "JS, develop",
        "date": "February 28, 2020",
        "author": "",
        "category": "DV/JavaScripts",
        "content": "개발 시작하기 전에 플로우를 기록해 둔다.html  그룹을 잘 묶어서 짠다.  하나의 기능이 들어간다고 하더라도 2중으로 그룹화 하는 것이 좋다.  입력 단위는 업데이트 되는 단위로 묶어준다.CSS  reset.css 파일 만들고 복사  내가 사용한 css 파일에 import  기본적으로 항상 css는 body 태그에 대해 설정을 하고 시작하는 것이 좋다. body 태그 안에서 설정해줘야 하는 것은 기본적으로 배경색과 폰트정도가 있다.  집합구조를 잘 생각해서 짠다.  css에서 먹일 때도 명확하게 이 객체의 위치를 명시적으로 적은 후에 걸어준다.JS      여거개의 객체 tag에 대해 같은 이벤트를 얻고 싶을 떄는 id로 js#@%@%이렇게 저장하는 것이아니고 class로 저장한다. 그 이후에 ‘getElementByClassName’으로 불러오면, 자동으로 배열로 모든 class에 해당하는 녀석을 가져온다.        이 때 불러와진 녀석은 배열이 아니다. 유사배열이다. JSON 파일과 같다고 보면 된다. 즉, a[0] 처럼 접근은 가능하나, Array의 메서드를 사용할 수 없다.    for (let i = 0; i &lt; colors.length; i++) {  const element = colors[i];  element.addEventListener(\"click\", handleColorChanging);}        Array.from(colors).forEach(item =&gt; {  console.log(item);  item.addEventListener(\"click\", handleColorChanging);});        따라서 이 두 코드는 같은 작동을 한다.        querySelector 사용처는 다음과 같다. 일반적으로 하나밖에 없는 이름을 갖고 있는 태그라면 querySelector를 쓰는게 좋아보인다.이 경우, 해당 객체에서 다시 querySelector를 사용할 수 있기 때문에, 사용하기 편리하다. 다만 가장 위에 있는 객체하나만을 들고 오기 때문에 여러개가 있을 경우 좋지 않다. 여러개를 들고 올 경우에는 getElementClassName을 사용하는 것이 좋아보인다. 이경우 HTMLCollenction이라는 객체로 들고오며, 이를 Array로 바꿔 사용하면 편리하다. getElementId 는 하나만 빠르게 들고올 떄 사용하면 편리하다.  ",
        
        "url": "/dv/javascripts/2020/02/28/JS.html"
      }
      ,
    
      "cv-projects-2020-02-01-data-science-for-covid-19-ds4c-html": {
        "title": "Data Science for COVID-19 (DS4C)",
        "tags": "project, CV",
        "date": "February 1, 2020",
        "author": "",
        "category": "CV/Projects",
        "content": "  COVID-19의 환자들에 대한 정보와 이동경로를 제공하는 데이터셋 제작 프로젝트이다.KAGGLE : Data Science for COVID-19 (DS4C)CORONAWHY : DS4C: Data Science for COVID-19 in South KoreaDatabricks Tech Talk",
        
        "url": "/cv/projects/2020/02/01/Data-Science-for-COVID-19(DS4C).html"
      }
      ,
    
      "cv-projects-2019-12-01-ec-b6-a4-ec-a0-80-ec-9e-91-ea-b6-8c-ec-a0-9c-ec-9e-91-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-html": {
        "title": "춤 저작권 제작 프로젝트",
        "tags": "project, CV",
        "date": "December 1, 2019",
        "author": "",
        "category": "CV/Projects",
        "content": "  Openpose를 사용하여 동작을 추출, 그것을 기반으로 동작을 예측하고 분류하는 모델을 제작했다.Github : Dance Achiving Through Openpose",
        
        "url": "/cv/projects/2019/12/01/%EC%B6%A4-%EC%A0%80%EC%9E%91%EA%B6%8C-%EC%A0%9C%EC%9E%91-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8.html"
      }
      ,
    
      "cv-projects-2019-11-01-ed-95-ad-ea-b3-b5-ec-a7-80-ec-97-b0-ec-98-88-ec-b8-a1-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-html": {
        "title": "항공 지연 예측 프로젝트",
        "tags": "project, CV",
        "date": "November 1, 2019",
        "author": "",
        "category": "CV/Projects",
        "content": "  항공기의 운행을 따라가는 Schedule이라는 변수를 사용하여 높은 정확도로 지연편을 검출할 수 있었다.파일을 불러오는데 시간이 좀 걸립니다!",
        
        "url": "/cv/projects/2019/11/01/%ED%95%AD%EA%B3%B5-%EC%A7%80%EC%97%B0-%EC%98%88%EC%B8%A1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8.html"
      }
      ,
    
      "cv-projects-2018-08-01-ec-84-9c-ec-9a-b8-ec-8b-9c-ec-b2-ad-ec-8b-9d-ec-88-98-ec-9d-b8-ec-9b-90-ec-98-88-ec-b8-a1-ed-94-84-eb-a1-9c-ec-a0-9d-ed-8a-b8-html": {
        "title": "서울시청 식수인원 예측 프로젝트",
        "tags": "project, CV",
        "date": "August 1, 2018",
        "author": "",
        "category": "CV/Projects",
        "content": "  서울시 관내 식당의 식수인원을 예측하여 사회적 이익을 가져오는 프로젝트를 진행했다.파일을 불러오는데 시간이 좀 걸립니다!",
        
        "url": "/cv/projects/2018/08/01/%EC%84%9C%EC%9A%B8%EC%8B%9C%EC%B2%AD-%EC%8B%9D%EC%88%98%EC%9D%B8%EC%9B%90-%EC%98%88%EC%B8%A1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8.html"
      }
      
    
  };
</script>

<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" charset="utf-8"></script>-->
<script src="./js/lunr.min.js" charset="utf-8"></script>
<script src="/assets/js/search.js" charset="utf-8"></script>
</section>
</article>
</div>

    





<footer class="site-footer">
	<div class="copyright">
		© 
		<span itemprop="copyrightYear">2018</span>
		<span class="with-love">
		  <i class="fa fa-heart"></i>
		</span>
		<span class="author" itemprop="copyrightHolder">Wansook</span>
	  </div>

	<div class="powered-by">
	Powered by <a class="theme-link" href="https://jekyllrb.com" >Jekyll</a>
	</div>

	<div class="prev-blog-info">
		Prev Blog -
		<a class="theme-link" href="https://egg-money.tistory.com/127?category=822389">
		  완숙의 블로그
		</a>
	</div>

	<div class="saying">What I cannot create, I do not understand. <br> - Richard Phillips Feynman -</div>
</footer>

 <script>
  /**
   * Animate scrolling to a target position
   * @param {string} _selector Target selector
   * @param {number} _duration (Option) Duration time(ms) (Default. 800ms)
   * @param {number} _adjust (Option) Adjustment value of position
   */
  /**
  animteScrollTo = function (_selector, _duration, _adjust) {
    const targetEle = document.querySelector(_selector);
    if (!targetEle) return;

    // - Get current &amp; target positions
    const scrollEle = document.documentElement || window.scrollingElement,
      currentY = scrollEle.scrollTop,
      targetY = targetEle.offsetTop - (_adjust || 0);
    animateScrollTo(currentY, targetY, _duration);

    // - Animate and scroll to target position
    function animateScrollTo(_startY, _endY, _duration) {
      _duration = _duration ? _duration : 600;
      const unitY = (targetY - currentY) / _duration;
      const startTime = new Date().getTime();
      const endTime = new Date().getTime() + _duration;

      const scrollTo = function () {
        let now = new Date().getTime();
        let passed = now - startTime;
        if (now <= endTime) {
          scrollEle.scrollTop = currentY + unitY * passed;
          requestAnimationFrame(scrollTo);
        } else {
          console.log("End off.");
        }
      };
      requestAnimationFrame(scrollTo);
    }
  };

  anchorArray = Array.from(document.querySelectorAll(".toc-anchor"));
  console.log(anchorArray);
  for (var i = 0; i < anchorArray.length; i++) {
    (function (m) {
      anchorId = String(anchorArray[m].innerText)
        .toLowerCase()
        .replace(/\s/g, "-");
      // console.log(anchorId);
      target = $(
        '.toc-whole-nav .toc-nav .toc-item a[href="#' + anchorId + '"]'
      );
      console.log(target);
      // console.log(anchorArray[m]);
      target.click(function () {
        name = String(target[0].innerText).toLowerCase().replace(/\s/g, "-");
        // name = name.replace(/\./, "-");
        console.log("#" + name);
        animteScrollTo("#" + name);
      }, false);
    })(i);
  }
**/
  // anchorArray = Array.from(document.querySelectorAll(".toc-anchor"));
  // // console.log(anchorArray);

  // anchorArray.map((anchor) => {
  //   $(anchor).click(function () {
  //     console.log(anchor["innerText"]);
  //     name = anchor["innerText"];
  //     name = name.replace(/\./, "-");
  //     // console.log(name);

  //     animteScrollTo("#" + name);
  //   });
  //   return anchor;
  // });

  // var headings = $("h1, h2, h3, h4, h5, h6").toArray()
  //         , headingToListElementLinkMap = getHeadingToListElementLinkMap(headings)
  //         , listElementLinks = $.map(headingToListElementLinkMap, (function(value, key) {
  //           return value
  //       }
  //       ))
  //         , scrollOffset = getScrollOffset();

  //   function getEzTocListElementLinkByHeading(heading) {
  //     return $('.toc-whole-nav .toc-nav .toc-item a[href="#' + $(heading).attr("id") + '"]')
  //   }

  //   function getHeadingToListElementLinkMap(headings) {
  //           return headings.reduce((function(map, heading) {
  //               return map[heading.id] = getEzTocListElementLinkByHeading(heading),
  //               map
  //           }
  //           ), {})
  //       }
  //   });
  //   function getScrollOffset() {
  //     var scrollOffset = 5;
  //     void 0 !== ezTOC.smooth_scroll && 1 === parseInt(ezTOC.smooth_scroll) && (scrollOffset = void 0 !== ezTOC.scroll_offset ? parseInt(ezTOC.scroll_offset) : 30);
  //     var adminbar = $("#wpadminbar");
  //     return adminbar.length && (scrollOffset += adminbar.height()),
  //     scrollOffset
  //   }

  // $(document).ready(function() {
  //   $('.user-list').append(_.map(users, function(user) {
  //     var button = $('<button type="button" class="btn btn-primary">').text(user.name);
  //     button.click(function() {
  //         if (confirm(user.name + "님을팔로잉하시겠습니까?")) follow(user);
  //     });
  //     return button;
  //   }));
  // });

  // function follow(user) {
  //     alert("이제 " + user.name + "님의소식을보실수있습니다.");
  // }
  // str.replace(/\./, "-")
  // anchorArray = Array.from(document.querySelectorAll(".toc-anchor"));
  // console.log(anchorArray);
  // anchorArray.map((anchor) => {
  //   console.log(anchor);
  //   // $(anchor).click(function () {
  //   //   console.log($("anchor"));
  //   // });
  //   // return anchor;
  // });

  //   var t = document.getElementById("target");
  //   const toc = document.querySelectorAll(".toc_nav > ul > li");
  //   console.log(toc);
  // t.addEventListener('click', function(event){
  //     alert('Hello world, '+event.target.value);
  // });
</script>

  </body>
</html>
